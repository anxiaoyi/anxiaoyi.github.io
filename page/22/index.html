<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>代码人生</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="赵坤的个人网站">
<meta property="og:type" content="website">
<meta property="og:title" content="代码人生">
<meta property="og:url" content="http://blog.kunzhao.org/page/22/index.html">
<meta property="og:site_name" content="代码人生">
<meta property="og:description" content="赵坤的个人网站">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代码人生">
<meta name="twitter:description" content="赵坤的个人网站">
  
    <link rel="alternate" href="/atom.xml" title="代码人生" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.kunzhao.org"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">首页</a>
        
          <a class="main-nav-link" href="/blog/archives">归档</a>
        
          <a class="main-nav-link" href="/blog/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">代码人生</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网站架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/10/网站架构/" class="article-date">
  <time datetime="2017-05-10T03:08:18.000Z" itemprop="datePublished">2017-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/10/网站架构/">网站架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h2><h3 id="负载均衡与-Session"><a href="#负载均衡与-Session" class="headerlink" title="负载均衡与 Session"></a>负载均衡与 Session</h3><p><img src="17-05-10-11_09_55_407_412.png" alt=""></p>
<p>HTTP 协议本身是无状态的，需要基于 HTTP 协议支持会话状态 (Session State) 的机制，而这样的机制应该可以使 Web 服务器从多次单独的 HTTP 请求中看到 “会话”，也就是知道哪些请求来自哪个会话。具体实现: 在会话开始的时候，分配一个唯一的会话标识 (SessionId)，通过 Cookie 把这个标识告诉浏览器，以后每次请求的时候，浏览器都会带上这个会话标识来告诉 Web 服务器请求是属于哪个会话的。如果遇到禁用 Cookie 的情况，一般是把 SessionId 放入 URL 参数中。</p>
<p>当应用服务器由一台变为两台后，遇到的问题是会话数据是需要保存到单机上的，第一次访问网站请求落到哪台服务器，我的 Session 就创建在哪个服务器上:</p>
<p><img src="17-05-10-11_15_19_897_477.png" alt=""></p>
<p>解决方案:</p>
<ul>
<li><strong>Session Sticky</strong>: 负载均衡根据 SessionId 分发</li>
<li><strong>Session Replication</strong>: 在两台 Application Server 之间进行 Session 数据同步</li>
<li><strong>Session 数据集中存储</strong>: 优势明显</li>
<li><strong>Cookie Based</strong>: Cookie 包含 Session 数据<ul>
<li>缺点: Cookie 长度限制、安全性</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://item.jd.com/11449803.html" target="_blank" rel="external">《大型网站系统与 Java 中间件实践》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/10/网站架构/" data-id="cjcdlsgib006udiemll93xddu" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Linux常见性能分析工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/10/Linux常见性能分析工具/" class="article-date">
  <time datetime="2017-05-10T02:15:56.000Z" itemprop="datePublished">2017-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/10/Linux常见性能分析工具/">Linux常见性能分析工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Linux常见性能分析工具"><a href="#Linux常见性能分析工具" class="headerlink" title="Linux常见性能分析工具"></a>Linux常见性能分析工具</h2><p>首先需要执行安装命令 <code>sysstat</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install sysstat</div></pre></td></tr></table></figure>
<h3 id="vmstat-Virtual-Memory-Statistics-监控内存和-CPU"><a href="#vmstat-Virtual-Memory-Statistics-监控内存和-CPU" class="headerlink" title="vmstat - Virtual Memory Statistics - 监控内存和 CPU"></a>vmstat - Virtual Memory Statistics - 监控内存和 CPU</h3><p>每 1 秒更新一次输出信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vmstat 1</div></pre></td></tr></table></figure>
<p>可以看到用红色框住的部分，有着很高的 cs (上下文切换) 值和 us(用户 CPU 时间) 值，表明系统上下文切换频繁，用户 CPU 占用率高:</p>
<p><img src="17-06-14-17_50_25_1093_203.png" alt=""></p>
<p>一般这样的代码容易产生上下文切换比较频繁的情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock[i]) &#123;</div><div class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            lock[i].wait(r.nextInt(<span class="number">10</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            lock[i].notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每 1 秒采样一次，共计 3 次:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vmstat 1 3</div></pre></td></tr></table></figure>
<p><img src="17-05-10-10_21_37_1064_422.png" alt=""></p>
<p>查看是否有<strong>大量磁盘交换</strong>，对于没有磁盘交换的服务器，这些值应该为 0:</p>
<p><img src="17-07-07-15_39_00_815_173.png" alt=""></p>
<h3 id="iostat-监控-I-O-使用-判断-I-O-是否过载"><a href="#iostat-监控-I-O-使用-判断-I-O-是否过载" class="headerlink" title="iostat - 监控 I/O 使用 - 判断 I/O 是否过载"></a>iostat - 监控 I/O 使用 - 判断 I/O 是否过载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iostat 1 2</div></pre></td></tr></table></figure>
<p>只输出磁盘使用情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iostat -d 1 2</div></pre></td></tr></table></figure>
<h3 id="pidstat-监视进程和线程"><a href="#pidstat-监视进程和线程" class="headerlink" title="pidstat - 监视进程和线程"></a>pidstat - 监视进程和线程</h3><p>什么叫做占用 CPU 的线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">double</span> a = Math.random() * Math.random();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么叫做空闲线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">    Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 <code>jps</code> 找到 <code>Java</code> 程序的 <code>PID</code> 1187，然后执行下面命令查看 CPU 使用情况:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pidstat -p 1187 -u 1 3</div></pre></td></tr></table></figure>
<ul>
<li><strong>-p</strong>: 指定进程 ID</li>
<li><strong>-u</strong>: 对 CPU 使用率的监控</li>
</ul>
<p>监控线程信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pidstat -p 1187 1 3 -u -t</div></pre></td></tr></table></figure>
<ul>
<li><strong>-t</strong>: 监控线程信息，输出的时候会多一个 <strong>TID</strong> 参数</li>
</ul>
<p><img src="17-06-14-20_12_26_1254_310.png" alt=""></p>
<p>使用 <code>jstack</code> 可以导出指定 Java 应用程序的所有线程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack -l 1187 &gt; /tmp/t.txt</div></pre></td></tr></table></figure>
<p><img src="17-06-14-20_12_58_1211_257.png" alt=""></p>
<p>如图所示，它的 <strong>nid (native ID)</strong> 为 0x4b4，转为 10 进制后，正好是 1024</p>
<hr>
<p><strong>有大量读写的线程</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"temp"</span>));</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</div><div class="line">    fos.write(i);</div><div class="line">&#125;</div><div class="line">fos.close();</div><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"temp"</span>));</div><div class="line"><span class="keyword">while</span> (fis.read() != -<span class="number">1</span>) ;</div></pre></td></tr></table></figure>
<p>使用如下命令监控磁盘 I/O 情况:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pidstat -p 22796 -d -t 1 3</div></pre></td></tr></table></figure>
<ul>
<li><strong>-d</strong>: 监控磁盘 I/O</li>
</ul>
<hr>
<p>进行内存监控</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pidstat -r -p 27233 1 5</div></pre></td></tr></table></figure>
<h3 id="free-Display-amount-of-free-and-used-内存-in-the-system"><a href="#free-Display-amount-of-free-and-used-内存-in-the-system" class="headerlink" title="free - Display amount of free and used 内存 in the system"></a>free - Display amount of free and used 内存 in the system</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 以 M 为单位查看</div><div class="line">free -mt</div></pre></td></tr></table></figure>
<ul>
<li><strong>-t</strong>: </li>
<li><strong>–total</strong>: Display a line showing the column totals.</li>
<li><strong>-h</strong>: human readable</li>
</ul>
<p><img src="17-05-10-10_34_20_1046_350.png" alt=""></p>
<h3 id="sar-收集-报告以及保存系统活动信息"><a href="#sar-收集-报告以及保存系统活动信息" class="headerlink" title="sar - 收集, 报告以及保存系统活动信息"></a>sar - 收集, 报告以及保存系统活动信息</h3><p>首次使用，需要编辑文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/default/sysstat</div></pre></td></tr></table></figure>
<p>将里面的内容改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#</div><div class="line"># Default settings for /etc/init.d/sysstat, /etc/cron.d/sysstat</div><div class="line"># and /etc/cron.daily/sysstat files</div><div class="line">#</div><div class="line"></div><div class="line"># Should sadc collect system activity informations? Valid values</div><div class="line"># are &quot;true&quot; and &quot;false&quot;. Please do not put other values, they</div><div class="line"># will be overwritten by debconf!</div><div class="line">ENABLED=&quot;true&quot;</div></pre></td></tr></table></figure>
<p>然后重新启动 <code>systat</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service sysstat restart</div></pre></td></tr></table></figure>
<p>才能直接使用 <code>sar</code></p>
<h3 id="uptime-Tell-how-long-the-system-has-been-running"><a href="#uptime-Tell-how-long-the-system-has-been-running" class="headerlink" title="uptime - Tell how long the system has been running"></a>uptime - Tell how long the system has been running</h3><p><img src="17-05-10-10_42_04_931_272.png" alt=""></p>
<h3 id="mpstat-Report-processors-related-statistics"><a href="#mpstat-Report-processors-related-statistics" class="headerlink" title="mpstat - Report processors related statistics"></a>mpstat - Report processors related statistics</h3><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -an</div></pre></td></tr></table></figure>
<ul>
<li><strong>-a</strong>:</li>
<li><strong>–all</strong>: 显示所有的监听和未监听的 Sockets</li>
<li><strong>-n</strong>:</li>
<li><strong>–numeric</strong>: 显示数字的地址，而不是显示 symbolic 地址，端口或用户名</li>
</ul>
<h3 id="top-显示系统整体资源使用情况"><a href="#top-显示系统整体资源使用情况" class="headerlink" title="top - 显示系统整体资源使用情况"></a>top - 显示系统整体资源使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 每隔 3 秒刷新一次</span></div><div class="line">top -d 3</div></pre></td></tr></table></figure>
<h3 id="lsof-list-open-files"><a href="#lsof-list-open-files" class="headerlink" title="lsof - list open files"></a>lsof - list open files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof -p <span class="variable">$PID</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>-p $PID</strong>: excludes or selects the listing  of  files  for  the  processes  whose  optional process  IDentification  (PID)  numbers are in the comma-separated set s.</li>
</ul>
<h3 id="strace-trace-system-calls-and-signals"><a href="#strace-trace-system-calls-and-signals" class="headerlink" title="strace - trace system calls and signals"></a>strace - trace system calls and signals</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace git status</div></pre></td></tr></table></figure>
<p>参考 <a href="https://item.jd.com/10948631481.html" target="_blank" rel="external">《TCP/IP高效编程改善网络程序的44个技巧》</a></p>
<h3 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h3><p><code>dstat</code> 是一个可以取代 <code>vmstat</code>，<code>iostat</code>，<code>netstat</code> 和 <code>ifstat</code> 这些命令的多功能产品。<code>dstat</code> 克服了这些命令的局限并增加了一些另外的功能，增加了监控项，也变得更灵活了。<code>dstat</code> 可以很方便监控系统运行状况并用于基准测试和排除故障。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install dstat</div></pre></td></tr></table></figure>
<p><code>dstat</code> 是使用 <code>Python</code> 写的，源码<a href="https://github.com/dagwieers/dstat/blob/master/dstat" target="_blank" rel="external">参考</a></p>
<p><img src="2017_12_14_16_12_49.png" alt=""></p>
<p>线程如果被频繁休眠/唤醒，会造成 <code>kernal cpu</code> 利用率高， <code>context switch</code> 达到 <code>cpu</code> 极高水平，进而导致<strong>其他线程获取 <code>cpu</code> 时间少</strong>，吞吐量下降。</p>
<p>就是下面这段代码导致的:</p>
<p><img src="2017_12_14_16_15_01.png" alt=""></p>
<h3 id="操作系统性能监控"><a href="#操作系统性能监控" class="headerlink" title="操作系统性能监控"></a>操作系统性能监控</h3><p><strong>CPU 使用率</strong>:</p>
<ul>
<li>图形界面: <code>gnome-system-monitor</code></li>
</ul>
<p><strong>CPU 调度程序运行队列 (等待好运行、正等待可用 CPU 的轻量级进程)</strong>:</p>
<ul>
<li><code>vmstat</code> 的第一列 <code>r</code> 列</li>
</ul>
<p><strong>内存使用率</strong>:</p>
<ul>
<li><code>vmstat</code> 的 <code>free</code> 列</li>
<li><code>top</code></li>
<li><code>/proc/meminfo</code></li>
</ul>
<p><strong>监控锁竞争</strong>:</p>
<p><img src="2018_01_03_23_12_15.png" alt="context_switch"></p>
<ul>
<li><strong>让步式上下文切换</strong>: 执行线程主动释放 CPU</li>
<li><strong>抢占式上下文切换</strong>: 线程因为分配的时间片用尽而被迫放弃 CPU 或者被更高优先级所抢占。</li>
</ul>
<p>通过命令 <strong><code>pidstat -w</code></strong> 的 <strong><code>nvcswch/s</code></strong> 这一列能够监控到抢占式上下文切换的数量。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://item.jd.com/1247899762.html" target="_blank" rel="external">《高性能Linux服务器构建实战:运维监控、性能调优与集群应用》</a></li>
<li><a href="https://item.jd.com/11670385.html" target="_blank" rel="external">《实战 Java 虚拟机》</a></li>
<li><a href="https://www.amazon.cn/dp/B00IOB0K1Q" target="_blank" rel="external">《Java性能优化权威指南》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/10/Linux常见性能分析工具/" data-id="cjcdlsfvk0013diemo0i6el1l" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-java-concurrency" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/09/java-concurrency/" class="article-date">
  <time datetime="2017-05-09T14:42:35.000Z" itemprop="datePublished">2017-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/09/java-concurrency/">Java Concurrency</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="FTHOR.png" alt=""></p>
<p><strong>Timed waiting</strong>:</p>
<ul>
<li><code>Thread.sleep(sleeptime)</code></li>
<li><code>Object.wait(timeout)</code></li>
<li><code>Thread.join(timeout)</code></li>
<li><code>LockSupport.parkNanos(timeout)</code></li>
<li><code>LockSupport.parkUntil(timeout)</code></li>
</ul>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Tests if some Thread has been interrupted.  The interrupted state</span></div><div class="line"><span class="comment"> * is reset or not based on the value of ClearInterrupted that is</span></div><div class="line"><span class="comment"> * passed.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常 <code>Thread</code> 写法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        Thread.currentThread().interrupt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>能够对 <code>Thread.interrupt()</code> 方法做出响应的一些方法:</p>
<p><img src="17-07-14-17_45_50_822_369.png" alt=""></p>
<hr>
<p><img src="2017_10_12_11_13_28.png" alt=""></p>
<hr>
<p><a href="https://stackoverflow.com/questions/15900387/how-to-stop-all-runnable-thread-in-java-executor-class" target="_blank" rel="external">立即<strong>结束</strong>整个线程池</a>:</p>
<p>The <code>shutDown()</code> method simply <strong>防止添加更多任务</strong> from being scheduled. Instead, you could call <code>shutDownNow()</code> and check for thread interruption in your Runnable.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in your Runnable...</span></div><div class="line"><span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">  <span class="comment">// Executor has probably asked us to stop</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给出一个 <code>Demo</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</div><div class="line">executor.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(<span class="number">20</span> * <span class="number">1000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      System.out.println(<span class="string">"Interrupted, so exiting."</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (executor.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</div><div class="line">  System.out.println(<span class="string">"task completed"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  System.out.println(<span class="string">"Forcing shutdown..."</span>);</div><div class="line">  executor.shutdownNow();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实际项目中，像下面这样的代码，使用 <code>shutdown()</code> 方法是结束不了的，必须使用 <code>shutdownNow()</code> 方法来触发中断才可以:</p>
<p><img src="2017_12_20_20_21_22.png" alt=""></p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AtomicInteger-vs-AtomicIntegerFieldUpdater"><a href="#AtomicInteger-vs-AtomicIntegerFieldUpdater" class="headerlink" title="AtomicInteger vs AtomicIntegerFieldUpdater"></a><code>AtomicInteger</code> vs <code>AtomicIntegerFieldUpdater</code></h3><p>The Java 5 atomic classes also include atomic field updaters. These are essentially used as “wrappers” around a volatile field (primitive or object reference). In truth, these wrappers are used inside the Java class libraries, but probably aren’t used much in user code. But it is worth taking a look at them to see when they could be useful. They are generally used when one or both of the following are true:</p>
<ul>
<li>You generally want to refer to the variable “normally” (that is, without having to always refer to it via the get or set methods on the atomic classes) but occasionally need an atomic get-set operation (which you can’t do with a normal volatile field);</li>
<li>you are going to <strong>创建大量的对象</strong> of the given type, and don’t want every single instance to have to have an extra object embedded in it just for atomic access.</li>
</ul>
<p>An example of the first kind is <code>BufferedInputStream</code>. Every instance of <code>BufferedInputStream</code> contains an internal buffer, defined as a volatile byte array. Generally speaking, <code>BufferedInputStream</code> just needs to refer to this array “normally” for the purpose of reading/writing bytes. However, an atomic get-and-set operation is needed in specific places where the buffer array is replaced (either to grow it or to mark it as null or closed), because closure can occur in <strong>一个不同的线程</strong> to that performing the reads. One option would have been to declare the buffer variable as an <code>AtomicReference</code> to an array, and always get and set the array via this variable. But that would be a bit messy. Instead, a noraml volatile array variable is used, and the class also contains a static <code>AtomicReferenceUpdater</code> as follows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> AtomicReferenceFieldUpdater&lt;BufferedInputStream, <span class="keyword">byte</span>[]&gt;</div><div class="line">  bufUpdater = AtomicReferenceFieldUpdater.newUpdater</div><div class="line">        (BufferedInputStream.class,  <span class="keyword">byte</span>[].class, <span class="string">"buf"</span>);</div></pre></td></tr></table></figure>
<p>The array itself still remains a normal (volatile) variable, and reads and writes from the array can use normal array syntax. But when necessary, via the field updater, an atomic compare-and-set operation can be performed on the volatile variable. Although the updater is static, each instance of BufferedInputStream has its own buffer of course. So when we perform the CAS operation, we need to pass into the updater the actual object whose variable we want to affect:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (bufUpdater.compareAndSet(<span class="keyword">this</span>, oldBuffer, newBuffer)) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This is a call inside a method of <code>BufferedInputStream</code>, so this refers to the particular instance of this class that the method is being called on, and that object’s variable will be affected.</p>
<hr>
<p><strong>Using atomic field updaters for linked nodes</strong>:</p>
<p>Another use for atomic field updaters is to avoid creating <strong>创建大量的原子变量</strong>. For example, if we were creating a linked list structure designed for concurrent access, we might want each node to have an atomic variable pointing to the next node in the list. Judicious code can then allow different parts of the list to be updated concurrently. Without atomic field updaters, this would have meant code such as the following:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> AtomicReference&lt;Node&lt;T&gt;&gt; next;</div><div class="line">  <span class="keyword">private</span> T val;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In other words, every single node will have an additional <code>AtomicReference</code> object embedded in it. Using an atomic field updater, we can get a performance gain by declaring the ‘next node’ variable as a normal volatile object reference, and then using a field updater (of which we declare a single, static, instance shared by all nodes to access their respective ‘next node’ field):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; next;</div><div class="line">  <span class="keyword">private</span> T val;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>As mentioned, atomic field updaters have been used in various places in the Java class libraries.In reality, if you want an efficient currently accessible data structure, it is strongly recommended to use one of the excellent standard implementations such as <code>ConcurrentHashMap</code>, <code>ConcurrentLinkedQueue</code> or (as of Java 6) <code>ConcurrentSkipListMap</code>.</p>
<hr>
<p>在 <code>Netty</code> 中，<a href="https://github.com/netty/netty/blob/4.1/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java" target="_blank" rel="external"><code>AbstractReferenceCountedByteBuf</code></a> 类使用 <code>AtomicIntegerFieldUpdater</code> 来更新字段 <code>refCnt</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractReferenceCountedByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractByteBuf</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater =</div><div class="line">            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, <span class="string">"refCnt"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> refCnt;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>参考:</p>
<ul>
<li><a href="http://www.javamex.com/tutorials/synchronization_concurrency_7_atomic_updaters.shtml" target="_blank" rel="external">http://www.javamex.com/tutorials/synchronization_concurrency_7_atomic_updaters.shtml</a></li>
</ul>
<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>使用自定义 <code>ThreadFactory</code> 的好处:</p>
<ul>
<li>命名线程</li>
<li>设置 <code>daemon</code> 状态</li>
<li>设置优先级</li>
<li>添加线程到一个组里面</li>
<li>给未捕获的异常添加一个 <code>Handler</code></li>
</ul>
<p>位于 <code>java.util.concurrent.Executors.java</code> 中的内部类 <code>DefaultThreadFactory</code> 的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The default thread factory</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</div><div class="line"></div><div class="line">    DefaultThreadFactory() &#123;</div><div class="line">        SecurityManager s = System.getSecurityManager();</div><div class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</div><div class="line">            Thread.currentThread().getThreadGroup();</div><div class="line">        namePrefix = <span class="string">"pool-"</span> +</div><div class="line">            poolNumber.getAndIncrement() +</div><div class="line">            <span class="string">"-thread-"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</div><div class="line">                              namePrefix + threadNumber.getAndIncrement(),</div><div class="line">                              <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (t.isDaemon())</div><div class="line">            t.setDaemon(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</div><div class="line">            t.setPriority(Thread.NORM_PRIORITY);</div><div class="line">        <span class="keyword">return</span> t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个比较优雅的采用 <a href="http://git.oschina.net/anxiaoyi/code-segments/blob/master/java/ThreadFactoryBuilder.java" target="_blank" rel="external"><code>Builder</code></a> 模式实现的 <code>ThreadFactory</code>:</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>【强制】<strong>线程资源必须通过线程池提供</strong>,不允许在应用中自行显式创建线程。使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销,解决资源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
<p>【强制】线程池不允许使用 <code>Executors</code> 去创建,而是通过 <code>ThreadPoolExecutor</code> 的方式,这样的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。<code>Executors</code> 返回的线程池对象的弊端如下:</p>
<p>1) <code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>: 允许的请求队列长度为 <code>Integer.MAX_VALUE</code> ,可能会堆积大量的请求，从而导致 <code>OOM</code> 。<br>2) <code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>: 允许的创建线程数量为 <code>Integer.MAX_VALUE</code> ,可能会创建大量的线程，从而导致 <code>OOM</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * The synchronization state.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * CLH 锁队列</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Node t = tail;</div><div class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></div><div class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                    tail = head;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                node.prev = t;</div><div class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                    t.next = node;</div><div class="line">                    <span class="keyword">return</span> t;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 独占式释放同步状态</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 独占式获取同步状态</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步器依赖内部的同步队列(一个 FIFO 双向队列)来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点 (Node) 并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p>同步队列中的节点(Node)用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p>
<p>在获取同步状态时，同步器维护一个同步队列，<strong>获取状态失败的线程都会被加入到队列中并在队列中进行自旋</strong>；移出队列(或停止自旋)的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用 <code>tryRelease(int arg)</code> 方法释放同步状态，然后唤醒头节点的后继节点。</p>
<p><strong>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态</strong>。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。</p>
<p><img src="17-05-10-19_44_23_765_426.png" alt=""></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>重入锁表示<strong>该锁能够支持一个线程对资源的重复加锁</strong>，该特性的实现需要解决以下两个问题:</p>
<ul>
<li><strong>线程再次获取锁</strong>。锁需要去识别获取锁的线程是否为当前占据锁的线程。如果是，则再次成功获取。</li>
<li><strong>锁的最终释放</strong>。线程重复 n 次获取了锁,随后在第 n 次释放该锁后,其他线程能够获取到该锁。锁的最终释放要求锁<strong>对于获取进行计数自增</strong>,计数表示当前锁被重复获取的次数,而锁被释放时,计数自减,当计数等于 0 时表示锁已经成功释放。</li>
</ul>
<p><img src="17-05-10-22_39_56_863_478.png" alt=""></p>
<p>对于非公平锁,只要 CAS 设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。该方法与 <code>nonfairTryAcquire(int acquires)</code> 比较,唯一不同的位置为判断条件多了 <code>hasQueuedPredecessors()</code> 方法,即加入了<strong>同步队列中当前节点是否有前驱节点</strong>的判断,如果该方法返回 true ,则表示<strong>有线程比当前线程更早地请求获取锁</strong>,因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<p><img src="17-05-10-22_48_30_758_487.png" alt=""></p>
<p>公平性锁保证了锁的获取按照 FIFO 原则, <strong>而代价是进行大量的线程切换</strong>。非公平性锁虽然可能造成线程“饥饿”,但极少的线程切换,保证了其更大的吞吐量。</p>
<h3 id="ReetrantReadWriteLock"><a href="#ReetrantReadWriteLock" class="headerlink" title="ReetrantReadWriteLock"></a>ReetrantReadWriteLock</h3><p>提供的特性:</p>
<ul>
<li>公平性选择</li>
<li>重进入</li>
<li>锁降级: 写锁能够降级为读锁</li>
</ul>
<p>读写锁同样依赖自定义同步器来实现同步功能,而读写状态就是其同步器的同步状态。回想 <code>ReentrantLock</code> 中自定义同步器的实现,同步状态表示锁被一个线程重复获取的次数,而读写锁的自定义同步器需要 <strong>在同步状态(一个整型变量)上维护多个读线程和一个写线程的状态,</strong> 使得该状态的设计成为读写锁实现的关键。</p>
<p>如果在一个整型变量上维护多种状态,就一定需要“按位切割使用”这个变量,读写锁将变量切分成了两个部分,<strong>高 16 位表示读,低 16 位表示写</strong>,划分方式如图所示:</p>
<p><img src="17-05-10-23_04_03_1003_456.png" alt=""></p>
<p>当前同步状态表示一个线程已经获取了写锁,且重进入了两次,同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢? 答案是通过位运算。假设当前同步状态值为 S ,写状态等于 <code>S &amp; 0x0000FFFF</code> (将高 16 位全部抹去),读状态等于 <code>S&gt;&gt;&gt;16</code> (无符号补 0 右移 16 位)。当写状态增加 1 时,等于 <code>S+1</code>,当读状态增加 1 时,等于 <code>S+(1&lt;&lt;16)</code> ,也就是 <code>S+0x00010000</code>。</p>
<p><img src="17-05-10-23_08_00_809_430.png" alt=""></p>
<p>如果存在读锁,则写锁不能被获取,原因在于:<strong>读写锁要确保写锁的操作对读锁可见</strong>,如果允许读锁在已被获取的情况下对写锁的获取,那么正在运行的其他读线程就无法感知到当前写线程的操作。因此,只有等待其他读线程都释放了读锁,写锁才能被当前线程获取,而写锁一旦被获取,则其他读写线程的后续访问均被阻塞。</p>
<p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁,然后将其释放,最后再获取读锁,这种分段完成的过程不能称之为锁降级。<strong>锁降级是指把持住(当前拥有的)写锁,再获取到读锁,随后释放(先前拥有的)写锁的过程</strong>。</p>
<hr>
<p><strong>1) 增加和删除</strong>的时候，使用 <code>writeLock</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// put into config Map</span></div><div class="line">        <span class="comment">// delete from config Map</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">this</span>.lock.writeLock().unlock();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    log.error(<span class="string">"InterruptedException"</span>, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2) 序列化、读取</strong>的时候，使用 <code>readLock</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">this</span>.lock.readLock().lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// Map persist to file</span></div><div class="line">        <span class="comment">// get from Map</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">this</span>.lock.readLock().unlock();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    log.error(<span class="string">"InterruptedException"</span>, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="LockSupport-工具"><a href="#LockSupport-工具" class="headerlink" title="LockSupport 工具"></a>LockSupport 工具</h3><p>当需要阻塞或唤醒一个线程的时候,都会使用 <code>LockSupport</code> 工具类来完成相应工作。<code>LockSupport</code> 定义了一组的公共静态方法,这些方法提供了最基本的线程<strong>阻塞和唤醒</strong>功能,而 <code>LockSupport</code> 也成为构建同步组件的基础工具。</p>
<p><code>LockSupport</code> 定义了一组以 <code>park</code> 开头的方法用来阻塞当前线程,以及 <code>unpark(Thread thread)</code> 方法来唤醒一个被阻塞的线程。<code>Park</code> 有停车的意思,假设线程为车辆,那么 <code>park</code> 方法代表着停车,而 <code>unpark</code> 方法则是指车辆启动离开。</p>
<p>有阻塞对象的 <code>parkNanos(Object blocker, long nanos)</code> 方法能够传递给开发人员更多的现场信息。这是由于在 Java 5 之前,当线程阻塞(使用 <code>synchronized</code> 关键字)在一个对象上时,通过线程 dump 能够查看到该线程的阻塞对象,方便问题定位,而 Java 5 推出的 <code>Lock</code> 等并发工具时却遗漏了这一点,致使在线程 dump 时无法提供阻塞对象的信息。因此,在 Java 6 中,<code>LockSupport</code> 新增了上述3个含有阻塞对象的 <code>park</code> 方法,用以替代原有的 <code>park</code> 方法。</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>任意一个 <code>Java</code> 对象，都拥有一组监视器方法(定义在 <code>java.lang.Object</code> 上)，主要包括 <code>wait()、wait(long timeout)、notify()</code> 以及 <code>notifyAll()</code> 方法，这些方法与 <code>synchronized</code> 同步关键字配合，可以实现等待/通知模式。<code>Condition</code> 接口也提供了类似 <code>Object</code> 的监视器方法，与 <code>Lock</code> 配合可以实现等待/通知模式。<code>Condition</code> 对象是由 <code>Lock</code> 对象(调用 <code>Lock</code> 对象的 <code>newCondition()</code> 方法)创建出来的，换句话说，<code>Condition</code> 是依赖 <code>Lock</code> 对象的。</p>
<p>每个 <code>Condition</code> 对象都包含着一个<strong>队列</strong>(以下称为等待队列),该队列是 <code>Condition</code> 对象实现等待/通知功能的关键。</p>
<p>在 <code>Object</code> 的监视器模型上,一个对象拥有一个同步队列和等待队列,而并发包中的 <code>Lock</code> (更确切地说是同步器)拥有一个同步队列和多个等待队列:</p>
<p><img src="17-05-11-08_52_56_1017_619.png" alt=""></p>
<p>调用 <code>Condition</code> 的 <code>signal()</code> 方法,将会唤醒在等待队列中等待时间最长的节点(首节点)，在唤醒节点之前，会将节点移到同步队列中:</p>
<p><img src="add-new-thread.png" alt=""></p>
<hr>
<p><code>await</code> 方法就是往队列里面<strong>添加一个标明当前线程的节点</strong>的过程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line"></div><div class="line">    Node t = lastWaiter;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        firstWaiter = node;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        t.nextWaiter = node;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><code>signal</code> 过程就是一个<strong>切换状态和队列</strong>的过程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node node = firstWaiter;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 入队列</span></div><div class="line">    Node p = enq(node);</div><div class="line">    <span class="keyword">int</span> ws = p.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line">        LockSupport.unpark(node.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Java-并发容器"><a href="#Java-并发容器" class="headerlink" title="Java 并发容器"></a>Java 并发容器</h3><ul>
<li><code>ConcurrentHashMap</code> 替代了 <code>HashMap</code></li>
<li><code>CopyOnWriteArrayList</code> 替代同步 <code>List</code></li>
<li><code>CopyOnWriteArraySet</code> 替代同步 <code>Set</code></li>
<li>阻塞队列</li>
</ul>
<p>阻塞队列提供了可<font color="red"><strong>阻塞</strong></font>的 <code>put</code> 和 <code>take</code> 方法，以及支持<font color="red"><strong>定时</strong></font>的 <code>offer</code> 和 <code>poll</code> 方法。如果队列已经满了，那么 <code>put</code> 方法将阻塞直到空间可用；如果队列为空，那么 <code>take</code> 方法将会阻塞直到有元素可用。队列可以是有界的也可以是无界的，无界队列永远都不会充满，因此无界队列上的 <code>put</code> 方法也永远不会阻塞。</p>
<p><code>BlockingQueue</code> 简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。</p>
<p>关于 <code>ArrayBlockingQueue</code> 的更多介绍:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean add(E e)</code></td>
<td>添加到队尾，<strong>满了抛出异常</strong>，无阻塞</td>
</tr>
<tr>
<td><code>boolean offer(E e)</code></td>
<td>添加到队尾，满了返回 <code>false</code>，无阻塞</td>
</tr>
<tr>
<td><code>E poll()</code></td>
<td>从队头取出，空直接返回 <code>null</code>，无阻塞</td>
</tr>
<tr>
<td><code>void put(E e) throws InterruptedException</code></td>
<td>添加到队尾，满了阻塞等待</td>
</tr>
<tr>
<td><code>E take() throws InterruptedException</code></td>
<td>从队头取出，空了阻塞等待</td>
</tr>
<tr>
<td><code>boolean offer(E e, long timeout, TimeUnit unit)</code></td>
<td>添加到队尾，带有定时的阻塞</td>
</tr>
<tr>
<td><code>E poll(long timeout, TimeUnit unit)</code></td>
<td>从队头取出，带有定时的阻塞</td>
</tr>
</tbody>
</table>
<h4 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1. ConcurrentHashMap"></a>1. ConcurrentHashMap</h4><p>在一些情况下，<code>ConcurrentHashMap</code> 将会使用<strong>红黑平衡树 (red-black tree) 而非链表</strong>来保存元素。当元素数量大于某个值的时候，使用平衡树可以把最坏情况的性能由 O(n) 提升到 O(log n)。<code>java.util.HashMap, java.util.LinkedHashMap and java.util.concurrent.ConcurrentHashMap</code> 这几个都做了类似的改动。</p>
<ul>
<li>当一个桶内的元素数量大于等于 8 个的时候，单链表转为红黑树</li>
<li>当一个桶内的元素数量小于等于 6 个的时候，红黑树转为单链表</li>
</ul>
<hr>
<ul>
<li><code>ConcurrentHashMap</code> 返回的迭代器具有弱一致性，而并非<strong>即使失败</strong>。</li>
<li><code>size()</code> 返回的结果在计算时可能已经过期了，它实际上只是一个估计值。</li>
</ul>
<h4 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2. ConcurrentLinkedQueue"></a>2. ConcurrentLinkedQueue</h4><p><img src="internal_storage_java8_hashmap.jpg" alt=""></p>
<p><code>ConcurrentLinkedQueue</code> 是一个基于链接节点的无界线程安全队列,它采用先进先出的规则对节点进行排序,当我们添加一个元素的时候,它会添加到队列的尾部;当我们获取一个元素时,它会返回队列头部的元素。</p>
<p><code>ConcurrentLinkedQueue</code> 使用场景: 当你需要从多线程中访问队列，但是你不需要等待新元素<br><code>LinkedBlockingQueue</code> 使用场景: 需要阻塞的队列</p>
<hr>
<p><strong>调用 <code>poll</code> 方法后一定要判断是否为空</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ChannelURL channelURL = channelURLQueue.poll();</div><div class="line"><span class="keyword">if</span> (channelURL != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3. DelayQueue"></a>3. DelayQueue</h4><p><code>DelayQueue</code> 是一个支持延时获取元素的无界阻塞队列。队列使用 <code>PriorityQueue</code> 来实现。队列中的元素必须实现Delayed接口,在创建元素时可以指定多久才能从队列中获取当前元素。<strong>只有在延迟期满时才能从队列中提取元素</strong>。</p>
<p><code>DelayQueue</code> 非常有用,可以将 <code>DelayQueue</code> 运用在以下应用场景。</p>
<ul>
<li>缓存系统的设计:可以用 <code>DelayQueue</code> 保存缓存元素的有效期,使用一个线程循环查询 <code>DelayQueue</code>, 一旦能从 <code>DelayQueue</code> 中获取元素时,表示缓存有效期到了。</li>
<li>定时任务调度:使用 <code>DelayQueue</code> 保存当天将会执行的任务和执行时间,一旦从 <code>DelayQueue</code> 中获取到任务就开始执行,比如 <code>TimerQueue</code> 就是使用 <code>DelayQueue</code> 实现的。</li>
</ul>
<p>延时阻塞队列的实现很简单,当消费者从队列里获取元素时,<strong>如果元素没有达到延时时间,就阻塞当前线程</strong>。</p>
<p><img src="17-05-11-11_18_43_802_699.png" alt=""></p>
<h4 id="4-LinkedBlockingQueue"><a href="#4-LinkedBlockingQueue" class="headerlink" title="4. LinkedBlockingQueue"></a>4. LinkedBlockingQueue</h4><p><code>LinkedBlockingQueue</code> 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 <code>Integer.MAX_VALUE</code>。</p>
<p><img src="17-05-11-11_28_28_726_198.png" alt=""></p>
<p><code>take</code> 如果为空，就会阻塞在 <code>notEmpty</code> 锁上:</p>
<p><img src="17-05-11-11_35_00_612_452.png" alt=""></p>
<h4 id="5-并发-Set"><a href="#5-并发-Set" class="headerlink" title="5. 并发 Set"></a>5. 并发 <code>Set</code></h4><p>There’s no built in type for <code>ConcurrentHashSet</code> because you can always <strong>derive a set from a map</strong>. Since there are many types of maps, you use a method to produce a set from a given map (or map class).</p>
<ul>
<li>在 <code>Java 8</code> 之前，你可以用 <code>Collections.newSetFromMap(map)</code></li>
<li>在 <code>Java 8</code> 中，你可以用 <code>ConcurrentHashMap.newKeySet()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ConcurrentHashMap&lt;String, Boolean&gt; conMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Boolean&gt;();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; distinctSet = Collections.newSetFromMap(conMap);</div></pre></td></tr></table></figure>
<h3 id="Java-并发工具类"><a href="#Java-并发工具类" class="headerlink" title="Java 并发工具类"></a>Java 并发工具类</h3><h4 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1 CountDownLatch"></a>1 CountDownLatch</h4><p><code>CountDownLatch</code> 允许一个或多个线程等待其他线程完成操作，其实就相当于 <code>thread.join()</code> 方法。</p>
<p><img src="17-05-11-12_01_42_839_572.png" alt=""></p>
<p>举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</div><div class="line"></div><div class="line">Waiter      waiter      = <span class="keyword">new</span> Waiter(latch);</div><div class="line">Decrementer decrementer = <span class="keyword">new</span> Decrementer(latch);</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(waiter)     .start();</div><div class="line"><span class="keyword">new</span> Thread(decrementer).start();</div><div class="line"></div><div class="line">Thread.sleep(<span class="number">4000</span>);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line">    CountDownLatch latch = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waiter</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.latch = latch;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            latch.await();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Waiter Released"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decrementer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    CountDownLatch latch = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decrementer</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.latch = latch;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            <span class="keyword">this</span>.latch.countDown();</div><div class="line"></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            <span class="keyword">this</span>.latch.countDown();</div><div class="line"></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            <span class="keyword">this</span>.latch.countDown();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>注意 <code>CountDownLatch</code> 是不支持 <code>reset</code> 的，因此在 <code>RocketMQ</code> 中，有一个类 <code>CountDownLatch2</code> 支持 <code>reset()</code> 方法，重置信号量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">        setState(startCount);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2 CyclicBarrier"></a>2 CyclicBarrier</h4><p><code>CyclicBarrier</code> 的字面意思是可循环使用 (Cyclic) 的屏障 (Barrier)。它要做的事情是,<strong>让一组线程到达一个屏障(也可以叫同步点)时被阻塞,直到最后一个线程到达屏障时,屏障才会开门</strong>, 所有被屏障拦截的线程才会继续运行。</p>
<p><strong><code>CyclicBarrier</code> vs <code>CountDownLatch</code></strong>:</p>
<ul>
<li><code>CyclicBarrier</code> 多一个 <code>reset()</code> 方法</li>
<li><code>CyclicBarrier</code> 多一个 <code>getNumberWaiting()</code> 方法</li>
<li><code>CyclicBarrier</code> 多一个 <code>isBroken()</code> 方法</li>
<li><code>CyclicBarrier</code> 有一个构造器 <code>public CyclicBarrier(int parties, Runnable barrierAction)</code> 方法，多个线程到达屏障以后，执行一个 <code>barrierAction</code> 任务</li>
<li><code>CyclicBarrier</code> 强调的是<strong>线程互相等待</strong>，而 <code>CountDownLatch</code> 强调的是<strong>某个线程等待其它一组线程完成</strong></li>
<li><code>CyclicBarrier</code> 必须有 N 个线程来等待，而 <code>CountDownLatch</code> 必须有 N 次调用，不一定有 N 个线程</li>
</ul>
<p><img src="cyclic-barrier.png" alt=""></p>
<h4 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3 Semaphore"></a>3 Semaphore</h4><p>Semaphore (信号量)是用来控制同时访问特定资源的线程数量,它通过协调各个线程,以保证合理的使用公共资源。</p>
<p>多年以来,我都觉得从字面上很难理解Semaphore所表达的含义,只能把它比作是<strong>控制流量的红绿灯</strong>。比如××马路要限制流量,只允许同时有一百辆车在这条路上行使,其他的都必须在路口等待,所以前一百辆车会看到绿灯,可以开进这条马路,后面的车会看到红灯,不能驶入××马路,但是如果前一百辆中有5辆车已经离开了××马路,那么后面就允许有5辆车驶入马路,这个例子里说的车就是线程,驶入马路就表示线程在执行,离开马路就表示线程执行完成,看见红灯就表示线程被阻塞,不能执行。</p>
<p><code>Semaphore</code> 可以用于做流量控制,特别是公用资源有限的应用场景,比如数据库连接。假如有一个需求,要读取几万个文件的数据,因为都是 IO 密集型任务,我们可以启动几十个线程并发地读取,但是如果读到内存后,还需要存储到数据库中,而数据库的连接数只有 10 个,这时我们必须控制只有 10 个线程同时获取数据库连接保存数据,否则会报错无法获取数据库连接。这个时候,就可以使用 Semaphore 来做流量控制。</p>
<h4 id="4-Exchanger"><a href="#4-Exchanger" class="headerlink" title="4 Exchanger"></a>4 Exchanger</h4><p>Exchanger (交换者)是一个用于线程间协作的工具类。<code>Exchanger</code> 用于进行线程间的数据交换。它提供一个同步点,<strong>在这个同步点,两个线程可以交换彼此的数据</strong>。这两个线程通过 <code>exchange</code> 方法交换数据,如果第一个线程先执行 <code>exchange()</code> 方法,它会一直等待第二个线程也执行 <code>exchange</code> 方法,当两个线程都到达同步点时,这两个线程就可以交换数据,将本线程生产出来的数据传递给对方。</p>
<h3 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>线程的运行机制:</p>
<ul>
<li>一个 CPU 每个时刻只能执行一条线程</li>
<li>操作系统给每条线程分配不同长度的时间片</li>
<li>操作系统会从一堆线程中随机选取一条来执行</li>
<li>每条线程用完自己的时间片后，即使任务还没完成，操作系统也会剥夺它的执行权，让另一条线程执行</li>
</ul>
<p>当一条线程的时间片用完后，操作系统会暂停该线程，并保存该线程相应的信息，然后再随机选择一条新线程去执行，这个过程就称为 “线程的上下文切换”。</p>
<p>上下文切换的过程:</p>
<ul>
<li>暂停正在执行的线程</li>
<li>保存该线程的相关信息（如：执行到哪一行、程序计算的中间结果等）</li>
<li>从就绪队列中随机选一条线程</li>
<li>读取该线程的上下文信息，继续执行</li>
</ul>
<p>如何减少上下文切换？</p>
<ul>
<li>减少线程的数量: 由于一个 CPU 每个时刻只能执行一条线程，而傲娇的我们又想让程序并发执行，操作系统只好不断地进行上下文切换来使我们从感官上觉得程序是并发执的行。因此，我们只要减少线程的数量，就能减少上下文切换的次数。然而如果线程数量已经少于 CPU 核数，每个 CPU 执行一条线程，照理来说 CPU 不需要进行上下文切换了，但事实并非如此。</li>
<li>控制同一把锁上的线程数量: 如果多条线程共用同一把锁，那么当一条线程获得锁后，其他线程就会被阻塞；当该线程释放锁后，操作系统会从被阻塞的线程中选一条执行，从而又会出现上下文切换。 因此，减少同一把锁上的线程数量也能减少上下文切换的次数。</li>
<li>采用无锁并发编程: 我们知道，如果减少同一把锁上线程的数量就能减少上下文切换的次数，那么如果不用锁，是否就能避免因竞争锁而产生的上下文切换呢？ 答案是肯定的！但你需要根据以下两种情况挑选不同的策略：<ul>
<li>需要并发执行的任务是无状态的：HASH 分段: 所谓无状态是指并发执行的任务没有共享变量，他们都独立执行。对于这种类型的任务可以按照 ID 进行 HASH 分段，每段用一条线程去执行。</li>
<li>需要并发执行的任务是有状态的：CAS 算法: 如果任务需要修改共享变量，那么必须要控制线程的执行顺序，否则会出现安全性问题。你可以给任务加锁，保证任务的原子性与可见性，但这会引起阻塞，从而发生上下文切换；为了避免上下文切换，你可以使用 CAS 算法， 仅在线程内部需要更新共享变量时使用 CAS 算法来更新，这种方式不会阻塞线程，并保证更新过程的安全性。</li>
</ul>
</li>
</ul>
<p><strong>使用 <code>perf</code> 命令来测量上下文切换的时间</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install linux-tools-generic</div><div class="line">sudo apt-get install linux-tools-4.4.0-75-generic</div><div class="line">perf <span class="built_in">stat</span> -e cpu-clock,task-clock,cs,cache-references,cache-misses java JavaThreadCreationAndRun</div></pre></td></tr></table></figure>
<h3 id="如何更好的使用多线程？"><a href="#如何更好的使用多线程？" class="headerlink" title="如何更好的使用多线程？"></a>如何更好的使用多线程？</h3><ul>
<li>① 高并发、任务执行<strong>时间短</strong>的业务，线程池线程数可以设置为<strong>CPU核数+1</strong>，减少线程上下文的切换。</li>
<li>② 并发不高、任务执行<strong>时间长</strong>的业务要区分开看：<ul>
<li>假如是业务时间长集中在I/O操作上，也就是I/O密集型的任务，因为<strong>I/O操作并不占用CPU</strong>，所以不要让所有的CPU闲下来，可以<strong>加大线程池中的线程数目</strong>，让CPU处理更多的业务。　　</li>
<li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和 ① 一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换。</li>
</ul>
</li>
<li>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能<strong>做缓存</strong>是第一步，<strong>增加服务器</strong>是第二步，至于线程池的设置，设置参考②。</li>
</ul>
<p>最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行<strong>拆分和解耦</strong>。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 在使用上有什么需要注意的？在高并发请求的环境下性能如何？会有什么问题？</p>
<p>答：</p>
<ul>
<li>① 注意事项：使用结束以后进行 <strong><code>remove</code></strong> 操作，避免 <code>ThreadLocal</code> 对象越来越大。</li>
<li>② 高并发的场景：由于 <code>ThreadLocal</code> 内部使用 <code>HashMap</code> 的原理，<code>key=currentThread</code>，因为 <code>HashMap</code> 是<strong>非线程安全</strong>的，一定要注意 <code>hashmap.resize</code> 的时候，可能会导致<strong>某几个CPU 100%</strong>的问题，进而导致应用出现资源耗尽等不可预知的问题。</li>
</ul>
<h3 id="什么时候应该考虑某个变量是否需要同步"><a href="#什么时候应该考虑某个变量是否需要同步" class="headerlink" title="什么时候应该考虑某个变量是否需要同步"></a>什么时候应该考虑某个变量是否需要同步</h3><p>当<strong>多个线程</strong>访问<strong>同一个</strong>可变的状态变量的时候。有三种方式解决这个问题:</p>
<ul>
<li><strong>不</strong>在线程之间<strong>共享</strong>该状态变量</li>
<li>将状态变量改为<strong>不可变</strong>的变量</li>
<li>在访问状态变量时<strong>使用同步</strong></li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h3><p><strong><code>volatile</code> 用来确保将变量的更新操作通知到其他线程</strong>。当把变量声明为 <code>volatile</code> 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量的操作与其他内存操作一起重排序。</p>
<h3 id="Final-域"><a href="#Final-域" class="headerlink" title="Final 域"></a><code>Final</code> 域</h3><p><strong><code>final</code></strong> 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时<strong>无须同步</strong>。即使对象是可变的，通过将对象的某些域声明为 <code>final</code> 类型，仍然可以<strong>简化对状态的判断</strong>，因此限制对象的可变性也就相当于限制了该对象可能的状态的集合。</p>
<h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p><code>JMM</code> 未程序中所有的操作定义了一个偏序关系，称之为 <code>Happens-Before</code> 规则。要想保证执行操作 <code>B</code> 的线程看到操作 <code>A</code> 的结果，那么在 <code>A</code> 和 <code>B</code> 之间必须满足 <code>Happens-Before</code> 关系:</p>
<p><img src="2017_11_02_15_06_48.png" alt=""></p>
<p>如果两个操作之间缺乏 <code>Happens-Before</code> 关系，那么 <code>JVM</code> 可以对他们进行任意重排序。</p>
<p><img src="2017_11_02_15_11_18.png" alt=""></p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a><code>Timer</code></h3><ul>
<li>在执行所有定时任务时只会创建一个线程。如果<strong>某个任务的执行时间过长，那么将破坏其它 <code>TimerTask</code> 的定时精确性</strong>。例如某个周期 <code>TimerTask</code> 需要每 10ms 执行一次，而另外一个 <code>TimerTask</code> 需要执行 40ms，那么这个周期任务或者在 40ms 任务执行完快速连续地调用 4 次，或者彻底 “丢失” 4 次调用。 (取决于它是基于固定速率调度还是基于固定延时来调度)。</li>
<li><code>TimerTask</code> 抛出了一个未检查异常，那么 <code>Timer</code> 将表现出糟糕的行为。它不捕获异常，也不会恢复线程的执行，而是会错误的认为<strong>整个 <code>Timer</code> 被取消了</strong>。</li>
</ul>
<h3 id="正确提交并使用多个-Callable-任务"><a href="#正确提交并使用多个-Callable-任务" class="headerlink" title="正确提交并使用多个 Callable 任务"></a>正确提交并使用多个 <code>Callable</code> 任务</h3><p><code>ExecutorCompletionService</code> 将 <code>Executor</code> 和 <code>BlockingQueue</code> 的功能融合在一起:</p>
<p><img src="2017_11_02_15_42_28.png" alt=""></p>
<h3 id="一次提交多个任务，并等待返回"><a href="#一次提交多个任务，并等待返回" class="headerlink" title="一次提交多个任务，并等待返回"></a>一次提交多个任务，并等待返回</h3><p><img src="2017_11_02_15_50_50.png" alt=""></p>
<h3 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h3><p><img src="2017_11_02_15_59_07.png" alt=""></p>
<p><code>volatile</code> 变量的问题:</p>
<p><img src="2017_11_02_16_00_42.png" alt=""></p>
<blockquote>
<p>实际上，在<strong>取消</strong>之外的其它操作中使用<strong>中断</strong>，都是不合适的，并且很难支撑起更大的应用。</p>
</blockquote>
<p><img src="2017_11_02_16_06_46.png" alt=""></p>
<h3 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h3><p>在<strong>内置锁</strong>中，恢复程序的唯一方法就是重新请程序，而防止死锁的唯一方法就是在构造程序时避免出现不一致的加锁顺序。</p>
<p><img src="2017_11_02_16_20_07.png" alt=""></p>
<h3 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h3><p>对于计算密集型任务，在拥有 $N_{cpu}$ 个处理器的系统上，当线程池的大小为 $N_{cpu} + 1$ 时，通常能够实现最优的利用率。</p>
<p>对于包含 <code>I/O</code> 操作或者其它<strong>阻塞</strong>操作的任务，由于线程池并<strong>不会一直执行</strong>，因此<strong>线程池的规模应该更大</strong>。</p>
<p>要正确地设置线程池的大小，你必须估算出任务的等待时间和计算时间的比值:</p>
<p>$$<br>N<em>{threads} = N</em>{cpu} <em> U_{cpu} </em> (1 + \frac{W}{C})<br>$$</p>
<p>其中:</p>
<ul>
<li>$N_{cpu}$: CPU 的个数</li>
<li>$U_{cpu}$: CPU 的利用率</li>
<li>$\frac{W}{C}$: 等待时间/计算时间</li>
</ul>
<h3 id="可阻塞的-take-的调用"><a href="#可阻塞的-take-的调用" class="headerlink" title="可阻塞的 take 的调用"></a>可阻塞的 <code>take</code> 的调用</h3><p>前提条件:</p>
<p><img src="2017_11_02_17_35_56.png" alt=""></p>
<p>当前提条件失败以后，调用者必须自行处理:</p>
<ul>
<li>容忍<strong>自旋</strong>导致的 CPU 时钟周期浪费</li>
<li>容忍由于<strong>休眠</strong>而导致的低响应性</li>
<li><strong><code>Thread.yield</code></strong> 给调度器一个提示: 现在需要让出一定时间使另一个线程运行。假如正在等待另外一个线程执行工作，那么如果选择让出处理器而不是消耗完整个 CPU 调度时间片，那么可以让整体的执行速度变快。</li>
</ul>
<p>通过<strong>轮询与休眠</strong>实现简单的阻塞:</p>
<p><img src="2017_11_02_17_44_28.png" alt=""></p>
<p>在 <code>take()</code> 出现可用空间的时刻与线程醒来并再次检查的时刻之间可能<strong>存在延迟</strong>:</p>
<p><img src="2017_11_02_17_46_44.png" alt=""></p>
<hr>
<p><strong>条件队列</strong>就好像烤面包机中通知 “面包已烤好” 的铃声。如果你注意听着铃声，那么当面包烤好后<strong>可以立刻得到通知</strong>。如果没有听见铃声，那么会错过通知消息，但是回到厨房时还可以<strong>观察烤面包机的状态</strong>，如果已经烤好，就取出面包；否则，再次留意铃声。</p>
<p>在 <code>Java</code> 中每个对象都可以作为一个条件队列，<code>Object</code> 中的 <code>wait</code>, <code>notify</code> 和 <code>notifyAll</code> 方法构成了内部条件队列的 API。</p>
<p>使用 <code>wait</code> 和 <code>notifyAll</code> 比使用 “休眠” <strong>更简单，更高效</strong> (醒来的次数更少)，<strong>响应性</strong>也更高 (发生特定状态变化时将立刻醒来)。但是需要注意的是，条件队列只是在多个方面进行了<font color="red"><strong>优化</strong></font>: CPU 效率、上下文切换开销和响应性等。</p>
<blockquote>
<p>如果某个功能无法通过 “轮询和休眠” 来实现，那么使用条件队列也无法实现。</p>
</blockquote>
<p><img src="2017_11_02_17_58_15.png" alt=""></p>
<hr>
<p>在产品的正式版本中，还应该包括限时版本的 <code>put</code> 和 <code>take</code> ，这样当操作不能在预计时间内完成时，可以因超时而返回。通过使用<strong>定时版本的 <code>Object.wait</code></strong>，可以很容易实现这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</div></pre></td></tr></table></figure>
<hr>
<p>通过一个锁来保护条件谓词:</p>
<p><img src="2017_11_02_21_27_18.png" alt=""></p>
<hr>
<p>在条件队列 API 中有两个发出<strong>通知</strong>的方法，即 <code>notify</code> 和 <code>notifyAll</code> 。无论使用哪一个，都必须持有与条件队列对象相关联的锁。在调用 <code>notify</code> 时，JVM 会从这个条件队列上等待的多个线程中选择<strong>一个</strong>来唤醒, 而调用 <code>notifyAll</code> 时则会唤醒<strong>所有</strong>在这个条件队列上等待的线程。</p>
<h4 id="Condition-对象"><a href="#Condition-对象" class="headerlink" title="Condition 对象"></a><code>Condition</code> 对象</h4><p>内置条件队列存在一些缺陷:</p>
<ul>
<li>每个内置锁都只能有<strong>一个</strong>相关联的条件队列，因此可能存在<strong>多个</strong>线程在同一个条件队列上<strong>等待不同条件谓词</strong>的情况。</li>
</ul>
<p>一个 <code>Condition</code> 和一个 <code>Lock</code> 关联在一起，就好像一个条件队列和一个内置锁相关联一样。调用 <code>Lock.newCondition</code> 方法就能直接创建一个 <code>Condition</code>。</p>
<p>与内置对象不同，对于每一个 <code>Lock</code>，可以有任意数量的 <code>Condition</code> 对象。</p>
<p><img src="2017_11_02_21_38_11.png" alt=""></p>
<h3 id="等待多个-Future-类的任务完成"><a href="#等待多个-Future-类的任务完成" class="headerlink" title="等待多个 Future 类的任务完成"></a>等待多个 <code>Future</code> 类的任务完成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>);</div><div class="line">CompletionService&lt;SomeResult&gt; completionService = </div><div class="line">       <span class="keyword">new</span> ExecutorCompletionService&lt;SomeResult&gt;(executor);</div><div class="line"></div><div class="line"><span class="comment">//4 tasks</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">   completionService.submit(<span class="keyword">new</span> Callable&lt;SomeResult&gt;() &#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> SomeResult <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">           ...</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> received = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> erros = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(received &lt; <span class="number">4</span> &amp;&amp; !errors) &#123;</div><div class="line">      Future&lt;SomeResult&gt; resultFuture = completionService.take(); <span class="comment">//blocks if none available</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         SomeResult result = resultFuture.get();</div><div class="line">         received ++;</div><div class="line">         ... <span class="comment">// do something with the result</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">             <span class="comment">//log</span></div><div class="line">         errors = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Thread-sleep-0-和-Thread-yield-的异同"><a href="#Thread-sleep-0-和-Thread-yield-的异同" class="headerlink" title="Thread.sleep(0) 和 Thread.yield() 的异同"></a><a href="https://stackoverflow.com/questions/1600572/are-thread-sleep0-and-thread-yield-statements-equivalent" target="_blank" rel="external"><code>Thread.sleep(0)</code> 和 <code>Thread.yield()</code></a> 的异同</h3><p>This really depends on the platform and version of the JVM. For example, under Windows in <strong>JDK 5</strong> (Hotspot), <code>yield()</code> is literally implemented as <code>Sleep(0)</code>– although a sleep of 0 is treated slightly specially by Windows as I recall. But in <strong>JDK 6</strong>, <code>yield()</code> is implemented as <code>SwitchToThread()</code>.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://wilddiary.com/understanding_custom_threadfactory_in_java/" target="_blank" rel="external">Understanding Custom ThreadFactory In Java</a></li>
<li><a href="http://www.infoq.com/cn/minibooks/Alibaba-Java-minibook?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">《阿里巴巴Java开发手册》</a></li>
<li><a href="http://blog.csdn.net/u010425776/article/details/54233279" target="_blank" rel="external">CSDN-Java并发编程的艺术(一)——并发编程需要注意的问题</a></li>
<li><a href="https://item.jd.com/11740734.html" target="_blank" rel="external">《Java 并发编程的艺术》</a></li>
<li><a href="(https://examples.javacodegeeks.com/core-java/util/hashmap/hashmap-changes-in-java-8/">HashMap changes in Java 8</a>)</li>
<li><a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/" target="_blank" rel="external">How does a HashMap work in JAVA</a></li>
<li><a href="http://mrbool.com/how-to-implement-concurrent-queue-linked-in-java/26640" target="_blank" rel="external">How to implement Concurrent Queue Linked in Java</a></li>
<li><a href="http://stackoverflow.com/questions/4168772/java-concurrency-countdown-latch-vs-cyclic-barrier" target="_blank" rel="external">Java concurrency: Countdown latch vs Cyclic barrier</a></li>
<li><a href="http://tutorials.jenkov.com/java-util-concurrent/cyclicbarrier.html" target="_blank" rel="external">CyclicBarrier</a></li>
<li><a href="https://stackoverflow.com/questions/27406200/visual-vm-thread-states/27406503" target="_blank" rel="external">Visual VM - Thread States</a></li>
<li><a href="https://item.jd.com/11785190.html" target="_blank" rel="external">《Java多线程编程实战指南（设计模式篇）》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/09/java-concurrency/" data-id="cjcdlsfxz004jdiem0m73qedi" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-IO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/06/IO/" class="article-date">
  <time datetime="2017-05-06T14:14:05.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/06/IO/">IO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="IO-Input-和-Output"><a href="#IO-Input-和-Output" class="headerlink" title="IO - Input 和 Output"></a>IO - Input 和 Output</h2><h3 id="5-种-I-O-模型"><a href="#5-种-I-O-模型" class="headerlink" title="5 种 I/O 模型"></a>5 种 I/O 模型</h3><ul>
<li>阻塞式 I/O</li>
</ul>
<p><img src="17-05-06-23_04_13_785_388.png" alt=""></p>
<p>可能阻塞的套接字调用可分为如下几类:</p>
<ul>
<li>输入操作: <code>read、readv、recv、recvfrom、recvmsg</code> 5 个函数</li>
<li>输出操作: <code>write、writev、send、sendto、sendmsg</code> 5 个函数</li>
<li>接受外来连接: <code>accept</code> 函数</li>
<li>发出外来连接: <code>connect</code> 函数</li>
</ul>
<p>标准访问文的方式: 当应用程序调用 <code>read()</code> 接口时，操作系统检查在内核的告诉缓存中有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回。写入的时候，从用户地址空间复制到内核地址空间的缓存中，什么时候写到磁盘由操作系统决定。</p>
<p><img src="17-05-17-20_39_07_411_271.png" alt=""></p>
<p>直接 I/O 的方式: 应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，减少一次从内核缓冲区到用户数据缓存的数据复制。这种访问文件的方式通常是在对数据的缓存管理由应用程序的数据库管理系统中。</p>
<p><img src="17-05-17-20_43_00_447_290.png" alt=""></p>
<ul>
<li>非阻塞式 I/O</li>
</ul>
<p><img src="17-05-08-21_05_13_734_355.png" alt=""></p>
<p>设置非阻塞 I/O:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> val = fcntl(STDOUT_FILENO, F_GETFL, <span class="number">0</span>);</div><div class="line">fcntl(STDOUT_FILENO, F_SETFL, val | O_NONBLOCK);</div></pre></td></tr></table></figure>
<ul>
<li>I/O 复用 (<code>select</code> 和 <code>poll</code>)</li>
</ul>
<p><img src="17-05-08-21_21_11_717_340.png" alt=""></p>
<ul>
<li>信号驱动式 I/O (<code>SIGIO</code>)</li>
</ul>
<p><img src="17-05-08-21_23_49_760_365.png" alt=""></p>
<ul>
<li>异步 I/O (POSIX 的 <code>aio_</code> 系列函数)</li>
</ul>
<p>信号驱动式 I/O 是由内核通知我们<strong>何时可以启动</strong>一个 I/O 操作，而异步 I/O 模型是由内核通知我们<strong>何时完成</strong>。</p>
<p><img src="17-05-08-21_26_37_741_386.png" alt=""></p>
<p>5 种 I/O 模型比较:</p>
<p><img src="17-05-08-21_29_37_796_397.png" alt=""></p>
<p><code>select</code> 指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它，函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timespec *timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>我们可以在下列情况收到内核通知:</p>
<ul>
<li>集合 {1, 4, 5} 中的任何描述符准备好读</li>
<li>集合 {2, 7} 中的任何描述符准备好写</li>
<li>集合 {1, 4} 中的任何描述符有异常条件待处理</li>
<li>已经历了 10.2 秒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fd_set rset; <span class="comment">// 比特位</span></div><div class="line">FD_ZERO(&amp;rset);</div><div class="line">FD_SET(<span class="number">1</span>, &amp;rset);</div><div class="line">FD_SET(<span class="number">5</span>, &amp;rset);</div><div class="line"></div><div class="line">select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</div><div class="line">    <span class="comment">// socket is readable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>select</code> 最大缺陷就是单个进程所打开的文件描述符是有一定限制的，它由 <strong>FD_SETSIZE</strong> 设置，默认值是 1024。可以选择修改这个宏然后重新编译内核，不过这会带来网络效率的下降。</p>
<p><code>pselect</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</div></pre></td></tr></table></figure>
<p><code>pselect</code> 是能够处理信号阻塞并提供更高事件分辨率的 <code>select</code> 的增强版本。</p>
<p><code>poll</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<p><code>epoll</code> 函数:</p>
<ul>
<li>一个进程打开的 <code>socket</code> 描述符不受限制 (仅受限于操作系统的最大文件句柄数 <code>cat /proc/sys/fs/file-max</code> )</li>
<li>I/O 效率不会随着文件描述符数目的增加而线性下降，<code>select/poll</code> 每次都会线性扫描全部的集合</li>
<li>把内核和用户空间 <code>mmap</code> 到同一块内存来加速这两者之间的消息传递</li>
</ul>
<h3 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h3><p>在 UNIX 系统上大多数 I/O 只需要通过这五个函数完成: <code>open, read, write, lseek, and close</code>。相对于标准 I/O，我们这里讨论的都是 <strong>unbuffered I/O (每一次 <code>read</code> 和 <code>write</code> 都会产生一个系统调用)</strong>。</p>
<p>通常，UNIX 系统 shell 把文件描述符 0 与进程的标准输入关联，文件描述符 1 与标准输出关联，文件描述符 2 与标准错误关联。</p>
<p>文件描述符的最大限制:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/fs/file-max <span class="comment"># 599216</span></div></pre></td></tr></table></figure>
<p>文件描述符的当前数量:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/fs/file-nr</div></pre></td></tr></table></figure>
<p>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span> )</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>; <span class="comment">// 改变已经打开文件的属性</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 成功: 返回 0</span></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence); <span class="comment">// 成功: 返回新的文件偏移量</span></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); <span class="comment">// 成功: 读到的字节数; 文件末尾: 返回 0</span></div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); <span class="comment">// 成功: 已写的字节数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 复制一个现有的文件描述符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 将所有修改的块缓冲区排入写队列，然后返回，并不等待磁盘操作结束</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 等待磁盘写操作结束</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>; <span class="comment">// I/O 操作的杂物箱，一般用于中断 I/O</span></div></pre></td></tr></table></figure>
<p>调用 <code>dup(fd)</code> 等效于 <code>fcntl(fd, F_DUPFD, 0)</code>; <code>fcntl</code> 函数可以:</p>
<ul>
<li>复制一个已有的文件描述符</li>
<li>获取/设置文件描述符标志</li>
<li>获取/设置文件状态标志</li>
<li>获取/设置异步 I/O 所有权</li>
<li>获取/设置记录锁</li>
</ul>
<h3 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h3><blockquote>
<p>文件 I/O 围绕文件描述符，标准 I/O 围绕流</p>
</blockquote>
<h4 id="Binary-I-O"><a href="#Binary-I-O" class="headerlink" title="Binary I/O"></a>Binary I/O</h4><p>一次读或写一个 <strong>structure</strong>，下述两个函数提供了二进制 I/O:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj,</div><div class="line">             FILE *<span class="keyword">restrict</span> fp);</div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj,</div><div class="line">              FILE *<span class="keyword">restrict</span> fp);</div></pre></td></tr></table></figure>
<p>我们可以这样操作一个结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">short</span> count;</div><div class="line">    <span class="keyword">long</span> total;</div><div class="line">    <span class="keyword">char</span> name[NAMESIZE];</div><div class="line">&#125; item;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (fwrite(&amp;item, <span class="keyword">sizeof</span>(item), <span class="number">1</span>, fp) != <span class="number">1</span>)</div><div class="line">    err_sys(<span class="string">"fwrite error"</span>);</div></pre></td></tr></table></figure>
<p>基于字节的 Java I/O 操作接口:</p>
<p><img src="file_io.jpg" alt=""></p>
<p>基于字符的 Java I/O 操作接口:</p>
<p><img src="reader_and_writer_class_in_java.jpg" alt=""></p>
<p>字节与字符的转化接口: <code>InputStreamReader</code> 派生出 <code>FileReader</code></p>
<h3 id="高级-I-O"><a href="#高级-I-O" class="headerlink" title="高级 I/O"></a>高级 I/O</h3><p>涵盖了一些 <strong>非阻塞 I/O、记录锁、I/O 多路复用 (<code>select</code> 和 <code>poll</code>)、异步 I/O、<code>readv</code> 和 <code>writev</code>、内存映射 I/O (mmap)</strong></p>
<h4 id="readv-和-writev"><a href="#readv-和-writev" class="headerlink" title="readv 和 writev"></a><code>readv</code> 和 <code>writev</code></h4><p>这两个函数可以让我们从多个缓冲区里面读和写，这些操作称之为 <strong>scatter read</strong> 和 <strong>gather write</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *iov_base; <span class="comment">/* starting address of buffer */</span></div><div class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/* size of buffer */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Memory-Mapped-I-O-内存映射-I-O"><a href="#Memory-Mapped-I-O-内存映射-I-O" class="headerlink" title="Memory-Mapped I/O 内存映射 I/O"></a>Memory-Mapped I/O 内存映射 I/O</h4><p>Memory-Mapped I/O 让我们可以将位于磁盘上的一个文件映射到内存上的一个缓冲区中，当我们从缓冲区中读，我们就是从文件中读；当我们向缓冲区写，对象的文件也被写入了。Memory-Mapped I/O 已经被用于 virtual memory systems 很多年了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off )</span></span>;</div></pre></td></tr></table></figure>
<p>内存映射文件:</p>
<p><img src="17-05-08-22_09_32_629_472.png" alt=""></p>
<h3 id="Client-Server-IO"><a href="#Client-Server-IO" class="headerlink" title="Client/Server IO"></a>Client/Server IO</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p><img src="17-05-08-22_45_10_757_283.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ServerSocket server = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    server = <span class="keyword">new</span> ServerSocket(port);</div><div class="line">    Socket socket = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        socket = server.accept();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Request(socket)).start();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</div><div class="line">        server.close();</div><div class="line">        server = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="伪异步-IO"><a href="#伪异步-IO" class="headerlink" title="伪异步 IO"></a>伪异步 IO</h4><p><img src="17-05-08-22_44_31_784_278.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TimeServerHandlerExcutePool singleExecutor = <span class="keyword">new</span> TimeServerHandlerExecutePool(<span class="number">50</span>, <span class="number">10000</span>);</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    socket = server.accept();</div><div class="line">    singleExecutor.execute(<span class="keyword">new</span> TimeServerHandler(socket));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当对 <code>Socket</code> 的输入流进行读取的操作的时候，它会一直阻塞下去，直到发生三种事件:</p>
<ul>
<li>有数据可读</li>
<li>可用数据已经读取完毕</li>
<li>发生空指针或 I/O 异常</li>
</ul>
<p>这意味着当对方发送请求或者应答消息比较缓慢，或者网络传输缓慢时，读取输入流的一方的通信线程将被长时间阻塞，如果对方要 60s 才能够将数据发送完成，读取一方的 I/O 线程也将会被同步阻塞 60s，在此期间，其他接入消息只能在消息队列中排队。当调用 <code>OutputStream</code> 的 <code>write</code> 方法时，也面临同样的问题。当消息的接收方处理缓慢的时候，将不能及时地从 TCP 缓冲区中读取数据，这将会导致发送方的 TCP window size 不断减小，直到为 0，双方处于 Keep-Alive 状态，消息发送方将不能再向 TCP 缓冲区写入消息，这时如果采用的是同步阻塞 I/O，<code>write</code> 操作将会被无期限阻塞，直到 TCP window size 大于 0 或者发生 I/O 异常。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MultiplexerTimeServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        selector = Selector.open();</div><div class="line">        servChannel = ServerSocketChannel.open();</div><div class="line">        servChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        servChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">1024</span>);</div><div class="line">        servChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!stop) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            selector.select(<span class="number">1000</span>);</div><div class="line">            Set&lt;SelectonKey&gt; selectedKeys = selector.selectedKeys();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 代码未完待续 ...</span></div></pre></td></tr></table></figure>
<p>由于 <code>SocketChannel</code> 是异步非阻塞的，它并不保证一次能够把需要发送的字节数组发送完，此时会出现 “写半包” 问题。我们需要注册写操作，不断轮询 <code>Selector</code> 将没有发送完的 <code>ByteBuffer</code> 发送完毕，然后可以通过 <code>ByteBuffer</code> 的 <code>hasRemain()</code> 方法判断消息是否发送完成。</p>
<p>相比于 BIO，NIO 的一个明显的好处是不需要为每一个 <code>Socket</code> 分配一个线程，而可以在一个线程中处理多个 <code>Socket</code> 套接字相关的工作。</p>
<p><img src="reactordiagram.png" alt=""></p>
<p>通过 <code>Channel</code> 对象获取的 I/O 数据首先要经过操作系统的 Socket 缓冲区，再将数据复制到 <code>Buffer</code> 中，这个操作系统缓冲区就是底层的 TCP 所关联的 RecvQ 或者 SendQ 队列，从操作系统缓冲区到用户缓冲区复制数据比较消耗性能，<code>Buffer</code> 还提供了另外一种直接操作系统缓冲区的方式，即 <code>ByteBuffer.allocateDirector(size)</code>，这个方法返回的 <code>DirectByteBuffer</code> 就是与底层存储空间关联的缓冲区，它通过 Native 代码操作非 JVM 堆的内存空间。每次创建或者释放的时候都会调用一次 <code>System.gc()</code>。一般在数据量比较大、生命周期比较长的情况下比较合适。</p>
<p><code>FileChannel.transferXXX</code> 与传统的访问文件方式相比可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动:</p>
<p><img src="17-05-17-20_54_48_510_282.png" alt=""></p>
<p><code>FileChannel.map</code> 将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时，将直接操作这个文件数据，这种方式省去了数据从内核空间向用户空间复制的损耗。这种方式适合对大文件的只读性操作，如大文件的 MD5 校验。</p>
<h4 id="AIO-编程"><a href="#AIO-编程" class="headerlink" title="AIO 编程"></a>AIO 编程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTimeServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    </div><div class="line">    CountDownLatch latch;</div><div class="line">    AsynchronousServerSocketChannel asynchronousServerSocketChannel;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTimeServerHandler</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();</div><div class="line">            asynchronousServerSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        latch = <span class="keyword">new</span> CountDownLatch();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            latch.await();    </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        asynchronousServerSocketChannel.accept(<span class="keyword">this</span>, <span class="keyword">new</span> AcceptCompletionHandler());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousServerSocketChannel result, AcceptCompletionHandler attachment)</span> </span>&#123;</div><div class="line">        attachment.asynchronousServerSocketChannel.accept(attachment, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="comment">// 代码未完继续 ...</span></div></pre></td></tr></table></figure>
<h4 id="I-O-调优"><a href="#I-O-调优" class="headerlink" title="I/O 调优"></a>I/O 调优</h4><p>性能检测: 通过压力测试，看系统 I/O wait 指标是否异常。例如，测试机器有 4 个 CPU，那么理想的 I/O wait 参数不应该超过 25%，如果超过，则 I/O 很可能成为应用程序的性能瓶颈。在 Linux 下通过 <code>iostat</code> 命令查看。通常我们还会查看另外一个参数，就是 IOPS，即要查看应用程序需要的最低的 IOPS 是多少，磁盘的 IOPS 能不能达到要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(磁盘数 * 每块磁盘的 IOPS) / (磁盘块的吞吐量 + RAID 因子 * 磁盘写的吞吐量) = IOPS</div></pre></td></tr></table></figure>
<p>TCP 连接查看主机可以使用的端口范围:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/net/ipv4/ip_local_port_range</div></pre></td></tr></table></figure>
<p><img src="17-05-17-21_11_26_708_54.png" alt=""></p>
<p>可用端口数量: 60999 - 32768 = 28231，如果这个值偏小，则遇到大量并发请求时就会成为性能瓶颈。</p>
<table>
<thead>
<tr>
<th>网络调优参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>echo &quot;1024 65535&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range</code></td>
<td>设置端口可用范围</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</code></td>
<td>设置 time_wait 连接重用</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</code></td>
<td>设置快速回收 time_wait 连接</td>
</tr>
<tr>
<td><code>echo 180000 &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets</code></td>
<td>设置最大 time_wait 连接长度</td>
</tr>
<tr>
<td><code>echo 0 &gt; /proc/sys/net/ipv4/tcp_timestamps</code></td>
<td>表示是否启用以一种比超时重发更精确的方法来启用对 RTT 的计算</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_window_scaling</code></td>
<td>设置 TCP/IP 会话的滑动窗口大小是否可变</td>
</tr>
<tr>
<td><code>echo 20000 &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog</code></td>
<td>设置最大等待处于客户端还没有应答回来的连接数</td>
</tr>
<tr>
<td><code>echo 10000 &gt; /proc/sys/net/core/somaxconn</code></td>
<td>设置每一个处于监听状态的端口的监听队列的长度</td>
</tr>
<tr>
<td><code>echo 10000 &gt; /proc/sys/net/core/netdev_max_backlog</code></td>
<td>设置最大等待 CPU 处理的包的数目</td>
</tr>
<tr>
<td><code>echo 2000000 &gt; /proc/sys/fs/file-max</code></td>
<td>设置最大打开的文件数</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>以上设置都是临时性的，系统重新启动后就会丢失。</p>
<h3 id="Buffered-I-O"><a href="#Buffered-I-O" class="headerlink" title="Buffered I/O"></a>Buffered I/O</h3><p><code>BufferedOutputStream</code> 经常被用在<strong>避免频繁操作磁盘和网络</strong>的地方(<a href="https://stackoverflow.com/questions/6821887/bufferedoutputstream-vs-bytearrayoutputstream" target="_blank" rel="external">参考</a>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(zip);</div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</div><div class="line">oos.writeObject(prices);</div></pre></td></tr></table></figure>
<p><code>ByteArrayOutputStream</code> <strong>只是在内存里面</strong>做一层缓冲:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">GZIPOutputStream zip = <span class="keyword">new</span> GZIPOutputStream(baos);</div></pre></td></tr></table></figure>
<h3 id="文件-I-O-CSAPP"><a href="#文件-I-O-CSAPP" class="headerlink" title="文件 I/O - CSAPP"></a>文件 I/O - CSAPP</h3><p><strong>文件描述符</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd1, fd2;</div><div class="line">    fd1 = open(<span class="string">"data/foo.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    close(fd1);</div><div class="line">    fd2 = open(<span class="string">"data/baz.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    <span class="comment">// fd2 = 3</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"fd2 = %d\n"</span>, fd2);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Unix <strong>进程生命周期</strong>开始时，打开的描述符赋给了 <code>stdin (0)</code>，<code>stdout (1)</code> 和 <code>stderr (2)</code>。 <code>open</code> 函数总是返回最低的未打开的描述符，所以第一次调用 <code>open</code> 会返回描述符 <code>3</code>，<strong>调用 <code>close</code> 函数会释放描述符 <code>3</code></strong>。最后依然会返回 <code>3</code>。</p>
<hr>
<p><strong>一次一个字节从标准输入拷贝到标准输出</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (read(STDIN_FILENO, &amp;c, <span class="number">1</span>) != <span class="number">0</span>) &#123;</div><div class="line">        write(STDOUT_FILENO, &amp;c, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="2017_12_04_22_40_07.png" alt=""></p>
<hr>
<p><strong>读取文件元数据</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></div><div class="line">    <span class="keyword">char</span> *type, *readok;</div><div class="line"></div><div class="line">    stat(argv[<span class="number">1</span>], &amp;stat_buf);</div><div class="line">    <span class="keyword">if</span> (S_ISREG(stat_buf.st_mode)) &#123;</div><div class="line">        type = <span class="string">"regular"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat_buf.st_mode)) &#123;</div><div class="line">        type = <span class="string">"directory"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        type = <span class="string">"other"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((stat_buf.st_mode &amp; S_IRUSR)) &#123;</div><div class="line">        readok = <span class="string">"yes"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        readok = <span class="string">"no"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"type: %s, read: %s\n"</span>, type, readok);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>共享文件</strong>:</p>
<p><img src="2017_12_05_15_05_04.png" alt=""></p>
<p>以同一个 <code>filename</code> 调用 <code>open</code> 函数两次，这个时候，<strong>每个描述符都有它自己的文件位置</strong>，所以对不同描述符的读操作可以从文件的不同位置获取数据:</p>
<p><img src="2017_12_05_15_05_35.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd1, fd2;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line"></div><div class="line">    <span class="comment">// foobar</span></div><div class="line">    fd1 = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    fd2 = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    read(fd1, &amp;c, <span class="number">1</span>);</div><div class="line">    read(fd2, &amp;c, <span class="number">1</span>);</div><div class="line">    <span class="comment">// c = f</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"c = %c\n"</span>, c);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fork</code> 之后，<strong>子进程有一个父进程的描述符表的副本</strong>:</p>
<p><img src="2017_12_05_15_05_54.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    </div><div class="line">    fd = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</div><div class="line">        read(fd, &amp;c, <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    wait(<span class="literal">NULL</span>);</div><div class="line">    read(fd, &amp;c, <span class="number">1</span>);</div><div class="line">    <span class="comment">// c = o</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"c = %c\n"</span>, c);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>I/O 重定向</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拷贝描述符表项 oldfd 到描述符表表项 newfd，覆盖描述符表表项 newfd 以前的内容</span></div><div class="line"><span class="comment">// 如果 newfd 已经打开，则会在拷贝 oldfd 之前关闭 newfd</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</div></pre></td></tr></table></figure>
<p>以命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls &gt; foo.txt</div></pre></td></tr></table></figure>
<p>为例，描述符 <code>1 (标准输出)</code> 原来对应于文件 <code>A (一个终端)</code>，描述符 <code>4</code> 原来对应于 <code>B (foo.txt)</code>，经过 <code>dup2(4, 1)</code> 之后:</p>
<p><img src="2017_12_05_17_54_09.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd1, fd2;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line"></div><div class="line">    fd1 = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    fd2 = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    read(fd2, &amp;c, <span class="number">1</span>);</div><div class="line">    <span class="comment">// int dup2(int oldfd, int newfd);</span></div><div class="line">    dup2(fd2, fd1);</div><div class="line">    read(fd1, &amp;c, <span class="number">1</span>);</div><div class="line">    <span class="comment">// c = o</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"c = %c\n"</span>, c);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><img src="2017_12_05_21_40_53.png" alt=""></p>
<p>当我们试图对网络输入使用标准 <code>I/O</code> 时，它会带来一些令人讨厌的问题:</p>
<ul>
<li><strong>标准 <code>I/O</code> 是全双工</strong>的，程序能够在同一个流上执行输入和输出。</li>
<li>跟在输出函数之后的输入函数。如果中间没有插入 <code>fflush</code>、<code>fseek</code>、<code>fsetpos</code> 或者 <code>rewind</code> 的调用，一个输入函数不能跟随在一个输出函数之后。<code>fflush</code> 清空与流相关的缓冲区。后三个函数调用使用 <code>Unix IO</code> 的 <code>lseek</code> 函数来重置当前的文件位置。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">write();</div><div class="line">fflush();</div><div class="line">read();</div></pre></td></tr></table></figure>
<ul>
<li>跟在输入函数之后的输出函数。如果中间没有插入 <code>fseek</code>、<code>fsetpos</code> 或者 <code>rewind</code> 的调用,一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个 <code>EOF</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一种可能解决方案</span></div><div class="line"><span class="comment">// 更正确的解决方案: 建议使用 RIO 函数</span></div><div class="line">FILE *fpin, *fpout;</div><div class="line"></div><div class="line">fpin = fdopen(sockfd, <span class="string">"r"</span>);</div><div class="line">fpout = fdopen(sockfd, <span class="string">"w"</span>);</div><div class="line"></div><div class="line">fclose(fpin);</div><div class="line"><span class="comment">// 第二个 close 操作可能会失败</span></div><div class="line">fclose(fpout);</div></pre></td></tr></table></figure>
<p>对套接字执行 <code>lseek</code> 函数是非法的。</p>
<h3 id="InputStream-available"><a href="#InputStream-available" class="headerlink" title="InputStream#available()"></a><code>InputStream#available()</code></h3><p>将 <code>InputStream</code> 变成 <code>byte[]</code> 的正确操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] inputStream2ByteArray(InputStream inputStream) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line"></div><div class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line">    <span class="keyword">while</span> ((c = inputStream.read(buf)) &gt;= <span class="number">0</span>) &#123;</div><div class="line">        byteArrayOutputStream.write(buf, <span class="number">0</span>, c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InputStream is;</div><div class="line"><span class="keyword">byte</span>[] bytes = IOUtils.toByteArray(is);</div></pre></td></tr></table></figure>
<p>千万不要像下面这样写 (<strong>尤其是网络流</strong>):</p>
<p>每次返回的 <code>available</code> 的值都不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] inputStream2ByteArray(InputStream inputStream) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">byte</span>[] buf = inputStream.available();</div><div class="line">    inputStream.read(buf);</div><div class="line">    <span class="keyword">return</span> buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The <code>available()</code> method tells you <strong>能够读取多少字节直到 the <code>read()</code></strong> call will block the execution flow of your program. On most of the input streams, all call to <code>read()</code> are blocking, that’s why available returns 0 by default.</p>
<p>However, on some streams (such as <code>BufferedInputStream</code>, that have an <strong>内部缓冲区</strong>), some bytes are read and kept in <strong>内存</strong>, so you can read them without blocking the program flow. In this case, the <code>available()</code> method tells you how many bytes are kept in the buffer.</p>
<h3 id="从文件末尾读取最多-30000-个字节的内容"><a href="#从文件末尾读取最多-30000-个字节的内容" class="headerlink" title="从文件末尾读取最多 30000 个字节的内容"></a>从文件末尾读取最多 30000 个字节的内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> SHOW_LOG_LENGTH = <span class="number">30000</span>;</div><div class="line"></div><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">FileChannel channel = fis.getChannel();</div><div class="line">size = channel.size();</div><div class="line"></div><div class="line">ByteBuffer bb;</div><div class="line"><span class="keyword">if</span> (size &lt;= SHOW_LOG_LENGTH) &#123;</div><div class="line">    bb = ByteBuffer.allocate((<span class="keyword">int</span>) size);</div><div class="line">    channel.read(bb, <span class="number">0</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">int</span> pos = (<span class="keyword">int</span>) (size - SHOW_LOG_LENGTH);</div><div class="line">    bb = ByteBuffer.allocate(SHOW_LOG_LENGTH);</div><div class="line">    channel.read(bb, pos);</div><div class="line">&#125;</div><div class="line"></div><div class="line">bb.flip();</div><div class="line">content = <span class="keyword">new</span> String(bb.array());</div></pre></td></tr></table></figure>
<h3 id="IO-重定向"><a href="#IO-重定向" class="headerlink" title="IO 重定向"></a>IO 重定向</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 摘自 Tomcat 9 源代码</span></div><div class="line"><span class="comment">// Catalina.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStreams</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Replace System.out and System.err with a custom PrintStream</span></div><div class="line">    System.setOut(<span class="keyword">new</span> SystemLogHandler(System.out));</div><div class="line">    System.setErr(<span class="keyword">new</span> SystemLogHandler(System.err));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/" target="_blank" rel="external">《Advanced Programming in the UNIX》</a></li>
<li><a href="https://www.amazon.com/Unix-Network-Programming-Sockets-Networking/dp/0131411551" target="_blank" rel="external">《Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)》</a></li>
<li><a href="https://item.jd.com/11681556.html" target="_blank" rel="external">《Netty 权威指南》</a></li>
<li><a href="https://item.jd.com/11449803.html" target="_blank" rel="external">《大型网站系统与 Java 中间件实践》</a></li>
<li><a href="https://unix.stackexchange.com/questions/36841/why-is-number-of-open-files-limited-in-linux" target="_blank" rel="external">Why is number of open files limited in Linux?</a></li>
<li><a href="https://item.jd.com/11520670.html" target="_blank" rel="external">《深入分析 Java Web 内幕》</a></li>
<li><a href="https://item.jd.com/11896988.html" target="_blank" rel="external">《Java Performance: The Definitive Guide》</a></li>
<li><a href="https://www.amazon.cn/gp/product/B01N03IQK4" target="_blank" rel="external">《深入理解计算机系统》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/06/IO/" data-id="cjcdlsfvh000zdiem3cauwa0i" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/06/TCP/" class="article-date">
  <time datetime="2017-05-06T02:56:10.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/理解计算机/">理解计算机</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/06/TCP/">TCP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="发送缓存和接受缓存"><a href="#发送缓存和接受缓存" class="headerlink" title="发送缓存和接受缓存"></a>发送缓存和接受缓存</h3><p>发送进程和接受进程可能以不同的速度写入数据和读取数据，因此 TCP 需要使用缓存来存储数据。缓存还被 TCP 用来进行流量控制和差错控制。</p>
<p><img src="chap-12-tcp-7-638.jpg" alt=""></p>
<p>IP 层作为 TCP 的服务提供者，<strong>它必须以分组 (in packets) 为单位发送数据</strong>，而不是按照字节流来发送。在运输层，TCP 把若干个字节组成一个分组 (TCP groups a number of bytes together into a packet called a segment)，称为 <strong>报文段 (segment)</strong>。TCP 给每个报文段添加一个首部（用于控制），然后再把这个 <strong>报文段 (segment)</strong> 交付给 IP 层传输。这些 <strong>报文段 (segment)</strong>被封装成 <strong>IP 数据报 (IP datagram)</strong> 后发送出去。这些 <strong>报文段 (segment)</strong> 在接受时，有可能会失序、丢失，或受到损伤和重传，所有这些都是由 TCP 来处理的，而接受进程并不知道 TCP 的这些活动。</p>
<blockquote>
<p>这些<strong>报文段 (segment)</strong>并不一定长度相同</p>
</blockquote>
<h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>面向的是虚连接，而不是物理连接，每一个 <strong>IP 数据报 (IP datagram)</strong> 可以走不同的路径到达终点。</p>
<h3 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h3><ul>
<li>编号系统 Numbering System</li>
<li>流量控制</li>
<li>差错控制</li>
<li>拥塞控制</li>
</ul>
<p><strong>报文段 (segment)</strong> 首部中有两个叫做<strong>序号 (sequence number)</strong> 和<strong>确认号 (acknowledgment number)</strong> 的字段。这两个字段都指的是字节 (byte number) 的编号，而不是 <strong>报文段 (segment)</strong> 的编号。</p>
<p>TCP 把在一个连接中要发送的所有数据字节都编上号，它随机选择一个位于 0 ~ (2^32 -1) 之间的一个数字作为第一个字节的编号。当字节都被编上号以后，TCP 就给每一个要发送的报文段指派一个<strong>序号 (sequence number)</strong>。</p>
<p>报文段中确认字段的值定义了某一方期望接受的下一个字节的编号，<strong>确认号是累积的</strong>。</p>
<h3 id="报文段-Segment"><a href="#报文段-Segment" class="headerlink" title="报文段 Segment"></a>报文段 Segment</h3><p><img src="tcphead1.gif" alt=""><br><img src="tcp-segment-1.gif" alt=""><br><img src="tcp-analysis-section-6-2.gif" alt=""></p>
<h3 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h3><p>TCP 协议在运输层和终点之间建立了一条虚路径。同属于一个报文的所有报文段都沿着这条虚路径发送 (All of the segments belonging to a message are then sent over this virtual path)。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li>客户端发送第一个报文段 (SYN 报文段)，其不携带任何数据，但是它要消耗一个序号。</li>
</ul>
<p><img src="tcphead1_three_way_shake_1.gif" alt=""></p>
<ul>
<li>服务器发送第二个报文段 (SYN + ACK 报文段)，其同样不携带任何数据，但是也要消耗一个序号。</li>
</ul>
<p><img src="tcphead1_three_way_shake_2.gif" alt=""></p>
<ul>
<li>客户端发送第三个报文段 (ACK 报文段)，请注意，这个报文段的序号和 SYN 报文段使用的序号一样，也就是说，它不消耗任何序号。在某些实现中，连接阶段的第三个报文段可以携带客户端的第一个数据块，在这种情况下，第三个报文段必须有一个新的序号来表示数据中的第一个字节的编号。</li>
</ul>
<p><img src="tcphead1_three_way_shake_3.gif" alt=""></p>
<p>TCP 中使用的连接建立过程很容易碰到一个严重的安全问题，称为 <strong>SYN 洪泛攻击 (SYN flooding attack)</strong>。当一个或多个恶意的攻击者向某台服务器发送大量的 SYN 报文段，并通过伪造报文段中的源 IP 地址来假装每一个报文段来自不同的客户时，这个问题就发生了。服务器认为这些客户发来了主动打开请求，于是就分配必要的资源，如创建传送控制块 (TCP) 表，并设置一些计时器。然后 TCP 的服务器向这些假冒的客户发送 <strong>SYN + ACK 报文段</strong>，而这些报文段都丢失了。但是，在服务器等待握手的第三步的这段时间里，大量的资源被占用而没有利用。如果在很短的时间内，SYN 报文段的数量很大，服务器最终会因资源耗尽而不能接受来自合法客户的连接请求。这种 SYN 洪泛攻击属于一组称为 <strong>拒绝服务攻击 (denial of service attack)</strong> 的安全攻击，即攻击者用大量的服务请求垄断了一个系统，使这个系统因超载而拒绝为合法的请求提供服务。</p>
<p>TCP 的一些实现采取了一些策略减轻 SYN 攻击的影响:</p>
<ul>
<li>强制限制在指定时间内的连接请求次数</li>
<li>把来自不希望的源地址的数据包过滤掉</li>
<li>SCTP: 使用 Cookie，做到推迟资源的分配，直至服务器能够证实连接请求来自合法的 IP 地址</li>
</ul>
<h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><p>数据可以双向传送，并且在同一个报文段中也可以携带确认，确认是随数据捎带过来的。举例，客户使用两个报文段发送了2000字节的数据，然后服务器使用一个报文段发送了2000字节的数据。前三个报文段既带有数据又带有确认，但最后一个报文段只有确认而没有数据。</p>
<ul>
<li>客户发送第一个报文段</li>
</ul>
<p><img src="tcphead1_send_data_1.gif" alt=""></p>
<ul>
<li>客户发送第二个报文段</li>
</ul>
<p><img src="tcphead1_send_data_2.gif" alt=""></p>
<ul>
<li>服务器发送第一个报文段</li>
</ul>
<p><img src="tcphead1_send_data_3.gif" alt=""></p>
<ul>
<li>客户返回最后一个报文段</li>
</ul>
<p><img src="tcphead1_send_data_4.gif" alt=""></p>
<p>客户发送的数据报文段具有<strong>置 1 的 PSH (推送)</strong> 标志，因此服务器 TCP 知道要在收到这些数据后<strong>尽可能快地 (不必等待更多数据的到来)</strong>把它们交付给服务器进程。而从服务器发送来的报文段则没有把推送标志置 1.</p>
<p>通过发送一个 URG (紧急) 位置 1 的报文段，可以发送<strong>紧急字节</strong>。TCP 紧急模式只是发送方的应用程序对某一部分字节流<strong>做了标记</strong>，要求接收方的应用程序特殊对待，并不是优先处理，也不是加速数据服务。</p>
<h4 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h4><p>目前，大多数 TCP 实现允许在连接终止时有两种选择：<strong>三次挥手</strong>和<strong>具有半关闭选项的四次挥手</strong>。</p>
<h5 id="三次挥手"><a href="#三次挥手" class="headerlink" title="三次挥手"></a>三次挥手</h5><ul>
<li>客户发送一个把 FIN 位置置为 1 的报文段，这个报文段也可以包含客户发送的最后一块数据，如果不包含，那么它只消耗一个序号。</li>
</ul>
<p><img src="tcphead1_close_conn_1.gif" alt=""></p>
<ul>
<li>服务器返回一个 FIN + ACK 报文段，这个报文段同样也可以包含来自服务器的最后一块数据。如果它不携带数据，那么它只消耗一个序号。</li>
</ul>
<p><img src="tcphead1_close_conn_2.gif" alt=""></p>
<ul>
<li>客户发送最后一个 ACK 报文段，不携带数据，也不消耗序号。</li>
</ul>
<p><img src="tcphead1_close_conn_3.gif" alt=""></p>
<h5 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h5><p>连接的一方停止接收数据，但是仍然发送数据，这称之为<strong>半关闭 (half-close)</strong></p>
<p><img src="chap-12-tcp-30-638.jpg" alt=""></p>
<h5 id="连接复位"><a href="#连接复位" class="headerlink" title="连接复位"></a>连接复位</h5><p>某一端的 TCP 可能会拒绝一个连接请求，也可能异常终止一条在用的连接，或者可能要终止一条空闲的连接，所有这些都是通过 RST (复位) 标志来完成的。</p>
<h4 id="连接建立和半关闭终止"><a href="#连接建立和半关闭终止" class="headerlink" title="连接建立和半关闭终止"></a>连接建立和半关闭终止</h4><p><img src="17-05-06-18_05_05_647_764.png" alt=""></p>
<p>MSL 是一个报文段被丢弃之前在因特网中能够生存的最大时间。TCP 报文段是封装在生存时间 (TTL) 受限的 IP 数据报中。当 IP 数据报被丢弃时，封装在其中的 TCP 报文段也就丢失了。MSL 的常用数值是 30 ～ 60 秒。有两个理由使得我们需要 TIME-WAIT 状态和 2MSL 计时器:</p>
<ul>
<li>如果最后一个 ACK 报文段丢失了，那么服务器 TCP 以为是它的 FIN 丢失了，因而重传它。如果客户已进入 CLOSED 状态，并在 2MSL 计时器超时之前就关闭了这条连接，那么客户就永远收不到这个重传的 FIN 报文段，因而服务器也就永远收不到最后的 ACK。服务器无法关闭这条连接。2MSL 计时器可以使客户等待足够长的时间，使得在 ACK 丢失 (一个 MSL) 的情况下，可以等到下一个 FIN 的到来 (另一个 MSL)。如果在 TIME-WAIT 状态中有一个新的 FIN 到达了，客户就发送一个新的 ACK，并重新启动这个 2MSL 计时器。</li>
<li>某个连接中的重复报文段可能会出现在下一个连接中。客户和服务器关闭连接，经过短暂时间后，它们又打开了一个新的使用相同 Socket 地址，那么<strong>前一个连接的重复报文段有可能会到达新连接中</strong>。为了避免这个问题，TCP 规定这种情况必须经过 2MSL 时间之后才能出现。</li>
</ul>
<p><strong>关于 <code>TIME-WAIT</code> 还有弄清楚三点</strong>:</p>
<p>(1) 通常，只有一端 — <strong>主动关闭 (发送第一条 <code>FIN</code> ) 的那一端会进入 <code>TIME-WAIT</code> 状态</strong><br>(2) <code>TIME-WAIT</code> 一般是 0.5 ~ 2 分钟<br>(3) 如果连接处于 <code>TIME-WAIT</code> 时有分组到达，就重启 2MSL 的定时器</p>
<p><strong><code>SO_LINGER</code> 选项</strong>不建议使用，这会暗杀 <code>TIME-WAIT</code> 状态，强壮的应用程序永远都不应该干扰 <code>TIME-WAIT</code> 状态 —- 这是 TCP 可靠机制的重要组成部分。</p>
<h4 id="三次挥手-1"><a href="#三次挥手-1" class="headerlink" title="三次挥手"></a>三次挥手</h4><p>连接建立和终止阶段更为常见的是使用三次挥手:</p>
<p><img src="17-05-06-18_19_29_702_523.png" alt=""></p>
<h4 id="拒绝连接"><a href="#拒绝连接" class="headerlink" title="拒绝连接"></a>拒绝连接</h4><p>服务器发送 RST + ACK 报文段后，客户端进入 CLOSED 状态:</p>
<p><img src="17-05-06-18_23_34_696_414.png" alt=""></p>
<h4 id="TCP-调参"><a href="#TCP-调参" class="headerlink" title="TCP 调参"></a>TCP 调参</h4><p>高并发服务器建议调小 <code>TCP</code> 协议的 <code>time_wait</code> 超时时间。操作系统默认 240 秒后,才会关闭处于 <code>time_wait</code> 状态的连接,在高并发访问下,服务器端会因为处于 <code>time_wait</code> 的连接数太多,可能无法建立新的连接,所以需要在服务器上调小此等待值。在 linux 服务器上请通过变更 <code>/etc/sysctl.conf</code> 文件去修改该缺省值 ( 秒 ): </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net.ipv4.tcp_fin_timeout = 30</div></pre></td></tr></table></figure>
<p>调大服务器所支持的最大文件句柄数 (File Descriptor ,简写为 fd) 。主流操作系统的设计是将 TCP / UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd 。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现 “ open too many files ” 错误,导致新的连接无法建立。 建议将 linux 服务器所支持的最大句柄数调高数倍 ( 与服务器的内存数量相关 ) 。</p>
<h3 id="TCP-中的窗口"><a href="#TCP-中的窗口" class="headerlink" title="TCP 中的窗口"></a>TCP 中的窗口</h3><p><strong>TCP 为每个方向的数据传送各使用两个窗口 (发送窗口和接受窗口)</strong>，也就是说总共有四个窗口。</p>
<p>发送窗口:</p>
<p><img src="17-05-06-19_35_55_933_493.png" alt=""></p>
<p>接受窗口:</p>
<p><img src="17-05-06-19_42_48_925_574.png" alt=""></p>
<p>通常接受窗口的大小可以这样计算:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rwnd = 缓存大小 - 正在等待被拉取的字节数</div></pre></td></tr></table></figure>
<h3 id="流量控制-Flow-Control"><a href="#流量控制-Flow-Control" class="headerlink" title="流量控制 Flow Control"></a>流量控制 Flow Control</h3><p>流量控制平衡了生产者生产数据的速度和消费者消耗数据的速度。为了实现流量控制，TCP 强制发送方和接收方<strong>不断调整它们的窗口大小</strong>，即使双方的缓存大小在连接建立时被固定了下来。流量控制的一个例子:</p>
<p><img src="17-05-06-19_51_13_901_757.png" alt=""></p>
<p><strong>糊涂窗口综合症 Silly Window Syndrome</strong>: 在滑动窗口的操作中可能出现一个严重的问题，这就是发送应用程序产生数据的速度很慢，或者接受应用程序消耗数据的速度很慢，或者两者都有。不管是哪一种情况，都会使得发送数据的报文段很小，这就会降低运行的效率。例如 TCP 发送的报文段只包含 1 个字节的数据，那么意味着我们为此多发送了 40 字节 (20 字节的 IP 首部和 20 字节的 TCP 首部) 的数据，再算上数据链路层和物理层的额外开销后，这种低效率的程度就更加严重了。解决这种问题的方法是防止一个字节一个字节的发送数据。</p>
<ul>
<li><strong>Nagle 算法</strong>: 在发送了第一个报文段后 (哪怕只有 1 字节)，发送 TCP 在输出缓存中累积数据并等待，直至收到接受 TCP 发来的确认，或者已累积了足够的数据可以装成最大长度的报文段，此时就可以发送这个报文段了。</li>
</ul>
<p>如果是接收方接受数据的速度太慢，它在收到数据后将其存储在缓存中。现在缓存满了，接收方通知的窗口值为 0，这表示发送方必须立即停止发送数据。对于这种情况，有两种解决办法:</p>
<ul>
<li><strong>Clark 算法</strong>: 只要有数据到达就发送确认，但在缓存中有足够大的空间放入最大长度的报文段之前，或者至少有一半的缓存空间为空之前，一直都宣布窗口大小为零。</li>
<li><strong>推迟确认</strong>: 接收方在对收到的报文段进行确认之前一直等待，直至输入缓存 (incoming buffer) 有足够的空间为止，减少通信量，但有可能迫使发送方重传未被确认的报文段。目前 TCP 的定义是推迟确认不能超过 500 ms。</li>
</ul>
<h3 id="差错控制-Error-Control"><a href="#差错控制-Error-Control" class="headerlink" title="差错控制 Error Control"></a>差错控制 Error Control</h3><ul>
<li>检测和重传受到损伤的报文段</li>
<li>重传丢失的报文段 - 差错控制机制的<strong>核心</strong></li>
<li>保存失序到达的报文段直至缺失的报文段到齐</li>
<li>检测和丢弃重复的报文段</li>
</ul>
<p>TCP 通过使用三个简单的工具来完成其差错控制: <strong>校验和、确认以及超时</strong>。</p>
<blockquote>
<p>ACK 报文段不消耗序号，也不需要被确认。</p>
</blockquote>
<p>正常情况:</p>
<p><img src="17-05-06-20_19_05_842_417.png" alt=""></p>
<p>报文段丢失:</p>
<p><img src="17-05-06-20_27_19_908_420.png" alt=""></p>
<p>快重传 - 具有更大数值的 RTO:</p>
<p><img src="17-05-06-20_35_54_833_570.png" alt=""></p>
<p>下一个确认自动纠正丢失确认带来的影响:</p>
<p><img src="17-05-06-20_36_59_641_341.png" alt=""></p>
<p>丢失的确认被重传的报文段纠正:</p>
<p><img src="17-05-06-20_38_32_708_330.png" alt=""></p>
<h3 id="拥塞控制-Congestion-Control"><a href="#拥塞控制-Congestion-Control" class="headerlink" title="拥塞控制 Congestion Control"></a>拥塞控制 Congestion Control</h3><p>除了接收方的 rwnd 之外，<strong>网络的发送速度</strong>是决定发送方窗口大小的第二个实体。</p>
<blockquote>
<p>真正的窗口大小: minimum(rwnd, cwnd)</p>
</blockquote>
<p>TCP 处理拥塞的一般策略是基于三个阶段: 慢开始、拥塞避免和拥塞检测。</p>
<ul>
<li><strong>慢开始: 指数增长</strong>: 拥塞窗口大小从 1 个最大报文段的长度 (MSS) 开始。每当一个报文段被确认，拥塞窗口就增大一个 MSS。慢开始算法开始很慢，但按指数规律增大。发送方密切关注一个称为 ssthresh (慢开始门限) 的变量。</li>
</ul>
<p><img src="17-05-06-20_49_21_823_470.png" alt=""></p>
<ul>
<li><strong>拥塞避免: 加法增大</strong>: 当拥塞窗口大小达到慢开始的门限时，慢开始阶段就停止，而加法增大阶段就开始了。每当一整个 “窗口” 中的报文段都被确认后，拥塞窗口大小才增加 1.一个 “窗口” 就是指在一个 RTT 期间传输的报文段的数量。换言之，这个增长是基于 RTT 的，而不是基于到达的 ACK 的数量。</li>
</ul>
<p><img src="17-05-06-20_52_28_749_542.png" alt=""></p>
<ul>
<li><strong>拥塞检测: 乘法减小</strong>: 让发送方能够猜测到拥塞已发生的唯一现象就是它需要重传一个报文段。之所以需要重传是为了恢复一个遗失的分组，而这个分组假设是因为某个路由器有太多的输入分组而不得不丢弃，所以才被丢弃掉的，也就是说路由器或者网络已变得超载或者拥塞了。重传可以发生在以下两种情况之一：当 RTO 计时器超时，或者是当收到了三个重复的 ACK 时。不管哪一种情况，<strong>门限值都要下降到一半</strong> (乘法减小)。大多数 TCP 实现有以下两种反应:</li>
</ul>
<ol>
<li>如果是计时器超时，那么出现拥塞的可能性就很大。TCP 会:<ul>
<li>设置门限值为<strong>当前窗口大小的一半</strong></li>
<li>cwnd 重置为 1</li>
<li>再次从慢开始阶段开始</li>
</ul>
</li>
<li>如果是收到三个 ACK，出现拥塞的可能性就很小。TCP 会启动快重传和快恢复:<ul>
<li>设置门限值为<strong>当前窗口大小的一半</strong></li>
<li>cwnd 设置为门限值</li>
<li>启动拥塞避免阶段</li>
</ul>
</li>
</ol>
<p>拥塞举例:</p>
<p><img src="17-05-06-21_10_16_803_370.png" alt=""></p>
<h3 id="TCP-的计时器"><a href="#TCP-的计时器" class="headerlink" title="TCP 的计时器"></a>TCP 的计时器</h3><p>为了能够顺利地进行 TCP 的操作，大多数的 TCP 实现至少使用 4 个计时器:</p>
<p><img src="17-05-06-21_28_51_717_125.png" alt=""></p>
<ul>
<li><strong>重传计时器</strong>: 重传丢失的报文段</li>
<li><strong>持续计时器</strong>: 发送 TCP 收到窗口值为 0 的确认时，就启动一个持续计时器，解决死锁问题</li>
<li><strong>保活计时器</strong>: 放置两个 TCP 之间长时间空闲。超时通常设置为两个小时。如果服务器过了两个小时还没有收到客户端的任何消息，它就发送一个<strong>探测报文段</strong>。若连续发送了 10 个探测报文段 (每隔 75 秒一个) 还没有收到响应，他就假定客户端出现了故障，并终止这个连接</li>
<li><strong>TIME-WAIT 计时器</strong>: 连接终止期间使用</li>
</ul>
<h3 id="TCP-Package"><a href="#TCP-Package" class="headerlink" title="TCP Package"></a>TCP Package</h3><p>典型 TCP 实现:</p>
<p><img src="17-05-06-21_35_43_888_486.png" alt=""></p>
<h3 id="TCP-粘包-拆包问题"><a href="#TCP-粘包-拆包问题" class="headerlink" title="TCP 粘包/拆包问题"></a>TCP 粘包/拆包问题</h3><p>TCP 是个 “流” 协议，所谓流，就是没有界限的一串数据，就像河里的流水，它们是连成一片的，其间并没有分界线。发生粘包/拆包的原因:</p>
<ul>
<li>应用程序 <code>write</code> 写入的字节大小大于套接口发送缓冲区的大小</li>
<li>进行 <code>MSS</code> 大小的 TCP 分段</li>
<li>以太网帧的 <code>payload</code> 大于 <code>MTU</code> 进行 IP 分片</li>
</ul>
<p>业界主流解决方案:</p>
<ul>
<li><strong>消息定长</strong>，每个报文固定长度 200 字节，不够补空格</li>
<li>在<strong>包尾增加回车换行符</strong>进行分割，例如 FTP 协议</li>
<li>将消息分为消息头和消息体，消息头中包含表示消息总长度 (或者消息体长度) 的字段，通常设计思路为消息头的第一个字段用 <code>int32</code> 来表示消息的总长度</li>
<li>更复杂的应用层协议</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">byte</span>[] req = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</div><div class="line">    buf.readBytes(req);</div><div class="line">    String body = <span class="keyword">new</span> String(req, <span class="string">"UTF-8"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Netty 默认提供多种解码器用于处理半包问题:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">socketChannel.pipeline().addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">1024</span>));</div><div class="line">socketChannel.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</div></pre></td></tr></table></figure>
<h3 id="常用-TCP-选项"><a href="#常用-TCP-选项" class="headerlink" title="常用 TCP 选项"></a>常用 TCP 选项</h3><p>摘自 <code>memcached.c</code> 源码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</div><div class="line"><span class="keyword">if</span> (IS_UDP(transport)) &#123;</div><div class="line">    maximize_sndbuf(sfd);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</div><div class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>)</div><div class="line">        perror(<span class="string">"setsockopt"</span>);</div><div class="line"></div><div class="line">    error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (<span class="keyword">void</span> *)&amp;ling, <span class="keyword">sizeof</span>(ling));</div><div class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>)</div><div class="line">        perror(<span class="string">"setsockopt"</span>);</div><div class="line"></div><div class="line">    error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</div><div class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>)</div><div class="line">        perror(<span class="string">"setsockopt"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>SO_REUSEADDR</code>: </li>
<li><code>SO_KEEPALIVE</code>:</li>
<li><code>SO_LINGER</code>: </li>
<li><code>TCP_NODELAY</code>:</li>
</ul>
<h4 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h4><p>以太网是 1500 字节，光纤是 4000 字节</p>
<h3 id="我们为什么一定需要三次握手，而不是两次"><a href="#我们为什么一定需要三次握手，而不是两次" class="headerlink" title="我们为什么一定需要三次握手，而不是两次?"></a>我们为什么一定需要三次握手，而不是两次?</h3><p>双方使用 Sequence number 来跟踪它们已经发送的信息。然而序列号并不是由 0 开始的，而是由 ISN (Initial Sequence Number), 即一个随机生成的数字。The three-way handshake is necessary because <strong>both parties need to synchronize their segment sequence numbers used during their transmission</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Alice ---&gt; Bob    SYNchronize with my Initial Sequence Number of X</div><div class="line">Alice &lt;--- Bob    I received your syn, I ACKnowledge that I am ready for [X+1]</div><div class="line">Alice &lt;--- Bob    SYNchronize with my Initial Sequence Number of Y</div><div class="line">Alice ---&gt; Bob    I received your syn, I ACKnowledge that I am ready for [Y+1]</div></pre></td></tr></table></figure>
<p>在这个过程中，产生了四个事件:</p>
<ol>
<li>Alice picks an ISN and <strong>SYNchronizes</strong> it with Bob.</li>
<li>Bob <strong>ACKnowledges</strong> the ISN.</li>
<li>Bob picks an ISN and <strong>SYNchronizes</strong> it with Alice.</li>
<li>Alice <strong>ACKnowledges</strong> the ISN.</li>
</ol>
<p>在实际中，第 2 个事件和第 3 个事件可以在放到一个包中，所以三次握手就够了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bob &lt;--- Alice         SYN</div><div class="line">Bob ---&gt; Alice     SYN ACK </div><div class="line">Bob &lt;--- Alice     ACK</div></pre></td></tr></table></figure>
<p>两次的话，只能保证一方建立一个 ISN，另一方 Acknowledge 它。但是另一方却无法发送任何数据。</p>
<p>ISN 不能从 0 开始因为: <a href="https://en.wikipedia.org/wiki/TCP_sequence_prediction_attack" target="_blank" rel="external">TCP sequence prediction attack</a> The attacker hopes to correctly guess the sequence number to be used by the sending host. If they can do this, they will be able to send counterfeit(伪造) packets to the receiving host which will seem to originate from the sending host, even though the counterfeit(伪造) packets may in fact originate from some third host controlled by the attacker.</p>
<h3 id="TCP-中间人攻击"><a href="#TCP-中间人攻击" class="headerlink" title="TCP 中间人攻击"></a>TCP 中间人攻击</h3><h3 id="服务器端在-accept-一个文件描述符之后怎么提高安全性？"><a href="#服务器端在-accept-一个文件描述符之后怎么提高安全性？" class="headerlink" title="服务器端在 accept 一个文件描述符之后怎么提高安全性？"></a>服务器端在 <code>accept</code> 一个文件描述符之后怎么提高安全性？</h3><h3 id="Internet-Protocol-Suite"><a href="#Internet-Protocol-Suite" class="headerlink" title="Internet Protocol Suite"></a>Internet Protocol Suite</h3><p><img src="13fig01.gif" alt=""></p>
<p><code>VPN</code> 工作在数据链路层。</p>
<h3 id="scp-卡死"><a href="#scp-卡死" class="headerlink" title="scp 卡死"></a><a href="http://jm.taobao.org/2017/07/27/20170727/#more" target="_blank" rel="external"><code>scp</code> 卡死</a></h3><p><img src="1d010b9937198aee9e798bb02913603874f19ddc.png" alt=""></p>
<ul>
<li>从抓包中可以明显知道 <code>scp</code> 之所以卡死是因为丢包了，<strong>客户端一直在重传</strong>，图中绿框</li>
<li>图中篮框显示时间间隔，时间都是花在在丢包重传等待的过程</li>
<li>奇怪的问题是图中橙色框中看到的，网络这时候是联通的，客户端跟服务端在这个会话中依然有些包能顺利到达（Keep-Alive包）</li>
<li>同时注意到重传的包长是1442，包比较大了，看了一下tcp建立连接的时候MSS是1500，应该没有问题</li>
<li>查看了scp的两个容器的网卡mtu都是1500，正常</li>
</ul>
<hr>
<p><code>scp</code> 传输的时候实际路由大概是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">容器A---&gt; 宿主机1 ---&gt; ……中间的路由设备 …… ---&gt; 宿主机2 ---&gt; 容器B</div></pre></td></tr></table></figure>
<ul>
<li>前面提过其它容器 <code>scp</code> 同一个文件到容器 <code>B</code> 没问题，所以我认为中间的路由设备没问题，问题出在两台宿主机上</li>
<li>在宿主机 1 上抓包发现抓不到丢失的那个长度为 1442 的包，也就是问题出在了 容器A—&gt; 宿主机1 上</li>
</ul>
<hr>
<p>查看宿主机1的 <code>dmesg</code> 看到了这样一些信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-08-08T08:15:27.125951+00:00 server kernel: openvswitch: ens2f0.627: dropped over-mtu packet: 1428 &gt; 1400</div><div class="line">2016-08-08T08:15:27.536517+00:00 server kernel: openvswitch: ens2f0.627: dropped over-mtu packet: 1428 &gt; 1400</div></pre></td></tr></table></figure>
<p>到这里问题已经很明确了 openvswitch 收到了 一个 <code>1428</code> 大小的包因为比 mtu1400 要大，所以扔掉了，接着查看宿主机 1 的网卡 mtu 设置果然是 1400，悲催，马上修改 mtu 到 1500，问题解决。</p>
<hr>
<ul>
<li>Q: <strong>传输的包超过 <code>MTU</code> 后表现出来的症状</strong>?</li>
<li>A： 卡死，比如 <code>scp</code> 的时候不动了，或者其他更复杂操作的时候不动了，卡死的状态。</li>
<li>Q： 为什么我的 <code>MTU</code> 是 <code>1500</code>，但是抓包看到有个包 <code>2700</code>，没有卡死？</li>
<li>A： 有些网卡有拆包的能力，具体可以 <code>Google：LSO、TSO</code>，这样可以减轻 <code>CPU</code> 拆包的压力，节省CPU资源。</li>
</ul>
<h3 id="关于TCP-半连接队列和全连接队列"><a href="#关于TCP-半连接队列和全连接队列" class="headerlink" title="关于TCP 半连接队列和全连接队列"></a><a href="http://jm.taobao.org/2017/05/25/525-1/" target="_blank" rel="external">关于TCP 半连接队列和全连接队列</a></h3><p><strong>问题描述</strong>:</p>
<p><code>JAVA</code> 的 <code>client</code> 和 <code>server</code>，使用 <code>socket</code> 通信。<code>server</code> 使用 <code>NIO</code>。</p>
<ol>
<li>间歇性的出现 <code>client</code> 向 <code>server</code> 建立连接三次握手已经完成，但 <strong><code>server</code> 的 <code>selector</code> 没有响应到这连接</strong>。</li>
<li>出问题的时间点，会同时有很多连接出现这个问题。</li>
<li><code>selector</code> 没有销毁重建，一直用的都是一个。</li>
<li>程序刚启动的时候必会出现一些，之后会间歇性出现。</li>
</ol>
<hr>
<p>通过 <code>ss -s</code> 去看队列的溢出统计数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">667399 times the listen queue of a socket overflowed</div></pre></td></tr></table></figure>
<p>反复看了几次之后发现这个 <code>overflowed</code> 一直在增加，那么可以明确的是 <code>server</code> 上全连接队列一定溢出了。</p>
<p>接着查看溢出后，OS怎么处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_abort_on_overflow</span></div><div class="line">0</div></pre></td></tr></table></figure>
<p><code>tcp_abort_on_overflow</code> 为 <code>0</code> 表示<strong>如果三次握手第三步的时候全连接队列满了</strong>那么 <code>server</code> 扔掉 <code>client</code> 发过来的 <code>ack</code>（在 <code>server</code> 端认为连接还没建立起来）</p>
<p>为了证明客户端应用代码的异常跟全连接队列满有关系，我先把 <code>tcp_abort_on_overflow</code> 修改成 1，<code>1</code> 表示第三步的时候如果全连接队列满了， <code>server</code> 发送一个 <code>reset</code> 包给 <code>client</code>，表示废掉这个握手过程和这个连接（本来在 <code>server</code> 端这个连接就还没建立起来）。</p>
<p>接着测试然后在客户端异常中可以看到很多 <strong><code>connection reset by peer</code></strong> 的错误，到此证明客户端错误是这个原因导致的。</p>
<hr>
<p>The maximum queue length for <strong>incoming connection</strong> indications (a request to connect) is set to <code>50</code>. If a connection indication arrives when the queue is full, the connection is <strong>refused</strong>.</p>
<p>Apparently your <code>ServerSocket</code> never accepts any connections, just listens. You must either call <code>accept()</code> and start handling the connection or <strong>increase</strong> the backlog queue size:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> ServerSocket(port, <span class="number">100</span>)</div></pre></td></tr></table></figure>
<hr>
<p>简单来说 <code>TCP</code> 三次握手后有个 <code>accept</code> 队列，进到这个队列才能从 <code>Listen</code> 变成 <code>accept</code>，默认 <code>backlog</code> 值是 <code>50</code>，很容易就满了。满了之后握手第三步的时候server就忽略了 <code>client</code> 发过来的 <code>ack</code> 包（隔一段时间 <code>server</code> 重发握手第二步的 <code>syn+ack</code> 包给 <code>client</code>），如果这个连接一直排不上队就异常了。</p>
<p><img src="tcp-sync-queue-and-accept-queue-small-1024x747.jpg" alt=""></p>
<p>如上图所示，这里有两个队列： <code>syns queue</code>(半连接队列）； <code>accept queue</code>（全连接队列）</p>
<p>三次握手中，在第一步 <code>server</code> 收到 <code>client</code> 的 <code>syn</code>后，<strong>把相关信息放到半连接队列中</strong>，同时回复 <code>syn+ack</code> 给 <code>client</code>（第二步）；</p>
<blockquote>
<p>比如 <code>syn floods</code> 攻击就是针对<strong>半连接队列</strong>的，攻击方不停地建连接，但是建连接的时候只做第一步，第二步中攻击方收到 <code>server</code> 的 <code>syn+ack</code> 后故意扔掉什么也不做，导致 <code>server</code> 上这个队列满其它正常请求无法进来。</p>
</blockquote>
<p>第三步的时候 <code>server</code> 收到 <code>client</code> 的 <code>ack</code> ，如果这时全连接队列没满，那么从半连接队列拿出相关信息放入到全连接队列中，否则按 <code>tcp_abort_on_overflow</code> 指示的执行。</p>
<p>这时如果全连接队列满了并且 <code>tcp_abort_on_overflow</code> 是 <code>0</code> 的话，<code>server</code> 过一段时间再次发送 <code>syn+ack</code> 给 <code>client</code>（也就是重新走握手的第二步），如果 <code>client</code> 超时等待比较短，就很容易异常了。</p>
<p>在我们的 <code>os</code> 中 <code>retry</code> 第二步的默认次数是 <code>2</code> （centos默认是5次）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net.ipv4.tcp_synack_retries = 2</div></pre></td></tr></table></figure>
<hr>
<p>如果TCP连接队列溢出，有哪些指标可以看呢？</p>
<p>上述解决过程有点绕，那么下次再出现类似问题有什么更快更明确的手段来确认这个问题呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -s</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@server ~]#  netstat -s | egrep &quot;listen|LISTEN&quot; </div><div class="line">667399 times the listen queue of a socket overflowed</div><div class="line">667399 SYNs to LISTEN sockets ignored</div></pre></td></tr></table></figure>
<p>比如上面看到的 667399 times ，表示<strong>全连接队列溢出的次数</strong>，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p>
<p><code>ss</code> 命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@server ~]<span class="comment"># ss -lnt</span></div><div class="line">Recv-Q Send-Q Local Address:Port  Peer Address:Port </div><div class="line">0        50               *:3306             *:*</div></pre></td></tr></table></figure>
<p>上面看到的第二列 <code>Send-Q</code> 表示第三列的 <code>listen</code> 端口上的全连接队列最大为 <code>50</code>，第一列 <code>Recv-Q</code> 为全连接队列当前使用了多少。</p>
<p>全连接队列的大小取决于：<code>min(backlog, somaxconn)</code> . <code>backlog</code>是在<code>socket</code>创建的时候传入的，<code>somaxconn</code>是一个<code>os</code>级别的系统参数</p>
<p>半连接队列的大小取决于：<code>max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)</code>。 不同版本的os会有些差异</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.amazon.com/Protocol-Suite-McGraw-Hill-Forouzan-Networking/dp/0073376043" target="_blank" rel="external">《TCP/IP Protocol Suite》</a></li>
<li><a href="https://item.jd.com/11681556.html" target="_blank" rel="external">《Netty 权威指南》</a></li>
<li><a href="https://blog.netherlabs.nl/articles/2009/01/18/the-ultimate-so_linger-page-or-why-is-my-tcp-not-reliable" target="_blank" rel="external"> TODO - The ultimate SO_LINGER page, or: why is my tcp not reliable</a></li>
<li><a href="http://www.infoq.com/cn/minibooks/Alibaba-Java-minibook?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">《阿里巴巴Java开发手册》</a></li>
<li><a href="https://item.jd.com/11908449.html" target="_blank" rel="external">《大话 Java 性能优化》</a></li>
<li><a href="https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way" target="_blank" rel="external">Why do we need a 3-way handshake? Why not just 2-way?</a></li>
<li><a href="https://item.jd.com/10948631481.html" target="_blank" rel="external">《TCP/IP高效编程改善网络程序的44个技巧》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/06/TCP/" data-id="cjcdlsfwf002hdiemph61mdbs" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/blog/page/21/">&laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/20/">20</a><a class="page-number" href="/blog/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/blog/page/23/">23</a><a class="extend next" rel="next" href="/blog/page/23/">Next&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2018/01/06/where-the-time-actually-gone/">时间都去哪儿了</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/05/dev-reflection/">开发反思</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/05/my-microblog/">我的微博</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/04/gcc-basic/">gcc-basic</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/04/java-internal/">Java Internal</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 赵坤&nbsp;|&nbsp;
      Theme by <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      Contact&nbsp;|&nbsp;igozhaokun@163.com
    </div>
  </div>
</footer>
 <script src="/blog/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">首页</a>
  
    <a href="/blog/archives" class="mobile-nav-link">归档</a>
  
    <a href="/blog/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/blog/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>

      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js"></script>
  


 <script src="/blog/js/is.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>
<script src="/blog/js/elevator.js"></script>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>