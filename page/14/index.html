<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>代码人生</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="赵坤的个人网站">
<meta property="og:type" content="website">
<meta property="og:title" content="代码人生">
<meta property="og:url" content="http://blog.kunzhao.org/page/14/index.html">
<meta property="og:site_name" content="代码人生">
<meta property="og:description" content="赵坤的个人网站">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代码人生">
<meta name="twitter:description" content="赵坤的个人网站">
  
    <link rel="alternate" href="/atom.xml" title="代码人生" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.kunzhao.org"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">首页</a>
        
          <a class="main-nav-link" href="/blog/archives">归档</a>
        
          <a class="main-nav-link" href="/blog/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">代码人生</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-algorithm-math" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/06/algorithm-math/" class="article-date">
  <time datetime="2017-07-06T13:59:57.000Z" itemprop="datePublished">2017-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/06/algorithm-math/">算法 - 数学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="算法-数学"><a href="#算法-数学" class="headerlink" title="算法 - 数学"></a>算法 - 数学</h2><h3 id="sqrt-实现"><a href="#sqrt-实现" class="headerlink" title="sqrt 实现"></a><a href="https://leetcode.com/problems/sqrtx/#/description" target="_blank" rel="external"><code>sqrt</code> 实现</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = Integer.MAX_VALUE;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (mid &gt; x/mid) &#123;</div><div class="line">            right = mid - <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mid + <span class="number">1</span> &gt; x/(mid + <span class="number">1</span>))</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组选择几个数求最大乘积问题"><a href="#数组选择几个数求最大乘积问题" class="headerlink" title="数组选择几个数求最大乘积问题"></a>数组选择几个数求最大乘积问题</h3><p>一般这种问题，几个数字相乘的，<strong>最小和最大的数字</strong>都需要记录，网友给出的<a href="https://discuss.leetcode.com/topic/93804/java-o-1-space-o-n-time-solution-beat-100" target="_blank" rel="external">解决方案</a></p>
<p>三个数的最大乘积，要么是<strong>最大的三个数</strong>的乘积，要么是<strong>最小的两个数乘以最大那个数</strong>的乘积。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">return</span> Math.max(nums[n-<span class="number">1</span>] * nums[n-<span class="number">2</span>] * nums[n-<span class="number">3</span>], </div><div class="line">                        nums[n-<span class="number">1</span>] * nums[<span class="number">0</span>] * nums[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/07/06/algorithm-math/" data-id="cjcdlsfwq0032dieme1a4koia" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-MySQL-Troubleshooting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/06/MySQL-Troubleshooting/" class="article-date">
  <time datetime="2017-07-06T13:49:28.000Z" itemprop="datePublished">2017-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/06/MySQL-Troubleshooting/">MySQL (一) - 排错指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="MySQL-一-排错指南"><a href="#MySQL-一-排错指南" class="headerlink" title="MySQL (一) - 排错指南"></a>MySQL (一) - 排错指南</h2><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h3><h4 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h4><p>(1) 使用<strong>反引号</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="string">`id`</span> <span class="keyword">FROM</span> <span class="string">`t1`</span> <span class="keyword">WHERE</span> <span class="string">`accessible`</span> = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>(2) 通过<strong>通用查询日志</strong>来记录你的每次查询:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 临时打开通用查询日志</span></div><div class="line">mysql&gt; SET GLOBAL general_log=<span class="string">'on'</span>;</div><div class="line"><span class="comment"># 将日志记录记录在表中</span></div><div class="line">mysql&gt; SET GLOBAL log_output=<span class="string">'table'</span>;</div><div class="line"><span class="comment"># 查询通用日志记录表</span></div><div class="line">mysql&gt; SELECT * FROM mysql.general_log;</div></pre></td></tr></table></figure>
<h4 id="SELECT-返回错误的结果"><a href="#SELECT-返回错误的结果" class="headerlink" title="SELECT 返回错误的结果"></a>SELECT 返回错误的结果</h4><p>(1) <code>EXPLAIN EXTENDED</code> 命令加 <code>SHOW WARNINGS</code> 命令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN EXTENDED SELECT count(*) FROM items WHERE id IN (SELECT id FROM items_links);</div><div class="line">mysql&gt; SHOW WARNINGS;</div></pre></td></tr></table></figure>
<p>在 <code>EXPLAIN EXTENDED</code> 之后，使用 <code>SHOW WARNINGS</code> 命令能够<strong>查看查询是如何优化与执行的</strong>。</p>
<h4 id="获取查询信息"><a href="#获取查询信息" class="headerlink" title="获取查询信息"></a>获取查询信息</h4><p>(1) 使用 <code>perror</code> 获取错误码对应的错误字符串，注意是在 <code>shell</code> 中获取的:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$perror 150</div></pre></td></tr></table></figure>
<h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>通过 <code>EXPLAIN</code> 信息调优查询</p>
<p>我们要重点观察两个数据:</p>
<ul>
<li><strong>type</strong>: 连接的执行方式</li>
<li><strong>rows</strong>: 查询执行过程中检查的行数的估计</li>
</ul>
<p><code>type</code> 的类型:</p>
<ul>
<li><strong>type: ALL</strong>: 没有索引，读取所有行</li>
<li><strong>type: index</strong>: 只有索引树被扫描</li>
<li><strong>type: ref</strong>: 只使用了索引的最左前缀，或者索引不是 <code>UNIQUE</code> 和 <code>PRIMARY KEY</code></li>
<li><strong>type: eq_ref</strong>: 唯一索引，非唯一的行永远不会产生 <code>eq_ref</code> 或者更好的类型</li>
<li><strong>type: const</strong>: 确定最多只会有一行匹配</li>
</ul>
<p>避免在生产环境中使用 <code>IGNORE INDEX</code> 和 <code>FORCE INDEX</code>。</p>
<h4 id="存储引擎问题"><a href="#存储引擎问题" class="headerlink" title="存储引擎问题"></a>存储引擎问题</h4><ul>
<li><strong>MyISAM</strong>: <code>table_name.frm</code>: 包含表的结构，<code>table_name.MYD</code> 包含存储数据，<code>table_name.MYI</code> 保存索引:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CHECK TABLE t2;</div><div class="line">mysql&gt; REPAIR TABLE t2;</div></pre></td></tr></table></figure>
<p>也可以使用工具 <code>mysqlcheck</code> 命令来检查。</p>
<h3 id="2-并发问题"><a href="#2-并发问题" class="headerlink" title="2 并发问题"></a>2 并发问题</h3><blockquote>
<p>InnoDB 引擎使用简写的 S 代表读锁/共享锁，用 X 代表写锁/排它锁</p>
</blockquote>
<h4 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h4><p>当访问表并且该表所使用的存储引擎支持表锁的时候，即会产生表锁，比如 MyISAM 引擎。当你怀疑是并发线程影响了查询的时候，使用 <code>SHOW PROCESSLIST</code> 命令查看状态:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW PROCESSLIST;</div><div class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST;</div></pre></td></tr></table></figure>
<p>然后重点观察 <code>status</code> 和 <code>info</code> 这两行的数据</p>
<h4 id="2-2-行锁"><a href="#2-2-行锁" class="headerlink" title="2.2 行锁"></a>2.2 行锁</h4><p>InnoDB 是当前使用行锁的主要的存储引擎。为了确定 InnoDB 中一个请求是否阻塞，可以执行 <code>SHOW ENGINE INNODB STATUS</code> 命令，该命令是 InnoDB 监控器机制的一部分:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW ENGINE INNODB STATUS;</div></pre></td></tr></table></figure>
<h4 id="2-3-事务"><a href="#2-3-事务" class="headerlink" title="2.3 事务"></a>2.3 事务</h4><p><strong>未提交的事务会持有锁</strong>，哪怕该影响到特定行的查询在数小时前已经结束了。当执行多语句事务的时候，应该尽可能及时提交事务，哪怕事务不会修改任何航，也不要在事务最后的更新都已经完成的情况下仍不提交事务。</p>
<p>InnoDB 引擎有内部的死锁探测器，当其发现有死锁的时候，它会回滚其中的一个事务，并会报告一个立即可见的错误。<code>SHOW ENGINE INNODB STATUS</code> 命令也可以用来<strong>检查死锁的一些信息</strong></p>
<h4 id="2-4-元数据锁"><a href="#2-4-元数据锁" class="headerlink" title="2.4 元数据锁"></a>2.4 元数据锁</h4><p>为了确保数据一致性，在有其他事务使用表的情况下，<strong>对该表的 DDL 操作应该阻塞</strong>。</p>
<h4 id="2-5-并发如何影响性能"><a href="#2-5-并发如何影响性能" class="headerlink" title="2.5 并发如何影响性能"></a>2.5 并发如何影响性能</h4><p>如果一个查询突然开始执行缓慢，第一步应该确认它是否是合理优化过的，最简单的确认方式就是<strong>在一个隔离的、单线程的环境里去执行该查询</strong>。如果该查询仍然执行缓慢，<strong>那么它或者需要优化，或者最近大量更新操作导致索引统计数据过期了</strong>。如果一个查询在单线程环境中很快完成但是在多线程环境中执行缓慢，这基本可以确定<strong>你遇到了并发问题</strong>。</p>
<p>要打开 InnoDB 监控器，需要在任何数据库中创建一个叫做 <code>innodb_monitor</code> 的表:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$mysql test -A</div><div class="line">mysql&gt; CREATE TABLE innodb_monitor(f1 INT) ENGINE=InnoDB;</div></pre></td></tr></table></figure>
<p>启动 MySQL 命令客户端时候的 <strong>-A</strong> 选项在你尝试调试与并发相关的问题时非常有用。正常情况下，客户端会请求可用表列表，然后，客户端会被其他连接持有的锁阻塞，这回阻塞客户端调试，选项 <strong>-A</strong> 会组织表列表请求。</p>
<h4 id="2-6-复制和并发"><a href="#2-6-复制和并发" class="headerlink" title="2.6 复制和并发"></a>2.6 复制和并发</h4><p>当排查复制问题的时候，需要记住主服务器总是多线程的，而从服务器在单个线程中执行所有更新。<strong>每个事务都只会在其提交的时候向二进制日志中写入数据</strong></p>
<h3 id="3-配置选项对服务器的影响"><a href="#3-配置选项对服务器的影响" class="headerlink" title="3 配置选项对服务器的影响"></a>3 配置选项对服务器的影响</h3><p><code>mysqladmin</code> 实用工具有一个 <code>ping</code> 命令，它能够报告 MySQL 服务器当前的状态是运行还是停止:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -hlocalhost -p3306 ping</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SET [SESSION] var_name=value</div><div class="line">SET GLOBAL var_name=value</div><div class="line">SHOW [SESSION|GLOBAL| VARIABLES LIKE &apos;变量名称&apos;</div></pre></td></tr></table></figure>
<h3 id="4-MySQL-环境"><a href="#4-MySQL-环境" class="headerlink" title="4 MySQL 环境"></a>4 MySQL 环境</h3><p>Linux/UNIX 上可以通过 <code>vmstat</code> 来查看 <code>mysqld</code> 是否有大量磁盘交换。使用 <a href="https://github.com/akopytov/sysbench" target="_blank" rel="external">sysbench</a> 来测试数据库和操作系统性能:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># install sysbench</span></div><div class="line">sudo apt install sysbench</div><div class="line">man sysbench</div><div class="line"></div><div class="line"><span class="comment"># CPU benchmark</span></div><div class="line">sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=20000 run</div><div class="line"></div><div class="line"><span class="comment"># 1. Create a 150G file</span></div><div class="line">sysbench --<span class="built_in">test</span>=fileio --file-total-size=150G prepare</div><div class="line"><span class="comment"># 2. File benchmark</span></div><div class="line">sysbench --<span class="built_in">test</span>=fileio --file-total-size=150G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run</div><div class="line"><span class="comment"># 3. Clean file</span></div><div class="line">sysbench --<span class="built_in">test</span>=fileio --file-total-size=150G cleanup</div><div class="line"></div><div class="line"><span class="comment"># 1. Create a `test` table</span></div><div class="line">sysbench --<span class="built_in">test</span>=oltp --oltp-table-size=1000000 --mysql-db=<span class="built_in">test</span> --mysql-user=root --mysql-password=yourrootsqlpassword prepare</div><div class="line"><span class="comment"># 2. MySQL benchmark</span></div><div class="line">sysbench --<span class="built_in">test</span>=oltp --oltp-table-size=1000000 --mysql-db=<span class="built_in">test</span> --mysql-user=root --mysql-password=yourrootsqlpassword --max-time=60 --oltp-read-only=on --max-requests=0 --num-threads=8 run</div><div class="line"><span class="comment"># 3. Clean `test` table</span></div><div class="line">sysbench --<span class="built_in">test</span>=oltp --mysql-db=<span class="built_in">test</span> --mysql-user=root --mysql-password=yourrootsqlpassword cleanup</div></pre></td></tr></table></figure>
<p>一个小例子说明硬件延迟是如何影响一条普通的 <code>UPDATE</code> 查询的，我们将自动提交打开，并同是打开二进制日志文件:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> test_rrbs <span class="keyword">SET</span> f1 = <span class="keyword">md5</span>(<span class="keyword">id</span>*<span class="number">2</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEn</span> <span class="number">200000</span> <span class="keyword">AND</span> <span class="number">300000</span>;</div></pre></td></tr></table></figure>
<p>这个简单的查询会在下面的情况下遭遇延迟:</p>
<ol>
<li>客户端发送命令到服务端经历半个 <code>RTT</code></li>
<li>执行 <code>UPDATE</code> 的 <code>WHERE</code> 子句，<code>mysqld</code> 读磁盘</li>
<li>由于自动提交开启 <code>mysqld</code> 会对此事务做一个 <code>fsync</code> 调用</li>
<li>为写入二进制日志文件 <code>mysqld</code> 做一次 <code>fsync</code> 调用</li>
<li>为提交改变 <code>mysqld</code> 做一次 <code>fsync</code> 调用</li>
<li>客户端接收到来自服务器的结果，这是 <code>RTT</code> 的另一半</li>
</ol>
<h3 id="5-复制故障诊断"><a href="#5-复制故障诊断" class="headerlink" title="5 复制故障诊断"></a>5 复制故障诊断</h3><p>查看复制状态信息的有用命令，从库上运行:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW SLAVE STATUS;</div></pre></td></tr></table></figure>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog.html" target="_blank" rel="external"><code>mysqlbinlog</code></a> 将二进制日志文件转为可视的格式</p>
<h3 id="6-问题排查技术与工具"><a href="#6-问题排查技术与工具" class="headerlink" title="6 问题排查技术与工具"></a>6 问题排查技术与工具</h3><p>慢查询日志: 记录运行时间超过 <code>long_query_time</code> 秒的查询，该变量的默认值是 10</p>
<p>推荐书籍:</p>
<ul>
<li>《Expert MySQL》</li>
<li>《Understanding MySQL Internals》</li>
<li>《MySQL 5.1 Plugin Development》</li>
<li>《High Performance MySQL》</li>
<li>《MySQL High Availability》</li>
</ul>
<p>收集信息的工具:</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-schema.html" target="_blank" rel="external">Information Schema</a></li>
</ul>
<h3 id="7-最佳实践"><a href="#7-最佳实践" class="headerlink" title="7 最佳实践"></a>7 最佳实践</h3><p>无</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/zhanjindong/p/3439042.html#type" target="_blank" rel="external">MySQL优化—工欲善其事，必先利其器之EXPLAIN</a></li>
<li><a href="https://item.jd.com/11741440.html" target="_blank" rel="external">《MySQL 排错指南》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/07/06/MySQL-Troubleshooting/" data-id="cjcdlsfvp001cdiem15dskqau" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-algorithm-linkedlist" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/05/algorithm-linkedlist/" class="article-date">
  <time datetime="2017-07-05T14:23:51.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/05/algorithm-linkedlist/">算法 - 链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="算法-链表"><a href="#算法-链表" class="headerlink" title="算法 - 链表"></a>算法 - 链表</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>(1) 所有操作基于<strong>哑节点</strong>，无<strong>哑节点</strong>，那么就创造一个<strong>哑节点</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</div><div class="line">dummyNode.next = head;</div><div class="line">ListNode fastPointer = dummyNode;</div><div class="line">ListNode slowPointer = dummyNode;</div></pre></td></tr></table></figure>
<p>(2) 针对哑节点获取链表长度，注意<strong>起步条件检查的是 <code>fastPointer.next</code></strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (fastPointer.next != <span class="keyword">null</span>) &#123;</div><div class="line">    count++;</div><div class="line">    fastPointer = fastPointer.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="翻转单链表"><a href="#翻转单链表" class="headerlink" title="翻转单链表"></a><a href="https://leetcode.com/problems/rotate-list/#/description" target="_blank" rel="external">翻转单链表</a></h3><h3 id="合并两个有序单链表"><a href="#合并两个有序单链表" class="headerlink" title="合并两个有序单链表"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/#/description" target="_blank" rel="external">合并两个有序单链表</a></h3><h3 id="结对交换单链表"><a href="#结对交换单链表" class="headerlink" title="结对交换单链表"></a><a href="https://leetcode.com/problems/swap-nodes-in-pairs/#/description" target="_blank" rel="external">结对交换单链表</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">slow          fast</div><div class="line"> ↓             ↓</div><div class="line">[X] -&gt; [1] -&gt; [2] -|&gt; [3]</div><div class="line">        ↑</div><div class="line">    fastPrev</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">slow          fastPrev</div><div class="line"> ↓             ↓</div><div class="line">[X] -&gt; [2] -&gt; [1] -|&gt; [3]</div><div class="line">        ↑</div><div class="line">      fast</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">slow          fast</div><div class="line"> ↓             ↓</div><div class="line">[X] -&gt; [2] -&gt; [1] -|&gt; [3]</div><div class="line">        ↑</div><div class="line">    fastPrev</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">              slow          fast</div><div class="line">               ↓             ↓</div><div class="line">[X] -&gt; [2] -&gt; [1] -&gt; [3] -&gt; [4] -|&gt; [5]</div><div class="line">                     ↑</div><div class="line">                  fastPrev</div></pre></td></tr></table></figure>
<h3 id="链表分区"><a href="#链表分区" class="headerlink" title="链表分区"></a><a href="https://leetcode.com/problems/partition-list/#/description" target="_blank" rel="external">链表分区</a></h3><p>想象一下串糖葫芦的感觉:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-----[-]-[-]-[-]-[-]-[-]-[-]-----&gt;</div><div class="line">-----[-]-[-]-[-]-[-]-[-]-[-]-----&gt;</div></pre></td></tr></table></figure>
<h3 id="从无序链表中移除重复节点"><a href="#从无序链表中移除重复节点" class="headerlink" title="从无序链表中移除重复节点"></a>从无序链表中移除重复节点</h3><ul>
<li>In order to remove duplicates from a linked list, we need to be able to <strong>track duplicates</strong>. A simple <strong>hash table</strong> will work well here.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(LinkedListNode n)</span> </span>&#123;</div><div class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">    LinkedListNode previous = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (n != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (set.contains(n.data)) &#123;</div><div class="line">            previous.next = n.next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            set.add(n.data);</div><div class="line">            previous = n;</div><div class="line">        &#125;</div><div class="line">        n = n.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/07/05/algorithm-linkedlist/" data-id="cjcdlsfwp0030diemx3gs0zla" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Redis-questions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/04/Redis-questions/" class="article-date">
  <time datetime="2017-07-04T03:53:30.000Z" itemprop="datePublished">2017-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/04/Redis-questions/">Redis 常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Redis-常见问题"><a href="#Redis-常见问题" class="headerlink" title="Redis 常见问题"></a>Redis 常见问题</h2><h3 id="为什么-Redis-这么快"><a href="#为什么-Redis-这么快" class="headerlink" title="为什么 Redis 这么快"></a>为什么 Redis 这么快</h3><p>总体来说快速的原因如下： </p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速） </li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件 </li>
<li>非阻塞 IO </li>
</ol>
<p>内部实现采用 <code>epoll</code>，采用了 <code>epoll</code> + 自己实现的简单的事件框架。<code>epoll</code> 中的读、写、关闭、连接都转化成了事件，然后利用<code>epoll</code> 的多路复用特性，绝不在 I/O 上浪费一点时间 </p>
<h3 id="redis-如何处理客户端连接"><a href="#redis-如何处理客户端连接" class="headerlink" title="redis 如何处理客户端连接"></a>redis 如何处理客户端连接</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=400335397&amp;idx=3&amp;sn=35f807a4fd813361a00a7a522bc9f146&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="external">redis 如何处理客户端连接</a></li>
</ul>
<h3 id="周期性出现-connect-timeout"><a href="#周期性出现-connect-timeout" class="headerlink" title="周期性出现 connect timeout"></a>周期性出现 connect timeout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">redis.clients.jedis.exceptions.JedisConnectionException</div><div class="line">java.net.SocketException</div><div class="line">java.net.SocketTimeoutException:connect time out</div></pre></td></tr></table></figure>
<p>一开始怀疑是网络问题，但是并未发现问题，观察各种对比图表，<code>tcp listenOverFlow</code> 和 <code>timeout</code> 经常周期出现。</p>
<p>I/O 多路复用程序<strong>通过队列</strong>向文件事件分派器传送套接字的过程:</p>
<p><img src="20160203203441_736.png" alt=""></p>
<p><code>Redis</code> 的单线程模型（对命令的处理和连接的处理都是在一个线程中），如果存在慢查询的话，会出现上面的这种情况，造成新的 accept 的连接进不了队列:</p>
<p><img src="20160203203441_928.png" alt=""></p>
<p>解决方法:</p>
<ul>
<li>对慢查询进行报警（频率、数量、时间）等等因素</li>
<li>告诉业务端人员执行 <code>monitor, keys *, flushall</code> 这些命令的坑</li>
</ul>
<h3 id="redis-bgrewriteaof-问题"><a href="#redis-bgrewriteaof-问题" class="headerlink" title="redis bgrewriteaof 问题"></a>redis bgrewriteaof 问题</h3><p>Redis 的 AOF 机制有点类似于 Mysql binlog，是 Redis 的提供的一种持久化方式（另一种是 RDB ），它会将所有的写命令按照一定频率(no, always, every seconds)写入到日志文件中，当 Redis 停机重启后恢复数据库。</p>
<p>AOF 重写:</p>
<ul>
<li>随着 AOF 文件越来越大，里面会有大部分是重复命令或者可以合并的命令（100 次 <code>incr</code> = <code>set key 100</code>）</li>
<li>重写的好处：减少 AOF 日志尺寸，减少内存占用，加快数据库恢复时间。</li>
</ul>
<p><img src="20160203203443_877.png" alt=""></p>
<p>单机多实例可能存在 <code>Swap</code> 和 <code>OOM</code> 的隐患: 由于 Redis 的单线程模型，理论上每个 redis 实例只会用到一个 CPU, 也就是说可以在一台多核的服务器上部署多个实例（实际就是这么做的）。但是 <strong>Redis 的 AOF 重写是通过 <code>fork</code> 出一个 Redis 进程来实现的</strong>，所以有经验的 Redis 开发和运维人员会告诉你，在一台服务器上要预留一半的内存（防止出现 AOF 重写集中发生，出现 swap 和 OOM）。</p>
<p><img src="20160203203444_104.png" alt=""></p>
<p>解决方案:</p>
<ul>
<li>让每个 redis 决定是否做 AOF 重写操作（根据 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code> 两个参数）</li>
<li><code>crontab</code>: 定时任务，可能仍然会出现多个 redis 实例，属于一种折中方案</li>
<li>remote 集中式: 以机器为单位，轮询每个机器的实例，如果满足条件就运行(比如 <code>currentSize</code> 和 <code>baseSize</code> 满足什么关系) <code>bgrewriteaof</code> 命令。</li>
</ul>
<h3 id="Redis-内存占用飙升"><a href="#Redis-内存占用飙升" class="headerlink" title="Redis 内存占用飙升"></a>Redis 内存占用飙升</h3><p>执行命令 <code>INFO</code> 查看当前系统状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; INFO</div></pre></td></tr></table></figure>
<p>观察 info 信息，有一点引起了怀疑： <code>client_longest_output_list</code> 有些异常，于是理解想到<strong>服务端和客户端交互时，分别为每个客户端设置了输入缓冲区和输出缓冲区</strong>，这部分如果很大的话也会占用 <code>Redis</code> 服务器的内存。</p>
<p><img src="20160203203449_225.png" alt=""></p>
<p>从上面的 <code>client_longest_output_list</code> 看，应该是输出缓冲区占用内存较大，也就是有大量的数据从Redis服务器向某些客户端输出。于是使用 <code>CLIENT LIST</code> 命令（类似于 <code>mysql processlist</code> ）<code>redis-cli -h host -p port client list | grep -v &quot;omem=0&quot;</code>，来查询输出缓冲区不为 0 的客户端连接，于是查询到祸首 <code>monitor</code>，于是豁然开朗. <code>monitor</code> 的模型是这样的，它会将所有在 Redis 服务器执行的命令进行输出，通常来讲 Redis 服务器的 QPS 是很高的，也就是如果执行了 monitor 命令，Redis 服务器在 Monitor 这个客户端的输出缓冲区又会有大量“存货”，也就占用了大量 Redis 内存。</p>
<p><img src="20160203203449_821.png" alt=""></p>
<p>紧急处理和解决方法:</p>
<ul>
<li>进行主从切换（主从内存使用量不一致），也就是 <code>redis-cluster</code> 的 <code>fail-over</code> 操作，继续观察新的 Master 是否有异常，通过观察未出现异常。查找到真正的原因后，也就是 monitor，关闭掉 monitor命令的进程后，内存很快就降下来了。</li>
</ul>
<h3 id="Redis-内存使用优化"><a href="#Redis-内存使用优化" class="headerlink" title="Redis 内存使用优化"></a>Redis 内存使用优化</h3><p>场景:</p>
<table>
<thead>
<tr>
<th>userId(用户id)</th>
<th>weiboCount(微博数)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2000</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>288</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>1000000</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>(1) 使用字符串数据结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET user:1 2000</div><div class="line">127.0.0.1:6379&gt; SET user:2 10</div><div class="line">127.0.0.1:6379&gt; SET user:3 288</div></pre></td></tr></table></figure>
<p>(2) 使用 Hash 结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HMSET allUserWeiboCount user:1 2000 user:2 10 user:3 288</div></pre></td></tr></table></figure>
<p>(3) 使用 Hash 结构 + 多个 HashKey: key=userId/100, field=userId%100, fieldValue=weiboCount</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HMSET hashKey:0 1 2000</div><div class="line">127.0.0.1:6379&gt; HMSET hashKey:0 2 10</div><div class="line">127.0.0.1:6379&gt; HMSET hashKey:0 3 288</div><div class="line">...</div><div class="line">127.0.0.1:6379&gt; HMSET hashKey:1 0 232</div><div class="line">127.0.0.1:6379&gt; HMSET hashKey:1 1 444</div><div class="line">127.0.0.1:6379&gt; HMSET hashKey:1 2 22</div><div class="line">...</div></pre></td></tr></table></figure>
<p>内存占用量对比 (100万用户 userId:1~1000000) :</p>
<p><img src="20160203203449_764.png" alt=""></p>
<p>Redis 其实是一把瑞士军刀:</p>
<p><img src="20160203203449_172.png" alt=""></p>
<h3 id="无穷无尽的-Replication-循环"><a href="#无穷无尽的-Replication-循环" class="headerlink" title="无穷无尽的 Replication 循环"></a>无穷无尽的 Replication 循环</h3><h4 id="1-Slave-和-Master-如何同步数据"><a href="#1-Slave-和-Master-如何同步数据" class="headerlink" title="(1) Slave 和 Master 如何同步数据:"></a>(1) Slave 和 Master 如何同步数据:</h4><ol>
<li>Slave: “我想要变成你”</li>
<li>Master: “你必须要有耐心”</li>
<li>Master forks 了他自己，然后<ol>
<li>fork 出来的进程开始 Dump RDB 文件</li>
<li>主进程继续处理常规 Redis 连接</li>
<li>任何对数据做出的改变都被拷贝到了 Replication 缓冲中</li>
</ol>
</li>
<li>Dump 完成了，Master: “过来拿吧”</li>
<li>Slave 通过网络连接把文件取回来，然后放到自己的磁盘上</li>
<li>Slave 放到本地之后，然后加载这个 RDB 文件</li>
<li>Slave: “我已经完成了我的 circle，我准备好了”</li>
<li>Master Replication 缓冲区的任何数据的改变将会自动同步到 Slave</li>
</ol>
<p>由上述步骤可知，Slave 和 Master 之间的数据同步分为两个阶段: <strong>全量和增量</strong>，当数据量很大的时候，会产生一种称之为 <strong><a href="https://redislabs.com/blog/testing-fork-time-on-awsxen-infrastructure" target="_blank" rel="external">latency due to fork</a></strong> 的现象: <strong>The bigger your dataset is, the longer it will take to fork, dump, copy and load it into the slave.</strong></p>
<h3 id="Replication-缓存限制"><a href="#Replication-缓存限制" class="headerlink" title="Replication 缓存限制"></a>Replication 缓存限制</h3><p>对于 Redis 服务器的输出（也就是命令的返回值）来说，其大小通常是不可控制的。有可能一个简单的命令，能够产生体积庞大的返回数据。另外也有可能因为执行了太多命令，导致产生返回数据的速率超过了往客户端发送的速率，这是也会导致<strong>服务器堆积大量消息，从而导致输出缓冲区越来越大，占用过多内存，甚至导致系统崩溃</strong>。</p>
<p>所幸，Redis 设置了一些保护机制来避免这种情况的出现，不同类型的客户端有不同的限制参数。限制方式有如下两种：</p>
<ol>
<li>大小限制，当某一个客户端的缓冲区超过某一个大小值时，直接关闭这个客户端的连接；</li>
<li>持续性限制，当某一个客户端的缓冲区持续一段时间占用过大空间时，会直接关闭客户端连接。</li>
</ol>
<p>In a full master-slave synchronization, changes performed to the data during the initial phase of the synchronization are <strong>held in the replication buffer by the master server</strong>.</p>
<p>所有的 client 请求 redis 数据的时候，redis 要返回给 client 的数据都会先被存储在 <code>output-buffer</code> 中，等所有信息都被传送完毕之后，再清除 <code>output-buffer</code> 中的数据:</p>
<p>Redis 限制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; config get client-output-buffer-limit</div><div class="line">1) &quot;client-output-buffer-limit&quot;</div><div class="line">// 硬限制: 256MB = 268435456 = 256 * 1024 * 1024</div><div class="line">// 当 output-buffer 的大小大于 256MB 之后就会断开连接</div><div class="line">// 软限制: 67108864 = 64MB = 64 * 1024 * 1024</div><div class="line">// 当 output-buffer 的大小大于 64MB 并且超过了 60 秒的时候就会断开连接</div><div class="line">2) &quot;normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60&quot;</div></pre></td></tr></table></figure>
<p>增加输出 Slave 的缓存大小:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// hard limit: 512MB</div><div class="line">// soft limit: 512MB</div><div class="line">// 临时生效</div><div class="line">127.0.0.1:6379&gt; config set client-output-buffer-limit &quot;slave 536870912 536870912 0&quot;</div></pre></td></tr></table></figure>
<h3 id="Replication-超时"><a href="#Replication-超时" class="headerlink" title="Replication 超时"></a>Replication 超时</h3><p>默认超时时间是 60 秒:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; CONFIG GET repl-timeout</div><div class="line">1) &quot;repl-timeout&quot;</div><div class="line">2) &quot;60&quot;</div></pre></td></tr></table></figure>
<p>超时时间 = ( <code>BGSAVE</code> + COPY + LOAD ) * (110% ~ 120%)</p>
<p>(1) 执行 <code>BGSAVE</code> 命令，然后查看日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tail -f /var/log/redis/redis-server.log</div></pre></td></tr></table></figure>
<p>如果是从源代码安装的话，那么日志文件位于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tail -f /var/log/redis_6379.log</div></pre></td></tr></table></figure>
<p>计量这两行经过了多少秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1012:M 05 Jul 11:27:29.659 * Background saving started by pid 10675</div><div class="line">...</div><div class="line">1012:M 05 Jul 11:27:29.764 * Background saving terminated with success</div></pre></td></tr></table></figure>
<p>(2) 统计拷贝 RDB 文件到 Slave 磁盘需要多久</p>
<p>(3) 统计加载 RDB 文件需要多久</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1012:M 05 Jul 08:27:31.898 * DB loaded from disk: 0.006 seconds</div></pre></td></tr></table></figure>
<p>最后多个 10% ~ 20% 的时间，来确保超时时间不出任何问题</p>
<h3 id="客户端缓冲区"><a href="#客户端缓冲区" class="headerlink" title="客户端缓冲区"></a>客户端缓冲区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Latency Comparison Numbers</div><div class="line">--------------------------</div><div class="line">L1 cache reference                           0.5 ns</div><div class="line">Branch mispredict                            5   ns</div><div class="line">L2 cache reference                           7   ns                      14x L1 cache</div><div class="line">Mutex lock/unlock                           25   ns</div><div class="line">Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache</div><div class="line">Compress 1K bytes with Zippy             3,000   ns        3 us</div><div class="line">Send 1K bytes over 1 Gbps network       10,000   ns       10 us</div><div class="line">Read 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD</div><div class="line">Read 1 MB sequentially from memory     250,000   ns      250 us</div><div class="line">Round trip within same datacenter      500,000   ns      500 us</div><div class="line">Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory</div><div class="line">Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip</div><div class="line">Read 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD</div><div class="line">Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</div><div class="line"></div><div class="line">Notes</div><div class="line">-----</div><div class="line">1 ns = 10^-9 seconds</div><div class="line">1 us = 10^-6 seconds = 1,000 ns</div><div class="line">1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns</div><div class="line"></div><div class="line">Credit</div><div class="line">------</div><div class="line">By Jeff Dean:               http://research.google.com/people/jeff/</div><div class="line">Originally by Peter Norvig: http://norvig.com/21-days.html#answers</div><div class="line"></div><div class="line">Contributions</div><div class="line">-------------</div><div class="line">Some updates from:       https://gist.github.com/2843375</div><div class="line">&apos;Humanized&apos; comparison:  https://gist.github.com/2843375</div><div class="line">Visual comparison chart: http://i.imgur.com/k0t1e.png</div><div class="line">Animated presentation:   http://prezi.com/pdkvgys-r0y6/latency-numbers-for-programmers-web-development/latency.txt</div></pre></td></tr></table></figure>
<p>每一个客户端连接都被分配了自己的缓冲区，当处理完一个请求之后，Redis 就会将响应数据到客户端缓冲区中。查看客户端缓冲区 (0: 无限制) 的命令是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; config get client-output-buffer-limit</div><div class="line">1) &quot;client-output-buffer-limit&quot;</div><div class="line">// |&lt;- CLI BUF -&gt;|</div><div class="line">2) &quot;normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60&quot;</div><div class="line">//                   |&lt;|- REPLICATION BUF -&gt;|</div></pre></td></tr></table></figure>
<p>客户端缓冲区的内存是从 Redis 可用的最大内存中分配的，<code>KEYS, SMEMBERS, HGETALL, LRANGE, ZRANGE</code> 这些个简单的命令可能会产生体积庞大的数据，很容易就会消耗掉巨大的内存，我们应该避免使用以上命令，取而代之的是应该首选 <code>[SCAN](https://redis.io/commands/scan)</code> 命令。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.open-open.com/lib/view/open1454502890526.html" target="_blank" rel="external">Redis上踩过的一些坑-美团</a></li>
<li><a href="https://redislabs.com/blog/top-redis-headaches-for-devops-replication-buffer/" target="_blank" rel="external">Top Redis Headaches for Devops – Replication Buffer</a></li>
<li><a href="https://redislabs.com/blog/top-redis-headaches-for-devops-replication-timeouts/" target="_blank" rel="external">Top Redis Headaches for Devops – Replication Timeouts</a></li>
<li><a href="https://redislabs.com/blog/top-redis-headaches-for-devops-client-buffers/" target="_blank" rel="external">Top Redis Headaches for Devops – Client Buffers</a></li>
<li><a href="https://redislabs.com/blog/the-endless-redis-replication-loop-what-why-and-how-to-solve-it/" target="_blank" rel="external">The Endless Redis Replication Loop: What, Why and How to Solve It</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/07/04/Redis-questions/" data-id="cjcdlsfvv001ndiem9qoiq5zd" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Linux-Programming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/04/Linux-Programming/" class="article-date">
  <time datetime="2017-07-04T01:16:07.000Z" itemprop="datePublished">2017-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/04/Linux-Programming/">Linux Programming</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Linux-Programming"><a href="#Linux-Programming" class="headerlink" title="Linux Programming"></a>Linux Programming</h1><h2 id="1-File-I-O"><a href="#1-File-I-O" class="headerlink" title="1 File I/O"></a>1 File I/O</h2><p>每个进程都有一个称之为 <strong>file table</strong> 的数据结构:</p>
<p><img src="screen-shot-2013-02-11-at-11-13-21-am.png" alt=""></p>
<p>每一个进程都有一个它能打开的文件描述符的最大数量限制，默认是 1024，最高可以设置为 1048576 。按照管理，每一个进程至少有 3 个文件描述符: 0(stdin), 1(stdout), 2(stderr)。默认情况下，子进程将会拥有一份父进程的 file table 拷贝。</p>
<h3 id="1-1-打开文件"><a href="#1-1-打开文件" class="headerlink" title="1.1 打开文件"></a>1.1 打开文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="comment">// 当使用 mode(权限) 参数的时候，必须指定使用了 O_CREAT 标志位</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="comment">// 相当于 open(const char *name, O_WRONLY|O_CREAT|O_TRUNC)</span></div><div class="line"><span class="comment">// Yes, this function’s name is missing an e. Ken Thompson, the creator of Unix,</span></div><div class="line"><span class="comment">// once joked that the missing letter was his largest regret in the design of Unix.</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">mode_t</span> mode)</span></span>;</div></pre></td></tr></table></figure>
<p><a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="external">open 函数参考手册</a></p>
<ul>
<li><strong>flags</strong>: <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code> …</li>
<li><strong>谁是文件的拥有者? </strong>: The uid of the file’s owner is the effective uid of the process creating the file. The default behavior is to set the file’s group to the effective gid of the process creating the file.</li>
</ul>
<p>The actual permission bits that hit the disk are determined by binary-ANDing the mode argument with the complement of the user’s file creation mask (<code>umask</code>). The permissions of the created file are (<code>mode &amp; ~umask</code>). The <code>umask</code> is a process-specific attribute that is usually set via the login shell but is modifiable by the <code>umask()</code> call, allowing the user to modify the permissions placed on newly created files and directories. 通常是 <code>022</code></p>
<h3 id="1-2-读取文件"><a href="#1-2-读取文件" class="headerlink" title="1.2 读取文件"></a>1.2 读取文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="comment">// buf: 数据将会被存储在 buf 区域中</span></div><div class="line"><span class="keyword">ssize_t</span> read (<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div></pre></td></tr></table></figure>
<p>A call is made for len bytes, but no bytes are available for reading, the call will block (sleep) until the bytes become available (assuming the file descriptor was not opened in nonblocking mode)</p>
<p>The call may returns a value less than len, but greater than zero. The read bytes are stored in buf. This can occur because <strong>a signal interrupted the read midway; an error occurred in the middle of the read; more than zero, but less than len bytes’ worth of data was available; or EOF was reached before len bytes were read.</strong> Reissuing the<br>read (with correspondingly updated buf and len values) will read the remaining bytes into the rest of the buffer or indicate the cause of the problem.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> ret;</div><div class="line"><span class="keyword">while</span> (len != <span class="number">0</span> &amp;&amp; (ret = read (fd, buf, len)) != <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (ret == −<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno == EINTR)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        perror (<span class="string">"read"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    len -= ret;</div><div class="line">    buf += ret;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="机器字节序"><a href="#机器字节序" class="headerlink" title="机器字节序"></a>机器字节序</h3><p>下面代码清单可用于<strong>检查机器的字节序</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteorder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">short</span> value;</div><div class="line">        <span class="keyword">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</div><div class="line">    &#125; test;</div><div class="line"></div><div class="line">    test.value = <span class="number">0x0102</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( (test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp;</div><div class="line">         (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>) ) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( (test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp;</div><div class="line">         (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>) ) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"small endian\n"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"unknown...\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现代 PC 大多采用小端字节序，因此<strong>小端字节序又被称为主机字节序</strong>。<strong>大端字节序被称为网络字节序</strong>。</p>
<p><code>Linux</code> 提供了这两个函数来完成主机字节序和网络字节序之间的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="Linux-网络基础、高级-I-O-函数"><a href="#Linux-网络基础、高级-I-O-函数" class="headerlink" title="Linux 网络基础、高级 I/O 函数"></a>Linux 网络基础、高级 I/O 函数</h3><h4 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a><code>bind</code> 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>
<p><code>bind</code> 成功返回 0 ，失败返回 -1，并设置 <code>errno</code>，其中两种常见的 <code>errno</code>:</p>
<ul>
<li><code>EACCES</code>: 被绑定的地址是<strong>受保护的地址</strong>，仅超级用户能够访问。例如普通用户绑定到知名服务端口 (0~1023) 上，<code>bind</code> 就会返回这个错误。</li>
<li><code>EADDRINUSE</code>: 被绑定的地址<strong>正在使用中</strong>。</li>
</ul>
<h4 id="backlog"><a href="#backlog" class="headerlink" title="backlog"></a><code>backlog</code></h4><p><code>backlog</code> 参数提示内核<strong>监听队列</strong>的最大长度。如果超过 <code>backlog</code>，那么客户端收到 <code>ECONNREFUSED</code> 错误信息。</p>
<ul>
<li>内核 2.2 之前，<code>backlog</code> 指所有处于<strong>半连接状态 (<code>SYN_RCVD</code>)</strong>和<strong>完全连接状态 (<code>ESTABLISHED</code>)</strong> 的 <code>socket</code> 的上限。</li>
<li>内核 2.2 之后，只表示处于完全连接状态的 <code>socket</code> 的上限，处于半连接状态的 <code>socket</code> 的上限则有 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 内核参数定义。</li>
</ul>
<p><img src="2018_01_02_18_37_13.png" alt="tcp_max_syn_backlog"></p>
<p>完整连接 (<code>ESTABLISHED</code>) 最多有 <strong><code>backlog + 1</code></strong> 个。</p>
<h4 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a><code>accept</code> 函数</h4><p>如果监听队列中处于 <code>ESTABLISHED</code> 状态的连接对应的客户端出现网络异常，或者提前退出，那么服务器对这个连接执行 <code>accept</code> 已然成功，<code>accept</code> 调用对于客户端网络断开毫不知情。它只是从队列中取出连接，而不论连接处于何种状态。</p>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a><code>close</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div></pre></td></tr></table></figure>
<p><code>close</code> 系统调用并非总是立即关闭一个连接，而是将 <code>fd</code> 的引用计数减 1.只有当 <code>fd</code> 的引用计数为 0 的时候，才会真正关闭连接。多进程程序中，一次 <code>fork</code> 系统调用偶人将使父进程中打开的 <code>socket</code> 的引用计数加 1，因此我们必须在父进程和子进程中都对该 <code>socket</code> 执行 <code>close</code> 调用才能将连接关闭。</p>
<p>如果无论如何都要立即关闭，请使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a><code>socket</code> 选项</h4><p><code>fcntl</code> 系统调用是专门用于<strong>控制文件描述符属性</strong>的通用 <code>POSIX</code> 方法，那么下面这两个系统调用是专门用来<strong>读取和设置 <code>socket</code> 文件描述符属性</strong>的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><code>SO_REUSEADDR</code>: 强制使用处于 <code>TIME_WAIT</code> 状态的连接占用的 <code>socket</code> 地址</li>
<li><code>SO_RCVBUF</code>: 最小值 256 字节</li>
<li><code>SO_SENDBUF</code>: 最小值 2048 字节 (不同系统可能有不同默认值)</li>
<li><code>SO_RCVLOWAT</code>: <code>TCP</code> 接收缓冲区第低水位标记，一般被 I/O 复用系统调用，判断 <code>socket</code> 是否可读。默认为 1。</li>
<li><code>SO_SNDLOWAT</code>: <code>TCP</code> 发送缓冲区第低水位标记，一般被 I/O 复用系统调用，判断 <code>socket</code> 是否可写。默认为 1。</li>
<li><code>SO_LINGER</code>: <code>l_onoff</code> 等于 0，<code>close</code> 用默认行为关闭 <code>socket</code>。<code>l_onoff</code> 不为 0，<code>TCP</code> 模块将<strong>丢弃</strong>被关闭的 <code>socket</code> 对应的 <code>TCP</code> 发送缓冲区中残留的数据，同时给对方发送一个<strong>复位报文段</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> l_onoff; <span class="comment">/* 开启还是关闭 **/</span></div><div class="line">    <span class="keyword">int</span> l_linger; <span class="comment">/* 等待多长时间再关闭 **/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="主机名、信息"><a href="#主机名、信息" class="headerlink" title="主机名、信息"></a>主机名、信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 根据主机名获取主机的完整信息 1. /etc/hosts, 2. DNS 服务器 **/</span></div><div class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</div><div class="line"><span class="comment">/** 根据 IP 地址获取主机的完整信息 **/</span></div><div class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// ================================================</span></div><div class="line"></div><div class="line"><span class="comment">/** 根据名称获取某个服务的完整信息 1. /etc/services **/</span></div><div class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</div><div class="line"><span class="comment">/** 根据端口号获取某个服务的完整信息， 1. /etc/services **/</span></div><div class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="pipe-函数"><a href="#pipe-函数" class="headerlink" title="pipe 函数"></a><code>pipe</code> 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div></pre></td></tr></table></figure>
<p><code>pipe</code> 函数用于创建一个管道，以实现<strong>进程间通信</strong>。<code>fd[0]</code> 和 <code>fd[1]</code> 构成管道的两端，往 <code>fd[1]</code> 写入的数据可以从 <code>fd[0]</code> 读出。并且，<code>fd[0]</code> 只能用于从管道读出数据，<code>fd[1]</code> 则只能用于往管道写入数据，而不能反过来用。默认情况下，这一对文件描述符都是<strong>阻塞</strong>的。</p>
<p>管道本身有一个<strong>容量</strong>限制，它规定如果应用程序不将数据从管道读走的话，该管道<strong>最多能被写入多少字节的数据</strong>。自 Linux 2.6.11 内核起，管道容量的大小默认 <code>65536</code> 字节。我们可以使用 <code>fcntl</code> 函数来修改管道容量。</p>
<h4 id="dup-和-dup2-函数"><a href="#dup-和-dup2-函数" class="headerlink" title="dup 和 dup2 函数"></a><code>dup</code> 和 <code>dup2</code> 函数</h4><p>有时我们希望把标准输入<strong>重定向</strong>到一个文件，或者把标准输出输出重定向到一个网络连接 (<code>CGI</code> 编程)。</p>
<p>通过 <code>dup</code> 和 <code>dup2</code> 创建的文件描述符并<strong>不继承</strong>原文件描述符的属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="comment">/* 返回的文件描述符总是取系统当前可用的最小整数值 **/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> file_descriptor)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> file_descriptor_one, <span class="keyword">int</span> file_descriptor_two)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="readv-和-writev-函数"><a href="#readv-和-writev-函数" class="headerlink" title="readv 和 writev 函数"></a><code>readv</code> 和 <code>writev</code> 函数</h4><p><code>readv</code> 函数将数据从文件描述符读到分散的内存块中，即<strong>分散读</strong>；<code>writev</code> 函数则将多块分散的内存数据一并写入文件描述符中，即<strong>集中写</strong>。</p>
<p>当 <code>Web</code> 服务器解析完一个 HTTP 请求之后，如果目标文档存在且客户端具有读取该文档的权限，那么它就需要发送一个 HTTP 应答来传输该文档。这个 HTTP 应答包含 1 个状态行、多个头部字段、1 个空行和文档的内容。其中前 3 部分的内容可能被 Web 服务器放置在一块内存中，而文档的内容则通常被读入到另外一块单独的内存中。我们并<strong>不需要把这两部分内容拼接</strong>到一起再发送，而是可以使用 <code>writev</code> 函数将它们<strong>同时写出</strong>。</p>
<h4 id="sendfile-零拷贝"><a href="#sendfile-零拷贝" class="headerlink" title="sendfile 零拷贝"></a><code>sendfile</code> 零拷贝</h4><p><code>sendfile</code> 函数在两个文件描述符之间直接传递数据 （<strong>完全在内核中操作</strong>），从而避免了内核缓冲区和用户缓冲区的数据拷贝，效率很高，这被成为<strong>零拷贝</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offset, <span class="keyword">size_t</span> count);</div></pre></td></tr></table></figure>
<ul>
<li><code>out_fd</code> 必须是一个 <code>socket</code>，由此可见，<code>sendfile</code> 几乎是<strong>专门为在网络上传输文件而设计</strong>的。</li>
</ul>
<h4 id="mmap-函数和-munmap-函数"><a href="#mmap-函数和-munmap-函数" class="headerlink" title="mmap 函数和 munmap 函数"></a><code>mmap</code> 函数和 <code>munmap</code> 函数</h4><p><code>mmap</code> 函数用于申请一段内存空间。我们可以将这段内存作为<strong>进程间通信的共享内存</strong>，也可以将文件直接映射到其中。<code>munmap</code> 函数则释放由 <code>mmap</code> 创建的这段内存空间。</p>
<h4 id="splice-函数"><a href="#splice-函数" class="headerlink" title="splice 函数"></a><code>splice</code> 函数</h4><p><code>splice</code> 函数用于<strong>在两个文件描述符之间移动数据</strong>，也是<strong>零拷贝</strong>操作。</p>
<h4 id="tee-函数"><a href="#tee-函数" class="headerlink" title="tee 函数"></a><code>tee</code> 函数</h4><p><code>tee</code> 函数<strong>在两个管道文件描述符之间复制数据</strong>，也是<strong>零拷贝</strong>操作。它<strong>不消耗数据</strong>。</p>
<h4 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a><code>fcntl</code> 函数</h4><p>名字 (file control)，提供了对文件描述符的各种控制操作。<code>ioctl</code> 比 <code>fcntl</code> 能够执行更多的控制。但是，对于控制文件描述符常用的属性和行为，<code>fcntl</code> 函数是由 <code>POSIX</code> <strong>规范指定的首选方法</strong>。</p>
<h4 id="epoll-函数"><a href="#epoll-函数" class="headerlink" title="epoll 函数"></a><code>epoll</code> 函数</h4><p><code>epoll</code> provides both <strong>edge-triggered</strong> and <strong>level-triggered</strong> modes.In <strong>edge-triggered</strong> mode, a call to <code>epoll_wait</code> will return only when a <strong>new event</strong> is <strong>enqueued (新事件进入队列)</strong> with the <code>epoll</code> object, while in <strong>level-triggered</strong> mode, <code>epoll_wait</code> will return as long as the condition holds.</p>
<p>For instance, if a pipe registered with epoll has <strong>received data (收到数据)</strong>, a call to <code>epoll_wait</code> will return, signaling the presence of data to be read. Suppose the reader only consumed part of data from the buffer. In <strong>level-triggered</strong> mode, further calls to <code>epoll_wait</code> will return immediately, as long as the pipe’s buffer <strong>contains data (只要有数据)</strong> to be read. In <strong>edge-triggered</strong> mode, however, <code>epoll_wait</code> will return <strong>only once (只会触发一次)</strong> new data is written to the pipe.</p>
<p>ET 模式在很大程度上降低了同一个 <code>epoll</code> 事件被重复触发的次数，因此效率要比 LT 模式要高。</p>
<p><code>Java</code>的<code>NIO</code>属于水平触发，即条件触发。</p>
<p>举个读<code>socket</code>的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个<code>read ready notification</code>通知应用程序<strong>可读</strong>。</p>
<p>应用程序读了<code>50</code>个字节，然后重新调用<code>API</code>等待<code>io</code>事件。这时条件触发的<code>api</code>会因为还有<code>50</code>个字节可读从而立即返回用户一个<code>read ready notification</code>。</p>
<p>而边缘触发的<code>api</code>会因为可读这个状态没有发生变化而<strong>陷入长期等待</strong>。 因此在使用边缘触发的<code>api</code>时，要注意每次都要读到<code>socket</code>返回<code>EWOULDBLOCK</code>为止，否则这个<code>socket</code>就算废了。</p>
<p>而使用条件触发的<code>API</code> 时，如果应用程序不需要写就不要关注<code>socket</code>可写的事件，否则就会无限次的立即返回一个<code>write ready notification</code>。大家常用的<code>select</code>就是属于条件触发这一类，长期关注<code>socket</code>写事件会出现CPU 100%的毛病。</p>
<p>所以在使用<code>Java</code>的<code>NIO</code>编程的时候，在<strong>没有数据可以往外写的时候要取消写事件，在有数据往外写的时候再注册写事件</strong>。</p>
<hr>
<p><code>Java NIO</code> 的写法:</p>
<p><strong>监听连接事件</strong>:</p>
<p><img src="2018_01_03_16_28_37.png" alt="连接事件"></p>
<p><strong>监听可读事件</strong>:</p>
<p><img src="2018_01_03_16_29_27.png" alt="可读"></p>
<p><strong>只要可读数据不为空，那么 <code>isReadable()</code> 会一直被调用</strong>:</p>
<p><img src="2018_01_03_16_36_09.png" alt="isReadable"></p>
<p><strong>只在有可写数据的时候，才注册 <code>OP_WRITE</code> 操作</strong>:</p>
<p><img src="2018_01_03_16_44_32.png" alt="OP_WRITE"></p>
<p>一旦一开始注册 <code>OP_WRITE</code> 的话，会发现一旦连接建立起来，屏幕上就会不停地输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">write</div><div class="line">write</div><div class="line">write</div><div class="line">...</div></pre></td></tr></table></figure>
<p>尽管这时客户端还没有任何输入，但<strong>这时<code>selector.select()</code>不会阻塞</strong>，因为<strong><code>socket</code>只要<code>send buffer</code>不满就可以写</strong>，刚开始<code>send buffer</code>为空，<code>socket</code>总是可以写，于是<code>server.select()</code>立即返回。由于这个<code>key</code>可写，所以服务器会执行 <code>isWritable()</code> 方法里面的逻辑。</p>
<p>这样下去，服务器什么事情也没有干，但是却一直在<strong>消耗 CPU</strong>。</p>
<blockquote>
<p>不要在同一个<code>socket</code>同时注册多个操作。<strong>要么只注册<code>OP_READ</code>，要么只注册<code>OP_WRITE</code></strong>。</p>
</blockquote>
<p><strong>读取数据</strong>:</p>
<p><img src="2018_01_03_16_57_06.png" alt="读取数据"></p>
<p><code>sock.read(buffer)</code> 方法的返回值:</p>
<ul>
<li><code>0</code>: 表示读取了 0 字节数据</li>
<li><code>-1</code>: 表示客户端关闭了连接</li>
</ul>
<p>在读取完成之后，如果有可写响应的话，那么应该<strong>关闭读，打开写</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">key.interestOps(SelectionKey.OP_WRITE);</div></pre></td></tr></table></figure>
<p><strong>写入数据</strong>:</p>
<p>写入数据完成后，应该<strong>关闭写，打开读</strong>:</p>
<p><img src="2018_01_03_17_01_01.png" alt="写入数据"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.amazon.cn/dp/B00ETOV4N0" target="_blank" rel="external">Linux高性能服务器编程</a></li>
<li><a href="https://www.zhihu.com/question/22524908" target="_blank" rel="external">java nio使用的是水平触发还是边缘触发？</a></li>
<li><a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/" target="_blank" rel="external">How to use epoll? A complete example in C</a></li>
<li><a href="http://marlonyao.iteye.com/blog/1005690" target="_blank" rel="external">java nio网络编程的一点心得</a></li>
<li><a href="http://adblogcat.com/asynchronous-java-nio-for-dummies/" target="_blank" rel="external">Asynchronous Java NIO for dummies</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/07/04/Linux-Programming/" data-id="cjcdlsfvj0011diem66km2az6" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/blog/page/13/">&laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/12/">12</a><a class="page-number" href="/blog/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/blog/page/15/">15</a><a class="page-number" href="/blog/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/23/">23</a><a class="extend next" rel="next" href="/blog/page/15/">Next&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2018/01/06/where-the-time-actually-gone/">时间都去哪儿了</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/05/dev-reflection/">开发反思</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/05/my-microblog/">我的微博</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/04/gcc-basic/">gcc-basic</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/04/java-internal/">Java Internal</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 赵坤&nbsp;|&nbsp;
      Theme by <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      Contact&nbsp;|&nbsp;igozhaokun@163.com
    </div>
  </div>
</footer>
 <script src="/blog/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">首页</a>
  
    <a href="/blog/archives" class="mobile-nav-link">归档</a>
  
    <a href="/blog/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/blog/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>

      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js"></script>
  


 <script src="/blog/js/is.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>
<script src="/blog/js/elevator.js"></script>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>