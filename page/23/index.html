<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>代码人生</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="赵坤的个人网站">
<meta property="og:type" content="website">
<meta property="og:title" content="代码人生">
<meta property="og:url" content="http://blog.kunzhao.org/page/23/index.html">
<meta property="og:site_name" content="代码人生">
<meta property="og:description" content="赵坤的个人网站">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代码人生">
<meta name="twitter:description" content="赵坤的个人网站">
  
    <link rel="alternate" href="/atom.xml" title="代码人生" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.kunzhao.org"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">首页</a>
        
          <a class="main-nav-link" href="/blog/archives">归档</a>
        
          <a class="main-nav-link" href="/blog/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">代码人生</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-线程同步机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/05/线程同步机制/" class="article-date">
  <time datetime="2017-05-05T08:43:10.000Z" itemprop="datePublished">2017-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/理解计算机/">理解计算机</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/05/线程同步机制/">线程同步机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><h3 id="Linux-线程同步机制"><a href="#Linux-线程同步机制" class="headerlink" title="Linux 线程同步机制"></a>Linux 线程同步机制</h3><ul>
<li>mutexes - Mutual exclusion lock (互斥锁):</li>
<li>joins - 让一个线程等待其他线程结束</li>
<li>condition variables 条件变量 - 数据类型 <code>pthread_cond_t</code></li>
</ul>
<h3 id="1-Mutexes"><a href="#1-Mutexes" class="headerlink" title="1. Mutexes"></a>1. Mutexes</h3><p><strong>A <code>mutex</code> is basically a lock that we set (lock) before accessing a shared resource and release (unlock) when we’re done.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Note scope of variable and mutex are the same */</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> mutex1 = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="keyword">int</span> counter=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/* Function C */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionC</span><span class="params">()</span> </span>&#123;</div><div class="line">    pthread_mutex_lock( &amp;mutex1 );</div><div class="line">    counter++;</div><div class="line">    pthread_mutex_unlock( &amp;mutex1 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用两个或以上的 <strong>Mutexes</strong> 的时候，一定要注意防范死锁问题，切记对加锁的顺序问题重点关注。</p>
<h3 id="2-Joins"><a href="#2-Joins" class="headerlink" title="2. Joins"></a>2. Joins</h3><p>一个线程等待另外一个线程结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 10</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</div><div class="line"><span class="keyword">pthread_mutex_t</span> mutex1 = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="keyword">int</span>  counter = <span class="number">0</span>;</div><div class="line"></div><div class="line">main() &#123;</div><div class="line">    <span class="keyword">pthread_t</span> thread_id[NTHREADS];</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; NTHREADS; i++) &#123;</div><div class="line">        pthread_create( &amp;thread_id[i], <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span> );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt; NTHREADS; j++) &#123;</div><div class="line">        <span class="comment">// 主线程等待 thread_id[j] 结束</span></div><div class="line">        pthread_join( thread_id[j], <span class="literal">NULL</span>); </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 走到这个地方说明所有线程都已经结束了</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Final counter value: %d\n"</span>, counter);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *dummyPtr)</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Thread number %ld\n"</span>, pthread_self());</div><div class="line">    pthread_mutex_lock( &amp;mutex1 );</div><div class="line">    counter++;</div><div class="line">    pthread_mutex_unlock( &amp;mutex1 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Condition-Variables"><a href="#3-Condition-Variables" class="headerlink" title="3. Condition Variables"></a>3. Condition Variables</h3><p><strong>Condition Variables</strong> 总是应该和 <strong>Mutex</strong> 一块使用来避免竞态条件。使用 <strong>Condition Variables</strong> 的函数:</p>
<ul>
<li>创建/销毁<ul>
<li><code>pthread_cond_init</code></li>
<li><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></li>
<li><code>pthread_cond_destroy</code></li>
</ul>
</li>
<li>等待一个 Condition<ul>
<li><code>pthread_cond_wait</code></li>
<li><code>pthread_cond_timedwait</code> - 阻塞多久</li>
</ul>
</li>
<li>唤醒在某个 Condition 上的线程<ul>
<li><code>pthread_cond_signal</code></li>
<li><code>pthread_cond_broadcast</code> - 唤醒等待在这个 Condition 上的所有线程</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pthread_mutex_t</span> condition_mutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="keyword">pthread_cond_t</span>  condition_cond  = PTHREAD_COND_INITIALIZER;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(;;) &#123;</div><div class="line">    <span class="comment">// 改变 condition_cond 状态之前，必须先锁住 Mutex</span></div><div class="line">    pthread_mutex_lock( &amp;condition_mutex );</div><div class="line">    <span class="keyword">while</span>( count &gt;= COUNT_HALT1 &amp;&amp; count &lt;= COUNT_HALT2 ) &#123;</div><div class="line">        pthread_cond_wait( &amp;condition_cond, &amp;condition_mutex );</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock( &amp;condition_mutex );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html" target="_blank" rel="external">POSIX thread (pthread) libraries</a></li>
<li><a href="https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/" target="_blank" rel="external">《Advanced Programming in the UNIX Environment 3rd Edition》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/05/线程同步机制/" data-id="cjcdlsgsd0075diemu4lec3an" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-gradle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/04/gradle/" class="article-date">
  <time datetime="2017-05-04T00:51:23.000Z" itemprop="datePublished">2017-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/04/gradle/">Gradle</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><h3 id="1-如何配置代理"><a href="#1-如何配置代理" class="headerlink" title="(1) 如何配置代理"></a>(1) 如何配置代理</h3><p>将文件 <code>gradle.properties</code> 放在项目根目录下或者 <code>~/.gradle/</code> 下即可配置代理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">systemProp.http.proxyHost=proxy.yourproxysite.com</div><div class="line">systemProp.http.proxyPort=<span class="number">8080</span></div><div class="line">systemProp.https.proxyHost=proxy.yourproxysite.com</div><div class="line">systemProp.https.proxyPort=<span class="number">8080</span></div></pre></td></tr></table></figure>
<h3 id="2-默认依赖缓存位置"><a href="#2-默认依赖缓存位置" class="headerlink" title="(2) 默认依赖缓存位置"></a>(2) 默认依赖缓存位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/.gradle/caches/</div></pre></td></tr></table></figure>
<h3 id="可用-API"><a href="#可用-API" class="headerlink" title="可用 API"></a>可用 API</h3><h4 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h4><p>在 <code>build.gradle</code> 文件中设置描述信息:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setDescription(<span class="string">"myProject"</span>)</div><div class="line">println <span class="string">"Description of project $name: "</span> + project.description</div></pre></td></tr></table></figure>
<h5 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h5><ul>
<li>方法一: 使用 <code>ext</code> 命名空间</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ext &#123;</div><div class="line">    a = <span class="number">123</span> </div><div class="line">&#125;</div><div class="line"></div><div class="line">println project.a <span class="comment">// 123</span></div><div class="line">println project.ext.a <span class="comment">// 123</span></div><div class="line">println a <span class="comment">// 123</span></div><div class="line">println <span class="string">"$a"</span> <span class="comment">// 123</span></div><div class="line">println $a <span class="comment">// ERROR</span></div></pre></td></tr></table></figure>
<ul>
<li>方法二: 使用 <code>gradle.properties</code></li>
</ul>
<p>在文件 <code>gradle.properties</code> 中声明变量:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b = <span class="number">456</span></div></pre></td></tr></table></figure>
<p>然后在文件 <code>build.gradle</code> 中直接引用:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">println project.b <span class="comment">// 456</span></div><div class="line">println project.ext.b <span class="comment">// 456</span></div><div class="line">println b <span class="comment">// 456</span></div><div class="line">println <span class="string">"$b"</span> <span class="comment">// 456</span></div><div class="line">println $b <span class="comment">// ERROR</span></div></pre></td></tr></table></figure>
<p>注意，带有前缀 <strong>$</strong> 符号的变量必须使用 <strong>“”</strong> 括起来:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">task printProperty &lt;&lt; &#123;</div><div class="line">    println $a <span class="comment">// ERROR</span></div><div class="line">    println $b <span class="comment">// ERROR</span></div><div class="line">    println <span class="string">"$a"</span> <span class="comment">// OK</span></div><div class="line">    println <span class="string">"$b"</span> <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><h5 id="dependsOn"><a href="#dependsOn" class="headerlink" title="dependsOn"></a>dependsOn</h5><p>在 <code>build.gradle</code> 文件中声明任务依赖:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">task first &lt;&lt; &#123; println <span class="string">"first"</span> &#125;</div><div class="line">task second &lt;&lt; &#123; println <span class="string">"second"</span> &#125;</div><div class="line">task printVersion(<span class="string">dependsOn:</span> [second, first]) &lt;&lt; &#123;</div><div class="line">    logger.quiet <span class="string">"Version: $version"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">task third &lt;&lt; &#123; println <span class="string">"third"</span> &#125;</div><div class="line">third.dependsOn(<span class="string">'printVersion'</span>)</div></pre></td></tr></table></figure>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>每一个任务都有一个类型，几个重要的 <strong>type</strong> 如下:</p>
<ul>
<li><strong>DefaultTask</strong>: 默认</li>
<li><strong>Copy</strong>: 拷贝文件</li>
<li><strong>Jar</strong>: 从源码创建一个 <strong>Jar</strong> 包</li>
<li><strong>JavaExec</strong>: 运行带有 <code>main()</code> 方法的 <strong>Java</strong> 类</li>
</ul>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在 <code>build.gradle</code> 文件中，我们可以对依赖进行分组，一组依赖可以放到一个 <strong>configuration</strong> 中，多组依赖可以放到一个 <strong>configurations</strong> 块中。如下代码所示，我们定义了两个 <strong>configuration</strong>，每个 <strong>configuration</strong> 都必须至少包含一个 <strong>name</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">configurations &#123;</div><div class="line">    <span class="comment">// 这个 configuration 的 name 是 commonsLib</span></div><div class="line">    commonsLib &#123;</div><div class="line">        description = <span class="string">'Common libraries'</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 这个 configuration 的 name 是 mainLib</span></div><div class="line">    mainLib &#123;</div><div class="line">        description = <span class="string">'Main libraries'</span></div><div class="line">        extendsFrom commonsLib</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">println configurations[<span class="string">'mainLib'</span>].name</div><div class="line">println configurations.commonsLib.name</div></pre></td></tr></table></figure>
<p>执行命令: <code>gradle dependencies</code> 我们可以查看当前所有的 <strong>configuration</strong> :</p>
<p><img src="17-05-04-15_42_59_901_453.png" alt=""></p>
<p>许多插件都会往 <code>ConfigurationContainer</code> 添加新的 <strong>configuration</strong>，例如我们使用 (<code>apply plugin: &#39;java&#39;</code>) 了 <code>java</code> 插件以后，我们的 <strong>configuration</strong> 也会变多:</p>
<p><img src="17-05-04-15_48_44_769_599.png" alt=""></p>
<h4 id="1-外部模块依赖"><a href="#1-外部模块依赖" class="headerlink" title="1. 外部模块依赖"></a>1. 外部模块依赖</h4><p>定义依赖的通用写法如下:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    configurationName dependencyNotation1, dependencyNotation2, ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像下面的这个例子，我们使用了 <strong>Java</strong> 插件，所以我们得到了 <strong>compile</strong> 和 <strong>runtime</strong> 两个依赖配置，我们可以使用不同的语法格式来为每一个配置添加依赖:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></div><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line">ext &#123;</div><div class="line">    springVersion = <span class="string">'3.1.1.RELEASE'</span></div><div class="line">    springGroup = <span class="string">'org.springframework'</span></div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">    <span class="comment">// 详细写法</span></div><div class="line">    compile <span class="string">group:</span> springGroup, <span class="string">name:</span> <span class="string">'spring-core'</span>, <span class="string">version:</span> springVersion</div><div class="line">    <span class="comment">// 快捷写法</span></div><div class="line">    runtime <span class="string">"$springGroup:spring-aop:$springVersion"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    mavenLocal()</div><div class="line">    mavenCentral()</div><div class="line">    <span class="comment">// 自定义 Maven 仓库位置</span></div><div class="line">    maven &#123;</div><div class="line">        <span class="comment">// Name is optional. If not set url property is used</span></div><div class="line">        name = <span class="string">'Main Maven repository'</span></div><div class="line">        url = <span class="string">'http://intranet/repo'</span></div><div class="line">    &#125;</div><div class="line">    mavenRepo(<span class="string">name:</span> <span class="string">'Snapshot repository'</span>, <span class="string">url:</span> <span class="string">'http://intranet/snapshots'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置阿里云 Maven 仓库:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    maven &#123; </div><div class="line">        url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span> </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-项目依赖"><a href="#2-项目依赖" class="headerlink" title="2. 项目依赖"></a>2. 项目依赖</h4><p>(1) 一般来说，<code>gradle</code> 如果有子项目的话，那么项目目录通常会这么组织:</p>
<p><img src="17-05-04-17_33_11_780_405.png" alt=""></p>
<p>我们通过在文件 <code>settings.gradle</code> 中声明:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">include <span class="string">'model'</span></div><div class="line">include <span class="string">'repository'</span></div><div class="line">include <span class="string">'web'</span></div></pre></td></tr></table></figure>
<p>这样执行 <code>gradle projects</code> 的时候，我们可以看见所有的子项目。<code>build.gradle</code> 文件一般而言，就是定义子项目共有行为的，例如为所有的子项目添加 <strong>Java</strong> 插件:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build.gradle 文件</span></div><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    group = <span class="string">'com.manning.gia'</span></div><div class="line">    version = <span class="string">'0.1'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">subprojects &#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'java'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子项目之间相互依赖:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 子项目 repository 的 build.gradle 文件</span></div><div class="line">dependencies &#123;</div><div class="line">    compile project(<span class="string">':model'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 子项目 web 的 build.gradle 文件</span></div><div class="line">apply <span class="string">plugin:</span> <span class="string">'war'</span></div><div class="line">apply <span class="string">plugin:</span> <span class="string">'jetty'</span></div><div class="line"></div><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile project(<span class="string">':repository'</span>)</div><div class="line">    providedCompile <span class="string">'javax.servlet:servlet-api:2.5'</span></div><div class="line">    runtime <span class="string">'javax.servlet:jstl:1.1.2'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <strong>:repository</strong> 中的 <strong>:</strong> 表示的是目录，也就是说如果你想要添加一个嵌套更深的子项目 (例如相对于 <code>root</code> 的位置在 <code>/model/todo/items</code>) 可以像下面这样声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include &apos;model:todo:items&apos;</div></pre></td></tr></table></figure>
<hr>
<p>(2) 如果是<strong>两个互相独立的项目</strong>依赖的话:</p>
<p><img src="2017_10_15_17_44_39.png" alt=""></p>
<p>需要声明所依赖的项目的位置:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">include <span class="string">':Dependency'</span></div><div class="line">project(<span class="string">':Dependency'</span>).projectDir = <span class="keyword">new</span> File(settingsDir, <span class="string">'../Dependency'</span>)</div></pre></td></tr></table></figure>
<hr>
<p>(3) <strong><code>Gradle</code> 依赖 <code>Maven</code></strong>:</p>
<p>You can’t really add the Maven multi-module project structure as a dependency directly. You can, however, build the multi-module project using <font color="red"><strong><code>mvn install</code></strong></font> to install the project jars to your <strong>local</strong> repository.</p>
<p>Then, in your <code>build.gradle</code>, you need the following configuration:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">  mavenLocal()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This will add your local Maven repository to the list of code repositories that Gradle will look through for your artifacts. You can then declare a dependency on the module(s) that your Gradle project requires.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile <span class="string">'my-group:my-artifact:version'</span>,</div><div class="line">            <span class="string">'my-group:my-other-artifact:version'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>When the multi-module project updates to a new release version, run <code>mvn install</code> for that release and update your <code>build.gradle</code> as needed.</p>
<p>(4) <strong><code>Gradle</code> 依赖 <code>Maven</code></strong>:</p>
<p>you can “fake” including a Maven project like this:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile files(<span class="string">"gradlemvn/target/classes"</span>) &#123;</div><div class="line">        builtBy <span class="string">"compileMavenProject"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    compile project(<span class="string">':gradledao'</span>)</div><div class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">task compileMavenProject(<span class="string">type:</span> Exec) &#123;</div><div class="line">    workingDir <span class="string">"gradlemvn/"</span></div><div class="line">    commandLine <span class="string">"/usr/bin/mvn"</span>, <span class="string">"clean"</span>, <span class="string">"compile"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This way Gradle will execute a Maven build (<code>compileMavenProject</code>) before compiling.</p>
<h4 id="3-文件依赖"><a href="#3-文件依赖" class="headerlink" title="3. 文件依赖"></a>3. 文件依赖</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></div><div class="line">dependencies &#123;</div><div class="line">    compile files(<span class="string">'spring-core.jar'</span>, <span class="string">'spring-aap.jar'</span>)</div><div class="line">    compile fileTree(<span class="string">dir:</span> <span class="string">'deps'</span>, <span class="string">include:</span> <span class="string">'*.jar'</span>)</div><div class="line">    compile fileTree(<span class="string">dir:</span> <span class="string">"$&#123;System.properties['user.home']&#125;/libs/cargo"</span>, <span class="string">include:</span> <span class="string">'*.jar'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>include: &#39;*.jar&#39;</code> 表示只有一级目录下面的 <strong>jar</strong> 文件才被包含，子目录下面的 <strong>jar</strong> 文件并不会被包含。</p>
<h3 id="安装-Gradle"><a href="#安装-Gradle" class="headerlink" title="安装 Gradle"></a>安装 Gradle</h3><ul>
<li>访问 <a href="https://gradle.org/install/" target="_blank" rel="external">https://gradle.org/install/</a></li>
</ul>
<h3 id="Gradle-跳过测试"><a href="#Gradle-跳过测试" class="headerlink" title="Gradle 跳过测试"></a><code>Gradle</code> 跳过测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle build -x test</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.amazon.com/Gradle-Action-Benjamin-Muschko/dp/1617291307" target="_blank" rel="external">《Gradle In Action》</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html" target="_blank" rel="external">Working with Manifest Files: The Basics</a></li>
<li><a href="https://www.amazon.com/Gradle-Effective-Implementation-Hubert-Ikkink/dp/1849518106/" target="_blank" rel="external">《Gradle Effective Implementation Guide》</a></li>
<li><a href="https://young4979.wordpress.com/2017/01/11/gradle%E4%BF%AE%E6%94%B9maven%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%E4%B8%BA%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/" target="_blank" rel="external">GRADLE修改MAVEN仓库地址为国内镜像</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/04/gradle/" data-id="cjcdlsfxp0045diemtbckaxc6" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-MySQL索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/03/MySQL索引/" class="article-date">
  <time datetime="2017-05-03T12:10:56.000Z" itemprop="datePublished">2017-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/笔记本/">笔记本</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/03/MySQL索引/">MySQL索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>除了一些特殊情况: <strong>R-树</strong> 以及使用 <strong>hash</strong> 索引的 <strong>MEMORY</strong> 表，大多数 MySQL 索引通常存储为 <strong>B-树</strong> 来形式。</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>如果表有多列索引，任何最左侧的索引前缀都可以被 <strong>Optimizer</strong> 查询数据，多列索引可以被看做一个有序数组。例如如果你在 <code>(col1, col2, col3)</code> 上创建了索引，那么你可以搜索 <code>(col1), (col1, col2), (col1, col2, col3)</code>。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://stackoverflow.com/questions/1108/how-does-database-indexing-work" target="_blank" rel="external">How does database indexing work?</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.5/en/mysql-indexes.html" target="_blank" rel="external">8.3.1 How MySQL Uses Indexes</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></li>
<li><a href="http://www.seanster.com/BplusTree/" target="_blank" rel="external">BplusTree</a></li>
<li><a href="http://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/BTree.java.html" target="_blank" rel="external">Btree.java</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/03/MySQL索引/" data-id="cjcdlsfvq001ediem9fsaeq9a" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-java-lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/03/java-lock/" class="article-date">
  <time datetime="2017-05-03T03:45:29.000Z" itemprop="datePublished">2017-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/03/java-lock/">Java并发-锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Java-并发-锁"><a href="#Java-并发-锁" class="headerlink" title="Java 并发-锁"></a>Java 并发-锁</h2><h3 id="内置锁-Synchronized"><a href="#内置锁-Synchronized" class="headerlink" title="内置锁 Synchronized"></a>内置锁 Synchronized</h3><p>Java 提供了一种<strong>内置锁 (Intrinsic Lock)</strong>机制来支持原子性: <strong>同步代码块 (Synchronized Block)</strong>。每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为<strong>内置锁 (Instrinsic Lock)</strong> 或<strong>监视器锁 (Monitor Lock)</strong>。Java 的内置锁相当于一种互斥体(或<strong>互斥锁</strong>)，这意味着最多只有一个线程能持有这种锁。但是，加锁的含义不仅仅局限于<strong>互斥行为</strong>，还包括<strong>内存可见性</strong>，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<p><strong><code>Java synchronized</code> 语句</strong> 是基于 <strong>monitorenter/monitorexit</strong> 机制来实现的。当你写下面这段代码的时候:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">    <span class="comment">// synchronize this operation so that some other thread can't</span></div><div class="line">    <span class="comment">// manipulate the array while we are sorting it. This assumes that other</span></div><div class="line">    <span class="comment">// threads also synchronize their accesses to the array.</span></div><div class="line">    <span class="keyword">synchronized</span>(array) &#123;</div><div class="line">        <span class="comment">// now sort elements in array</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上 <strong>JVM</strong> 可能会生成下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.<span class="function">method <span class="keyword">static</span> <span class="title">Sort</span><span class="params">([I)</span>V</span></div><div class="line"><span class="function">    aload_0</span></div><div class="line"><span class="function">    monitorenter    </span>; lock object in local variable <span class="number">0</span> </div><div class="line"></div><div class="line">    ; now sort elements in <span class="built_in">array</span></div><div class="line"></div><div class="line">    aload_0</div><div class="line">    monitorexit      ; finished with object in local variable <span class="number">0</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">.end method</div></pre></td></tr></table></figure>
<p><code>monitorenter</code> 在对象的引用上获取了一个 <strong>exclusive lock (独占锁)</strong></p>
<hr>
<p><strong>内置锁 <code>synchronized</code> 是可重入</strong>的，某个线程试图获取一个已经由它自己持有的锁，那么这个请求就会成功。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在<strong>数据库系统的设计中考虑了监测死锁以及从死锁中恢复</strong>。在执行一个事务 (Transaction) 时可能需要获取多个锁，并一直持有这些锁直到事务提交。当数据库服务器监测到一组事务发生了死锁时 (<strong>通过在表示等待关系的有向图中搜索循环</strong>)，将 选择一个牺牲者并放弃这个事务。作为牺牲者的事务会释放它所持有的资源，从而让其它事务继续进行。应用程序可以重新执行被强行中止的事务，而这个事务现在也可以成功完成。</p>
<p>死锁的四大必要条件 (必须全部满足):</p>
<ol>
<li>互斥</li>
<li>持有并等待资源</li>
<li>不可抢占</li>
<li>循环等待</li>
</ol>
<p>如果所有的线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不要这么做</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadlock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (left) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (right) &#123;</div><div class="line">                doSomething();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (right) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (left) &#123;</div><div class="line">                doSomethingElse();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候，你并不能清除地知道是否在锁顺序上有足够的控制权来避免死锁的发生:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 动态的锁顺序</span></div><div class="line"><span class="comment">// Warning: deadlock-prone!</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount,</span></span></div><div class="line"><span class="function"><span class="params">                          Account toAccount,</span></span></div><div class="line"><span class="function"><span class="params">                          DollarAmount amount)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (fromAccount) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</div><div class="line">            <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                fromAccount.debit(amount);</div><div class="line">                toAccount.credit(amount);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里锁的顺序取决于参数顺序，而这些参数顺序又取决于外部输入，考虑下面代码就有可能发生死锁:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A: transferMoney(myAccount, yourAccount, <span class="number">10</span>);</div><div class="line">B: transferMoney(yourAccount, myAccount, <span class="number">20</span>);</div></pre></td></tr></table></figure>
<p>使用 <code>System.identityHashCode</code> 来定义锁的顺序:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object tieLock = <span class="keyword">new</span> Object();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(<span class="keyword">final</span> Account fromAcct,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> Account toAcct,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> DollarAmount amount)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</div><div class="line">            <span class="keyword">if</span> (fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                fromAcct.debit(amount);</div><div class="line">                toAcct.credit(amount);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果 Account 中包含一个唯一的、不可变的，并且具备可比性的键值，例如</span></div><div class="line">    <span class="comment">// 账号，那么制定锁的顺序就更加容易了。</span></div><div class="line">    <span class="keyword">int</span> fromHash = System.identityHashCode(fromAcct);</div><div class="line">    <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (fromAcct) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (toAcct) &#123;</div><div class="line">                <span class="keyword">new</span> Helper().transfer();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (toAcct) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</div><div class="line">                <span class="keyword">new</span> Helper().transfer();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 在极少数情况下，两个对象可能拥有相同的散列值，</span></div><div class="line">        <span class="comment">// 此时可以通过某种任意的方法来决定锁的顺序，</span></div><div class="line">        <span class="comment">// 而这有可能重新引入死锁。为了避免这种情况，可以使用</span></div><div class="line">        <span class="comment">// “加时赛”锁</span></div><div class="line">        <span class="keyword">synchronized</span> (tieLock) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</div><div class="line">                <span class="keyword">synchronized</span> (toAcct) &#123;</div><div class="line">                    <span class="keyword">new</span> Helper().transfer();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>某些获取多个锁的操作并不像 <code>LeftRightDeadLock</code> 或 <code>transferMoney</code> 中那么明显，这两个锁并不一定必须在同一个方法中被获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.dispatcher = dispatcher;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> location;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 先获取 Taxi 锁</span></div><div class="line">    <span class="comment">// 再获取 Dispatcher 锁</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.location = location;</div><div class="line">        <span class="keyword">if</span> (location.equals(destination))</div><div class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</div><div class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</div><div class="line">        availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</div><div class="line">        availableTaxis.add(taxi);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 先获取 Dispatcher 锁</span></div><div class="line">    <span class="comment">// 再获取每一个 Taxi 锁</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</div><div class="line">        Image image = <span class="keyword">new</span> Image();</div><div class="line">        <span class="keyword">for</span> (Taxi t : taxis)</div><div class="line">            image.drawMarker(t.getLocation());</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过将上述代码修改为<strong>开放调用 (调用某个方法时不需要使用锁)</strong>，从而消除发生死锁的风险:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</div><div class="line">    ...</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> location;</div><div class="line">        &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> reachedDestination;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.location = location;</div><div class="line">            reachedDestination = location.equals(destination);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (reachedDestination)</div><div class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</div><div class="line">    ...</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</div><div class="line">            availableTaxis.add(taxi);</div><div class="line">        &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</div><div class="line">        Set&lt;Taxi&gt; copy;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            copy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);</div><div class="line">        &#125;</div><div class="line">        Image image = <span class="keyword">new</span> Image();</div><div class="line">        <span class="keyword">for</span> (Taxi t : copy)</div><div class="line">            image.drawMarker(t.getLocation());</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序中应该尽量使用开放调用。与那些在持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。通过使用<strong>定时锁</strong>能够有效地应对死锁问题，通过 <strong>Thread Dump</strong> 能够帮助你识别死锁的发生。</p>
<h3 id="减少锁的竞争"><a href="#减少锁的竞争" class="headerlink" title="减少锁的竞争"></a>减少锁的竞争</h3><p>有三种方式可以降低锁的竞争程度:</p>
<ul>
<li>减少锁的持有时间</li>
<li>降低锁的请求频率</li>
<li>使用带有协调机制的独占锁，这些机制允许更高的并发性</li>
</ul>
<h3 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁 ReentrantLock"></a>重入锁 ReentrantLock</h3><p><code>ReentrantLock</code> 的 <code>tryLock</code> 方法为你提供了<strong>轮询锁与定时锁</strong>的锁获取模式，与无条件的锁获取模式相比，它具有更完善的错误恢复机制。方法 <code>lockInterruptibly</code> 方法能够在获得锁的同时<strong>保持对中断的响应</strong>。<code>ReentrantLock</code> 的构造函数中提供了两种<strong>公平性</strong>选择: 创建一个非公平的锁 (默认) 或者一个公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允许“插队”。在大多数情况下，非公平锁的性能要高于公平锁的性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</div><div class="line"></div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.release(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁 ReadWriteLock"></a>读写锁 ReadWriteLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</div><div class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="记录锁-Record-Locking"><a href="#记录锁-Record-Locking" class="headerlink" title="记录锁 Record Locking"></a>记录锁 Record Locking</h3><p><strong>Record Locking</strong> 更好的叫法应该被称为: <strong>byte-range locking</strong>，目的是为了防止两个进程同时修改一个文件的某块区域。函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="comment">// 出错返回 -1</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *flockptr */</span> )</span></span>;</div></pre></td></tr></table></figure>
<p>其中 <code>flock</code> 结构体定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></div><div class="line">    <span class="keyword">short</span> l_type; <span class="comment">/* F_RDLCK, F_WRLCK, or F_UNLCK */</span></div><div class="line">    <span class="keyword">short</span> l_whence; <span class="comment">/*SEEK_SET, SEEK_CUR, or SEEK_END */</span></div><div class="line">    <span class="keyword">off_t</span> l_start; <span class="comment">/*offset in bytes, relative to l_whence */</span></div><div class="line">    <span class="keyword">off_t</span> l_len; <span class="comment">/*length, in bytes; 0 means lock to EOF */</span></div><div class="line">    <span class="keyword">pid_t</span> l_pid; <span class="comment">/*returned with F_GETLK */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>F_RDLCK</code>: 共享读锁</li>
<li><code>F_WRLCK</code>: 排斥写锁</li>
<li><code>F_UNLCK</code>: 取消某个区域的锁</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁-SpinLock"><a href="#自旋锁-SpinLock" class="headerlink" title="自旋锁 SpinLock"></a>自旋锁 SpinLock</h4><p><strong>互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成</strong>，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，<strong>共享数据的锁定状态只会持续很短的一段时间</strong>，为了这段时间去挂起和恢复线程并不值得。为了能让线程稍微等一会，我们只需让线程执行一个忙循环 (自旋)，这项技术就是所谓的自旋锁。</p>
<p>现在我们假设<strong>硬件</strong>上有一种能够保证原子性的 <code>TestAndSet</code> 指令实现函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *x)</span></span>&#123;</div><div class="line">    <span class="keyword">register</span> <span class="keyword">int</span> temp = *x;</div><div class="line">    *x = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TestAndSet</code> 是一种常用的用于支持并发的原子操作指令。另外一种经常使用的指令是原子 <code>Exchange</code> 操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = *a;</div><div class="line">    *a = *b;</div><div class="line">    *b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些所有的原子性操作中最重要的是 <code>CompareAndSwap (CAS)</code> 操作，它经常被用于 <a href="http://en.wikipedia.org/wiki/Lock-free_and_wait-free_algorithms" target="_blank" rel="external">lock-free and wait-free algorithms</a> 算法中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">boolean <span class="title">CAS</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> old, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = *a;</div><div class="line">    <span class="keyword">if</span> (temp == old) &#123;</div><div class="line">        *a = <span class="keyword">new</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> </div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 <code>CAS</code> 来实现 <code>temp++</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> temp = x;</div><div class="line"><span class="keyword">while</span> (!CAS(&amp;x, temp, temp+<span class="number">1</span>)) &#123;</div><div class="line">    temp = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 <code>CAS</code> 来实现更链表头插法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    Node *q = *head;</div><div class="line">    p-&gt;next = q;</div><div class="line">    <span class="keyword">if</span> (CAS(head, q, p))</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般而言，<code>SpinLock</code> 是一种抽象的数据类型，其通常提供三种操作:</p>
<ul>
<li><code>InitLock</code></li>
<li><code>Lock</code></li>
<li><code>UnLock</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Lock(mutex);</div><div class="line">Si;</div><div class="line">UnLock(mutex);</div></pre></td></tr></table></figure>
<p>实现 <code>SpinLock</code> 的伪代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SpinLock;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLock</span><span class="params">(SpinLock *L)</span> </span>&#123;</div><div class="line">    *L = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lock</span><span class="params">(SpinLock *L)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (TestAndSet(L)) </div><div class="line">		;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnLock</span><span class="params">(SpinLock *L)</span> </span>&#123;</div><div class="line">    *L = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一种使用 <code>Exchange</code> 操作的可能实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SpinLock;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLock</span><span class="params">(SpinLock *s)</span> </span>&#123;</div><div class="line">    *s = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lock</span> <span class="params">(SpinLock *s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        Exchange(&amp;L, s);</div><div class="line">    &#125; <span class="keyword">while</span> (L == <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnLock</span> <span class="params">(SpinLock *s)</span> </span>&#123;</div><div class="line">    *s = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一种使用 <code>CompareAndSwap</code> 指令的实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SpinLock;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLock</span><span class="params">(SpinLock *s)</span> </span>&#123;</div><div class="line">    *s = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lock</span> <span class="params">(SpinLock *s)</span> </span>&#123;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">    &#125; until (CompareAndSwap(s, <span class="number">0</span>, <span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnLock</span> <span class="params">(SpinLock *s)</span> </span>&#123;</div><div class="line">    *s = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自旋锁最大的问题就是可能会占用比较高的 <strong>memory bus</strong> 带宽，另外它也不保证公平性，即无法保证先后进入临界区的两个进程 P 和 Q 按照 FIFO 顺序来服务。</p>
<h4 id="锁消除-Lock-Elimination"><a href="#锁消除-Lock-Elimination" class="headerlink" title="锁消除 Lock Elimination"></a>锁消除 Lock Elimination</h4><p>虚拟机 JIT 在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。主要判定依据来自于<strong>逃逸分析</strong>的数据支持。</p>
<h4 id="锁粗化-Lock-Coarsening"><a href="#锁粗化-Lock-Coarsening" class="headerlink" title="锁粗化 Lock Coarsening"></a>锁粗化 Lock Coarsening</h4><h4 id="轻量级锁-Lightweight-Locking"><a href="#轻量级锁-Lightweight-Locking" class="headerlink" title="轻量级锁 Lightweight Locking"></a>轻量级锁 Lightweight Locking</h4><h4 id="偏向锁-Biased-Locking"><a href="#偏向锁-Biased-Locking" class="headerlink" title="偏向锁 Biased Locking"></a>偏向锁 Biased Locking</h4><p>偏向锁的”偏”，是偏心的”偏”，它的意思就是<strong>这个锁会偏向于第一个获得它的线程</strong>，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p>
<p>JDK 1.6 默认开启 <code>-XX:+UseBiasedLocking</code>，使用 <code>-XX:-UseBiasedLocking</code> 来关闭。</p>
<p><strong>偏向锁转为轻量级锁</strong>的流程图:</p>
<p><img src="217664272.jpg" alt=""></p>
<h4 id="锁升级-Lock-Escalation"><a href="#锁升级-Lock-Escalation" class="headerlink" title="锁升级 Lock Escalation"></a>锁升级 Lock Escalation</h4><p>所谓的锁升级（lock escalation），是数据库的一种作用机制，该机制普遍见于各大数据库产品。 为了节约内存的开销，其会<strong>将为数众多并占用大量资源的细粒度的锁转化为数量较少的且占用相对较少资源的粗粒度的锁</strong>，多数情况下主要指<strong>将为数众多的行锁升级为一个表锁</strong>。当然，DB2 支持很多粒度的锁，如<strong>表空间（table space），表（table），行（row）以及索引（index）</strong>等。MySQL 的 InnoDB 存储引擎支持事务，<strong>默认是行锁</strong>。得益于这些特性，数据库支持高并发。</p>
<p>锁升级与两种事情有关:</p>
<ul>
<li>事务的隔离级别</li>
<li>索引</li>
</ul>
<p>常用的索引有三类：<strong>主键、唯一索引、普通索引</strong>。主键 不由分说，自带最高效的索引属性；唯一索引 指的是该属性值重复率为0，一般可作为业务主键，例如学号；普通索引 与前者不同的是，属性值的重复率大于0，不能作为唯一指定条件，例如学生姓名。<strong>当“值重复率”低时，甚至接近主键或者唯一索引的效果，“普通索引”依然是行锁；当“值重复率”高时，MySQL 不会把这个“普通索引”当做索引，即造成了一个没有索引的 SQL，此时引发表锁</strong>。索引不是越多越好，索引存在一个和这个表相关的文件里，占用硬盘空间，宁缺勿滥，每个表都有主键（id），操作能使用主键尽量使用主键。同 JVM 自动优化 java 代码一样，MySQL 也具有自动优化 SQL 的功能。<strong>低效的索引将被忽略</strong>，这也就倒逼开发者使用正确且高效的索引。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://item.jd.com/10922250.html" target="_blank" rel="external">《Java 并发编程实战》</a></li>
<li><a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="external">Deadlock</a></li>
<li><a href="https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/" target="_blank" rel="external">《Advanced Programming in the UNIX》</a></li>
<li><a href="https://item.jd.com/11252778.html" target="_blank" rel="external">《深入理解 Java 虚拟机》</a></li>
<li><a href="https://cis.temple.edu/~giorgio/cis307/readings/spinsem.html" target="_blank" rel="external">CIS 4307: Spinlocks and Semaphores</a></li>
<li><a href="https://cs.au.dk/~mis/dOvs/jvmspec/ref--44.html" target="_blank" rel="external">enter synchronized region of code</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1312db2lockescalation/" target="_blank" rel="external">关于 DB2 锁升级 (lock escalation) 相关问题的探讨</a></li>
<li><a href="http://zhoupq.com/MySQL-%E9%81%BF%E5%85%8D%E8%A1%8C%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%A1%A8%E9%94%81%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E9%AB%98%E6%95%88%E7%9A%84%E7%B4%A2%E5%BC%95/" target="_blank" rel="external">MySQL 避免行锁升级为表锁——使用高效的索引</a></li>
<li><a href="http://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">Innodb中的事务隔离级别和锁的关系</a></li>
<li><a href="http://www.imooc.com/article/17291?block_id=tuijian_wz" target="_blank" rel="external">MySQL数据库事务各隔离级别加锁情况–read uncommitted篇</a></li>
<li><a href="http://www.artima.com/insidejvm/ed2/threadsynchP.html" target="_blank" rel="external">Thread Synchronization</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/03/java-lock/" data-id="cjcdlsfy6004rdiempa5kwix2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-jvm-optimization" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/02/jvm-optimization/" class="article-date">
  <time datetime="2017-05-02T03:52:13.000Z" itemprop="datePublished">2017-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/02/jvm-optimization/">JVM性能调优</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="JVM-性能调优"><a href="#JVM-性能调优" class="headerlink" title="JVM 性能调优"></a>JVM 性能调优</h2><h3 id="Java-虚拟机内存模型"><a href="#Java-虚拟机内存模型" class="headerlink" title="Java 虚拟机内存模型"></a>Java 虚拟机内存模型</h3><p>JVM 虚拟机将内存数据分为如下这几部分：</p>
<p><img src="jvm_memory_overview.jpg" alt=""></p>
<h3 id="pc-register"><a href="#pc-register" class="headerlink" title="pc register"></a>pc register</h3><ul>
<li><strong>pc register (program counter)</strong>： 一个包含当前时刻指令的地址的<strong>寄存器</strong></li>
</ul>
<p>程序寄存器区域是<strong>唯一一个</strong>在 Java 虚拟机规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>栈会抛出两种异常：<code>StackOverflowError</code> 和 <code>OutOfMemoryError</code>，在 HotSpot 虚拟机栈中，可以使用参数 <code>-Xss1M</code> 来设置栈的大小为 <strong>1MB</strong>。随着<strong>调用函数参数的增加和局部变量的增加</strong>，单次函数调用对栈空间的需求也会增加，因此栈的最大递归次数不是一成不变的。函数嵌套调用的次数由栈的大小决定：栈越大，函数嵌套调用次数越多；对一个函数而言，它的参数越多，内部局部变量越多，它的栈帧就越大，其嵌套调用次数就会越少。</p>
<p><img src="3558cf63-bac7-42b3-9f3b-bcdebffa40a6.png" alt=""></p>
<ul>
<li><code>Xss1M</code>: 设置栈的大小</li>
</ul>
<h3 id="native-method-stack"><a href="#native-method-stack" class="headerlink" title="native method stack"></a>native method stack</h3><p>与 <strong>stack</strong> 一样，同样抛出两种异常：<code>StackOverflowError</code> 和 <code>OutOfMemoryError</code>。在 sun 的 HOT SPOT 虚拟机中，不区分本地方法栈和虚拟机栈</p>
<h3 id="HEAP"><a href="#HEAP" class="headerlink" title="HEAP"></a>HEAP</h3><p><img src="Java-Memory-Model.png" alt=""></p>
<ul>
<li><code>-Xmx</code>: 设置<font color="red"><strong>堆的最大值</strong></font></li>
<li><code>-Xms</code>: 设置堆的最小值，即 JVM 启动时，所占据的操作系统内存大小。JVM 会试图将系统内存尽可能地限制在 <code>-Xms</code> 中，因此当内存使用量触及 <code>-Xms</code> 指定的大小时，会触发 <strong>Full GC</strong>。因此<strong>把 <code>-Xms</code> 值设置为 <code>-Xmx</code> 时</strong>，可以在系统运行初期减少 <strong>GC</strong> 的次数和耗时。</li>
<li><code>Xmn</code>: 设置新生代大小。等于把 <code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code> 设置成了相同的大小。这两个如果设置成不同的值，会导致内存震荡，产生不必要的开销。<ul>
<li><code>-XX:NewSize</code>: 设置新生代的初始大小</li>
<li><code>-XX:MaxNewSize</code>: 设置新生代的最大值</li>
</ul>
</li>
</ul>
<p>错误的把 <code>Xmx</code> 参数设置为了 <code>Xmn</code> 参数以后:</p>
<p><img src="TIM图片20170814035500.png" alt=""></p>
<p>获取当前内存/最大可用内存/最大可用堆:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span></div><div class="line">Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span></div><div class="line">Runtime.getRuntime().maxMemory() / <span class="number">1000</span> / <span class="number">1000</span></div></pre></td></tr></table></figure>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>Java 7 开始支持<strong>对象的栈分配和逃逸分析机制</strong>，这样的机制能够将<strong>堆分配对象变成栈分配对象</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">    V v = <span class="keyword">new</span> V();</div><div class="line">    <span class="comment">// use v</span></div><div class="line">    v = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong><code>-server</code></strong>: <code>server</code> 模式下，才可以启用逃逸分析</li>
<li><strong><code>-XX:DoEscapeAnalysis</code></strong>: 启用逃逸分析</li>
</ul>
<h3 id="method-area"><a href="#method-area" class="headerlink" title="method area"></a>method area</h3><p>方法区主要保存的是<strong>类的元数据</strong>：类型、常量池、字段、方法。在 Hot Spot 虚拟机中，<strong>方法区也称为永久区</strong>，同样也可以被 GC 回收。<strong>持久代的大小直接决定了系统可以支持多少个类定义和多少常量</strong>。对于使用 CGLIB 或者 Javassist 等动态字节码生成工具的应用程序而言，设置合理的持久代有利于维持系统稳定。</p>
<p><strong>方法区的大小直接决定了系统可以保存多少个类</strong>，如果系统使用了一些动态代理，那么有可能会在运行时生成大量的类，如果这样，就需要设置一个合理的永久区大小，确保不发生永久区内存溢出。</p>
<ul>
<li><code>-XX:MaxPermSize=4M</code>: 设置持久代的最大值</li>
<li><code>-XX:PermSize=4M</code>: 设置持久代的初始大小</li>
</ul>
<p>在 JDK 1.8 中，永久区已经被彻底移除，取而代之的是<strong>元数据区 (Metaspace)，元数据区是一块堆外的直接内存</strong>，如果不指定元数据区大小的话，默认情况下，虚拟机会耗尽所有的可用系统内存。</p>
<ul>
<li><code>-XX:MaxMetaspaceSize</code>: 指定元数据区大小</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>使用 <strong>NIO</strong> 之后，直接内存的使用变得非常普遍，直接内存跳过了 Java 堆，可以直接访问原生堆空间。<strong>直接内存适合申请次数少、访问较为频繁的场合。如果需要频繁申请，则并不适合使用直接内存</strong>。</p>
<ul>
<li><code>-XX:MaxDirectMemorySize</code>: 最大可用直接内存，默认为 <code>-Xmx</code></li>
</ul>
<h3 id="区域比例"><a href="#区域比例" class="headerlink" title="区域比例"></a>区域比例</h3><p><img src="gc_s.png" alt=""></p>
<ul>
<li><code>-XX:SurvivorRatio=8</code>: 设置新生代中 <strong>eden 空间</strong> 和 <strong>S0 空间</strong> 的比例关系</li>
<li><code>-XX:NewRatio=2</code>: 设置老生代和新生代的比例</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li><strong>引用计数法</strong>: 无法解决循环引用问题</li>
<li>标记-清除算法 (Mark-Sweep): <ol>
<li>标记从根节点开始的可达对象</li>
<li>清除所有未被标记的对象</li>
<li><strong>最大缺点: 回收后的空间是不连续的</strong></li>
</ol>
</li>
<li>复制算法 (<strong>新生代</strong>):<ol>
<li>内存空间分为两块，每次只用一块</li>
<li><strong>存活对象复制到未使用的内存块中</strong></li>
<li>清除正在使用的内存块中的所有对象</li>
<li>交换两个内存的角色</li>
<li><strong>适合于新生代: 垃圾对象通常多于存活对象</strong></li>
</ol>
</li>
<li>标记-压缩算法:<ol>
<li>标记从根节点开始的可达对象</li>
<li>将所有存活对象 (未标记的对象) 压缩到内存的一端</li>
<li>清理边界外 (标记和未标记对象的边界) 的对象</li>
</ol>
</li>
</ul>
<p><img src="gc-algorithms-37-638.jpg" alt=""></p>
<ul>
<li>分代 (Generational Collecting):<ol>
<li>根据每块内存空间特点的不同，使用不同的回收算法。如新生代 (存活对象少，垃圾对象多) 使用复制算法，老年代 (大部分对象是存活对象) 使用标记-压缩算法</li>
</ol>
</li>
</ul>
<p>为了支持高频率的新生代回收，虚拟机可能使用一种叫做<strong>卡表 (Card Table)</strong> 的数据结构。卡表为一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。这样在新生代 GC 时，只需先扫描卡表，就能快速知道用不用扫描特定的老年代对象，而卡表为 0 的所在区域一定不含有新生代对象的引用。</p>
<h3 id="谁才是真正的垃圾"><a href="#谁才是真正的垃圾" class="headerlink" title="谁才是真正的垃圾"></a>谁才是真正的垃圾</h3><ul>
<li><strong>可触及性</strong>: 根节点可到达</li>
<li><strong>可复活</strong>: <code>finalize()</code> 中复活</li>
<li><strong>不可触及</strong>: <code>finalize()</code> 中未复活</li>
</ul>
<p><code>finalize()</code> 方法只会被调用一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">super</span>.finalize();</div><div class="line">    obj = <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure>
<p>假设以上代码是在函数体内运行的，那么:</p>
<p><img src="17-06-13-17_10_03_775_199.png" alt=""></p>
<hr>
<p><strong>软引用</strong>: <code>java.lang.ref.SoftReference</code> 可被回收的引用</p>
<hr>
<p><strong>弱引用</strong>: 发现即回收。由于垃圾回收器的线程通常优先级很大，因此并不一定很快地发现持有弱引用的对象。</p>
<hr>
<p><strong>虚引用</strong>: 跟踪垃圾回收过程</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="串行回收器"><a href="#串行回收器" class="headerlink" title="串行回收器"></a>串行回收器</h4><ul>
<li>新生代垃圾串行收集器，使用 <code>-XX:+UseSerialGC</code> 来指定新生代和老年代都是用串行收集器。这个收集器虽然古老，但却久经考验。使用单线程进行垃圾回收。虚拟机在 <code>Client</code> 模式下运行，它是默认的垃圾收集器。<strong>独占式回收</strong>。</li>
</ul>
<p><img src="17-06-13-17_38_50_1259_97.png" alt=""></p>
<ul>
<li>老年代串行收集器，使用的是<strong>标记-压缩</strong>算法。<ul>
<li><code>-XX:+UseSerialGC</code>: 新生代、老生代都使用串行回收器</li>
<li><code>-XX:+UseParNewGC</code></li>
<li><code>-XX:+UseParallelGC</code></li>
</ul>
</li>
</ul>
<p><img src="17-06-13-17_39_16_1257_130.png" alt=""></p>
<hr>
<h4 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h4><p><strong>新生代 ParNew 回收器</strong>:</p>
<ul>
<li><code>-XX:+UseParNewGC</code></li>
<li><code>-XX:+UseConcMarkSweepGC</code></li>
</ul>
<p>回收器工作时的线程数量可以使用 <code>-XX:ParallelGCThreads</code> 参数指。一般最好与 CPU 数量相当，避免过多的线程数。默认算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGCThreadsCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( countOfCPU &lt; <span class="number">8</span> )</div><div class="line">        <span class="keyword">return</span> countOfCPU;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">3</span> + ( ( <span class="number">5</span> * countOfCPU ) / <span class="number">8</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="17-06-13-17_45_54_1260_94.png" alt=""></p>
<hr>
<p><strong>新生代 ParallelGC 回收器</strong>: 关注系统吞吐量</p>
<ul>
<li><code>-XX:+UseParallelGC</code></li>
<li><code>-XX:+UseParallelOldGC</code></li>
</ul>
<p>两个重要参数控制系统吞吐量:</p>
<ul>
<li><strong><code>-XX:MaxGCPauseMillis</code></strong>: 设置最大垃圾收集停顿时间</li>
<li><strong><code>-XX:GCTimeRatio</code></strong>: 设置吞吐量大小</li>
<li><strong><code>-XX:+UseAdaptiveSizePolicy</code></strong>: 打开自适应 GC 策略</li>
</ul>
<p><img src="17-06-13-17_49_11_1247_81.png" alt=""></p>
<hr>
<p><strong>老年代 ParallelOldGC</strong>: 标记压缩算法</p>
<p><img src="17-06-13-17_50_34_1253_127.png" alt=""></p>
<hr>
<ul>
<li>并行收集器，将串行回收器多线程化。并行回收器工作时的线程数量可以使用 <code>-XX:ParallelGCThreads</code> 参数指定，一般最好与 CPU 数量相当，避免过多的线程数，影响垃圾收集性能。<ul>
<li><code>-XX:+UseParNewGC</code>: 新生代使用并行回收收集器 (<code>ParNew</code>)，老年代使用串行收集器</li>
<li><code>-XX:+UseConcMarkSweepGC</code>: 新生代使用并行收集器 (<code>ParNew</code>)，老年代使用 CMS</li>
</ul>
</li>
<li>新生代并行回收收集器，使用复制算法<ul>
<li><code>-XX:+UseParallelGC</code>: 新生代使用并行回收收集器 (<code>ParallelGC</code>)，老年代使用串行收集器</li>
</ul>
</li>
<li>老年代并行回收收集器，使用<strong>标记-压缩</strong>算法<ul>
<li>使用 <code>-XX:+UseParallelOldGC</code>: 新生代使用 <code>ParallelGC</code> ，老年代使用 <code>ParallelOldGC</code></li>
</ul>
</li>
</ul>
<hr>
<p><strong>CMS (Concurrent Mark Sweep)</strong>: 关注系统停顿时间，非独占式</p>
<ul>
<li><strong>-XX:+UseConcMarkSweepGC</strong></li>
<li><strong>-XX:CMSInitiatingOccupancyFraction</strong>: 当老年代的空间使用率达到 68% (默认) 时进行一次 CMS 垃圾回收</li>
<li><strong>-XX:+UseCMSCompactAtFullCollection</strong>: 在垃圾收集完成之后，进行一次内存碎片整理</li>
<li>CMS 收集器，这是一个关注停顿的垃圾收集器</li>
</ul>
<p><img src="17-06-13-18_03_12_1240_884.png" alt=""></p>
<hr>
<ul>
<li>G1 收集器: JDK 1.7 正式启用</li>
</ul>
<p>新生代串行收集器和老年代串行收集器都是<strong>串行的、独占式的</strong>垃圾收集器。不要求整个 eden 区、年轻代或者老年代都连续</p>
<hr>
<p>使用 <code>-XX:+UseSerialGC</code> 打印出的 GC 信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[GC (Allocation Failure) </div><div class="line">[DefNew: 18954K-&gt;897K(28864K), 0.0020543 secs]</div><div class="line">18954K-&gt;897K(93056K), 0.0020917 secs]</div><div class="line">[Times: user=0.00 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure>
<p>使用 <code>-XX:+UseParNewGC</code> 打印出的 GC 信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[GC (Allocation Failure) </div><div class="line">[ParNew: 19468K-&gt;880K(28864K), 0.0033698 secs]</div><div class="line">19468K-&gt;880K(93056K), 0.0034037 secs]</div><div class="line">[Times: user=0.00 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure>
<p>使用 <code>-XX:+UseParallelOldGC</code> (默认) 打印出的 GC 信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[GC (Allocation Failure) </div><div class="line">[PSYoungGen: 24485K-&gt;448K(28160K)]</div><div class="line">368549K-&gt;344520K(379904K), 0.0039329 secs]</div><div class="line">[Times: user=0.02 sys=0.00, real=0.01 secs]</div></pre></td></tr></table></figure>
<h4 id="G1-Garbage-First-垃圾收集器"><a href="#G1-Garbage-First-垃圾收集器" class="headerlink" title="G1 (Garbage-First) 垃圾收集器"></a>G1 (Garbage-First) 垃圾收集器</h4><p>以前的垃圾收集器 (serial, parallel, CMS) 将堆分为固定大小的三个区域: 年轻代、老年代和永久代:</p>
<p><img src="HeapStructure.png" alt=""></p>
<p>但是，G1 采取了一种不同的方法:</p>
<p><img src="g1_heap_allocation.PNG" alt=""></p>
<p>堆被分成了一系列相同大小的区域，并且相同角色的区域的大小不再是固定的，这样在内存使用上能够提供<strong>更大的灵活性</strong>。当垃圾收集开始的时候，G1 和 CMS 执行的操作其实是一样的:</p>
<ol>
<li>并发全局扫描标记检查存活的对象</li>
<li>哪些区域垃圾对象最多，G1 就先收集哪些区域，这也是它为什么称为 <strong>Garbage-First</strong> 的原因</li>
</ol>
<hr>
<p>其他垃圾收集器使用 jvm 内置线程回收，而 G1 采用应用线程承担回收工作。</p>
<h4 id="G1-垃圾收集器-VS-CMS-垃圾收集器"><a href="#G1-垃圾收集器-VS-CMS-垃圾收集器" class="headerlink" title="G1 垃圾收集器 VS CMS 垃圾收集器"></a>G1 垃圾收集器 VS CMS 垃圾收集器</h4><p>G1 就是计划取代 Concurrent Mark-Sweep Collector (CMS). 与 CMS 相比，G1:</p>
<ul>
<li>G1 是一个 <strong>compacting collector</strong>. G1 compacts sufficiently to completely avoid the use of fine-grained free lists for allocation, and instead relies on regions. This considerably simplifies parts of the collector, and mostly eliminates potential fragmentation issues. </li>
<li>G1 提供了更多的可预测的垃圾收集停顿，允许用户指定停顿时间</li>
</ul>
<h3 id="实用-JVM-参数"><a href="#实用-JVM-参数" class="headerlink" title="实用 JVM 参数"></a>实用 JVM 参数</h3><ul>
<li>获取堆快照。</li>
</ul>
<p>发生 <code>OutOfMemoryError</code> 时，可以使用 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=C:\m.hprof</code> 来保存当前的堆快照到文件中。也可以加上参数 <code>-XX:OnOutOfMemoryError=c:\reset.bat</code> 来运行一段脚本。</p>
<p>当发生 <code>OutOfMemoryError</code> (在一个 <code>Windows 32</code> 系统上就发生过) 的时候，<strong>应该尝试使用增大可用堆</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Xmn1024M -jar xxx.jar</div></pre></td></tr></table></figure>
<p><strong>TODO: 思考: 如果知晓程序究竟需要多大内存？</strong></p>
<ul>
<li>获取 GC 信息</li>
</ul>
<p>使用参数 <code>-verbose:gc</code> 或者 <code>-XX:+PrintGC</code> 来获取简要的 GC 信息，也可以使用 <code>-XX:+PrintGCDetails</code> 来获取更加详细的信息。如果需要在 GC 发生的时刻打印 GC 发生的时间，则可以追加 <code>-XX:+PrintGCTimeStamps</code> 选项以查看<strong>相对时间</strong>或者 <code>-XX:+PrintGCDateStamps</code> 以查看<strong>绝对时间</strong>。如果许雅查看新生对象晋升到老年代的实际阈值，可以使用参数 <code>-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=18</code> 来运行程序。如果需要在 GC 时，打印详细的堆信息，则可以打开 <code>-XX:+PrintHeapAtGC</code> 开关。</p>
<ul>
<li>控制 GC</li>
</ul>
<p><code>-XX:+PrintExplicitGC</code> 选项用于禁止显式的 GC 操作，即禁止在程序中使用 <code>System.gc()</code> 触发的 <code>Full GC</code>。另一个有用的 GC 控制参数是 <code>-Xincgc</code>，一旦启用这个参数，系统便会进行增量式的 GC。</p>
<p><strong>JVM 调优的主要过程有</strong>: 确定堆内存大小 (<code>-Xmx、-Xms</code>)、合理分配新生代和老年代 (<code>-XX:NewRatio、-Xmn、-XX:SurvivorRatio</code>)、确定永久区大小 (<code>-XX:Permsize、-XX:MaxPermSize</code>)、选择垃圾收集器、对垃圾收集器进行合理的设置。除此之外，禁用显式 GC (<code>-XX:+DisableExplicitGC</code>)、禁用类元数据回收 (<code>+Xnoclassgc</code>)、禁用类验证 (<code>-Xverify:none</code>) 等设置，对提升系统性能也有一定的帮助。</p>
<ul>
<li>GC 日志示例</li>
</ul>
<p>使用 <code>-XX:+PrintGC</code> 获取的 GC 日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[GC (Allocation Failure)  GC前堆使用量20M-&gt;GC后堆使用量(当前可用堆大小90M), 本次GC花费 0.0028389 秒]</div><div class="line">[GC (Allocation Failure)  20409K-&gt;432K(92672K), 0.0028389 secs]</div></pre></td></tr></table></figure>
<p>同样的代码使用 <code>-X:+PrintGCDetails</code> 获取的 GC 日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[GC (Allocation Failure) [新生代: 从20M-&gt;降为0.4M(可用28M)] 整个堆从20M-&gt;将为0.4M(可用90M), 0.0151333 secs] [Times: 用户态时间耗时，系统态时间耗时，GC 实际经历的时间]</div><div class="line">    新生代 总大小 28M, 已用 13M [下界，当前上界，上界]</div><div class="line">[GC (Allocation Failure) [PSYoungGen: 20409K-&gt;448K(28160K)] 20409K-&gt;456K(92672K), 0.0151333 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] </div><div class="line">Heap</div><div class="line"> PSYoungGen      total 28160K, used 13461K [0x00000000e1380000, 0x00000000e4a80000, 0x0000000100000000)</div><div class="line">  eden space 24576K, 52% used [0x00000000e1380000,0x00000000e20356d0,0x00000000e2b80000)</div><div class="line">  from space 3584K, 12% used [0x00000000e2b80000,0x00000000e2bf0020,0x00000000e2f00000)</div><div class="line">  to   space 3584K, 0% used [0x00000000e4700000,0x00000000e4700000,0x00000000e4a80000)</div><div class="line"> ParOldGen       total 64512K, used 8K [0x00000000a3a00000, 0x00000000a7900000, 0x00000000e1380000)</div><div class="line">  object space 64512K, 0% used [0x00000000a3a00000,0x00000000a3a02000,0x00000000a7900000)</div><div class="line"> Metaspace       used 3264K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 363K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure>
<p>如果需要更为全面的堆信息，还可以使用参数 <code>-XX:+PrintHeapAtGC</code>，它会在每次 GC 前后分别打印堆的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;Heap before GC invocations=1 (full 0):</div><div class="line">    ...</div><div class="line">Heap after GC invocations=1 (full 0):</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果需要分析 GC 发生的时间，还可以使用 <code>-XX:+PrintGCTimeStamps</code> 参数，该输出时间为虚拟机启动后的时间偏移量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0.174: [GC (Allocation Failure)  20409K-&gt;504K(92672K), 0.0016586 secs]</div><div class="line">0.179: [GC (Allocation Failure)  19415K-&gt;464K(92672K), 0.0031200 secs]</div><div class="line">0.186: [GC (Allocation Failure)  19812K-&gt;432K(92672K), 0.0009531 secs]</div></pre></td></tr></table></figure>
<p>由于 GC 还会引起应用程序停顿，使用参数 <code>-XX:+PrintGCApplicationConcurrentTime</code> 可以打印应用程序的执行时间，使用参数 <code>-XX:+PrintGCApplicationStoppedTime</code> 可以打印应用程序由于 GC 而产生的停顿时间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Application time: 0.0084849 seconds</div><div class="line">[GC (Allocation Failure)  20409K-&gt;520K(92672K), 0.0044274 secs]</div><div class="line">Total time for which application threads were stopped: 0.0045452 seconds, Stopping threads took: 0.0000210 seconds</div><div class="line">Application time: 0.0033066 seconds</div><div class="line">[GC (Allocation Failure)  19431K-&gt;440K(117248K), 0.0020202 secs]</div><div class="line">Total time for which application threads were stopped: 0.0021438 seconds, Stopping threads took: 0.0000258 seconds</div><div class="line">Application time: 0.0082455 seconds</div></pre></td></tr></table></figure>
<p>如果想跟踪系统内的软引用、弱引用、虚引用和 <code>Finalize</code> 队列，则可以使用打开 <code>-XX:+PrintReferenceGC</code> 开关. 使用参数 <code>-Xloggc:log/gc.log</code> 启动虚拟机，将 GC 日志输出到 <code>gc.log</code> 文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Java HotSpot(TM) 64-Bit Server VM (25.111-b14) for linux-amd64 JRE (1.8.0_111-b14), built on Sep 22 2016 16:14:03 by &quot;java_re&quot; with gcc 4.3.0 20080428 (Red Hat 4.3.0-8)</div><div class="line">Memory: 4k page, physical 6052560k(316636k free), swap 6233084k(4248464k free)</div><div class="line">CommandLine flags: -XX:InitialHeapSize=96840960 -XX:MaxHeapSize=1549455360 -XX:+PrintGC -XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </div><div class="line">0.183: Application time: 0.0107645 seconds</div><div class="line">0.183: [GC (Allocation Failure)  20409K-&gt;432K(92672K), 0.0033748 secs]</div><div class="line">0.187: Total time for which application threads were stopped: 0.0035825 seconds, Stopping threads took: 0.0000191 seconds</div><div class="line">0.192: Application time: 0.0054269 seconds</div><div class="line">0.193: [GC (Allocation Failure)  19343K-&gt;496K(117248K), 0.0108382 secs]</div><div class="line">0.204: Total time for which application threads were stopped: 0.0116746 seconds, Stopping threads took: 0.0000766 seconds</div><div class="line">0.212: Application time: 0.0084699 seconds</div></pre></td></tr></table></figure>
<p><img src="17-06-13-17_16_55_1236_518.png" alt=""></p>
<p><font color="red"><strong>系统参数查看</strong></font>:</p>
<ul>
<li><strong>-XX:+PrintVMOptions</strong>: 打印虚拟机接受的命令行<strong>显示</strong>参数</li>
<li><strong>-XX:+PrintCommandLineFlags</strong>: 打印虚拟机的<strong>显示和隐式</strong>参数</li>
<li><strong>-XX:+PrintFlagsFinal</strong>: 打印所有的系统参数的值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 打印出系统的堆大小</span></div><div class="line">java -XX:+PrintFlagsFinal -version | grep -iE <span class="string">'HeapSize|PermSize|ThreadStackSize'</span></div></pre></td></tr></table></figure>
<h3 id="Minor-GC、Major-GC-和-Full-GC"><a href="#Minor-GC、Major-GC-和-Full-GC" class="headerlink" title="Minor GC、Major GC 和 Full GC"></a>Minor GC、Major GC 和 Full GC</h3><p><img src="minor-gc-major-gc-full-gc.jpg" alt=""></p>
<ul>
<li><strong>Minor GC</strong>: 从年轻代回收垃圾，当 <strong>JVM</strong> 无法分配新对象的时候会触发 <strong>Minor GC</strong>，也就是说 <strong>Eden</strong> 区域已经满了</li>
<li><strong>Major GC</strong>: 清除 <strong>Tenured</strong> 区域</li>
<li><strong>Full GC</strong>: 清除整个堆，包括 <strong>Yound 和 Tenured</strong> 区域</li>
</ul>
<h3 id="Java-各版本默认垃圾收集器"><a href="#Java-各版本默认垃圾收集器" class="headerlink" title="Java 各版本默认垃圾收集器"></a>Java 各版本默认垃圾收集器</h3><p>参考 <a href="http://download.oracle.com/javase/6/docs/technotes/guides/vm/gc-ergonomics.html" target="_blank" rel="external">1</a> 说:</p>
<p>On <strong>server-class machines</strong> running the server VM, the garbage collector (GC) has changed from the previous serial collector […] to a parallel collector</p>
<p>Reference <a href="http://download.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html" target="_blank" rel="external">2</a> says:</p>
<p>Starting with J2SE 5.0, when an application starts up, the launcher can attempt to detect whether the application is running on a “server-class” machine and, if so, use the Java HotSpot Server Virtual Machine (server VM) instead of the Java HotSpot Client Virtual Machine (client VM).</p>
<p>Also, reference <a href="http://download.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html" target="_blank" rel="external">2</a> says:</p>
<p>注意: 对于 Java SE 6, the definition of <strong>a server-class machine is one with at least 2 CPUs and at least 2GB of physical memory</strong>.</p>
<p>Java 7 和 Java 8 使用的都是 Parallel GC，Java 9 使用的是 G1 垃圾收集器</p>
<h3 id="JVM-的工作模式"><a href="#JVM-的工作模式" class="headerlink" title="JVM 的工作模式"></a>JVM 的工作模式</h3><ul>
<li><strong><code>java -version</code></strong>: 查看 <code>Server VM</code></li>
<li><strong><code>java -client -version</code></strong>: 查看 <code>Client VM</code></li>
</ul>
<p><code>Client</code> 和 <code>Server</code> 模式下的各种参数可能会有很大不同</p>
<h3 id="Heap-Memory-最佳实践"><a href="#Heap-Memory-最佳实践" class="headerlink" title="Heap Memory 最佳实践"></a>Heap Memory 最佳实践</h3><ul>
<li>是否分配了过多实例: 使用 <code>jcmd 8998 GC.class_histogram</code> 来查看各实例有多少个，也可以使用 <code>jmap -histo 8998</code> 来获得相同的结果</li>
<li>分析堆快照: 使用 <strong>jhat、jvisualvm、mat</strong> 等工具来分析 <strong>hprof</strong> 文件<ul>
<li><code>jcmd 8998 GC.heap_dump /path/to/heap_dump.hprof</code></li>
<li><code>jmap -dump:live,file=/path/to/heap_dump.hprof 8998</code>: 引入 <code>live</code> 强制 <strong>full GC</strong></li>
</ul>
</li>
</ul>
<h3 id="Java-Monitoring-常用工具"><a href="#Java-Monitoring-常用工具" class="headerlink" title="Java Monitoring 常用工具"></a>Java Monitoring 常用工具</h3><h4 id="jstack-Dumps-the-stacks-of-a-Java-进程"><a href="#jstack-Dumps-the-stacks-of-a-Java-进程" class="headerlink" title="jstack: Dumps the stacks of a Java 进程"></a>jstack: Dumps the stacks of a Java 进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jstack-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div></pre></td></tr></table></figure>
<h4 id="jinfo-Provides-visibility-into-the-system-properties-of-the-JVM-and-allows-some-system-properties-to-be-set-dynamically"><a href="#jinfo-Provides-visibility-into-the-system-properties-of-the-JVM-and-allows-some-system-properties-to-be-set-dynamically" class="headerlink" title="jinfo: Provides visibility into the system properties of the JVM, and allows some system properties to be set dynamically."></a>jinfo: Provides visibility into the system properties of the JVM, and allows some system properties to be set dynamically.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">root@zk-pc:~<span class="comment"># jinfo 18772</span></div><div class="line">Attaching to process ID 18772, please <span class="built_in">wait</span>...</div><div class="line">Debugger attached successfully.</div><div class="line">Server compiler detected.</div><div class="line">JVM version is 25.144-b01</div><div class="line">Java System Properties:</div><div class="line"></div><div class="line">com.sun.management.jmxremote.authenticate = <span class="literal">false</span></div><div class="line">java.runtime.name = Java(TM) SE Runtime Environment</div><div class="line">java.vm.version = 25.144-b01</div><div class="line">...(省略好多)</div><div class="line"></div><div class="line">VM Flags:</div><div class="line">Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=98566144 -XX:+ManagementServer -XX:MaxHeapSize=1549795328 -XX:MaxNewSize=516423680 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=32505856 -XX:OldSize=66060288 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC </div><div class="line">Command line:  -Dcom.sun.management.jmxremote.port=5780 -Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> -Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> -javaagent:/usr/lib/intellij_idea/idea-IC-172.3968.16/lib/idea_rt.jar=35487:/usr/lib/intellij_idea/idea-IC-172.3968.16/bin -Dfile.encoding=UTF-8</div></pre></td></tr></table></figure>
<h4 id="jstat-提供有关-GC-和类加载活动的相关信息"><a href="#jstat-提供有关-GC-和类加载活动的相关信息" class="headerlink" title="jstat: 提供有关 GC 和类加载活动的相关信息"></a>jstat: 提供有关 GC 和类加载活动的相关信息</h4><p>显示可用的九个 options:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat -options</div></pre></td></tr></table></figure>
<p>One useful option is <code>-gcutil</code>, which displays the <strong>time spent in GC</strong> as well as the <strong>percentage of each GC area that is currently filled</strong>. Other options to <code>jstat</code> will display the <strong>GC sizes in terms of KB</strong>.</p>
<p>Remember that <code>jstat</code> takes an optional argument—<strong>the number of milliseconds to repeat the command</strong>—so it can monitor over time the effect of GC in an application. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat -gcutil process_id 1000</div></pre></td></tr></table></figure>
<p>打印出的是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@zk-pc:~<span class="comment"># jstat -gcutil 18772</span></div><div class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </div><div class="line">  0.00  71.53  97.93  34.02  96.70  93.37     29    0.133     1    0.040    0.172</div></pre></td></tr></table></figure>
<hr>
<p><code>gccapacity</code> 可以显示 VM 内存中三代（young,old,perm）对象的使用和占用大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat -gccapacity process_id</div></pre></td></tr></table></figure>
<p>打印出的是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@zk-pc:~<span class="comment"># jstat -gccapacity 18772</span></div><div class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC </div><div class="line"> 31744.0 504320.0  30720.0 4608.0 4608.0  21504.0    64512.0  1009152.0    44032.0    44032.0      0.0 1069056.0  22272.0      0.0 1048576.0   2560.0     32     1</div></pre></td></tr></table></figure>
<h4 id="jmap-Memory-Map-Provides-heap-dumps-and-other-information-about-JVM-memory-usage"><a href="#jmap-Memory-Map-Provides-heap-dumps-and-other-information-about-JVM-memory-usage" class="headerlink" title="jmap (Memory Map): Provides heap dumps and other information about JVM memory usage."></a>jmap (Memory Map): Provides heap dumps and other information about JVM memory usage.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmap <span class="variable">$PID</span></div></pre></td></tr></table></figure>
<p>打印的是一堆这种东西:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">root@zk-pc:~<span class="comment"># jmap 18772</span></div><div class="line">Attaching to process ID 18772, please <span class="built_in">wait</span>...</div><div class="line">Debugger attached successfully.</div><div class="line">Server compiler detected.</div><div class="line">JVM version is 25.144-b01</div><div class="line">0x0000000000400000	7K	/usr/lib/jvm/oracle_jdk8/jdk1.8.0_144/bin/java</div><div class="line">0x00007f7072978000	98K	/lib/x86_64-linux-gnu/libresolv-2.23.so</div><div class="line">0x00007f7072b93000	26K	/lib/x86_64-linux-gnu/libnss_dns-2.23.so</div><div class="line">0x00007f7072d9a000	10K	/lib/x86_64-linux-gnu/libnss_mdns4_minimal.so.2</div><div class="line">0x00007f70737a1000	87K	/lib/x86_64-linux-gnu/libgcc_s.so.1</div><div class="line">0x00007f70739b7000	251K	/usr/lib/jvm/oracle_jdk8/jdk1.8.0_144/jre/lib/amd64/libsunec.so</div><div class="line">...(省略好多)</div></pre></td></tr></table></figure>
<hr>
<p><strong>Print histogram(直方图；柱状图) of java object heap</strong>; if the “live” suboption is specified, only count live objects:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jmap -histo <span class="variable">$PID</span></div><div class="line">jmap -histo:live <span class="variable">$PID</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">root@zk-pc:~<span class="comment"># jmap -F -histo 18772</span></div><div class="line">Object Histogram:</div><div class="line"></div><div class="line">num 	  <span class="comment">#instances	#bytes	Class description</span></div><div class="line">--------------------------------------------------------------------------</div><div class="line">1:		65711	10183976	char[]</div><div class="line">2:		13523	8919400	byte[]</div><div class="line">3:		54732	2159368	java.lang.Object[]</div><div class="line">4:		7341	1451792	int[]</div><div class="line">5:		56423	1354152	java.lang.String</div><div class="line">6:		15476	619040	java.util.TreeMap<span class="variable">$Entry</span></div><div class="line">7:		16562	529984	java.io.ObjectStreamClass<span class="variable">$WeakClassKey</span></div><div class="line">8:		11915	476600	java.util.LinkedHashMap<span class="variable">$Entry</span></div><div class="line">9:		9716	466368	java.util.HashMap</div><div class="line">10:		3993	453312	java.lang.Class</div><div class="line">11:		11568	370176	java.util.concurrent.ConcurrentHashMap<span class="variable">$Node</span></div><div class="line">12:		6160	306952	java.util.HashMap<span class="variable">$Node</span>[]</div><div class="line">13:		4210	279856	java.util.Hashtable<span class="variable">$Entry</span>[]</div><div class="line">14:		8320	266240	java.util.Vector</div><div class="line">15:		8070	258240	java.util.HashMap<span class="variable">$Node</span></div><div class="line">16:		10495	251880	org.jsoup.nodes.Attribute</div><div class="line">17:		4181	200688	java.util.Hashtable</div><div class="line">...(省略好多)</div></pre></td></tr></table></figure>
<hr>
<p><strong>Print java heap summary</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmap -heap <span class="variable">$PID</span></div></pre></td></tr></table></figure>
<p>打印出的是一堆这种东西:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">root@zk-pc:~<span class="comment"># jmap -heap 18772</span></div><div class="line">Attaching to process ID 18772, please <span class="built_in">wait</span>...</div><div class="line">Debugger attached successfully.</div><div class="line">Server compiler detected.</div><div class="line">JVM version is 25.144-b01</div><div class="line"></div><div class="line">using thread-local object allocation.</div><div class="line">Parallel GC with 4 thread(s)</div><div class="line"></div><div class="line">Heap Configuration:</div><div class="line">   MinHeapFreeRatio         = 0</div><div class="line">   MaxHeapFreeRatio         = 100</div><div class="line">   MaxHeapSize              = 1549795328 (1478.0MB)</div><div class="line">   NewSize                  = 32505856 (31.0MB)</div><div class="line">   MaxNewSize               = 516423680 (492.5MB)</div><div class="line">   OldSize                  = 66060288 (63.0MB)</div><div class="line">   NewRatio                 = 2</div><div class="line">   SurvivorRatio            = 8</div><div class="line">   MetaspaceSize            = 21807104 (20.796875MB)</div><div class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</div><div class="line">   MaxMetaspaceSize         = 17592186044415 MB</div><div class="line">   G1HeapRegionSize         = 0 (0.0MB)</div><div class="line"></div><div class="line">Heap Usage:</div><div class="line">PS Young Generation</div><div class="line">Eden Space:</div><div class="line">   capacity = 23068672 (22.0MB)</div><div class="line">   used     = 11772712 (11.227333068847656MB)</div><div class="line">   free     = 11295960 (10.772666931152344MB)</div><div class="line">   51.03333213112571% used</div><div class="line">From Space:</div><div class="line">   capacity = 11010048 (10.5MB)</div><div class="line">   used     = 2035424 (1.941131591796875MB)</div><div class="line">   free     = 8974624 (8.558868408203125MB)</div><div class="line">   18.48696754092262% used</div><div class="line">To Space:</div><div class="line">   capacity = 11534336 (11.0MB)</div><div class="line">   used     = 0 (0.0MB)</div><div class="line">   free     = 11534336 (11.0MB)</div><div class="line">   0.0% used</div><div class="line">PS Old Generation</div><div class="line">   capacity = 45088768 (43.0MB)</div><div class="line">   used     = 13718432 (13.082916259765625MB)</div><div class="line">   free     = 31370336 (29.917083740234375MB)</div><div class="line">   30.42538665061773% used</div><div class="line"></div><div class="line">8999 interned Strings occupying 836656 bytes.</div></pre></td></tr></table></figure>
<h3 id="堆内存使用最佳实践"><a href="#堆内存使用最佳实践" class="headerlink" title="堆内存使用最佳实践"></a>堆内存使用最佳实践</h3><h4 id="堆分析"><a href="#堆分析" class="headerlink" title="堆分析"></a>堆分析</h4><p>(1) 查看直方图</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// jcmd 命令默认就会进行 full GC</div><div class="line">jcmd 6808 GC.class_histogram</div><div class="line">jmap -histo 6808</div><div class="line">// 如果指明 live: 选项，将会强制进行一个 full GC</div><div class="line">jmap -histo:live 6808</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> num     #instances         #bytes  class name</div><div class="line">----------------------------------------------</div><div class="line">   1:         12227        1303424  [C</div><div class="line">   2:          1003         627856  [B</div><div class="line">   3:          1917         461864  [I</div><div class="line">   4:          3828         421768  java.lang.Class</div><div class="line">   5:         11665         279960  java.lang.String</div><div class="line">   6:          6065         194080  java.util.concurrent.ConcurrentHashMap$Node</div><div class="line">   7:          2794         173144  [Ljava.lang.Object;</div><div class="line">   8:          3072         122880  org.apache.lucene.index.FreqProxTermsWriter$PostingList</div><div class="line">   9:          2760         110400  java.util.LinkedHashMap$Entry</div><div class="line">  10:          1097         101144  [Ljava.util.HashMap$Node;</div><div class="line">  11:          5440          87040  java.lang.Object</div><div class="line">  12:          2680          85760  java.util.HashMap$Node</div><div class="line">  13:           520          45760  java.lang.reflect.Method</div><div class="line">  14:            44          44064  [Ljava.util.concurrent.ConcurrentHashMap$Node;</div><div class="line">  15:           781          43736  java.util.LinkedHashMap</div><div class="line">  16:            96          41088  [Lorg.apache.lucene.index.RawPostingList;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>(2) Dump 堆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 指明 live，强制进行 full GC</div><div class="line">jmap -dump:live,file=/tmp/heap_dump.hprof 6808</div><div class="line">// 或者</div><div class="line">jmap -F -dump:format=b,file=filename.hprof 20961</div><div class="line">// 或者简单点</div><div class="line">jmap -F -dump:file=filename.hprof 20961</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: 路径一定要显示指明，否则不知道默认保存到哪里去了</p>
</blockquote>
<p>通常有三种工具能够分析 <code>.hprof</code> 文件：</p>
<ul>
<li><code>jhat</code></li>
<li><code>jvisualvm</code></li>
<li><code>mat</code></li>
</ul>
<p>(3) 内存溢出</p>
<p>内存溢出通常发生在:</p>
<ul>
<li>Native 内存用光了</li>
<li>permgen(Java 7) 或者 metaspace(Java 8) 内存用光了</li>
<li>Java 堆内存用光了</li>
<li>JVM 进行 GC 的时间太长了</li>
</ul>
<h4 id="使用更少的内存"><a href="#使用更少的内存" class="headerlink" title="使用更少的内存"></a>使用更少的内存</h4><p>(1) 减少对象大小</p>
<p><img src="17-07-04-11_00_08_851_488.png" alt=""></p>
<p>(2) 延迟初始化<br>(3) 不可变对象<br>(4) String Interning</p>
<h4 id="对象生命周期管理"><a href="#对象生命周期管理" class="headerlink" title="对象生命周期管理"></a>对象生命周期管理</h4><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><h4 id="1-编译还是解释"><a href="#1-编译还是解释" class="headerlink" title="(1) 编译还是解释"></a>(1) 编译还是解释</h4><p>Languages like C++ and Fortran are called <strong>compiled languages</strong> because their programs are delivered as binary (compiled) code: the program is written, and then a static compiler produces a binary. The assembly code in that binary is targeted to a particular CPU. Complementary CPUs can execute the same binary: for example, AMD and Intel CPUs share a basic, common set of assembly language instructions, and later versions of CPUs almost always can execute the same set of instructions as previous versions of that CPU.</p>
<p>Languages like PHP and Perl, on the other hand, <strong>are interpreted</strong>. The same program source code can be run on any CPU as long as the machine has the correct interpreter (that is, the program called <code>php</code> or <code>perl</code>). <strong>The interpreter translates each line of the program into binary code as that line is executed</strong>.</p>
<p>Java attempts to find a middle ground here. Java applications are compiled—but instead of being compiled into a specific binary for a specific CPU, <strong>they are compiled into an idealized assembly language</strong>. This assembly language (know as Java bytecodes) is then run by the <code>java</code> binary (in the same way <strong>that an interpreted</strong> PHP script is run by the php binary). This gives Java the platform independence of an interpreted language. Because it is executing an idealized binary code, <strong>the java program is able to compile the code into the platform binary as the code executes</strong>. This compilation occurs as the program is executed: it happens “just in time.</p>
<h4 id="2-HotSpot-名字的含义"><a href="#2-HotSpot-名字的含义" class="headerlink" title="(2) HotSpot 名字的含义"></a>(2) HotSpot 名字的含义</h4><p>In a typical program, <strong>only a small subset of code is executed frequently, and the performance of an application depends primarily on how fast those sections of code are executed</strong>. These critical sections are known as the hot spots of the application; <strong>the more the section of code is executed, the hotter that section is said to be</strong>.</p>
<p>Hence, when the JVM executes code, <strong>it does not begin compiling the code immediately</strong>. There are two basic reasons for this. First, if the code is going to be executed only once, then compiling it is essentially a wasted effort; it will be faster to interpret the Java bytecodes than to compile them and execute (only once) the compiled code.</p>
<p>the more times that the JVM executes a particular method or loop, the more information it has about that code. This allows the JVM to make a number of optimizations when it compiles the code.</p>
<h4 id="3-寄存器和内存"><a href="#3-寄存器和内存" class="headerlink" title="(3) 寄存器和内存"></a>(3) 寄存器和内存</h4><p><img src="17-08-01-11_07_53_611_306.png" alt=""></p>
<p>If the value of sum were to be retrieved from (and stored back to) main memory on every iteration of this loop, performance would be dismal. Instead, the compiler will <strong>load a register with the initial value of sum</strong>, perform the loop using that value in the register, and then (at an indeterminate point in time) store the final result from the register back to main memory.</p>
<p><strong>Register usage</strong> is a general optimization of the compiler, and when <strong>escape analysis</strong> is enabled (see the end of this chapter), register use is quite aggressive.</p>
<h4 id="4-选择-Java-编译器"><a href="#4-选择-Java-编译器" class="headerlink" title="(4) 选择 Java 编译器"></a>(4) 选择 Java 编译器</h4><ul>
<li>A 32-bit client version (<code>-client</code>)</li>
<li>A 32-bit server version (<code>-server</code>)</li>
<li>A 64-bit server version (<code>-d64</code>)</li>
</ul>
<p>For the sake of compatibility, the argument specifying which compiler to use is not rigorously followed. If you have a 64-bit JVM and specify <code>-client</code>, the application will use the 64-bit server compiler anyway. If you have a 32 bit JVM and you specify <code>-d64</code>, you will get an error that the given instance does not support a 64-bit JVM.</p>
<p><strong>The client compiler begins compiling sooner than the server compiler does. code produced by the server compiler will be faster than that produced by the client compiler.</strong> couldn’t the JVM start with the client compiler, and then use the server compiler as code gets hotter? That technique is known as <strong>tiered compilation</strong>. With tiered compilation, code is first compiled by the client compiler; as it becomes hot, it is recompiled by the server compiler.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Java 7 需要打开, Java 8 默认开启</span></div><div class="line">-server -XX:+TieredCompilation</div></pre></td></tr></table></figure>
<ul>
<li>For <strong>GUI programs</strong>, uses the client compiler by default. Performance is often all about perception: <strong>if the initial startup seems faster, and everything else seems fine, users will tend to view the program that has started faster as being faster overall</strong>.</li>
<li>For <strong>long-running applications</strong>, always choose the server compiler, preferably in conjunction with tiered compilation.</li>
</ul>
<p>查看默认编译器:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure>
<h4 id="5-更多考虑因素"><a href="#5-更多考虑因素" class="headerlink" title="(5) 更多考虑因素"></a>(5) 更多考虑因素</h4><p><strong>Code Cache</strong>: When the JVM compiles code, it holds the set of assembly-language instructions in the code cache. <strong>Code Cache 有固定大小</strong>, and once it has filled up, the JVM is not able to compile any additional code.</p>
<p><img src="17-08-01-11_39_30_662_364.png" alt=""></p>
<hr>
<p><strong>编译阈值</strong>: The major factor involved here is <strong>多频繁</strong> the code is executed; once it is executed a certain number of times, its compilation threshold is reached, and the compiler deems that it has enough information to compile the code.</p>
<p>Compilation is based on two counters in the JVM: <strong>方法调用次数</strong>, and <strong>方法内循环的实际次数</strong>. When the JVM executes a Java method, it checks the sum of those two counters and decides whether or not the method is eligible for compilation.  This kind of compilation has no official name but is often called <strong>standard compilation (标准编译)</strong>.</p>
<p>But what if the method has a really long loop—or one that never exits and provides all the logic of the program? In that case, the JVM needs to compile the loop without waiting for a method invocation. So every time the loop completes an execution, the branching counter is incremented and inspected. If the branching counter has exceeded its individual threshold, then the loop (and not the entire method) becomes eligible for compilation.</p>
<p>This kind of compilation is called <strong>on-stack replacement (OSR)</strong>, because even if the loop is compiled, that isn’t sufficient: the JVM has to have the ability to start executing the compiled version of the loop while the loop is still running. When the code for the has finished compiling, the JVM replaces the code (on-stack), and the next iteration of the loop will execute the much-faster compiled version of the code (<strong>下一次循环就是编译版本了</strong>).</p>
<p>Standard compilation is triggered by the value of the <code>-XX:CompileThreshold=N</code> flag. The default value of N for the client compiler is <code>1,500</code>; for the server compiler it is <code>10,000</code>.</p>
<hr>
<p><strong>查看编译过程</strong>: <code>-XX:+PrintCompilation</code>.</p>
<p><code>jstat</code> has two options to provide information about the compiler. The <code>-compiler</code> option supplies summary information about <strong>多少方法被编译了</strong> (here 5003 is the process ID of the program to be inspected):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat -compiler 5003</div></pre></td></tr></table></figure>
<p>lternately, you can use the <code>-printcompilation</code> option to get information about the <strong>最后一个方法</strong> that is compiled. In this example, <code>jstat</code> repeats the information for process ID 5003 every second (1,000 ms):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat -printcompilation 5003 1000</div></pre></td></tr></table></figure>
<hr>
<p><strong>编译线程个数</strong>:</p>
<p><img src="17-08-01-14_38_57_660_434.png" alt=""></p>
<hr>
<p><strong>内联</strong>:</p>
<p>One of the most important optimizations the compiler makes is to <strong>inline methods</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; x = i; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你写这样代码的时候:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Point p = getPoint();</div><div class="line">p.setX(p.getX() * <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>编译后的代码执行的将会是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Point p = getPoint();</div><div class="line">p.x = p.x * <span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>The basic decision about whether to inline a method depends on <strong>多频繁</strong> and <strong>大小</strong>. The JVM determines if a method is hot (i.e., called frequently) based on an internal calculation; it is not directly subject to any tunable parameters. If a method is eligible for inlining because it is called frequently, then it will be inlined only if its <strong>字节码大小小于 325 字节</strong> (or whatever is specified as the <code>-XX:MaxFreqInlineSize=N</code> flag). Otherwise, it is eligible for inlining only if it is small: <strong>小于 35 字节</strong> (or whatever is specified as the <code>-XX:MaxInlineSize=N</code> flag)</p>
<hr>
<p><strong>逃逸分析</strong>:</p>
<p>The server compiler performs some very <strong>aggressive optimizations</strong> if escape analysis is enabled (<code>-XX:+DoEscapeAnalysis</code>, <strong>默认开启</strong>).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> BigInteger factorial;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.n = n;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> BigInteger <span class="title">getFactorial</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (factorial == <span class="keyword">null</span>)</div><div class="line">            factorial = ...;</div><div class="line">        <span class="keyword">return</span> factorial;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="17-08-01-14_51_48_789_196.png" alt=""></p>
<p>The <code>factorial</code> object is referenced only inside that loop; no other code can ever access that object. Hence, the JVM is free to perform a number of optimizations on that object:</p>
<ul>
<li>It needn’t get a synchronization lock when calling the <code>getFactorial()</code> method.</li>
<li>It needn’t store the field <code>n</code> in memory; it can keep that value in a <code>register</code>. Similarly it can store the <code>factorial</code> object reference in a register.</li>
<li>In fact, it needn’t allocate an actual <code>factorial</code> object at all; it can just keep track of the individual fields of the object.</li>
</ul>
<h4 id="6-Deoptimization"><a href="#6-Deoptimization" class="headerlink" title="(6) Deoptimization"></a>(6) Deoptimization</h4><p>Deoptimization means that the compiler <strong>不得不撤销一些优化</strong>; the effect is that the performance of the application will be reduced—at least until the compiler can recompile the code in question. There are two cases of deoptimization: when code is <strong>“made not entrant,”</strong> and when code is <strong>“made zombie”</strong>.</p>
<hr>
<p><strong>Not Entrant Code</strong>:</p>
<p>There are two things that cause code to be made not entrant. One is due to <strong>the way classes and interfaces work</strong>, and one is <strong>an implementation detail of tiered compilation</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">StockPriceHistory sph;</div><div class="line">String log = request.getParameter(<span class="string">"log"</span>);</div><div class="line"><span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.equals(<span class="string">"true"</span>)) &#123;</div><div class="line">    sph = <span class="keyword">new</span> StockPriceHistoryLogger(...);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    sph = <span class="keyword">new</span> StockPriceHistoryImpl(...);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Then the JSP makes calls to:</span></div><div class="line">sph.getHighPrice();</div><div class="line">sph.getStdDev();</div><div class="line"><span class="comment">// and so on</span></div></pre></td></tr></table></figure>
<p>If a bunch of calls are made to <code>http://localhost:8080/StockServlet</code> (that is, without the log parameter), the compiler will see that the actual type of the sph object is <code>StockPriceHistoryImpl</code>. It will then inline code and perform other optimizations based on that knowledge. Later, say a call is made to <code>http://localhost:8080/StockServlet?log=true</code>. Now the assumption the compiler made regarding the type of the sph object is false; the previous optimizations are no longer valid. This generates a deoptimization trap, and the previous optimizations are discarded. If a lot of additional calls are made with logging enabled, the JVM will quickly end up compiling that code and making new optimizations.</p>
<p>In tiered compilation, code is compiled by the client compiler, and then later compiled by the server compiler (and actually it’s a little more complicated than that, as discussed in the next section). When the code compiled by the server compiler is ready, the JVM must replace the code compiled by the client compiler. It does this by <strong>将旧代码标记为 Not Entrant</strong> and using the same mechanism to substitute the newly compiled (and more efficient) code.</p>
<hr>
<p><strong>Deoptimizing Zombie Code</strong>:</p>
<p>Recall that the compiled code is held in a fixedsize code cache; when zombie methods are identified, it means that the code in question can be removed from the code cache, making room for other classes to be compiled (or limiting the amount of memory the JVM will need to allocate later).</p>
<p>The possible downside here is that if the code for the class is made zombie and then later reloaded and heavily used again, the JVM will need to recompile and reoptimize the code.</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li><a href="https://docs.oracle.com/javase/6/docs/technotes/guides/management/jconsole.html" target="_blank" rel="external">https://docs.oracle.com/javase/6/docs/technotes/guides/management/jconsole.html</a></li>
<li><a href="https://stackoverflow.com/questions/1058991/how-to-monitor-java-memory-usage" target="_blank" rel="external">https://stackoverflow.com/questions/1058991/how-to-monitor-java-memory-usage</a></li>
</ul>
<h3 id="远程-JVisualVM"><a href="#远程-JVisualVM" class="headerlink" title="远程 JVisualVM"></a>远程 <code>JVisualVM</code></h3><p>远程机器上输入 <code>jstatd</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Could not create remote object</div><div class="line">access denied (&quot;java.util.PropertyPermission&quot; &quot;java.rmi.server.ignoreSubClasses&quot; &quot;write&quot;)</div><div class="line">java.security.AccessControlException: access denied (&quot;java.util.PropertyPermission&quot; &quot;java.rmi.server.ignoreSubClasses&quot; &quot;write&quot;)</div><div class="line">	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)</div><div class="line">	at java.security.AccessController.checkPermission(AccessController.java:884)</div><div class="line">	at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)</div><div class="line">	at java.lang.System.setProperty(System.java:792)</div><div class="line">	at sun.tools.jstatd.Jstatd.main(Jstatd.java:139)</div></pre></td></tr></table></figure>
<p>你需要创建一个安全策略文件: <code>jstatd.all.policy</code>，里面写上这句话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grant codebase &quot;file:/opt/java/jdk1.7.0_21/lib/tools.jar&quot; &#123; permission java.security.AllPermission; &#125;;</div></pre></td></tr></table></figure>
<p>然后使用如下命令重新启动:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstatd -J-Djava.security.policy=/home/user/jstatd.all.policy</div></pre></td></tr></table></figure>
<p>在本机测试，是否能够 <code>telnet</code> 到 <code>jstatd</code> 服务:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet 10.108.112.218 1099</div></pre></td></tr></table></figure>
<p>有些时候，<code>jstatd</code> 可能绑定的并不是正确的网卡:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-J-Djava.rmi.server.hostname=10.1.1.123</div></pre></td></tr></table></figure>
<p>强制使用 <code>IPV4</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-J-Djava.net.preferIPv4Stack=<span class="literal">true</span></div></pre></td></tr></table></figure>
<p>查看一些日志输出:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-J-Djava.rmi.server.logCalls=<span class="literal">true</span></div></pre></td></tr></table></figure>
<p>最后的命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstatd -J-Djava.security.policy=./jstatd.all.policy -J-Djava.rmi.server.hostname=10.108.112.218 -J-Djava.rmi.server.logCalls=<span class="literal">true</span></div></pre></td></tr></table></figure>
<h3 id="GC-日志分析工具"><a href="#GC-日志分析工具" class="headerlink" title="GC 日志分析工具"></a>GC 日志分析工具</h3><ul>
<li><a href="http://gceasy.io/" target="_blank" rel="external">GCeasy</a></li>
</ul>
<h3 id="DUMP-什么"><a href="#DUMP-什么" class="headerlink" title="DUMP 什么"></a>DUMP 什么</h3><p>以下是 <a href="https://github.com/alibaba/dubbo/blob/master/dubbo-container/dubbo-container-api/src/main/resources/META-INF/assembly/bin/dump.sh" target="_blank" rel="external">dubbo - dump.sh</a> 备份的内容:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">DUMP_DATE=`date +%Y%m%d%H%M%S`</div><div class="line">DATE_DIR=<span class="variable">$DUMP_DIR</span>/<span class="variable">$DUMP_DATE</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"Dumping the <span class="variable">$SERVER_NAME</span> ...\c"</span></div><div class="line"><span class="keyword">for</span> PID <span class="keyword">in</span> <span class="variable">$PIDS</span> ; <span class="keyword">do</span></div><div class="line">	jstack <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jstack-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line">	jinfo <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jinfo-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line">	jstat -gcutil <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jstat-gcutil-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line">	jstat -gccapacity <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jstat-gccapacity-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line">	jmap <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jmap-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line">	jmap -heap <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jmap-heap-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line">	jmap -histo <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jmap-histo-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line">	<span class="keyword">if</span> [ -r /usr/sbin/lsof ]; <span class="keyword">then</span></div><div class="line">	/usr/sbin/lsof -p <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/lsof-<span class="variable">$PID</span>.dump</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line">	<span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -r /bin/netstat ]; <span class="keyword">then</span></div><div class="line">/bin/netstat -an &gt; <span class="variable">$DATE_DIR</span>/netstat.dump 2&gt;&amp;1</div><div class="line"><span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -r /usr/bin/iostat ]; <span class="keyword">then</span></div><div class="line">/usr/bin/iostat &gt; <span class="variable">$DATE_DIR</span>/iostat.dump 2&gt;&amp;1</div><div class="line"><span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -r /usr/bin/mpstat ]; <span class="keyword">then</span></div><div class="line">/usr/bin/mpstat &gt; <span class="variable">$DATE_DIR</span>/mpstat.dump 2&gt;&amp;1</div><div class="line"><span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -r /usr/bin/vmstat ]; <span class="keyword">then</span></div><div class="line">/usr/bin/vmstat &gt; <span class="variable">$DATE_DIR</span>/vmstat.dump 2&gt;&amp;1</div><div class="line"><span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -r /usr/bin/free ]; <span class="keyword">then</span></div><div class="line">/usr/bin/free -t &gt; <span class="variable">$DATE_DIR</span>/free.dump 2&gt;&amp;1</div><div class="line"><span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -r /usr/bin/sar ]; <span class="keyword">then</span></div><div class="line">/usr/bin/sar &gt; <span class="variable">$DATE_DIR</span>/sar.dump 2&gt;&amp;1</div><div class="line"><span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -r /usr/bin/uptime ]; <span class="keyword">then</span></div><div class="line">/usr/bin/uptime &gt; <span class="variable">$DATE_DIR</span>/uptime.dump 2&gt;&amp;1</div><div class="line"><span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>从上可知一般<strong>统计</strong>的都有如下几项:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html" target="_blank" rel="external"><strong><code>jstack</code></strong></a>: 线程信息</li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html" target="_blank" rel="external"><strong><code>jinfo</code></strong></a>: 配置信息. The configuration information includes <strong>Java system properties</strong> and <strong>Java Virtual Machine (JVM) command-line flags</strong>.</li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="external"><strong><code>jstat -gcutil</code></strong></a>: 垃圾收集统计</li>
<li><strong><code>jstat -gccapacity</code></strong>: Displays statistics about the <strong>capacities</strong> of the generations and their corresponding spaces.</li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html" target="_blank" rel="external"><strong><code>jmap</code></strong></a>: Prints <strong>共享对象内存</strong> maps or <strong>堆内存</strong> details for a process, core file, or remote debug server.</li>
<li><code>jmap -heap</code>: Prints a heap summary of the garbage collection used, the head configuration, and generation-wise heap usage. In addition, the number and size of interned Strings are printed.</li>
<li><code>jmap -histo</code>: Prints a <strong>histogram</strong> of the heap</li>
<li><code>lsof -p</code></li>
<li><code>netstat -an</code></li>
<li><code>iostat</code>: Report Central Processing Unit (CPU) statistics and input/output statistics for devices, partitions and network filesystems (NFS).</li>
<li><code>mpstat</code>: Report <strong>处理器</strong> related statistics.</li>
<li><code>vmstat</code>: vmstat (virtual memory statistics) is a computer system monitoring tool that collects and displays summary information about operating system memory, processes, interrupts, paging and block I/O.</li>
<li><code>free -t</code>: Display amount of <strong>可用/已用内存</strong> in the system. <code>-t</code>: Display a line showing the column totals.</li>
<li><code>sar</code>: In computing, sar (<strong>System Activity Report</strong>) is a Unix System V-derived system monitor command used to report on various system loads, including <strong>CPU 活动</strong>, memory/paging, <strong>设备负载</strong>, <strong>网络</strong>. Linux distributions provide <code>sar</code> through the <code>sysstat</code> package.</li>
<li><code>uptime</code>: uptime gives a one line display of the following information. The <strong>当前时间</strong>, <strong>多长时间</strong> the system has been running, <strong>多少用户</strong> are currently logged on, and the <strong>系统平均负载</strong> averages for the past 1, 5, and 15 minutes.</li>
</ul>
<h3 id="实际运用中如何清晰明了地观察-JVM-的运行过程"><a href="#实际运用中如何清晰明了地观察-JVM-的运行过程" class="headerlink" title="实际运用中如何清晰明了地观察 JVM 的运行过程?"></a>实际运用中如何清晰明了地观察 JVM 的运行过程?</h3><ul>
<li>图形工具: <code>JProfiler</code>, <code>JConsole</code>, <code>Java VisualVM</code></li>
<li>命令: <code>jps</code>, <code>jstack</code>, <code>jmap</code>, <code>jhat</code>, <code>jstat</code></li>
</ul>
<h3 id="JVM-如何进阶"><a href="#JVM-如何进阶" class="headerlink" title="JVM 如何进阶"></a>JVM 如何进阶</h3><p>问:<code>JVM</code>如何进阶，目前周志明的《深入理解JVM》第2版看了两遍，能够根据目录口述书中大部分内容，还需要了解哪些知识？</p>
<p>答：周志明的书只能算是 <code>JVM</code> 的入门书籍。接下来你应该去读一读<strong>《Java虚拟机规范》</strong>，周志明的书很多内容是从里面来的，但是规范本身比较详细，注意读英文原版。其次去读一下Oralce的文档：<strong>《Hotspot Memory Management white paper》, 《Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide》</strong>。现在你需要进一步修炼关于<strong>内存管理</strong>的部分，阅读比如<strong>《垃圾回收算法与实现》</strong>，如果这本读完还不满足，那么阅读<strong>《自动内存管理艺术——垃圾回收算法手册》</strong>。到了这一步，理论你已经掌握得很好了，是时候把 <code>Hotspot</code> 源码 download 下来编译好之后断点调试玩玩了，这个时候我要推荐你今年阿里人刚出的<strong>《揭秘Java虚拟机》</strong>，不过阅读这本书之前你要是愿意先读完<strong>《深入理解计算机系统》</strong>效果更好。到了这一步，剩下的，自己探索了，我也在探索。</p>
<h3 id="线上CPU很高、内存占用很少，有能快速查找到原因的方法吗？"><a href="#线上CPU很高、内存占用很少，有能快速查找到原因的方法吗？" class="headerlink" title="线上CPU很高、内存占用很少，有能快速查找到原因的方法吗？"></a>线上CPU很高、内存占用很少，有能快速查找到原因的方法吗？</h3><p>给一个代码，在 <code>Linux</code> 下保存成 <code>.sh</code> 文件直接执行即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">ts=$(date +<span class="string">"%s"</span>)</div><div class="line">jvmPid=<span class="variable">$1</span></div><div class="line">defaultLines=100</div><div class="line">defaultTop=20</div><div class="line"></div><div class="line">threadStackLines=<span class="variable">$&#123;2:-$defaultLines&#125;</span></div><div class="line">topThreads=<span class="variable">$&#123;3:-$defaultTop&#125;</span></div><div class="line"></div><div class="line">jvmCapture=$(top -b -n1 | grep java )</div><div class="line">threadsTopCapture=$(top -b -n1 -H | grep java )</div><div class="line">jstackOutput=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$(jstack $jvmPid )</span>"</span> )</div><div class="line">topOutput=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$(echo "$threadsTopCapture" | head -n $topThreads | perl -pe 's/\e\[?.*?[\@-~] ?//g' | awk '&#123;gsub(/^ +/,"")</span>;print&#125;' | awk '&#123;gsub(/ +|[+-]/,"</span> <span class="string">");print&#125;' | cut -d "</span> <span class="string">" -f 1,9 )\n "</span>)</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"*************************************************************************************************************"</span></div><div class="line"></div><div class="line">uptime</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"Analyzing top <span class="variable">$topThreads</span> threads"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"*************************************************************************************************************"</span></div><div class="line"></div><div class="line"><span class="built_in">printf</span> %s <span class="string">"<span class="variable">$topOutput</span>"</span> | <span class="keyword">while</span> IFS= <span class="built_in">read</span>  line</div><div class="line"></div><div class="line"><span class="keyword">do</span></div><div class="line">   pid=$(<span class="built_in">echo</span> <span class="variable">$line</span> | cut -d <span class="string">" "</span> -f 1)</div><div class="line">   hexapid=$(<span class="built_in">printf</span> <span class="string">"%x"</span> <span class="variable">$pid</span>)</div><div class="line">   cpu=$(<span class="built_in">echo</span> <span class="variable">$line</span> | cut -d <span class="string">" "</span> -f 2)</div><div class="line">   <span class="built_in">echo</span> -n <span class="variable">$cpu</span><span class="string">"% [<span class="variable">$pid</span>] "</span> </div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$jstackOutput</span>"</span> | grep <span class="string">"tid.*0x<span class="variable">$hexapid</span> "</span> -A <span class="variable">$threadStackLines</span> | sed -n -e <span class="string">'/0x'</span><span class="variable">$hexapid</span><span class="string">'/,/tid/ p'</span> | head -n -1</div><div class="line">   <span class="built_in">echo</span> <span class="string">"\n"</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"\n"</span></div></pre></td></tr></table></figure>
<p>代码的意思，打印出 <code>JVM</code> 的所有线程以及按照 <code>CPU</code> 占比排序。</p>
<h3 id="您好，想问一个-JVM-比较基础的知识，现在的垃圾收集都是分代回收，那么在回收新生代的时候是要同时扫描老年代吗？是全表还是有一种策略，比如-G1-的-Remembered-set，这个-set-只是记录了一种引用关系；那其它的分代回收，比如-CMS-和-ParNew-组合时只能是回收新生代的时候扫描老年代吗？那这样效率不就是降低了不少吗？"><a href="#您好，想问一个-JVM-比较基础的知识，现在的垃圾收集都是分代回收，那么在回收新生代的时候是要同时扫描老年代吗？是全表还是有一种策略，比如-G1-的-Remembered-set，这个-set-只是记录了一种引用关系；那其它的分代回收，比如-CMS-和-ParNew-组合时只能是回收新生代的时候扫描老年代吗？那这样效率不就是降低了不少吗？" class="headerlink" title="您好，想问一个 JVM 比较基础的知识，现在的垃圾收集都是分代回收，那么在回收新生代的时候是要同时扫描老年代吗？是全表还是有一种策略，比如 G1 的 Remembered set，这个 set 只是记录了一种引用关系；那其它的分代回收，比如 CMS 和 ParNew 组合时只能是回收新生代的时候扫描老年代吗？那这样效率不就是降低了不少吗？"></a>您好，想问一个 JVM 比较基础的知识，现在的垃圾收集都是分代回收，那么在回收新生代的时候是要同时扫描老年代吗？是全表还是有一种策略，比如 G1 的 Remembered set，这个 set 只是记录了一种引用关系；那其它的分代回收，比如 CMS 和 ParNew 组合时只能是回收新生代的时候扫描老年代吗？那这样效率不就是降低了不少吗？</h3><p>答：对于老年代指向新生代的引用，JVM提供了一种叫 <code>card table</code> 的数据结构，所以每次<strong>并不需要全量遍历老年代</strong>，只需要遍历 <code>card table</code> 就行了。</p>
<h3 id="线上定位内存-JVM-内存溢出，除了打印堆栈拿出来分析，还有没有其它的方式？"><a href="#线上定位内存-JVM-内存溢出，除了打印堆栈拿出来分析，还有没有其它的方式？" class="headerlink" title="线上定位内存 JVM 内存溢出，除了打印堆栈拿出来分析，还有没有其它的方式？"></a>线上定位内存 JVM 内存溢出，除了打印堆栈拿出来分析，还有没有其它的方式？</h3><p>答：<strong>导出 <code>JVM dump</code> 文件</strong>，在本地使用 <code>Eclipse</code> 插件 <strong><code>MAT</code></strong> 分析，可视化的分析最方便、直观、有效。</p>
<h3 id="垃圾回收器怎么选择"><a href="#垃圾回收器怎么选择" class="headerlink" title="垃圾回收器怎么选择"></a>垃圾回收器怎么选择</h3><ul>
<li>最小化地使用内存和并行开销，请选择 <code>Serial GC</code></li>
<li>最大化应用程序的吞吐量，请选择<code>Parallel GC</code></li>
<li>最小化 <code>GC</code> 的中断或者停顿时间，请选择 <code>CMS GC</code></li>
</ul>
<hr>
<p>并发和并行都可以表示两个或者多个任务一起执行，但是偏重点不同。并发偏重于<strong>多个任务交替执行</strong>，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。</p>
<h3 id="内存泄漏代码示例"><a href="#内存泄漏代码示例" class="headerlink" title="内存泄漏代码示例"></a>内存泄漏代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (!m.contains(<span class="keyword">new</span> Key(i))) &#123;</div><div class="line">      m.put(<span class="keyword">new</span> Key(i), <span class="string">"Number:"</span> + i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interned-Strings"><a href="#Interned-Strings" class="headerlink" title="Interned Strings"></a>Interned Strings</h3><p><code>String</code> 类型的常量池比较特殊。主要使用方法有两种:</p>
<ul>
<li>直接使用双引号声明出来的 <code>String</code> 对象会直接存储在常量池中。</li>
<li>如果不是双引号声明的 <code>String</code> 对象，可以使用 <code>String</code> 提供的 <code>intern</code> 方法。<code>intern</code> 会先判断是否存在常量池中，如果不存在，则会将当前字符串放入常量池中。</li>
</ul>
<p>JDK 6的常量池放在 <strong><code>Perm</code></strong> 区中，默认大小只有 4 MB。JDK 7开始，放在<strong>堆</strong>中。</p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p><strong>1) The Dominator Tree</strong>:</p>
<p>The key to understanding your retained heap, is looking at the dominator tree. The dominator tree is a tree produced by the <strong>complex object graph</strong> in your system. The dominator tree allows you to identify the largest memory graphs. An Object X is said to dominate an Object Y if every path from the Root to Y must pass through X.</p>
<p><a href="https://javaeesupportpatterns.blogspot.jp/2013/03/openjpa-memory-leak-case-study.html" target="_blank" rel="external">https://javaeesupportpatterns.blogspot.jp/2013/03/openjpa-memory-leak-case-study.html</a></p>
<h3 id="JVM-诊断示例"><a href="#JVM-诊断示例" class="headerlink" title="JVM 诊断示例"></a>JVM 诊断<a href="https://plumbr.eu/blog/memory-leaks/memory-leaks-fallacies-and-misconceptions" target="_blank" rel="external">示例</a></h3><p><strong>1) 健康的 <code>JVM</code></strong>:</p>
<p><img src="java-memory-usage-example.png" alt=""></p>
<p><strong>2) 启动内存暴涨</strong>:</p>
<p><img src="java-memory-usage-quick-growth-at-startup.png" alt=""></p>
<p><strong>3) 激增</strong>:</p>
<p><img src="java-memory-usage-spike.png" alt=""></p>
<p><strong>4) 内存泄露</strong></p>
<p><img src="java-memory-leak.png" alt=""></p>
<h3 id="JVisualVM"><a href="#JVisualVM" class="headerlink" title="JVisualVM"></a>JVisualVM</h3><p>需要安装一个 <code>Visual GC</code> 插件:</p>
<p><img src="2017_09_18_14_38_51.png" alt=""></p>
<p>才能显示具体的 <code>GC</code> 过程:</p>
<p><img src="2017_09_18_14_40_26.png" alt=""></p>
<h3 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h3><p><a href="https://plumbr.eu/handbook/garbage-collection-algorithms-implementations#serial-minor-gc" target="_blank" rel="external">https://plumbr.eu/handbook/garbage-collection-algorithms-implementations#serial-minor-gc</a></p>
<h3 id="如何在生产环境使用-Btrace-进行调试"><a href="#如何在生产环境使用-Btrace-进行调试" class="headerlink" title="如何在生产环境使用 Btrace 进行调试"></a><a href="http://www.importnew.com/23614.html" target="_blank" rel="external">如何在生产环境使用 Btrace 进行调试</a></h3><p>大多数问题的解决方式都是在<strong>本地打断点</strong>进行调试，或者在测试环境利用<strong>输出日志</strong>进行调试，这种方式简单粗暴，但过程比较繁琐，需要各种重新发布，重启应用，还不能保证一次就找到问题的根源。</p>
<p><a href="https://github.com/btraceio/btrace" target="_blank" rel="external"><code>BTrace</code></a> 是 sun 公司推出的一款 <code>Java</code> <strong>动态、安全追踪（监控）工具</strong>，可以在不用重启的情况下监控系统运行情况，方便的获取程序运行时的数据信息，如<strong>方法参数、返回值、全局变量和堆栈信息</strong>等，并且做到最少的侵入，占用最少的系统资源。</p>
<p>由于 Btrace 会把<strong>脚本逻辑</strong>直接侵入到运行的代码中，所以在使用上做很多限制：</p>
<ol>
<li>不能创建对象</li>
<li>不能使用数组</li>
<li>不能抛出或捕获异常</li>
<li>不能使用循环</li>
<li>不能使用 <code>synchronized</code> 关键字</li>
<li>属性和方法必须使用 <code>static</code> 修饰</li>
</ol>
<p>根据官方声明，不恰当的使用 BTrace 可能导致 JVM 崩溃，如在 BTrace 脚本使用错误的 class 文件，所以在上生产环境之前，<strong>务必在本地充分的验证脚本的正确性</strong>。</p>
<h4 id="Btrace-可以做什么？"><a href="#Btrace-可以做什么？" class="headerlink" title="Btrace 可以做什么？"></a>Btrace 可以做什么？</h4><ul>
<li>接口性能变慢，分析每个方法的<strong>耗时</strong>情况；</li>
<li>当在 Map 中插入大量数据，分析其扩容情况；</li>
<li>分析哪个方法调用了 <code>System.gc()</code></li>
<li>执行某个方法抛出异常时，分析<strong>运行时参数</strong>；</li>
<li>…</li>
</ul>
<p>假设服务器端运行的是如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BtraceCase</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> BtraceCase().run();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            add(random.nextInt(<span class="number">10</span>), random.nextInt(<span class="number">10</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Thread.sleep(random.nextInt(<span class="number">10</span>) * <span class="number">100</span>);</div><div class="line">        <span class="keyword">return</span> a + b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们想要对 <code>add</code> 方法的<strong>传入参数、返回值和执行耗时</strong>进行分析:</p>
<p><img src="2184951-03afa420cfaa077d.png" alt=""></p>
<p>通过 <code>jps</code> 获取服务器端的进程ID: 8454，执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btrace 8454 Debug.java</div></pre></td></tr></table></figure>
<p>实现对运行代码的监控:</p>
<p><img src="2184951-9264da5116fd16eb.png" alt=""></p>
<p>可以发现，<code>Btrace</code> 可以获取每次执行 <code>add</code> 方法时的数据，当然 <code>Btrace</code> 能做的远远不止这些，比如获取当前 <code>jvm</code> 堆使用情况、当前线程的执行栈等等。</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// clazz: 需要监控的类</span></div><div class="line"><span class="comment">// method: 需要监控的方法</span></div><div class="line"><span class="comment">//       clazz 和 method 可以使用正则、接口、注解等来指定</span></div><div class="line"><span class="comment">// location: 拦截位置</span></div><div class="line"><span class="comment">//     Kind.ENTRY: 进入方法的时候，调用脚本</span></div><div class="line"><span class="comment">//     Kind.RETURN: 执行完的时候，调用脚本</span></div><div class="line"><span class="comment">//     只有定义为 RETURN，才能获取方法的返回结果 @Return 和 @Duration</span></div><div class="line"><span class="meta">@OnMethod</span>(clazz=<span class="string">"com.metty.rpc.common.BtraceCase"</span>,</div><div class="line">          method=<span class="string">"add"</span>,</div><div class="line">          location=<span class="meta">@Location</span>(Kind.RETURN))</div></pre></td></tr></table></figure>
<h4 id="如何使用-Btrace-定位问题"><a href="#如何使用-Btrace-定位问题" class="headerlink" title="如何使用 Btrace 定位问题"></a>如何使用 Btrace 定位问题</h4><ul>
<li><strong>找出所有耗时超过 1ms</strong> 的过滤器 <code>Filter</code></li>
</ul>
<p><img src="2184951-5a84b16be8670045.png" alt=""></p>
<p>由于 <code>@Dutation</code> 返回的时间是<strong>纳秒</strong>级别，需要进行转换。</p>
<ul>
<li>哪个方法调用了 <strong><code>System.gc()</code></strong>，调用栈如何？</li>
</ul>
<p><img src="2184951-2ed3e5769fcd41a4.png" alt=""></p>
<ul>
<li><strong>统计方法的调用次数</strong>，且每隔 1 分钟<strong>打印调用次数</strong></li>
</ul>
<p><img src="2184951-0545a415522401b1.png" alt=""></p>
<p>Btrace 的 <code>@OnTimer</code> 注解可以实现<strong>定时执行</strong>脚本中的一个方法</p>
<ul>
<li>方法执行时，<strong>查看对象的实例属性值</strong></li>
</ul>
<p><img src="2184951-c246051ab7985760.png" alt=""></p>
<p>通过反射机制，可以很方便的得到当前实例的属性值。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Btrace</code> 能做的事情太多，但使用之前切记检查脚本的可行性，一旦 <code>Btrace</code> 脚本侵入到系统中，<strong>只有通过重启才能恢复</strong>。</p>
<h3 id="待读"><a href="#待读" class="headerlink" title="待读"></a>待读</h3><ul>
<li><a href="http://blog.csdn.net/wanghuiqi2008/article/details/50724676" target="_blank" rel="external">利用内存分析工具（Memory Analyzer Tool，MAT）分析java项目内存泄露</a></li>
</ul>
<h3 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a><code>JConsole</code></h3><p><img src="2017_11_02_15_37_16.png" alt=""></p>
<h3 id="JVisualVM-1"><a href="#JVisualVM-1" class="headerlink" title="JVisualVM"></a><code>JVisualVM</code></h3><p><img src="2017_11_02_15_38_23.png" alt=""></p>
<h3 id="执行-jmap-不允许操作"><a href="#执行-jmap-不允许操作" class="headerlink" title="执行 jmap 不允许操作"></a>执行 <code>jmap</code> 不允许操作</h3><p><img src="2017_11_06_10_59_36.png" alt=""></p>
<p>解决办法就是在运行 <code>jmap</code> 之前执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</div></pre></td></tr></table></figure>
<h3 id="jstack-分析"><a href="#jstack-分析" class="headerlink" title="jstack 分析"></a><code>jstack</code> 分析</h3><p>线程状态:</p>
<ul>
<li><code>BLOCKED</code>: 这个线程正在等待其它线程释放锁</li>
<li><code>WAITING</code>: 使用 <code>wait</code>, <code>join</code>, <code>park</code> 命令之后，线程正在等待</li>
<li><code>TIMED_WAITING</code>: 使用 <code>sleep</code>, <code>wait</code>, <code>join</code>, <code>park</code> 命令之后， 线程正在等待，最大等待时间是由方法参数决定的</li>
</ul>
<hr>
<p>线程类型:</p>
<ul>
<li><code>daemon</code> 线程: 当没有其它非 <code>daemon</code> 线程之后， <code>daemon</code> 线程自动停止工作</li>
</ul>
<hr>
<p><img src="2017_11_06_11_31_19.png" alt=""></p>
<h3 id="Analyzing-HotSpot-Crashes"><a href="#Analyzing-HotSpot-Crashes" class="headerlink" title="Analyzing HotSpot Crashes"></a>Analyzing HotSpot Crashes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Crash</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="keyword">static</span> Unsafe	UNSAFE = getUnsafe();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crash</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">		UNSAFE.putInt(<span class="number">0x99</span>, x);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span> </span>&#123;</div><div class="line">		crash(<span class="number">0x42</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>RAX</code>: register a extended, 64 bit register</li>
<li><code>RDX</code>: register d extended, 64 bit register</li>
<li><code>EAX</code>: 32 bit register</li>
<li><code>R9</code>: register 9</li>
</ul>
<p><img src="2017_11_26_14_34_54.png" alt=""></p>
<h3 id="JVM-Tuning-at-Twitter"><a href="#JVM-Tuning-at-Twitter" class="headerlink" title="JVM Tuning at Twitter"></a><a href="https://www.youtube.com/watch?v=8wHx31mvSLY" target="_blank" rel="external">JVM Tuning at Twitter</a></h3><p>Web services biggest enemy:</p>
<ul>
<li>Latency</li>
</ul>
<p>Server-side Latency contributors:</p>
<ul>
<li>By far the biggest contributror is garbage collector</li>
<li>others are, in no particular order:<ul>
<li>in-process locking and thread scheduling</li>
<li>I/O</li>
<li>application algorithm inefficiencies</li>
</ul>
</li>
</ul>
<p>Areas of performance tuning:</p>
<ul>
<li>Memory tuning</li>
<li>Lock contention tuning</li>
<li>CPU usage tuning</li>
<li>I/O tuning</li>
</ul>
<hr>
<p>Areas of memory performance tuning:</p>
<ul>
<li>Memory footprint tuning</li>
<li>Allocation rate tuning</li>
<li>Garbage collection tuning</li>
</ul>
<hr>
<p>Memory footprint tuning:</p>
<ul>
<li>Maybe you have too much data !</li>
<li>Maybe your data representation is fat !</li>
<li>You can also have a genuine memory leack …</li>
</ul>
<hr>
<p>Too much data:</p>
<ul>
<li>Run with <code>-verbosegc</code></li>
<li>Observe numbers in “Full GC” messages</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Full GC $before-&gt;$after($total), $time secs]</div></pre></td></tr></table></figure>
<ul>
<li>Can you give the JVM more memory ?</li>
<li>Do you need all that data in memory ? Consider using:<ul>
<li>a LRU cache</li>
<li>soft references</li>
</ul>
</li>
</ul>
<hr>
<p>Fat data: object header</p>
<ul>
<li>JVM objects is normally two machine words.</li>
<li>That’s 16 bytes, or 128 bits on a 64-bit JVM!</li>
<li><code>new java.lang.Object()</code> takes 16 bytes.</li>
<li><code>new byte[0]</code> takes 24 bytes.<ul>
<li>16 bytes object header</li>
<li>4 bytes for the length of the array</li>
<li>4 bytes of padding</li>
</ul>
</li>
</ul>
<hr>
<p>Fat data: padding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">	<span class="keyword">byte</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">	<span class="keyword">byte</span> y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>new A()</code> takes 24 bytes<ul>
<li>16 bytes object header</li>
<li>1 byte filed</li>
<li>7 bytes padding</li>
</ul>
</li>
<li><code>new B()</code> takes 32 bytes<ul>
<li>16 bytes object header</li>
<li>1 byte for x</li>
<li>7 bytes padding</li>
<li>1 byte for y</li>
<li>7 bytes padding</li>
</ul>
</li>
</ul>
<p>Fat data: no inline structs</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">	Object A = <span class="keyword">new</span> Object();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>new C()</code> takes 40 bytes</li>
</ul>
<h3 id="JVM-概览"><a href="#JVM-概览" class="headerlink" title="JVM 概览"></a>JVM 概览</h3><p><u><strong>64 位 VM 带来哪些性能损失</strong></u>:</p>
<p>内部 <code>Java</code> 对象表示 (成为<strong>普通对象指针</strong>，Ordinary Object Pointers, 或 oops) 的长度从 32 位变成了 64 位，导致 <code>CPU</code> 高速缓存行中可用的 <code>oops</code> 变少，从而降低了 <code>CPU</code> 缓存的效率。</p>
<p>接着，Java 6 添加了<strong>压缩指针 (<code>-XX:+UseCompressedOops</code>)</strong>，它能够通过<strong>对齐、偏移量</strong>将 64 位指针压缩成 32 位。CPU 使用率由此得以<strong>改善</strong>。</p>
<p><u><strong>什么时候触发类加载</strong></u>:</p>
<p><code>HotSpot VM</code> 负责解析常量池符号，这个过程需要加载、链接，然后初始化 <code>Java</code> 类和 <code>Java</code> 接口。<strong>类加载的最佳时机是在解析 <code>Java</code> 字节码类文件中常量池符号的时候</strong>。 <code>Class.forName()</code>、<code>ClassLoader.loadClass()</code>、反射 <code>API</code>和<code>JNI_FindClass</code>都可以引发类加载。</p>
<p>HotSpot VM 自身也会引发类加载，启动时，除了加载许多<strong>普通类</strong>，也会加载诸如 <code>java.lang.Object</code> 和 <code>java.lang.Thread</code> 这样的<strong>核心类</strong>。</p>
<p>加载类时也需要加载它的所有 <code>Java</code> 超类和所有 <code>Java</code> 超接口。</p>
<p>实际上，加载类是 <code>HotSpot VM</code> 和特定类加载器如 <code>java.lang.ClassLoader</code> 之间<strong>相互协作</strong>的过程。</p>
<p><u><strong>类加载阶段可能遇见哪些异常</strong></u>:</p>
<ul>
<li>没有找到类名字对应的二进制文件: <code>NoClassDefFound</code></li>
<li>语法错误: <code>ClassFormatError</code> 或者 <code>UnsupportedClassVersionError</code></li>
<li>类继承层次有误: <code>ClassCircularityError</code></li>
<li>直接超类本身并不是接口: <code>IncompatibleClassChangeError</code></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://item.jd.com/11099999.html" target="_blank" rel="external">《Java 程序性能优化》</a></li>
<li><a href="http://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="external">Java (JVM) Memory Model – Memory Management in Java</a></li>
<li><a href="http://stackoverflow.com/questions/5024959/find-which-type-of-garbage-collector-is-running" target="_blank" rel="external">find which type of garbage collector is running</a></li>
<li><a href="http://stackoverflow.com/questions/33206313/default-garbage-collector-for-java-8" target="_blank" rel="external">Default garbage collector for Java 8</a></li>
<li><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="external">Getting Started with the G1 Garbage Collector</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank" rel="external">cms</a></li>
<li><a href="https://plumbr.eu/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc" target="_blank" rel="external">Minor GC vs Major GC vs Full GC</a></li>
<li><a href="https://www.amazon.com/Java-Performance-Definitive-Guide-Getting/dp/1449358454/" target="_blank" rel="external">《Java Performance: The Definitive Guide》</a></li>
<li><a href="https://item.jd.com/11908449.html" target="_blank" rel="external">《大话 Java 性能调优》</a></li>
<li><a href="https://item.jd.com/12087807.html" target="_blank" rel="external">《深入理解 JVM &amp; G1 GC》</a></li>
<li><a href="https://www.amazon.cn/dp/B00IOB0K1Q" target="_blank" rel="external">《Java性能优化权威指南》</a></li>
<li><a href="http://www.xwood.net/_site_domain_/_root/5870/5874/t_c255066.html" target="_blank" rel="external">【TODO】关于JVM内存参数在不同场景需求优化设置，并对相关参数进行详细分析及实例说明</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/02/jvm-optimization/" data-id="cjcdlsfyc0052diem1z085w09" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/blog/page/22/">&laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/21/">21</a><a class="page-number" href="/blog/page/22/">22</a><span class="page-number current">23</span>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2018/01/06/where-the-time-actually-gone/">时间都去哪儿了</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/05/dev-reflection/">开发反思</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/05/my-microblog/">我的微博</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/04/gcc-basic/">gcc-basic</a>
          </li>
        
          <li>
            <a href="/blog/2018/01/04/java-internal/">Java Internal</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 赵坤&nbsp;|&nbsp;
      Theme by <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      Contact&nbsp;|&nbsp;igozhaokun@163.com
    </div>
  </div>
</footer>
 <script src="/blog/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">首页</a>
  
    <a href="/blog/archives" class="mobile-nav-link">归档</a>
  
    <a href="/blog/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/blog/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>

      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js"></script>
  


 <script src="/blog/js/is.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>
<script src="/blog/js/elevator.js"></script>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>