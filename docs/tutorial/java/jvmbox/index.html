<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="JVM BOX"><meta property="og:title" content="JVM BOX" />
<meta property="og:description" content="JVM 命令工具箱  在 Ubuntu 18.04 上验证
 切换 Java 版本 $ update-alternatives --config java JDK 命令无法执行 报错：
Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can&#39;t attach to the process: ptrace(PTRACE_ATTACH, ..) failed for 34131: Operation not permitted 解决方法：
# 把这个文件里面的值从 1 改为 0 即可 echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope  报错：
Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at sun.tools.jinfo.JInfo.runTool(JInfo.java:108) at sun.tools.jinfo.JInfo.main(JInfo.java:76) Caused by: java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kunzhao.org/docs/tutorial/java/jvmbox/" /><meta property="article:section" content="docs" />



<title>JVM BOX | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.827556f4a4b428e6ff4e68c72777003c28afbb68322bd35664dd0889a941daa0.css" integrity="sha256-gnVW9KS0KOb/TmjHJ3cAPCivu2gyK9NWZN0IialB2qA=">


<script defer src="/en.search.min.c41e2d56fb8780ede7944020c03cc31855b9adc615b14e19966073539bd6e2c4.js" integrity="sha256-xB4tVvuHgO3nlEAgwDzDGFW5rcYVsU4ZlmBzU5vW4sQ="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡 教程
  </a>


    

    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/front-end-optimization-guide/" >
      前端优化指南
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/algorithm/" >
      算法
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/raft/" >
      raft
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/unix-command/" >
      UNIX 常用命令大全
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/unix-optimize/" >
      UNIX 性能优化
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/vue3/" >
      Vue.js 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/git/" >
      Git 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/network/" >
      网络协议
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/awk/" >
      AWK 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/devops/" >
      DevOps
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/sentinel/" >
      阿里巴巴 Sentinel
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/zipkin/" >
      Zipkin 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/eureka/" >
      Netflix Eureka 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/distributed-storage/" >
      分布式存储
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/maven/" >
      Maven 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/java/" >
      Java 教程
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/tutorial/java/stream/" >
      Stream 编程
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/date-time/" >
      Java Date 和 Time
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/classloader/" >
      Java 类加载
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/juc/" >
      JUC 并发包
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/gc-analyze/" >
      Hotspot GC 源码分析
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/java-io/" >
      Java IO
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/jvm/" >
      JVM
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/jvmbox/"  class="active">
      JVM BOX
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/g1-gc-analyze/" >
      Hotspot G1 GC 源码分析
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/basic/" >
      Java 基础
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/btrace/" >
      BTrace
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/java-collection/" >
      Java 集合类
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/concurrency/" >
      多线程并发示例
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/spring/" >
      Spring 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/distributed/" >
      分布式系统与架构设计
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/softskill/" >
      箴言箴句
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/database/" >
      数据库
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/redis/" >
      Redis
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/bigdata/" >
      大数据场景
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/technique/" >
      技术
  </a>


    

    






  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var a=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>JVM BOX</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#切换-java-版本">切换 Java 版本</a></li>
    <li><a href="#jdk-命令无法执行">JDK 命令无法执行</a></li>
    <li><a href="#查看进程基础信息">查看进程基础信息</a></li>
    <li><a href="#查看进程系统信息">查看进程系统信息</a></li>
    <li><a href="#查看-gc-情况">查看 GC 情况</a></li>
    <li><a href="#查看堆情况">查看堆情况</a></li>
    <li><a href="#查看栈信息">查看栈信息</a></li>
    <li><a href="#jvm-参数解释">JVM 参数解释</a></li>
    <li><a href="#各命令含义具体解释">各命令含义具体解释</a>
      <ul>
        <li><a href="#class-name">class name</a></li>
        <li><a href="#xx-参数语法">XX 参数语法</a></li>
        <li><a href="#maxmetaspacesize-值过大">MaxMetaspaceSize 值过大</a></li>
        <li><a href="#默认堆大小">默认堆大小</a></li>
        <li><a href="#nativememorytracking">NativeMemoryTracking</a></li>
        <li><a href="#gc-后内存何时释放给-os">GC 后内存何时释放给 OS</a></li>
        <li><a href="#jdk-18-内存占用">JDK 1.8 内存占用</a></li>
        <li><a href="#jvm-运行在-pod-中">JVM 运行在 Pod 中</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  
<ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-8950855178079071"
data-ad-slot="6142361626"
data-ad-format="auto"
data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1 id="jvm-命令工具箱">JVM 命令工具箱</h1>
<blockquote>
<p>在 Ubuntu 18.04 上验证</p>
</blockquote>
<h2 id="切换-java-版本">切换 Java 版本</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ update-alternatives --config java
</code></pre></div><h2 id="jdk-命令无法执行">JDK 命令无法执行</h2>
<p>报错：</p>
<pre><code>Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can't attach to the process: ptrace(PTRACE_ATTACH, ..) failed for 34131: Operation not permitted
</code></pre><p>解决方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 把这个文件里面的值从 1 改为 0 即可</span>
echo <span style="color:#ae81ff">0</span> | sudo tee /proc/sys/kernel/yama/ptrace_scope
</code></pre></div><hr>
<p>报错：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at sun.tools.jinfo.JInfo.runTool(JInfo.java:108)
	at sun.tools.jinfo.JInfo.main(JInfo.java:76)
Caused by: java.lang.InternalError: Metadata does not appear to be polymorphic
	at sun.jvm.hotspot.types.basic.BasicTypeDataBase.findDynamicTypeForAddress(BasicTypeDataBase.java:278)
	at sun.jvm.hotspot.runtime.VirtualBaseConstructor.instantiateWrapperFor(VirtualBaseConstructor.java:102)
	at sun.jvm.hotspot.oops.Metadata.instantiateWrapperFor(Metadata.java:68)
	at sun.jvm.hotspot.memory.SystemDictionary.getSystemKlass(SystemDictionary.java:127)
	at sun.jvm.hotspot.runtime.VM.readSystemProperties(VM.java:879)
</code></pre><p>或</p>
<pre><code>Heap Usage:
Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at sun.tools.jmap.JMap.runTool(JMap.java:201)
	at sun.tools.jmap.JMap.main(JMap.java:130)
Caused by: java.lang.RuntimeException: unknown CollectedHeap type : class sun.jvm.hotspot.gc_interface.CollectedHeap
	at sun.jvm.hotspot.tools.HeapSummary.run(HeapSummary.java:144)
	at sun.jvm.hotspot.tools.Tool.startInternal(Tool.java:260)
	at sun.jvm.hotspot.tools.Tool.start(Tool.java:223)
	at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118)
</code></pre><p>解决方法，应该安装对应的 Java 版本的 debug 包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo apt install openjdk-8-dbg
</code></pre></div><h2 id="查看进程基础信息">查看进程基础信息</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jps -l</code></td>
<td>列举全部 JVM 的进程</td>
</tr>
<tr>
<td><code>jps -l -m</code></td>
<td>列举全部 JVM 的进程, <code>-m</code> 列举传递给 <code>main()</code> 方法的参数</td>
</tr>
<tr>
<td><code>java -version</code></td>
<td>查看 JVM 工作模式</td>
</tr>
<tr>
<td><code>jinfo &lt;pid&gt;</code></td>
<td>查看配置信息: System properties、JVM 命令行参数</td>
</tr>
<tr>
<td><code>jinfo -flag OldSize &lt;pid&gt;</code></td>
<td>查看老年代内存大小</td>
</tr>
<tr>
<td><code>java -XX:+PrintCommandLineFlags -version</code></td>
<td>让 JVM 打印出那些已经被用户或者JVM设置过的详细的XX参数的名称和值</td>
</tr>
<tr>
<td><code>java -XX:+PrintFlagsInitial -version</code></td>
<td>看下所有 XX 参数的初始值</td>
</tr>
<tr>
<td><code>java -XX:+PrintFlagsFinal -version</code></td>
<td>看下所有 XX 参数的最终值，这个就是程序最终使用的堆的配置</td>
</tr>
</tbody>
</table>
<h2 id="查看进程系统信息">查看进程系统信息</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uname -a</code></td>
<td>操作系统信息</td>
</tr>
<tr>
<td><code>cat /proc/&lt;pid&gt;/status</code></td>
<td><code>VmRSS</code> 的值是当前占用的<strong>物理内存</strong></td>
</tr>
<tr>
<td><code>ps -p 51748 -o rss, vsz, sz</code></td>
<td><code>RSS</code> 是实际使用的内存，<code>VSZ</code> 是虚拟内存，单位都是 KB</td>
</tr>
<tr>
<td>JVM 参数 <code>-XX:NativeMemoryTracking=detail</code></td>
<td>追踪 JVM 的<strong>内部内存</strong>使用，生产环节勿用</td>
</tr>
<tr>
<td><code>jcmd &lt;pid&gt; VM.native_memory scale=MB</code></td>
<td>获取<strong>内存</strong>信息</td>
</tr>
</tbody>
</table>
<h2 id="查看-gc-情况">查看 GC 情况</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jstat -gc &lt;pid&gt; 1000 5</code></td>
<td>堆各个区占用情况、垃圾回收次数，每 1000 毫秒输出一次，共输出 5 次</td>
</tr>
<tr>
<td><code>jstat -gccapacity &lt;pid&gt; 1000 5</code></td>
<td>比上面命令多输出: 各区域最大最小空间</td>
</tr>
<tr>
<td><code>jstat -gcutil &lt;pid&gt; 1000 5</code></td>
<td>各区域所占的<strong>百分比</strong></td>
</tr>
<tr>
<td><code>jstat -gccause &lt;pid&gt; 1000 5</code></td>
<td>附加最近两次垃圾回收事件的原因</td>
</tr>
</tbody>
</table>
<h2 id="查看堆情况">查看堆情况</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jmap -heap &lt;pid&gt;</code></td>
<td>查看当前堆内存配置信息和使用情况</td>
</tr>
<tr>
<td>`jmap -histo <!-- raw HTML omitted --></td>
<td>sort -n -r -k 3</td>
</tr>
<tr>
<td>`jmap -histo <!-- raw HTML omitted --></td>
<td>sort -n -r -k 2</td>
</tr>
<tr>
<td>`jmap -histo:live <!-- raw HTML omitted --></td>
<td>sort -n -r -k 2</td>
</tr>
<tr>
<td><code>jmap -dump:live,format=b,file=/home/myheapdump.hprof &lt;pid&gt;</code></td>
<td>Dump 堆内存</td>
</tr>
<tr>
<td><code>jhat /home/myheapdump.hprof</code></td>
<td>本地启动 HTTP Server 分析堆内存</td>
</tr>
<tr>
<td><code>jstat -class &lt;pid&gt;</code></td>
<td>查看<strong>类加载</strong>情况</td>
</tr>
<tr>
<td><code>jmap -clstats &lt;pid&gt;</code></td>
<td>查看<strong>类加载</strong>情况</td>
</tr>
</tbody>
</table>
<h2 id="查看栈信息">查看栈信息</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jstack -l &lt;pid&gt;</code></td>
<td>查看当前栈信息</td>
</tr>
</tbody>
</table>
<h2 id="jvm-参数解释">JVM 参数解释</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:InitialHeapSize=96468992</code> 或 <code>-Xms</code></td>
<td>JVM 初始堆内存，单位 Byte</td>
</tr>
<tr>
<td><code>-XX:MaxHeapSize=1541406720</code> 或 <code>-Xmx</code></td>
<td>JVM 最大堆内存</td>
</tr>
<tr>
<td><code>-XX:MaxNewSize=513802240</code></td>
<td>JVM 新生代最大空间</td>
</tr>
<tr>
<td><code>-XX:NewSize=31981568</code></td>
<td>JVM 新生代初始大小</td>
</tr>
<tr>
<td><code>-XX:OldSize=64487424</code></td>
<td>老年代的默认大小，参数不一定生效</td>
</tr>
<tr>
<td><code>-XX:NewRatio</code></td>
<td>老年代与新生代的比例</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>Eden 与 Survivor 幸存区 To/From 的比例</td>
</tr>
<tr>
<td><code>-XX:+HeapDumpBeforeFullGC</code> 和 <code>-XX:+HeapDumpAfterFullGC</code></td>
<td><code>FullGC</code> 前后分别对内存做 Heap Dump</td>
</tr>
<tr>
<td><code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics</code></td>
<td>JVM shutdown 的时候输出整体的 native memory 统计</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">更多参数</a></li>
</ul>
<h2 id="各命令含义具体解释">各命令含义具体解释</h2>
<h3 id="class-name">class name</h3>
<p><code>jmap -histo</code> 列举的最后一列的 <code>class name</code> 的含义：</p>
<ul>
<li><code>B</code>: byte</li>
<li><code>C</code>: char</li>
<li><code>S</code>: short</li>
<li><code>D</code>: double</li>
<li><code>F</code>: float</li>
<li><code>I</code>: int</li>
<li><code>J</code>: long</li>
<li><code>Z</code>: boolean</li>
<li><code>[</code>: 数组，例如 <code>[i</code> 表示 <code>int[]</code></li>
<li><code>[L 类名</code>: 表示某个类的数组</li>
</ul>
<h3 id="xx-参数语法">XX 参数语法</h3>
<p>所有的XX参数都以”-XX:”开始，但是随后的语法不同，取决于参数的类型。</p>
<ul>
<li>对于<strong>布尔类型</strong>的参数，我们有”+”或”-“，然后才设置JVM选项的实际名称。例如，<code>-XX:+&lt;name&gt;</code>用于激活<code>&lt;name&gt;</code>选项，而<code>-XX:-&lt;name&gt;</code>用于注销选项。</li>
<li>对于需要<strong>非布尔值</strong>的参数，如string或者integer，我们先写参数的名称，后面加上”=”，最后赋值。例如，  <code>-XX:&lt;name&gt;=&lt;value&gt;</code>给<code>&lt;name&gt;</code>赋值<code>&lt;value&gt;</code></li>
</ul>
<h3 id="maxmetaspacesize-值过大">MaxMetaspaceSize 值过大</h3>
<p>用 <code>jmap -heap &lt;pid&gt;</code> 显示的 <code>MaxMetaspaceSize</code> 值特别大，看起来就和没有限制一样。JDK 1.8 之后<strong>应该</strong>使用 <code>-XX:MetaspaceSize=64m</code> 和 <code>-XX:MaxMetaspaceSize=128m</code> 这两个参数限制<strong>元空间</strong>的大小。</p>
<h3 id="默认堆大小">默认堆大小</h3>
<p>默认最多使用多大内存的堆空间是根据每台机器的<strong>配置</strong>、<strong>物理内存</strong>决定的。可以使用命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">java -XX:+PrintFlagsFinal -version | grep HeapSize
</code></pre></div><p>来查看<strong>初始堆内存</strong>和<strong>最大堆内存</strong>大小。对于 JDK 8 而言，一般最小和最大堆内存位于机器物理内存的 1/64 ~ 1/4 之间，其中物理内存从 <code>cat /proc/meminfo</code> 信息中获取。从如下参数也可以看到使用 RAM 的百分比：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">java -XX:+PrintFlagsFinal -version | grep RAM
</code></pre></div><p>对于容器而言，Docker 容器本质是是宿主机上的一个进程，它与宿主机共享一个 <code>/proc</code> 目录，也就是说我们在容器内看到的 <code>/proc/meminfo</code>，<code>/proc/cpuinfo</code> 与直接在宿主机上看到的一致，如果不加限制，可能存在 JVM 超额使用内存被 OS Kill 掉的风险。</p>
<p>对于 Java SE 8u131 之前的 JDK 版本，需要将 <code>-Xmx</code> 参数定义为与容器限制的资源一样的参数。</p>
<p>对于 Java SE 8u131 之后和 JDK 9 的版本，如果 JVM 是运行在容器中，那么需要正确的配置 JVM 参数以便感知到容器对于 JVM 最大可用内存的限制。当配置上 <code>UseCGroupMemoryLimitForHeap</code> 参数后，JVM 会根据 Linux cgroup 中的配置来决定最大内存，如下参数可以配置在 Tomcat 的 <code>JAVA_OPTS</code> 参数中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap
</code></pre></div><p>在此多少一句，对于 <code>-XX:ParalllelGCThreads</code>、<code>-XX:CICompilerCount</code> 未设置的情况下，JVM Java SE 8u131 和 JDK 9 版本能够自动透明自动感知到 Docker 对于 CPU 的如<strong>个数</strong>等资源的限制。</p>
<p>对于 JDK8 的版本高于 191 以及 JDK 10，<code>XXFraction</code> 被标记为 deprecated，可以使用 <code>Percentage</code> 来更为灵活的定义<strong>堆空间可用比例</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-XX:+UseContainerSupport -XX:MaxRAMPercentage<span style="color:#f92672">=</span>75.0 -XX:InitialRAMPercentage<span style="color:#f92672">=</span>75.0 -XX:MinRAMPercentage<span style="color:#f92672">=</span>75.0
</code></pre></div><h3 id="nativememorytracking">NativeMemoryTracking</h3>
<ul>
<li>reserved 表示应用<strong>可用</strong>的内存大小，是 JVM 通过 mmaped <strong>申请</strong>的虚拟地址空间，权限是 <code>PROT_NONE</code>，在页表中已经存在了记录（entries），保证了其他进程不会被占用，但是 JVM 还不能直接使用这块内存。</li>
<li>committed 表示应用<strong>正在使用</strong>的内存大小，是 JVM 向操作系统<strong>实际分配</strong>的内存（malloc/mmap）,mmaped 权限是 <code>PROT_READ | PROT_WRITE</code>，这块内存可以被直接使用。</li>
</ul>
<p><code>mmap</code> 函数可以<strong>把一个文件的内容在内存里面做一个映像</strong>。映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于<strong>内核空间&lt;&ndash;&gt;用户空间</strong>两者之间需要大量数据传输等操作的话效率是非常高的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">mmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>start, size_t length, <span style="color:#66d9ef">int</span> prot , <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">int</span> fd, off_t offset);
</code></pre></div><p><code>mmap</code> 函数里面的 <code>prot</code> 参数有如下取值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">PROT_EXEC <span style="color:#75715e">//页内容可以被执行
</span><span style="color:#75715e"></span>PROT_READ  <span style="color:#75715e">//页内容可以被读取
</span><span style="color:#75715e"></span>PROT_WRITE <span style="color:#75715e">//页可以被写入
</span><span style="color:#75715e"></span>PROT_NONE  <span style="color:#75715e">//页不可访问
</span></code></pre></div><h3 id="gc-后内存何时释放给-os">GC 后内存何时释放给 OS</h3>
<p>JVM GC 是把占用的垃圾内存回收到 JVM，而不是把 JVM 的内存回收给<strong>操作系统</strong>。可是 JVM 在申请内存的时候却不使用回收来的内存，而是继续去<strong>未开发的内存里</strong>去申请，直到申请到定义的 <code>max</code> 的内存。</p>
<p><strong>堆收缩能力</strong>取决于 JVM 和 GC 垃圾收集器的版本：</p>
<ul>
<li>JDK 1.8 中默认的 GC 收集器为 Parallel GC，这个 GC 收集器在 GC 之后不会将内存返还给 OS，所以 GC 之后进程内存占用不会降低。<a href="https://www.cnblogs.com/ynx01/p/10876460.html">参考</a></li>
<li>JDK 8 以及更早版本，没有明确的选项一定会让内存回收给操作系统，但是通过配置如下这些参数 <code>-XX:GCTimeRatio=19</code>、<code>-XX:MinHeapFreeRatio=20</code>、<code>-XX:MaxHeapFreeRatio=30</code> 可以让 GC 更具 aggresive，花费更多的时间在 CPU 上，从而在 GC 之后约束<strong>分配但未使用的堆内存</strong>的总量。</li>
<li>对于并发收集器，可以设置 <code>-XX:InitiatingHeapOccupancyPercent=N</code> 参数为<strong>比较低</strong>的值，可以让 GC 几乎连续不停地收集垃圾，虽然会耗费更多的 CPU 但会更快的<strong>收缩堆</strong>。</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code> 可以自动调整堆大小。</li>
<li>G1 收集器，并且程序里面时不时的调用 <code>System.gc()</code>，Java 将会释放内存给 OS。从 JDK 12 开始，空闲的时候 G1 收集器可以自动释放内存给 OS。</li>
<li>ZGC 会自动释放内存给 OS。</li>
</ul>
<h3 id="jdk-18-内存占用">JDK 1.8 内存占用</h3>
<p><img src="/images/docs/tutorial/java/jvmbox/jvm-memory.png" alt="">
<img src="/images/docs/tutorial/java/jvmbox/1521449812178.png" alt=""></p>
<h3 id="jvm-运行在-pod-中">JVM 运行在 Pod 中</h3>
<ul>
<li>Docker 汇报的内存 = file cache + <code>top</code> 命令汇报的 <code>RSS</code></li>
<li><code>RSS</code> = <code>Heap</code> 大小 + <code>MetaSpace</code> + <code>OffHeap</code></li>
<li><code>OffHeap</code> = <code>threads stack</code> + <code>direct buffer</code> (NIO) + <code>mapped files</code> (libraries/jars) + <code>JVM code</code></li>
</ul>
<p>使用 JVisualVM 可以看到 JVM 总共有多少个线程，每个线程占用的大小可以用 <code>java -XX:+PrintFlagsFinal -version |grep ThreadStackSize</code> 命令看到，一般是 <strong>1MB</strong>。<code>direct buffer</code> 的大小可以用 JMX 工具看到。</p>
<p>从 JDK 1.8.40 可以看到，可以使用 Native Memory Tracker 来追踪 JVM 详细的内存开销，NMT 展示的是 <code>committed</code> 内存，而非 <code>ps</code> 命令汇报的 <code>resident</code> 内存，所以 NMT 展示的非堆内存可能高于 <code>ps</code> 命令汇报的 <code>resident</code> 内存。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://ifeve.com/useful-jvm-flags-part-3-printing-all-xx-flags-and-their-values/">JVM实用参数（三）打印所有XX参数及值</a></li>
<li><a href="http://ifeve.com/useful-jvm-flags-part-5-young-generation-garbage-collection/">JVM实用参数（五）新生代垃圾回收</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html">Oracle GC Tuning Guide</a></li>
<li><a href="https://www.cnblogs.com/cn-coder/p/13716457.html">Java虚拟机中 -XX:+PrintFlagsFinal与XX:+PrintCommandLineFlags 中MaxHeapSize的值不同的原因</a></li>
<li><a href="https://www.cnblogs.com/rude3knife/p/13570423.html">一次完整的JVM堆外内存泄漏故障排查记录</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1406522">聊聊HotSpot VM的Native Memory Tracking</a></li>
<li><a href="https://www.itdaan.com/blog/2016/11/23/1efed2e6a4229e7892e586f6ce30ee8a.html">请教为何JVM不把空闲内存归还给操作系统</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/350828180">Java内存占用分析</a></li>
<li><a href="https://stackoverflow.com/questions/30458195/does-gc-release-back-memory-to-os">Does GC release back memory to OS?</a></li>
<li><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/9080173">Linux 内存映射函数 mmap（）函数详解</a></li>
<li><a href="https://stackoverflow.com/questions/4667483/how-is-the-default-max-java-heap-size-determined">How is the default max Java heap size determined?</a></li>
<li><a href="https://blogs.oracle.com/java/post/java-se-support-for-docker-cpu-and-memory-limits">Java SE support for Docker CPU and memory limits</a></li>
<li><a href="https://blog.51cto.com/daisywei/2697536">Kubernetes_pod_javajdk_动态JVM堆内存大小限制</a></li>
<li><a href="https://www.jianshu.com/p/c3a4d7b20024">关于Docker中设置Java应用的JVM</a></li>
<li><a href="http://trustmeiamadeveloper.com/2016/03/18/where-is-my-memory-java/">Analyzing java memory usage in a Docker container</a></li>
<li><a href="https://blog.csdn.net/weishuai528/article/details/96899513">JVM调优之探索CMS和G1的物理内存归还机制</a></li>
</ul>

<ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-8950855178079071"
data-ad-slot="6142361626"
data-ad-format="auto"
data-full-width-responsive="true"></ins>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  </div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#切换-java-版本">切换 Java 版本</a></li>
    <li><a href="#jdk-命令无法执行">JDK 命令无法执行</a></li>
    <li><a href="#查看进程基础信息">查看进程基础信息</a></li>
    <li><a href="#查看进程系统信息">查看进程系统信息</a></li>
    <li><a href="#查看-gc-情况">查看 GC 情况</a></li>
    <li><a href="#查看堆情况">查看堆情况</a></li>
    <li><a href="#查看栈信息">查看栈信息</a></li>
    <li><a href="#jvm-参数解释">JVM 参数解释</a></li>
    <li><a href="#各命令含义具体解释">各命令含义具体解释</a>
      <ul>
        <li><a href="#class-name">class name</a></li>
        <li><a href="#xx-参数语法">XX 参数语法</a></li>
        <li><a href="#maxmetaspacesize-值过大">MaxMetaspaceSize 值过大</a></li>
        <li><a href="#默认堆大小">默认堆大小</a></li>
        <li><a href="#nativememorytracking">NativeMemoryTracking</a></li>
        <li><a href="#gc-后内存何时释放给-os">GC 后内存何时释放给 OS</a></li>
        <li><a href="#jdk-18-内存占用">JDK 1.8 内存占用</a></li>
        <li><a href="#jvm-运行在-pod-中">JVM 运行在 Pod 中</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</body>



</html>












