<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Java 集合类"><meta property="og:title" content="Java 集合类" />
<meta property="og:description" content="Java 集合类 Collections 框架图 List 框架图 Set 框架图 Map 框架图 Queue 框架图 HashMap  并发下的 HashMap 会有哪些安全问题？
 这里我只是简单的说了写覆盖跟不可重复读（联想到数据库了），面试官就放我过了。
 添加元素时头插还是尾插？
 1.7 头插，1.8 尾插。
数组长度为什么必须是 2 的指数幂 减少哈希冲突，均匀分布元素。
1）通过将 Key 的 hash 值与 length-1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；
2）如果 length 为 2 的次幂，则 length-1 转化为二进制必定是 11111…… 的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kunzhao.org/docs/tutorial/java/java-collection/" />

<title>Java 集合类 | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.2c8703ef3571e9e1469d79306fda1ed51333153e6ba74aff763a8bc7a9fdaea2.css" integrity="sha256-LIcD7zVx6eFGnXkwb9oe1RMzFT5rp0r/djqLx6n9rqI=">


<script defer src="/en.search.min.1e7619796b61414a9016ae3ce0c51191e796bfabae1a014100792c00d2d6c838.js" integrity="sha256-HnYZeWthQUqQFq484MURkeeWv6uuGgFBAHksANLWyDg="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡 教程
  </a>


    

    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/front-end-optimization-guide/" >
      前端优化指南
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/algorithm/" >
      算法
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/unix-command/" >
      UNIX 常用命令大全
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/unix-optimize/" >
      UNIX 性能优化
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/vue3/" >
      Vue.js 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/git/" >
      Git 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/network/" >
      网络协议
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/awk/" >
      AWK 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/devops/" >
      DevOps
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/sentinel/" >
      阿里巴巴 Sentinel
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/zipkin/" >
      Zipkin 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/eureka/" >
      Netflix Eureka 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/distributed-storage/" >
      分布式存储
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/maven/" >
      Maven 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/java/" >
      Java 教程
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/tutorial/java/stream/" >
      Stream 编程
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/date-time/" >
      Java Date 和 Time
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/classloader/" >
      Java 类加载
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/juc/" >
      JUC 并发包
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/java-io/" >
      Java IO
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/jvm/" >
      JVM
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/basic/" >
      Java 基础
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/java/java-collection/"  class="active">
      Java 集合类
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/spring/" >
      Spring 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/distributed/" >
      分布式系统与架构设计
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/database/" >
      数据库
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/redis/" >
      Redis
  </a>


    

    






  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Java 集合类</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#collections-框架图">Collections 框架图</a></li>
    <li><a href="#list-框架图">List 框架图</a></li>
    <li><a href="#set-框架图">Set 框架图</a></li>
    <li><a href="#map-框架图">Map 框架图</a></li>
    <li><a href="#queue-框架图">Queue 框架图</a></li>
    <li><a href="#hashmap">HashMap</a>
      <ul>
        <li><a href="#数组长度为什么必须是-2-的指数幂">数组长度为什么必须是 2 的指数幂</a></li>
        <li><a href="#如何扩容的">如何扩容的</a></li>
        <li><a href="#元素如何迁移">元素如何迁移</a></li>
        <li><a href="#头插法设计思路">头插法设计思路</a></li>
        <li><a href="#get-方法如何实现的">get 方法如何实现的</a></li>
        <li><a href="#红黑树">红黑树</a></li>
        <li><a href="#keyvalue-可否为-null">key、Value 可否为 null</a></li>
        <li><a href="#并发问题">并发问题</a></li>
      </ul>
    </li>
    <li><a href="#treemap">TreeMap</a>
      <ul>
        <li><a href="#如何保证有序">如何保证有序</a></li>
      </ul>
    </li>
    <li><a href="#linkedhashmap">LinkedHashMap</a>
      <ul>
        <li><a href="#特点">特点</a></li>
        <li><a href="#entry">Entry</a></li>
        <li><a href="#get">get</a></li>
      </ul>
    </li>
    <li><a href="#concurrenthashmap">ConcurrentHashMap</a>
      <ul>
        <li><a href="#插入流程">插入流程</a></li>
        <li><a href="#扩容流程">扩容流程</a></li>
        <li><a href="#jdk7-获取集合大小流程">JDK7 获取集合大小流程</a></li>
        <li><a href="#jdk8-获取集合大小流程">JDK8 获取集合大小流程</a></li>
      </ul>
    </li>
    <li><a href="#arraylist">ArrayList</a>
      <ul>
        <li><a href="#初始容量">初始容量</a></li>
        <li><a href="#如何扩容">如何扩容</a></li>
        <li><a href="#放满了会发生什么">放满了会发生什么</a></li>
        <li><a href="#多线程使用">多线程使用</a></li>
        <li><a href="#transient">transient</a></li>
      </ul>
    </li>
    <li><a href="#fail-fast-机制">fail-fast 机制</a></li>
    <li><a href="#copyonwritearraylist">CopyOnWriteArrayList</a>
      <ul>
        <li><a href="#底层数据结构">底层数据结构</a></li>
        <li><a href="#添加元素">添加元素</a></li>
        <li><a href="#读取元素">读取元素</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  
<ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-8950855178079071"
data-ad-slot="6142361626"
data-ad-format="auto"
data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1 id="java-集合类">Java 集合类</h1>
<h2 id="collections-框架图">Collections 框架图</h2>
<p><img src="/images/docs/tutorial/java/java-collection/collections-framework-overview.png" alt=""></p>
<h2 id="list-框架图">List 框架图</h2>
<p><img src="/images/docs/tutorial/java/java-collection/List-API-class-diagram.png" alt=""></p>
<h2 id="set-框架图">Set 框架图</h2>
<p><img src="/images/docs/tutorial/java/java-collection/Set-API-class-diagram.png" alt=""></p>
<h2 id="map-框架图">Map 框架图</h2>
<p><img src="/images/docs/tutorial/java/java-collection/Map-API-class-diagram.png" alt=""></p>
<h2 id="queue-框架图">Queue 框架图</h2>
<p><img src="/images/docs/tutorial/java/java-collection/Queue-API-class-diagram.png" alt=""></p>
<h2 id="hashmap">HashMap</h2>
<blockquote>
<p>并发下的 HashMap 会有哪些安全问题？</p>
</blockquote>
<p>这里我只是简单的说了<strong>写覆盖</strong>跟<strong>不可重复读</strong>（联想到数据库了），面试官就放我过了。</p>
<blockquote>
<p>添加元素时头插还是尾插？</p>
</blockquote>
<p>1.7 头插，1.8 尾插。</p>
<h3 id="数组长度为什么必须是-2-的指数幂">数组长度为什么必须是 2 的指数幂</h3>
<p>减少哈希冲突，均匀分布元素。</p>
<p>1）通过将 Key 的 hash 值与 length-1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；</p>
<p>2）如果 length 为 2 的次幂，则 length-1 转化为二进制必定是 11111…… 的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</p>
<h3 id="如何扩容的">如何扩容的</h3>
<p>(1) 初始扩容因子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_INITIAL_CAPACITY <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 4<span style="color:#f92672">;</span> <span style="color:#75715e">// aka 16
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> DEFAULT_LOAD_FACTOR <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">75f</span><span style="color:#f92672">;</span>
</code></pre></div><blockquote>
<p>为什么是 <code>0.75</code> 这个值呢？</p>
</blockquote>
<p>这是因为对于使用链表法的哈希表来说，查找一个元素的平均时间是 <code>O(1+n)</code>，这里的 <code>n</code> 指的是遍历链表的长度，因此加载因子越大，对空间的利用就越充分，这就意味着链表的长度越长，查找效率也就越低。如果设置的加载因子太小，那么哈希表的数据将过于稀疏，对空间造成严重浪费。</p>
<p>(2) 何时扩容</p>
<p>首次 <code>put</code> 的时候，如果 <code>table</code> 为空，会执行扩容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
    n <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">=</span> resize<span style="color:#f92672">()).</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
</code></pre></div><p>在 <code>put</code> 方法中，<code>size++</code> 之后的值如果大于 <code>threshold</code>，那么也会执行 <code>resize</code> 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(++</span>size <span style="color:#f92672">&gt;</span> threshold<span style="color:#f92672">)</span>
    resize<span style="color:#f92672">();</span>
</code></pre></div><p>(3) 扩容扩多少</p>
<p>首次扩容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">newCap <span style="color:#f92672">=</span> DEFAULT_INITIAL_CAPACITY<span style="color:#f92672">;</span>
newThr <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)(</span>DEFAULT_LOAD_FACTOR <span style="color:#f92672">*</span> DEFAULT_INITIAL_CAPACITY<span style="color:#f92672">);</span>
</code></pre></div><p>非首次扩容，新的容量和新的 <code>threshold</code> 都是<strong>翻一倍</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">newCap <span style="color:#f92672">=</span> oldCap <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">;</span>
newThr <span style="color:#f92672">=</span> oldThr <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">;</span>
</code></pre></div><h3 id="元素如何迁移">元素如何迁移</h3>
<ul>
<li>创建新的数组</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> newTab <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">[</span>newCap<span style="color:#f92672">];</span>
</code></pre></div><ul>
<li>遍历旧数组</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> oldCap<span style="color:#f92672">;</span> <span style="color:#f92672">++</span>j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> oldTab<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>如果 <code>e.next</code> 不为空，即数组里面只存储了这一个元素</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">newTab<span style="color:#f92672">[</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>newCap <span style="color:#f92672">-</span> 1<span style="color:#f92672">)]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
</code></pre></div><ul>
<li>如果 <code>e</code> 是 <code>TreeNode</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#f92672">((</span>TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>e<span style="color:#f92672">).</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> newTab<span style="color:#f92672">,</span> j<span style="color:#f92672">,</span> oldCap<span style="color:#f92672">);</span>
</code></pre></div><ul>
<li>如果 <code>e</code> 有 <code>next</code>，维持原来的顺序，挂到新的数组上</li>
</ul>
<p>原来的元素在重新计算 <code>hash</code> 之后，会放到两个数组的坑里面。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// (e.hash &amp; oldCap) == 0 的属于 loHead
</span><span style="color:#75715e"></span>newTab<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> loHead<span style="color:#f92672">;</span>
<span style="color:#75715e">// 否则属于 hiHead
</span><span style="color:#75715e"></span>newTab<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> oldCap<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> hiHead<span style="color:#f92672">;</span>
</code></pre></div><h3 id="头插法设计思路">头插法设计思路</h3>
<p>JDK1.7是考虑新增数据大多数是热点数据，所以考虑放在链表头位置，也就是数组中，这样可以提高查询效率，但这种方式会出现插入数据是逆序的。在JDK1.8开始hashmap链表在节点长度达到8之后会变成红黑树，这样一来在数组后节点长度不断增加时，遍历一次的次数就会少很多，相比头插法而言，尾插法操作额外的遍历消耗已经小很多了。</p>
<p>也有很多人说避免多线程情况下hashmap扩容时的死循环问题，我个人觉得避免死循环的关键不在尾插法的改变，而是扩容时，用了首尾两个指针来避免死循环。这个我会在后面的多线程中讲到hashmap扩容导致死循环的问题。</p>
<h3 id="get-方法如何实现的">get 方法如何实现的</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">=</span> getNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">:</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getNode</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> first<span style="color:#f92672">,</span> e<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">;</span> K k<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span>
        <span style="color:#f92672">(</span>first <span style="color:#f92672">=</span> tab<span style="color:#f92672">[(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">])</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>first<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span> <span style="color:#75715e">// always check first node
</span><span style="color:#75715e"></span>            <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
            <span style="color:#66d9ef">return</span> first<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>first <span style="color:#66d9ef">instanceof</span> TreeNode<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> <span style="color:#f92672">((</span>TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>first<span style="color:#f92672">).</span><span style="color:#a6e22e">getTreeNode</span><span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                    <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                    <span style="color:#66d9ef">return</span> e<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>首先使用 <code>(n - 1) &amp; key.hash</code> 定位到这个 <code>key</code> 应该落到 <code>table</code> 的哪一个<strong>桶</strong>里面，其中 <code>n</code> 是指 <code>table</code> 的长度。</li>
<li>然后看这个桶里面的 <code>first</code> 元素是否是目标值，如果是，直接返回。</li>
<li>否则看 <code>first</code> 是否属于 <code>TreeNode</code>，如果是 <code>TreeNode</code>，则调用 <code>getTreeNode</code> 方法；否则沿着 <code>e.next</code> 往下遍历，并依次检查条件 <code>key.hash == k.hash</code> 并且 <code>key.equals(k)</code>。</li>
</ul>
<h3 id="红黑树">红黑树</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TREEIFY_THRESHOLD <span style="color:#f92672">=</span> 8<span style="color:#f92672">;</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> UNTREEIFY_THRESHOLD <span style="color:#f92672">=</span> 6<span style="color:#f92672">;</span>
</code></pre></div><p>Because <strong>TreeNodes are about twice the size of regular nodes</strong>, we use them <strong>only when bins contain enough nodes</strong> to warrant use (see <code>TREEIFY_THRESHOLD</code>). And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a parameter of about <code>0.5</code> on average for the default resizing threshold of <code>0.75</code>, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size <code>k</code> are <code>(exp(-0.5) pow(0.5, k) / factorial(k))</code>. The first values are:</p>
<p>根据泊松分布实验发现，假设hashmap长度length为16，假设放入12（0.75*16）个数据到hashmap中，链表中存放8个节点的概率仅为0.00000006，而链表中存放1~7节点的概率为：</p>
<pre><code>0:    0.60653066
1:    0.30326533
2:    0.07581633
3:    0.01263606
4:    0.00157952
5:    0.00015795
6:    0.00001316
7:    0.00000094
8:    0.00000006
</code></pre><h3 id="keyvalue-可否为-null">key、Value 可否为 null</h3>
<p><img src="/images/docs/tutorial/java/java-collection/kv-can-be-null.png" alt=""></p>
<h3 id="并发问题">并发问题</h3>
<p>(1) 数据丢失</p>
<p>新添加的元素直接放在 <code>slot</code> 槽上，如果两个线程同时执行到这里，那么一个线程的赋值就会被另一个覆盖掉：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> table<span style="color:#f92672">[</span>bucketIndex<span style="color:#f92672">];</span>
table<span style="color:#f92672">[</span>bucketIndex<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">&lt;&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> e<span style="color:#f92672">);</span>
</code></pre></div><p>(2) 循环死链</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">whilte <span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">!=</span> e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> V<span style="color:#f92672">&gt;</span> next <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
    e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newTable<span style="color:#f92672">[</span>5883<span style="color:#f92672">];</span>
    newTable<span style="color:#f92672">[</span>5883<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
    e <span style="color:#f92672">=</span> next<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="treemap">TreeMap</h2>
<h3 id="如何保证有序">如何保证有序</h3>
<p>TreeMap 底层是<strong>红黑树</strong>结构，而红黑树本质是一颗二叉查找树。如下是 <code>put</code> 方法的部分细节即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">Comparator<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> K<span style="color:#f92672">&gt;</span> cpr <span style="color:#f92672">=</span> comparator<span style="color:#f92672">;</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cpr <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
        parent <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
        cmp <span style="color:#f92672">=</span> cpr<span style="color:#f92672">.</span><span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
            t <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
            t <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">return</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span>value<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="linkedhashmap">LinkedHashMap</h2>
<h3 id="特点">特点</h3>
<ul>
<li><strong>循环双向链表</strong></li>
<li>key 和 value 都允许为空</li>
<li>key 重复会覆盖</li>
<li>有序的</li>
<li>LinkedHashMap 是非线程安全的</li>
</ul>
<h3 id="entry">Entry</h3>
<p><code>LinkedHashMap</code> 的 <code>Entry&lt;K,V&gt;</code> 继承了 <code>HashMap.Node&lt;K,V&gt;</code> 的数据结构，并且新增了 <code>before</code>，<code>after</code> 来维护链表插入/访问顺序。<code>head</code> 存储第一个头结点，<code>tail</code> 存储尾结点，<code>accessOrder=true</code> 链表维护访问顺序，<code>false</code> 链表维护插入顺序。这个访问顺序指的是按照最近被访问的Entry的顺序进行排序（从最近最少访问到最近最多访问）。基于这点可以简单实现一个采用**LRU（Least Recently Used）**策略的缓存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> before<span style="color:#f92672">,</span> after<span style="color:#f92672">;</span>
    Entry<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> next<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="get">get</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> getNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>accessOrder<span style="color:#f92672">)</span>
        afterNodeAccess<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="concurrenthashmap">ConcurrentHashMap</h2>
<ul>
<li><code>jdk1.8</code> 之前，<code>ConcurrentHashMap</code> 采用分段锁（Segment），对不同段的 <code>Entry</code> 进行操作互不影响；</li>
<li><code>jdk1.8</code> 之后，<code>ConcurrentHashMap</code> 直接使用Node数组+链表+红黑树，通过 <code>synchronized</code> 和 <code>CAS</code> 来保证并发的可靠性。</li>
</ul>
<p><img src="/images/docs/tutorial/java/java-collection/concurrenthashmap-store-structure.png" alt=""></p>
<h3 id="插入流程">插入流程</h3>
<p><img src="/images/docs/tutorial/java/java-collection/concurrenthashmap-insert-flow.png" alt=""></p>
<p>在插入的時候，有多个地方用到了 <code>synchronized</code>，以 <code>putVal</code> 举例子，在发现想要插入的这个槽的 <code>Node&lt;K, V&gt;</code> 不为空的时候，就会去 <code>synchronized (node)</code> ，去锁住这个槽的链表的第一个 <code>Node&lt;K, V&gt;</code> 节点。</p>
<h3 id="扩容流程">扩容流程</h3>
<p><img src="/images/docs/tutorial/java/java-collection/concurrenthashmap-resize.png" alt=""></p>
<h3 id="jdk7-获取集合大小流程">JDK7 获取集合大小流程</h3>
<p><img src="/images/docs/tutorial/java/java-collection/concurrenthashmap_1_7_size.png" alt=""></p>
<h3 id="jdk8-获取集合大小流程">JDK8 获取集合大小流程</h3>
<ul>
<li>并发量较小，优先使用 CAS 直接更新 baseCount</li>
<li>更新 baseCount 冲突，则会认为进入到比较激烈的竞争状态，通过启用 counterCells 减少竞争，通过 CAS 的方式把总数更新情况记录在 counterCells 对应的位置上</li>
<li>如果更新 counterCells 上的某个位置出现了多次失败，则会通过扩容 counterCells 的方式减少冲突</li>
<li>当 counterCells 处在扩容期间时，会尝试更新 baseCount 值</li>
</ul>
<p>对于元素总数的统计，逻辑就非常简单了，只需要让 baseCount 加上各 counterCells 内的数据，就可以得出哈希内的元素总数，整个过程不需要借助锁。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// 记录了元素总数值，CAS 更新这个值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> baseCount<span style="color:#f92672">;</span>
<span style="color:#75715e">// 计数器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CounterCell</span> <span style="color:#f92672">{}</span>
<span style="color:#75715e">// 竞争激烈，线程会把总数更新情况存放到这个数组中
</span><span style="color:#75715e">// 竞争进一步加剧，会通过扩容减少竞争
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> CounterCell<span style="color:#f92672">[]</span> counterCells<span style="color:#f92672">;</span>
</code></pre></div><h2 id="arraylist">ArrayList</h2>
<h3 id="初始容量">初始容量</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Default initial capacity.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_CAPACITY <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Shared empty array instance used for default sized empty instances. We
</span><span style="color:#75715e"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
</span><span style="color:#75715e"> * first element is added.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Object<span style="color:#f92672">[]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span style="color:#f92672">=</span> <span style="color:#f92672">{};</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Constructs an empty list with an initial capacity of ten.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ArrayList</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">elementData</span> <span style="color:#f92672">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><code>new ArrayList()</code> 时拥有的是一个<strong>空数组</strong>，在第一次 <code>add</code> 的时候，才会创建一个长度为 10 的数组。</p>
<h3 id="如何扩容">如何扩容</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">grow</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// overflow-conscious code
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> elementData<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> oldCapacity <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>oldCapacity <span style="color:#f92672">&gt;&gt;</span> 1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> minCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
        newCapacity <span style="color:#f92672">=</span> minCapacity<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> MAX_ARRAY_SIZE <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
        newCapacity <span style="color:#f92672">=</span> hugeCapacity<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
    <span style="color:#75715e">// minCapacity is usually close to size, so this is a win:
</span><span style="color:#75715e"></span>    elementData <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOf</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> newCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>扩容后新的数组长度为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是<strong>旧容量的 1.5 倍</strong></li>
<li>然后使用 <code>Arrays.copyOf</code> 静态方法将旧数组里面的内容<strong>全部拷贝</strong>到新的数组里面</li>
</ul>
<h3 id="放满了会发生什么">放满了会发生什么</h3>
<p>抛出 OOM 异常：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hugeCapacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#75715e">// overflow
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> OutOfMemoryError<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>minCapacity <span style="color:#f92672">&gt;</span> MAX_ARRAY_SIZE<span style="color:#f92672">)</span> <span style="color:#f92672">?</span>
        Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">:</span>
        MAX_ARRAY_SIZE<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="多线程使用">多线程使用</h3>
<ul>
<li>数组越界异常</li>
<li>元素值覆盖和为空问题</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">elementData<span style="color:#f92672">[</span>size<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> e
</code></pre></div><h3 id="transient">transient</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">transient</span> Object<span style="color:#f92672">[]</span> elementData<span style="color:#f92672">;</span>
</code></pre></div><p><code>ArrayList</code>在序列化的时候会调用<code>writeObject</code>，直接将<code>size</code>和<code>element</code>写入<code>ObjectOutputStream</code>；反序列化时调用<code>readObject</code>，从<code>ObjectInputStream</code>获取<code>size</code>和<code>element</code>，再恢复到<code>elementData</code>。</p>
<p>为什么不直接用<code>elementData</code>来序列化，而采用上诉的方式来实现序列化呢？原因在于<code>elementData</code>是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证<strong>只序列化实际存储的那些元素</strong>，而不是整个数组，从而节省空间和时间。</p>
<h2 id="fail-fast-机制">fail-fast 机制</h2>
<p>fail-fast 机制是一种对集合遍历操作时的错误检测机制，在遍历中途出现意料之外的修改时，通过 unchecked 异常暴力地反馈出来。这种机制经常出现在多线程环境下，当前线程会维护一个计数比较器，即 <code>expectedModCount</code>，记录已经修改的次数。在进入遍历前, 会把实时修改次数 <code>modCount</code> 赋值给 <code>expectedModCount</code> ,如果这两个数据不相等，则抛出异常。<code>java.util</code> 下的所有集合类都是 fail-fast，而 concurrent 包中的集合类都是 fail-safe 。</p>
<p>(1) <code>masterList</code> 集合元素个数的增加、删除，均会导致子列表的遍历、增加、删除，进而产生 fail-fast 机制。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">List masterList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>
masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;one&#34;</span><span style="color:#f92672">);</span>
masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;two&#34;</span><span style="color:#f92672">);</span>
masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;three&#34;</span><span style="color:#f92672">);</span>
masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;cour&#34;</span><span style="color:#f92672">);</span>
masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;five&#34;</span><span style="color:#f92672">);</span>

List branchList <span style="color:#f92672">=</span> masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">subList</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 3<span style="color:#f92672">);</span>

<span style="color:#75715e">// 下面三行代码，会导致 branchList 操作会出现 ConcurrentModificationException 异常
</span><span style="color:#75715e"></span>masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>O<span style="color:#f92672">);</span>
masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ten&#34;</span><span style="color:#f92672">);</span>
masterList<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
</code></pre></div><p>(2) foreach 遍历，产生 fail-fast 异常</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;one&#34;</span><span style="color:#f92672">);</span>
list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;two&#34;</span><span style="color:#f92672">);</span>
list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;three&#34;</span><span style="color:#f92672">);</span>

<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String s <span style="color:#f92672">:</span> list<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;one&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>s<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        list<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="copyonwritearraylist">CopyOnWriteArrayList</h2>
<h3 id="底层数据结构">底层数据结构</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">transient</span> ReentrantLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock<span style="color:#f92672">();</span>

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> Object<span style="color:#f92672">[]</span> array<span style="color:#f92672">;</span>

<span style="color:#75715e">// 内部只能通过 getArray() 访问 array
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> Object<span style="color:#f92672">[]</span> <span style="color:#a6e22e">getArray</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> array<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="添加元素">添加元素</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>E e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> ReentrantLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">;</span>
    lock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        Object<span style="color:#f92672">[]</span> elements <span style="color:#f92672">=</span> getArray<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> elements<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        Object<span style="color:#f92672">[]</span> newElements <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOf</span><span style="color:#f92672">(</span>elements<span style="color:#f92672">,</span> len <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
        newElements<span style="color:#f92672">[</span>len<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
        setArray<span style="color:#f92672">(</span>newElements<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        lock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="读取元素">读取元素</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">private</span> E <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>E<span style="color:#f92672">)</span> a<span style="color:#f92672">[</span>index<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> E <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> get<span style="color:#f92672">(</span>getArray<span style="color:#f92672">(),</span> index<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/106638832">Java集合之LinkedHashMap实现与原理</a></li>
</ul>

<ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-8950855178079071"
data-ad-slot="6142361626"
data-ad-format="auto"
data-full-width-responsive="true"></ins>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  </div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#collections-框架图">Collections 框架图</a></li>
    <li><a href="#list-框架图">List 框架图</a></li>
    <li><a href="#set-框架图">Set 框架图</a></li>
    <li><a href="#map-框架图">Map 框架图</a></li>
    <li><a href="#queue-框架图">Queue 框架图</a></li>
    <li><a href="#hashmap">HashMap</a>
      <ul>
        <li><a href="#数组长度为什么必须是-2-的指数幂">数组长度为什么必须是 2 的指数幂</a></li>
        <li><a href="#如何扩容的">如何扩容的</a></li>
        <li><a href="#元素如何迁移">元素如何迁移</a></li>
        <li><a href="#头插法设计思路">头插法设计思路</a></li>
        <li><a href="#get-方法如何实现的">get 方法如何实现的</a></li>
        <li><a href="#红黑树">红黑树</a></li>
        <li><a href="#keyvalue-可否为-null">key、Value 可否为 null</a></li>
        <li><a href="#并发问题">并发问题</a></li>
      </ul>
    </li>
    <li><a href="#treemap">TreeMap</a>
      <ul>
        <li><a href="#如何保证有序">如何保证有序</a></li>
      </ul>
    </li>
    <li><a href="#linkedhashmap">LinkedHashMap</a>
      <ul>
        <li><a href="#特点">特点</a></li>
        <li><a href="#entry">Entry</a></li>
        <li><a href="#get">get</a></li>
      </ul>
    </li>
    <li><a href="#concurrenthashmap">ConcurrentHashMap</a>
      <ul>
        <li><a href="#插入流程">插入流程</a></li>
        <li><a href="#扩容流程">扩容流程</a></li>
        <li><a href="#jdk7-获取集合大小流程">JDK7 获取集合大小流程</a></li>
        <li><a href="#jdk8-获取集合大小流程">JDK8 获取集合大小流程</a></li>
      </ul>
    </li>
    <li><a href="#arraylist">ArrayList</a>
      <ul>
        <li><a href="#初始容量">初始容量</a></li>
        <li><a href="#如何扩容">如何扩容</a></li>
        <li><a href="#放满了会发生什么">放满了会发生什么</a></li>
        <li><a href="#多线程使用">多线程使用</a></li>
        <li><a href="#transient">transient</a></li>
      </ul>
    </li>
    <li><a href="#fail-fast-机制">fail-fast 机制</a></li>
    <li><a href="#copyonwritearraylist">CopyOnWriteArrayList</a>
      <ul>
        <li><a href="#底层数据结构">底层数据结构</a></li>
        <li><a href="#添加元素">添加元素</a></li>
        <li><a href="#读取元素">读取元素</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279346965'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279346965%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>



</html>












