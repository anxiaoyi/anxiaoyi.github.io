<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/tutorial/algorithm/</link>
    <description>Recent content in 算法 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://kunzhao.org/docs/tutorial/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>回溯法</title>
      <link>https://kunzhao.org/docs/tutorial/algorithm/backtracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/algorithm/backtracking/</guid>
      <description>回溯法 回溯法的套路解法在这篇文章中给了详细的说明。
岛屿数量 输入：grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;] ] 输出：3  图的深度优先遍历，将 1 置为 0  public int numIslands(char[][] grid) { int num = 0; for (int i = 0; i &amp;lt; grid.length; i++) { for (int j = 0; j &amp;lt; grid[i].length; j++) { if (grid[i][j] == &amp;#39;1&amp;#39;) { num++; mark(grid, i, j); } } } return num; } private void mark(char[][] grid, int i, int j) { if (i &amp;lt; 0 || i &amp;gt;= grid.</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://kunzhao.org/docs/tutorial/algorithm/array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/algorithm/array/</guid>
      <description>数组 无序数组第 K 大的数字  partition 算法每次返回的都是 pivot 所在的索引 partition 算法实现的思路，i 指向的是小于 pivot 的数列的最后一个值的索引。j 在前面探路，如果遇见小于等于 pivot 的值 arr[j]，说明这个值应该放在前半段，那么它应该前半段的谁交换呢？答案就是这个 arr[j] 应该添加到 i 的下一个位置。也就是需要 swap(++i, j)。 最后 swap(++i, high)，将 pivot 放到中间。  小小小小小大大大大小...pivot i j public int findKthLargest(int[] nums, int k) { k = nums.length - k; // 1 2 3 4 5 6  // ↑(第 2 大)  // ↑(partition = 2 的时候，实际上指向的是这里)  int lo = 0; int hi = nums.</description>
    </item>
    
    <item>
      <title>树</title>
      <link>https://kunzhao.org/docs/tutorial/algorithm/tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/algorithm/tree/</guid>
      <description>树 二叉树的最近公共祖先  先看孩子是否有可能是公共祖先，最后看树根有没有可能是公共祖先。因为树根总是祖先。是用来兜底的。 root 是 p 的祖先，那么 p 是 root 的子系亲属或者孙子系亲属，即向下的亲属关系。  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root != null) { TreeNode left = lowestCommonAncestor(root.left, p, q); if (left != null) { return left; } TreeNode right = lowestCommonAncestor(root.right, p, q); if (right != null) { return right; } if (isSubNode(root, p) &amp;amp;&amp;amp; isSubNode(root, q)) { return root; } } return null; } private boolean isSubNode(TreeNode root, TreeNode p) { if (root == null) { return false; } if (root.</description>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://kunzhao.org/docs/tutorial/algorithm/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/algorithm/string/</guid>
      <description>字符串 字符串相加  使用两个指针 index-- 即可  public String addStrings(String num1, String num2) { if (num1 == null) { return num2; } if (num2 == null) { return num1; } final StringBuilder sb = new StringBuilder(Math.max(num1.length(), num2.length()) + 1); int index1 = num1.length() - 1; int index2 = num2.length() - 1; int remainder = 0; while (index1 &amp;gt;= 0 &amp;amp;&amp;amp; index2 &amp;gt;= 0) { char a = num1.charAt(index1); char b = num2.</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://kunzhao.org/docs/tutorial/algorithm/dp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/algorithm/dp/</guid>
      <description>动态规划 买卖股票的最佳时机  用一个变量记录一个历史最低价格 minprice，如果当前值比 minPrice 小，则更新 minPrice。即我们全程都在寻找一个历史最低值。 否则就考虑是否可以卖出：看当前值减去 minPrice 是否可以更新 maxProfit。  public int maxProfit(int prices[]) { int minprice = Integer.MAX_VALUE; int maxprofit = 0; for (int i = 0; i &amp;lt; prices.length; i++) { if (prices[i] &amp;lt; minprice) { minprice = prices[i]; } else if (prices[i] - minprice &amp;gt; maxprofit) { maxprofit = prices[i] - minprice; } } return maxprofit; } 最大子序和 找到一个具有最大和的连续子数组。
 看当前累加的 sum 对求最终的最大和是否有正向的增益效果。
 腾讯：返回子数组</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://kunzhao.org/docs/tutorial/algorithm/linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/algorithm/linkedlist/</guid>
      <description>链表 反转链表 头条：迭代、递归都要写出来。
迭代版本：
public ListNode reverseList(ListNode head) { ListNode newHead = new ListNode(); while (head != null) { // 5 -&amp;gt; 4 -&amp;gt; 3  //  ListNode tmp = head.next; head.next = newHead.next; newHead.next = head; head = tmp; } return newHead.next; } 递归版本。
 将链表想象为：head -&amp;gt; 其余部分，那么翻转 其余部分 如何翻转：p = reverseList(head.next)。其余部分 的 next 的节点需要指向 head，head 的 next 节点需要置为 null，以确保 head 变成了末尾节点。最后返回 p 节点。
  在写的时候，有一次写成了 p.next = head，这里是不正确的。head.</description>
    </item>
    
  </channel>
</rss>
