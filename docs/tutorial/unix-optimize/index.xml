<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>UNIX 性能优化 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/tutorial/unix-optimize/</link>
    <description>Recent content in UNIX 性能优化 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://kunzhao.org/docs/tutorial/unix-optimize/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>平均负载</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/avg-load/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/avg-load/</guid>
      <description>平均负载  作者：赵坤
 uptime 命令 了解负载情况：
$ uptime 22:39:37 up 2:47, 1 user, load average: 1.44, 1.12, 0.79 含义：
# 当前时间 22:39:37 # 系统运行多久了 up 2:47 # 当前有几个用户登录 1 user # 过去 1 分钟、5 分钟、15 分钟的平均负载 load average: 1.44, 1.12, 0.79 平均负载的含义  平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。
  可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。  $ ps -efl F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD 4 S root 1 0 0 80 0 - 42420 - 19:51 ?</description>
    </item>
    
    <item>
      <title>CPU 上下文切换</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/context-switch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/context-switch/</guid>
      <description>CPU 上下文切换  作者：赵坤
 CPU 上下文  CPU 上下文是 CPU 在运行任何任务前，必须的依赖环境。在每个任务运行前，CPU 需要知道任务从哪里加载、又从哪里开始运行，所以这些环境通常包括 CPU 寄存器和程序计数器等。
 查看系统上下文切换情况 可以使用 vmstat 查询：
# 每隔 5 秒查询一次 $ vmstat 5 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 256 170532 136656 3361432 0 0 38 53 189 557 6 2 92 0 0 0 0 256 170060 136668 3362284 0 0 0 62 441 785 2 1 97 0 0 0 0 256 170320 136676 3362360 0 0 0 13 706 1002 3 1 97 0 0  cs：每秒上下文切换的次数</description>
    </item>
    
    <item>
      <title>内存</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/memory/</guid>
      <description>内存  作者：赵坤
 内存分配 首先给出 32 位系统虚拟内存空间分布图：
在 C 语言中，内存分配采用 malloc() 函数进行分配。底层实现：
 申请的内存小于 128K，使用 brk() 函数完成，也就是从上图中的堆中分配的内存 申请的内存大于 128K，使用 mmap() 内存映射函数完成，也就是从上图中的文件映射中分配的内存  内存回收 应用程序应通过 free() 或 unmap() 来释放内存。
当然，系统也会监管进程的内存，当发现系统内存不足时，会采取措施：
 使用 LRU 算法回收缓存 回收不常访问的内存，写到 Swap 区（位于硬盘上） 杀死进程  查看整个系统的内存 $ free total used free shared buff/cache available Mem: 6030036 2312004 266488 624252 3451544 2911700 Swap: 2097148 256 2096892 查看某个进程的内存 使用 top 或 ps：
$ top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 8883 zk 20 0 16.</description>
    </item>
    
    <item>
      <title>磁盘 I/O</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/io/</guid>
      <description>磁盘 I/O  作者：赵坤
 虚拟文件系统 I/O 调度 为了减小不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理各种不同的块设备。通用块层，其实是处在文件系统和磁盘驱动中间的一个块设备抽象层。它会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。
Linux 内核支持四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine。
 NONE，不使用 I/O 调度算法 NOOP，先入先出 CFQ（Completely Fair Scheduler），为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求 DeadLine，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理  每块磁盘 I/O 性能 $ iostat -d -x 1 Linux 5.4.0-42-generic (zk) 2020年09月02日 _x86_64_	(4 CPU) Device r/s rkB/s rrqm/s %rrqm r_await rareq-sz w/s wkB/s wrqm/s %wrqm w_await wareq-sz d/s dkB/s drqm/s %drqm d_await dareq-sz aqu-sz %util loop0 0.</description>
    </item>
    
  </channel>
</rss>
