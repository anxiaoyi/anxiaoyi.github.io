<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>UNIX 性能优化 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/tutorial/unix-optimize/</link>
    <description>Recent content in UNIX 性能优化 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://kunzhao.org/docs/tutorial/unix-optimize/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>平均负载</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/avg-load/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/avg-load/</guid>
      <description>平均负载  作者：赵坤
 uptime 命令 了解负载情况：
$ uptime 22:39:37 up 2:47, 1 user, load average: 1.44, 1.12, 0.79 含义：
# 当前时间 22:39:37 # 系统运行多久了 up 2:47 # 当前有几个用户登录 1 user # 过去 1 分钟、5 分钟、15 分钟的平均负载 load average: 1.44, 1.12, 0.79 平均负载的含义  平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。
  可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。  $ ps -efl F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD 4 S root 1 0 0 80 0 - 42420 - 19:51 ?</description>
    </item>
    
    <item>
      <title>CPU 上下文切换</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/context-switch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/context-switch/</guid>
      <description>CPU 上下文切换  作者：赵坤
 CPU 上下文  CPU 上下文是 CPU 在运行任何任务前，必须的依赖环境。在每个任务运行前，CPU 需要知道任务从哪里加载、又从哪里开始运行，所以这些环境通常包括 CPU 寄存器和程序计数器等。
 查看系统上下文切换情况 可以使用 vmstat 查询：
# 每隔 5 秒查询一次 $ vmstat 5 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 256 170532 136656 3361432 0 0 38 53 189 557 6 2 92 0 0 0 0 256 170060 136668 3362284 0 0 0 62 441 785 2 1 97 0 0 0 0 256 170320 136676 3362360 0 0 0 13 706 1002 3 1 97 0 0  cs：每秒上下文切换的次数</description>
    </item>
    
    <item>
      <title>CPU 飙升或 load 飙升</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/high-cpu-and-load/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/high-cpu-and-load/</guid>
      <description>CPU 飙升或 load 飙升 CPU 使用率飙升怎么办 ? 通过 top、ps、pidstat 等工具，你能够轻松找到 CPU 使用率较高（比如 100% ）的进程。接下来，你可能又想知道，占用 CPU 的到底是代码里的哪个函数呢？找到它，你才能更高效、更针对性地进行优化。
哪种工具适合在第一时间分析进程的 CPU 问题呢？我的推荐是 perf。perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。
# -g开启调用关系分析，-p指定php-fpm的进程号21515 $ perf top -g -p 21515  用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。 系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。  load 飙升怎么办 ? 用 iostat、mpstat、pidstat 等工具，找出平均负载升高的根源。
 平均负载高有可能是 CPU 密集型进程导致的； 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了； 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。  </description>
    </item>
    
    <item>
      <title>内存</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/memory/</guid>
      <description>内存  作者：赵坤
 内存分配 首先给出 32 位系统虚拟内存空间分布图：
在 C 语言中，内存分配采用 malloc() 函数进行分配。底层实现：
 申请的内存小于 128K，使用 brk() 函数完成，也就是从上图中的堆中分配的内存 申请的内存大于 128K，使用 mmap() 内存映射函数完成，也就是从上图中的文件映射中分配的内存  内存回收 应用程序应通过 free() 或 unmap() 来释放内存。
当然，系统也会监管进程的内存，当发现系统内存不足时，会采取措施：
 使用 LRU 算法回收缓存 回收不常访问的内存，写到 Swap 区（位于硬盘上） 杀死进程  查看整个系统的内存 $ free total used free shared buff/cache available Mem: 6030036 2312004 266488 624252 3451544 2911700 Swap: 2097148 256 2096892 查看某个进程的内存 使用 top 或 ps：
$ top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 8883 zk 20 0 16.</description>
    </item>
    
    <item>
      <title>磁盘 I/O</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/io/</guid>
      <description>磁盘 I/O  作者：赵坤
 虚拟文件系统 I/O 调度 为了减小不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理各种不同的块设备。通用块层，其实是处在文件系统和磁盘驱动中间的一个块设备抽象层。它会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。
Linux 内核支持四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine。
 NONE，不使用 I/O 调度算法 NOOP，先入先出 CFQ（Completely Fair Scheduler），为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求 DeadLine，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理  每块磁盘 I/O 性能 $ iostat -d -x 1 Linux 5.4.0-42-generic (zk) 2020年09月02日 _x86_64_	(4 CPU) Device r/s rkB/s rrqm/s %rrqm r_await rareq-sz w/s wkB/s wrqm/s %wrqm w_await wareq-sz d/s dkB/s drqm/s %drqm d_await dareq-sz aqu-sz %util loop0 0.</description>
    </item>
    
    <item>
      <title>Linux 零拷贝</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/zero-copy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/zero-copy/</guid>
      <description>Linux 零拷贝 为什么需要零拷贝  传统 read，write I/O 接口，数据拷贝的好处：通过中间缓存的机制，**减少磁盘 I/O **的操作 拷贝的坏处：大量数据的拷贝，用户态和内核态的频繁切换，会消耗大量的 CPU 资源，严重影响数据传输的性能  什么是零拷贝 零拷贝就是这个问题的一个解决方案，通过尽量避免拷贝操作来缓解 CPU 的压力。Linux 下常见的零拷贝技术可以分为两大类：一是针对特定场景，去掉不必要的拷贝；二是去优化整个拷贝的过程。由此看来，零拷贝并没有真正做到“0”拷贝，它更多是一种思想，很多的零拷贝技术都是基于这个思想去做的优化。
零拷贝的几种方法 原始数据拷贝操作 在介绍之前，先看看 Linux 原始的数据拷贝操作是怎样的。如下图，假如一个应用需要从某个磁盘文件中读取内容通过网络发出去，像这样：
while((n = read(diskfd, buf, BUF_SIZE)) &amp;gt; 0) write(sockfd, buf , n); 那么整个过程就需要经历：
 1）read 将数据从磁盘文件通过 DMA 等方式拷贝到内核开辟的缓冲区； 2）数据从内核缓冲区复制到用户态缓冲区； 3）write 将数据从用户态缓冲区复制到内核协议栈开辟的 socket 缓冲区； 4）数据从 socket 缓冲区通过 DMA 拷贝到网卡上发出去。  可见，整个过程发生了至少四次数据拷贝，其中两次是 DMA 与硬件通讯来完成，CPU 不直接参与，去掉这两次，仍然有两次 CPU 数据拷贝操作。
方法一：用户态直接 I/O 这种方法可以使应用程序或者运行在用户态下的库函数直接访问硬件设备，数据直接跨过内核进行传输，内核在整个数据传输过程除了会进行必要的虚拟存储配置工作之外，不参与其他任何工作，这种方式能够直接绕过内核，极大提高了性能。
缺陷：
 1）这种方法只能适用于那些不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如数据库管理系统就是一个代表。 2）这种方法直接操作磁盘 I/O，由于 CPU 和磁盘 I/O 之间的执行时间差距，会造成资源的浪费，解决这个问题需要和异步 I/O 结合使用。  方法二：mmap 这种方法，使用 mmap 来代替 read，可以减少一次拷贝操作，如下：</description>
    </item>
    
    <item>
      <title>同步/异步与阻塞/非阻塞</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/async_block/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/async_block/</guid>
      <description>同步/异步与阻塞/非阻塞  两组概念不在同一个纬度
 同步/异步 同步：操作者主动完成了这件事情，需要自己完成的操作都是同步操作。
异步：调用指令发出，操作马上返回，处理完成后，再通过通知的手段来告诉操作者结果，不是调用者自己完成的。
阻塞/非阻塞 阻塞：从头到尾只做这一件事情，不能做其他事情：
非阻塞：无需等待在这里，反复过来检查：
总结  POSIX defines these two terms as follows: A synchronous I/O operation causes therequesting process to be blocked until that I/O operation completes. An asynchronous I/O operation does not cause the requesting process to be blocked. Using these definitions, the first four I/O modes - blocking, nonblocking, I/O multiplexing, and signal-driven I/O - are all synchronous because the actual I/O operation (recvfrom) blocks the process.</description>
    </item>
    
    <item>
      <title>线程</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/thread/</guid>
      <description>线程 生命周期 自发性上下文切换 自发性上下文切换指线程由 Java 程序调用导致切出，在多线程编程中，执行调用以下方法或关键字，常常就会引发自发性上下文切换。sleep()、wait()、yield()、join()、park()、synchronized、lock。</description>
    </item>
    
  </channel>
</rss>
