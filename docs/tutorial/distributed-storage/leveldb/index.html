<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="leveldb 源码分析与实现"><meta property="og:title" content="leveldb 源码分析与实现" />
<meta property="og:description" content="leveldb 源码分析与实现  源代码基于 1.22 之后的版本
 特性 leveldb 是一个键值对 library，它的键是有序排列的，用户也可以提供自定义的键比较器，多个操作也可以合并为一起，进行原子操作更新。其架构如下:
编译 mkdir -p build &amp;&amp; cd build cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build . 如果 Ubuntu 提示 No CMAKE_CXX_COMPILER could be found :
sudo apt-get update &amp;&amp; sudo apt-get install build-essential 打开数据库 Options // Options to control the behavior of a database (passed to DB::Open) struct LEVELDB_EXPORT Options { // Create an Options object with default values for all fields." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kunzhao.org/docs/tutorial/distributed-storage/leveldb/" />

<title>leveldb 源码分析与实现 | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.2c8703ef3571e9e1469d79306fda1ed51333153e6ba74aff763a8bc7a9fdaea2.css" integrity="sha256-LIcD7zVx6eFGnXkwb9oe1RMzFT5rp0r/djqLx6n9rqI=">


<script defer src="/en.search.min.1e7619796b61414a9016ae3ce0c51191e796bfabae1a014100792c00d2d6c838.js" integrity="sha256-HnYZeWthQUqQFq484MURkeeWv6uuGgFBAHksANLWyDg="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡 教程
  </a>


    

    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/front-end-optimization-guide/" >
      前端优化指南
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/algorithm/" >
      算法
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/unix-command/" >
      UNIX 常用命令大全
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/unix-optimize/" >
      UNIX 性能优化
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/vue3/" >
      Vue.js 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/git/" >
      Git 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/network/" >
      网络协议
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/awk/" >
      AWK 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/devops/" >
      DevOps
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/sentinel/" >
      阿里巴巴 Sentinel
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/zipkin/" >
      Zipkin 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/eureka/" >
      Netflix Eureka 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/distributed-storage/" >
      分布式存储
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/tutorial/distributed-storage/c_cpp/" >
      C &amp; C&#43;&#43;
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/distributed-storage/leveldb/"  class="active">
      leveldb 源码分析与实现
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/tutorial/distributed-storage/leveldb-read/" >
      leveldb 源码分析与实现 - 读取
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/maven/" >
      Maven 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/java/" >
      Java 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/spring/" >
      Spring 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/distributed/" >
      分布式系统与架构设计
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/database/" >
      数据库
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/redis/" >
      Redis
  </a>


    

    






  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>leveldb 源码分析与实现</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#特性">特性</a></li>
    <li><a href="#编译">编译</a></li>
    <li><a href="#打开数据库">打开数据库</a>
      <ul>
        <li><a href="#options">Options</a></li>
        <li><a href="#versionedit">VersionEdit</a></li>
      </ul>
    </li>
    <li><a href="#put">Put</a>
      <ul>
        <li><a href="#slice">Slice</a></li>
        <li><a href="#底层存储数据的地方">底层存储数据的地方</a></li>
        <li><a href="#写入顺序">写入顺序</a></li>
        <li><a href="#写-log-日志文件">写 Log 日志文件</a></li>
        <li><a href="#写到-memtable-内存数据库中">写到 MemTable 内存数据库中</a></li>
      </ul>
    </li>
    <li><a href="#delete">Delete</a></li>
    <li><a href="#snapshot-快照">Snapshot 快照</a>
      <ul>
        <li><a href="#创建快照">创建快照</a></li>
      </ul>
    </li>
    <li><a href="#数据库文件">数据库文件</a>
      <ul>
        <li><a href="#数据库所有文件">数据库所有文件</a></li>
        <li><a href="#log-logold">LOG, LOG.old</a></li>
        <li><a href="#log"><code>*.log</code></a></li>
        <li><a href="#lock">LOCK</a></li>
      </ul>
    </li>
    <li><a href="#compaction">Compaction</a></li>
    <li><a href="#版本管理">版本管理</a>
      <ul>
        <li><a href="#环形双端链表">环形双端链表</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  
<ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-8950855178079071"
data-ad-slot="6142361626"
data-ad-format="auto"
data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1 id="leveldb-源码分析与实现">leveldb 源码分析与实现</h1>
<blockquote>
<p>源代码基于 <strong>1.22</strong> 之后的版本</p>
</blockquote>
<h2 id="特性">特性</h2>
<p>leveldb 是一个<strong>键值对</strong> library，它的键是<strong>有序</strong>排列的，用户也可以提供自定义的键比较器，多个操作也可以合并为一起，进行<strong>原子操作更新</strong>。其架构如下:</p>
<p><img src="/images/docs/tutorial/distributed-storage/leveldb/architecture.png" alt=""></p>
<h2 id="编译">编译</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mkdir -p build <span style="color:#f92672">&amp;&amp;</span> cd build
cmake -DCMAKE_BUILD_TYPE<span style="color:#f92672">=</span>Release .. <span style="color:#f92672">&amp;&amp;</span> cmake --build .
</code></pre></div><p>如果 <code>Ubuntu</code> 提示 <code>No CMAKE_CXX_COMPILER could be found</code> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo apt-get update <span style="color:#f92672">&amp;&amp;</span> sudo apt-get install build-essential
</code></pre></div><h2 id="打开数据库">打开数据库</h2>
<h3 id="options">Options</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// Options to control the behavior of a database (passed to DB::Open)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LEVELDB_EXPORT</span> Options {
  <span style="color:#75715e">// Create an Options object with default values for all fields.
</span><span style="color:#75715e"></span>  Options();

  <span style="color:#75715e">// -------------------
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Parameters that affect behavior
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// Comparator 用来决定 key 在 table 中的顺序.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Default: a comparator that uses lexicographic byte-wise ordering
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// REQUIRES: The client must ensure that the comparator supplied
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// here has the same name and orders keys *exactly* the same as the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// comparator provided to previous open calls on the same DB.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> Comparator<span style="color:#f92672">*</span> comparator;

  <span style="color:#75715e">// If true, the database will be created if it is missing.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> create_if_missing <span style="color:#f92672">=</span> false;

  <span style="color:#75715e">// If true, an error is raised if the database already exists.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> error_if_exists <span style="color:#f92672">=</span> false;

  <span style="color:#75715e">// If true, the implementation will do aggressive checking of the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// data it is processing and will stop early if it detects any
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// errors.  This may have unforeseen ramifications: for example, a
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// corruption of one DB entry may cause a large number of entries to
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// become unreadable or for the entire DB to become unopenable.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> paranoid_checks <span style="color:#f92672">=</span> false;

  <span style="color:#75715e">// Use the specified object to interact with the environment,
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// e.g. to read/write files, schedule background work, etc.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Default: Env::Default()
</span><span style="color:#75715e"></span>  Env<span style="color:#f92672">*</span> env;

  <span style="color:#75715e">// Any internal progress/error information generated by the db will
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// be written to info_log if it is non-null, or to a file stored
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// in the same directory as the DB contents if info_log is null.
</span><span style="color:#75715e"></span>  Logger<span style="color:#f92672">*</span> info_log <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

  <span style="color:#75715e">// -------------------
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Parameters that affect performance
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 存储在内存中的数据 (backed by an unsorted log
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// on disk) before converting to a sorted on-disk file.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 数值较大有助于提升性能 especially during bulk loads.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Up to two write buffers may be held in memory at the same time,
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// so you may wish to adjust this parameter to control memory usage.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 不过，数值较大也可能造成在下次打开 leveldb 数据库的时候加载时间过长
</span><span style="color:#75715e"></span>  size_t write_buffer_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>;

  <span style="color:#75715e">// DB 最多可以打开多少文件.  You may need to
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// increase this if your database has a large working set (budget
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// one open file per 2MB of working set).
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> max_open_files <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;

  <span style="color:#75715e">// Control over blocks (user data is stored in a set of blocks, and
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// a block is the unit of reading from disk).
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// If non-null, use the specified cache for blocks.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// If null, leveldb will automatically create and use an 8MB internal cache.
</span><span style="color:#75715e"></span>  Cache<span style="color:#f92672">*</span> block_cache <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

  <span style="color:#75715e">// Approximate size of user data packed per block.  Note that the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// block size specified here corresponds to uncompressed data.  The
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// actual size of the unit read from disk may be smaller if
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// compression is enabled.  This parameter can be changed dynamically.
</span><span style="color:#75715e"></span>  size_t block_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>;

  <span style="color:#75715e">// Number of keys between restart points for delta encoding of keys.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// This parameter can be changed dynamically.  Most clients should
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// leave this parameter alone.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> block_restart_interval <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>;

  <span style="color:#75715e">// Leveldb will write up to this amount of bytes to a file before
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// switching to a new one.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Most clients should leave this parameter alone.  However if your
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// filesystem is more efficient with larger files, you could
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// consider increasing the value.  The downside will be longer
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// compactions and hence longer latency/performance hiccups.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Another reason to increase this parameter might be when you are
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// initially populating a large database.
</span><span style="color:#75715e"></span>  size_t max_file_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>;

  <span style="color:#75715e">// Compress blocks using the specified compression algorithm.  This
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// parameter can be changed dynamically.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Default: kSnappyCompression, which gives lightweight but fast
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// compression.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//    ~200-500MB/s compression
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//    ~400-800MB/s decompression
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Note that these speeds are significantly faster than most
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// persistent storage speeds, and therefore it is typically never
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// worth switching to kNoCompression.  Even if the input data is
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// incompressible, the kSnappyCompression implementation will
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// efficiently detect that and will switch to uncompressed mode.
</span><span style="color:#75715e"></span>  CompressionType compression <span style="color:#f92672">=</span> kSnappyCompression;

  <span style="color:#75715e">// EXPERIMENTAL: If true, append to existing MANIFEST and log files
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// when a database is opened.  This can significantly speed up open.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Default: currently false, but may become true later.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> reuse_logs <span style="color:#f92672">=</span> false;

  <span style="color:#75715e">// If non-null, use the specified filter policy to reduce disk reads.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Many applications will benefit from passing the result of
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// NewBloomFilterPolicy() here.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> FilterPolicy<span style="color:#f92672">*</span> filter_policy <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
};
</code></pre></div><h3 id="versionedit">VersionEdit</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VersionEdit</span> {

	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	 <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VersionSet</span>;

	 <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">uint64_t</span><span style="color:#f92672">&gt;&gt;</span> DeletedFileSet;

	 std<span style="color:#f92672">::</span>string comparator_;
	 <span style="color:#66d9ef">uint64_t</span> log_number_;
	 <span style="color:#66d9ef">uint64_t</span> prev_log_number_;
	 <span style="color:#66d9ef">uint64_t</span> next_file_number_;
	 SequenceNumber last_sequence_;
	 <span style="color:#66d9ef">bool</span> has_comparator_;
	 <span style="color:#66d9ef">bool</span> has_log_number_;
	 <span style="color:#66d9ef">bool</span> has_prev_log_number_;
	 <span style="color:#66d9ef">bool</span> has_next_file_number_;
	 <span style="color:#66d9ef">bool</span> has_last_sequence_;

	 std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, InternalKey<span style="color:#f92672">&gt;&gt;</span> compact_pointers_;
	 DeletedFileSet deleted_files_;
	 std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, FileMetaData<span style="color:#f92672">&gt;&gt;</span> new_files_;

}
</code></pre></div><h2 id="put">Put</h2>
<h3 id="slice">Slice</h3>
<p><code>Slice</code> 的<strong>底层</strong>数据结构：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LEVELDB_EXPORT</span> Slice {
 <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> data_;
  size_t size_;
};
</code></pre></div><h3 id="底层存储数据的地方">底层存储数据的地方</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// db_impl.h
</span><span style="color:#75715e"></span>MemTable<span style="color:#f92672">*</span> mem_; <span style="color:#75715e">// 缓存
</span><span style="color:#75715e"></span>MemTable<span style="color:#f92672">*</span> imm_ <span style="color:#a6e22e">GUARDED_BY</span>(mutex_); <span style="color:#75715e">// 数据库
</span></code></pre></div><h3 id="写入顺序">写入顺序</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// 先写到 Log 文件中
</span><span style="color:#75715e"></span>status <span style="color:#f92672">=</span> log_<span style="color:#f92672">-&gt;</span>AddRecord(WriteBatchInternal<span style="color:#f92672">::</span>Contents(write_batch));
<span style="color:#66d9ef">bool</span> sync_error <span style="color:#f92672">=</span> false;
<span style="color:#66d9ef">if</span> (status.ok() <span style="color:#f92672">&amp;&amp;</span> options.sync) {
  status <span style="color:#f92672">=</span> logfile_<span style="color:#f92672">-&gt;</span>Sync();
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>status.ok()) {
    sync_error <span style="color:#f92672">=</span> true;
  }
}

<span style="color:#75715e">// 如果写到 Log 文件成功
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (status.ok()) {
  <span style="color:#75715e">// 则写到数据库中
</span><span style="color:#75715e"></span>  status <span style="color:#f92672">=</span> WriteBatchInternal<span style="color:#f92672">::</span>InsertInto(write_batch, mem_);
}
</code></pre></div><p>如下图所示，数据先<strong>顺序写入</strong>到位于磁盘上的 log 文件中，如果写入成功，则再写入到 <code>MemTable</code> 中:</p>
<p><img src="/images/docs/tutorial/distributed-storage/leveldb/write-process.png" alt=""></p>
<h3 id="写-log-日志文件">写 Log 日志文件</h3>
<p>日志存储在 <code>WriteBatch</code> 的 <code>std::string rep_</code> 里面，其存储的内容如下代码所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> WriteBatch<span style="color:#f92672">::</span>Put(<span style="color:#66d9ef">const</span> Slice<span style="color:#f92672">&amp;</span> key, <span style="color:#66d9ef">const</span> Slice<span style="color:#f92672">&amp;</span> value) {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  rep_.push_back(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(kTypeValue));
  PutLengthPrefixedSlice(<span style="color:#f92672">&amp;</span>rep_, key);
  PutLengthPrefixedSlice(<span style="color:#f92672">&amp;</span>rep_, value);
}

<span style="color:#75715e">// coding.cc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PutLengthPrefixedSlice</span>(std<span style="color:#f92672">::</span>string<span style="color:#f92672">*</span> dst, <span style="color:#66d9ef">const</span> Slice<span style="color:#f92672">&amp;</span> value) {
  PutVarint32(dst, value.size());
  dst<span style="color:#f92672">-&gt;</span>append(value.data(), value.size());
}
</code></pre></div><p>写入 Log 日志的时候，对记录的类型和数据计算 CRC 编码，这个编码作为 <code>buf</code> 数组的前 4 位，<code>buf</code> 数组的后 3 位依次填充上:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">buf[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(length <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>);
buf[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(length <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>);
buf[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(t);
</code></pre></div><p><code>buf</code> 数组的内容就是这条记录的<strong>头</strong>的内容，<code>ptr</code> 指向的是这条记录的实际数据:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// log_writer.cc
</span><span style="color:#75715e">// Write the header and the payload
</span><span style="color:#75715e"></span>Status s <span style="color:#f92672">=</span> dest_<span style="color:#f92672">-&gt;</span>Append(Slice(buf, kHeaderSize));
<span style="color:#66d9ef">if</span> (s.ok()) {
  s <span style="color:#f92672">=</span> dest_<span style="color:#f92672">-&gt;</span>Append(Slice(ptr, length));
  <span style="color:#66d9ef">if</span> (s.ok()) {
    s <span style="color:#f92672">=</span> dest_<span style="color:#f92672">-&gt;</span>Flush();
  }
}
</code></pre></div><p><strong>头</strong>的长度为 7 位:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// log_format.h
</span><span style="color:#75715e">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> kHeaderSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><p><code>Append</code> 内部调用了 <code>std:memcpy</code> 函数。</p>
<h3 id="写到-memtable-内存数据库中">写到 MemTable 内存数据库中</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> MemTable<span style="color:#f92672">::</span>Add(SequenceNumber s, ValueType type, <span style="color:#66d9ef">const</span> Slice<span style="color:#f92672">&amp;</span> key,
                   <span style="color:#66d9ef">const</span> Slice<span style="color:#f92672">&amp;</span> value) {
  <span style="color:#75715e">// 使用 Arena 分配内存
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> buf <span style="color:#f92672">=</span> arena_.Allocate(encoded_len);
  <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> EncodeVarint32(buf, internal_key_size);

  <span style="color:#75715e">// 将 key 拷贝到 buf 中
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>memcpy(p, key.data(), key_size);

  <span style="color:#75715e">// 将 value 拷贝到 buf 中
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>memcpy(p, value.data(), val_size);

  <span style="color:#75715e">// 插入到 table 中
</span><span style="color:#75715e"></span>  table_.Insert(buf);
}
</code></pre></div><p>如下是 <code>std::memcpy</code> 的签名:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// Copies count bytes from the object pointed to by src to the object pointed to by dest.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">memcpy</span>( <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> dest, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> src, std<span style="color:#f92672">::</span>size_t count );
</code></pre></div><p>上述代码最后一行出现的 <code>table_.Insert(buf)</code>，此处的 <code>Table</code> 其实就是<strong>跳表</strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// memtable.h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> SkipList<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>, KeyComparator<span style="color:#f92672">&gt;</span> Table;
</code></pre></div><p>因此在 <code>MemTable</code> 中分配的 <code>buf</code> 最终将会存储到<strong>跳表</strong>中。</p>
<h2 id="delete">Delete</h2>
<p><code>Delete</code> 的底层很像 <code>Put</code> 操作:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// write_batch.cc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Delete</span>(<span style="color:#66d9ef">const</span> Slice<span style="color:#f92672">&amp;</span> key) <span style="color:#66d9ef">override</span> {
  mem_<span style="color:#f92672">-&gt;</span>Add(sequence_, kTypeDeletion, key, Slice());
  sequence_<span style="color:#f92672">++</span>;
}
</code></pre></div><p>只是 <code>key</code> 的被标记为 <code>kTypeDeletion</code> 标签了。</p>
<h2 id="snapshot-快照">Snapshot 快照</h2>
<h3 id="创建快照">创建快照</h3>
<p>从 <code>VersionSet</code> 中获取最后一个序号 <code>LastSequence</code>，然后根据这最后一个序号创建一个快照:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// db_impl.cc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> Snapshot<span style="color:#f92672">*</span> DBImpl<span style="color:#f92672">::</span>GetSnapshot() {
  MutexLock <span style="color:#a6e22e">l</span>(<span style="color:#f92672">&amp;</span>mutex_);
  <span style="color:#66d9ef">return</span> snapshots_.New(versions_<span style="color:#f92672">-&gt;</span>LastSequence());
}
</code></pre></div><p>其中 <code>versions_</code> 的定义:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">VersionSet<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> versions_ <span style="color:#a6e22e">GUARDED_BY</span>(mutex_);
</code></pre></div><h2 id="数据库文件">数据库文件</h2>
<h3 id="数据库所有文件">数据库所有文件</h3>
<p>数据库名字命名的文件夹的目录，包含的文件有如下几种类型:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// filename.h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">FileType</span> {
  kLogFile, <span style="color:#75715e">// 000025.log
</span><span style="color:#75715e"></span>  kDBLockFile, <span style="color:#75715e">// LOCK
</span><span style="color:#75715e"></span>  kTableFile, <span style="color:#75715e">// xxxxxx.ldb, *.sst
</span><span style="color:#75715e"></span>  kDescriptorFile, <span style="color:#75715e">// MANIFEST-000023
</span><span style="color:#75715e"></span>  kCurrentFile, <span style="color:#75715e">// CURRENT
</span><span style="color:#75715e"></span>  kTempFile, <span style="color:#75715e">// *.dbtmp
</span><span style="color:#75715e"></span>  kInfoLogFile  <span style="color:#75715e">// LOG, LOG.old 
</span><span style="color:#75715e"></span>};
</code></pre></div><p>下面展示的是一个示例目录结构:</p>
<p><img src="/images/docs/tutorial/distributed-storage/leveldb/leveldb-files.png" alt=""></p>
<h3 id="log-logold">LOG, LOG.old</h3>
<p>文件内容示例:</p>
<pre><code>2020/10/25-15:37:29.918667 140486263023424 Recovering log #25
2020/10/25-15:37:29.918906 140486263023424 Level-0 table #27: started
2020/10/25-15:37:29.923419 140486263023424 Level-0 table #27: 133 bytes OK
2020/10/25-15:37:29.930591 140486263023424 Delete type=0 #25
2020/10/25-15:37:29.930639 140486263023424 Delete type=3 #23
2020/10/25-15:37:29.930944 140486263019264 Compacting 4@0 + 1@1 files
2020/10/25-15:37:29.931234 140486263019264 compacted to: files[ 4 1 0 0 0 0 0 ]
</code></pre><p>文件内容是通过 <code>Log</code> 方法写入进去的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Log(options_.info_log, <span style="color:#e6db74">&#34;compacted to: %s&#34;</span>, versions_<span style="color:#f92672">-&gt;</span>LevelSummary(<span style="color:#f92672">&amp;</span>tmp));
</code></pre></div><h3 id="log"><code>*.log</code></h3>
<p>位于 <code>db_impl.h</code> 中的 <code>logfile_</code> 和 <code>log_</code> 指向的文件就是 <code>log</code> 文件:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// db_impl.h
</span><span style="color:#75715e"></span>WritableFile<span style="color:#f92672">*</span> logfile_;
log<span style="color:#f92672">::</span>Writer<span style="color:#f92672">*</span> log_;
</code></pre></div><p><code>log</code> 文件中的内容是是通过 <code>AddRecord</code> 写进去的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">status <span style="color:#f92672">=</span> log_<span style="color:#f92672">-&gt;</span>AddRecord(WriteBatchInternal<span style="color:#f92672">::</span>Contents(write_batch));
</code></pre></div><p>如下是用 Vim 打开的某个 <code>log</code> 文件所看到的内容:</p>
<p><img src="/images/docs/tutorial/distributed-storage/leveldb/log_file_content.png" alt=""></p>
<h3 id="lock">LOCK</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// Lock over the persistent DB state.  Non-null iff successfully acquired.
</span><span style="color:#75715e"></span>FileLock<span style="color:#f92672">*</span> db_lock_;
</code></pre></div><h2 id="compaction">Compaction</h2>
<p>当内存中的 <code>MemTable</code> 达到一定大小的时候，Compaction 可以将其内容保持到<strong>磁盘</strong>中。</p>
<p><img src="/images/docs/tutorial/distributed-storage/leveldb/minor-compaction.png" alt=""></p>
<h2 id="版本管理">版本管理</h2>
<h3 id="环形双端链表">环形双端链表</h3>
<p><code>AppendVersion</code> 的过程:</p>
<pre><code>[prev] &lt;-&gt; [dummy]
</code></pre><p>转为:</p>
<pre><code>[prev] &lt;-&gt; [current] &lt;-&gt; [dummy]
</code></pre><h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/google/leveldb/blob/master/doc/impl.md">impl</a></li>
<li><a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">数据分析与处理之二（Leveldb 实现原理）</a></li>
</ul>

<ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-8950855178079071"
data-ad-slot="6142361626"
data-ad-format="auto"
data-full-width-responsive="true"></ins>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  </div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#特性">特性</a></li>
    <li><a href="#编译">编译</a></li>
    <li><a href="#打开数据库">打开数据库</a>
      <ul>
        <li><a href="#options">Options</a></li>
        <li><a href="#versionedit">VersionEdit</a></li>
      </ul>
    </li>
    <li><a href="#put">Put</a>
      <ul>
        <li><a href="#slice">Slice</a></li>
        <li><a href="#底层存储数据的地方">底层存储数据的地方</a></li>
        <li><a href="#写入顺序">写入顺序</a></li>
        <li><a href="#写-log-日志文件">写 Log 日志文件</a></li>
        <li><a href="#写到-memtable-内存数据库中">写到 MemTable 内存数据库中</a></li>
      </ul>
    </li>
    <li><a href="#delete">Delete</a></li>
    <li><a href="#snapshot-快照">Snapshot 快照</a>
      <ul>
        <li><a href="#创建快照">创建快照</a></li>
      </ul>
    </li>
    <li><a href="#数据库文件">数据库文件</a>
      <ul>
        <li><a href="#数据库所有文件">数据库所有文件</a></li>
        <li><a href="#log-logold">LOG, LOG.old</a></li>
        <li><a href="#log"><code>*.log</code></a></li>
        <li><a href="#lock">LOCK</a></li>
      </ul>
    </li>
    <li><a href="#compaction">Compaction</a></li>
    <li><a href="#版本管理">版本管理</a>
      <ul>
        <li><a href="#环形双端链表">环形双端链表</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279346965'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279346965%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>



</html>












