<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/tutorial/database/</link>
    <description>Recent content in 数据库 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://kunzhao.org/docs/tutorial/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>事务实现原理</title>
      <link>https://kunzhao.org/docs/tutorial/database/transaction-internal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/database/transaction-internal/</guid>
      <description>事务实现原理 Redo Log  A: 要么不执行，要么完全执行，宕机重启已执行的要回滚 C: 主键不为空、参照完整性等 I: 如果全是串行执行，也不需要隔离，所以和并发有关 D: 数据不能丢  C 一致性 C 由各种规则约束实现，比较简单。
Write-Ahead Log 先在内存中提交事务，然后写 Write-Ahead Log，然后后台把数据异步刷到磁盘。在 InnoDB 中，Write-Ahead Log 是 Redo Log。事务提交之后，Redo Log 先写入到内存的 Redo Log Buffer 中，然后异步刷到磁盘上的 Redo Log 。
InnoDB 关键参数 innodb_flush_log_at_trx_commit 控制刷盘策略：
 0: 每秒刷一次 (默认) 1: 提交一个事务，就刷一次 2: 不刷盘，根据 innodb_flush_log_at_timeout 设置的值决定刷盘频率  Redo Log 逻辑与物理结构  为什么 Redo Log Block 是 512 字节?
 因为早期的磁盘，一个扇区是存储 512 字节数据。
 为什么 Redo Log 循坏使用?</description>
    </item>
    
    <item>
      <title>Oracle VS MySQL</title>
      <link>https://kunzhao.org/docs/tutorial/database/oracls-vs-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/database/oracls-vs-mysql/</guid>
      <description>Oracle VS MySQL     Oracle MySQL     事务默认隔离级别 read commited repeatable read   价格 ORACLE 11g 标准版售价在六位数 开源免费   AUTO_INCREMENT 不可以声明，主键自带自增长 可以声明   索引 Oracle 的索引是数据库级别，不可以同名 MySQL 的索引是表级别的，可以同名   数字类型 NUMBER INT/DECIMAL   分页 Oracle 是需要用到伪列 ROWNUM 和嵌套查询 LIMIT X, Y   默认端口 1521 3306    参考  Oracle与MySQL的SQL语句区别  </description>
    </item>
    
    <item>
      <title>ShardingSphere 3.X</title>
      <link>https://kunzhao.org/docs/tutorial/database/sharding-sphere/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/database/sharding-sphere/</guid>
      <description>ShardingSphere 3.X 分片 分片键 用于分片的数据库字段，是将数据库(表)水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，ShardingSphere也支持根据多个字段进行分片。
分片算法 通过分片算法将数据分片，支持通过=、BETWEEN和IN分片。分片算法需要应用方开发者自行实现，可实现的灵活度非常高。
 精确分片算法 PreciseShardingAlgorithm: 用于处理使用单一键作为分片键的 = 与 IN 进行分片的场景。 范围分片算法 RangeShardingAlgorithm: 用于处理使用单一键作为分片键的 BETWEEN AND 进行分片的场景。 复合分片算法 ComplexKeysShardingAlgorithm: 用于处理使用多键作为分片键进行分片的场景。 Hint 分片算法 HintShardingAlgorithm: 用于处理使用 Hint 行分片的场景。  分片策略 包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。目前提供5种分片策略。
 标准分片策略 复合分片策略 行表达式分片策略: 使用 Groovy 表达式 Hint 分片策略 不分片策略   行表达式语法说明
 行表达式的使用非常直观，只需要在配置中使用${ expression }或$-&amp;gt;{ expression }标识行表达式即可。 目前支持数据节点和分片算法这两个部分的配置。行表达式的内容使用的是Groovy的语法，Groovy能够支持的所有操作，行表达式均能够支持。
${begin..end}表示范围区间
${[unit1, unit2, unit_x]}表示枚举值
(1) 行表达式 ${[&#39;online&#39;, &#39;offline&#39;]}_table${1..3} 解析为：
online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3 (2) 数据节点配置</description>
    </item>
    
  </channel>
</rss>
