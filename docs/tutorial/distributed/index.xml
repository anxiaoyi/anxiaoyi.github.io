<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式系统教程 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/tutorial/distributed/</link>
    <description>Recent content in 分布式系统教程 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://kunzhao.org/docs/tutorial/distributed/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>服务治理</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/it-govern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/it-govern/</guid>
      <description>服务治理 企业治理：对企业 IT 的问题梳理、改进、优化，IT 治理是为业务服务的，涉及到了组织、管理效能、架构、基础资源、应用、数据等治理。
 SOA 治理，技术栈太重
  推荐的微服务工程组织模式
  DevOps 最核心的工作就是构建标准化、规范化和自动化的研发流水线或工具链，实现计划、设计、开发、测试、发布和运维的紧密协同。
 DevOps 通常包含如下工作：
 测试用例管理 测试环境管理 自动化持续构建 (CI) 持续部署 (CD) 发布管理 负载测试 应用系统监控 反馈管理  微服务架构 代理模式 Spring Cloud 使用 Zuul 组件实现代理网关。
缺点：
 网络上多了一次请求，比直连模式慢 网关存在单点隐患  直连模式 缺点：
 服务方、调用方耦合性较强  边车模式 弱耦合 SDK 微服务框架，将直连模式的 SDK 拆分出来，以独立进程和微服务应用部署在同一个操作系统中，使其免受技术选型和开发语言的限制，业界称之为 ServiceMesh。
直连模式架构  服务提供方的 SDK 做了什么?
 将业务逻辑封装成一个远程服务，然后暴露出去。Java 普遍采用的手段是：
 Instrumentation 字节码替换技术 InvocationHandler 动态代理技术，生成代理类，让代理类来负责远程请求的解析匹配和本地真实服务的调用。   服务调用放的 SDK 做了什么?</description>
    </item>
    
    <item>
      <title>服务度量</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/service-measurement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/service-measurement/</guid>
      <description>服务度量  如果你不能度量它，你就无法改进它。&amp;mdash; 彼得德鲁克
 调用量、延时、异常 点: 单次请求指标采集 线：单服务一分钟指标叠加统计 面：单服务时间纬度汇总统计 对性能进行度量 调用耗时分区统计 部分请求落到了远离中心的 256 ~ 512 ms 这个长尾区间，这就意味着系统中存在异常的延时 &amp;ldquo;毛刺&amp;rdquo;，周期性出现的毛刺，和系统脆弱性有关，在高并发、大负载情况下，这种脆弱性会被放大，给系统造成严重影响。
性能横向对比 服务异常纬度 整体错误分部 </description>
    </item>
    
    <item>
      <title>服务管控</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/service-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/service-control/</guid>
      <description>服务管控 服务负载 随机策略 各个服务器处理能力不同，处理性能弱的会被打趴。可以加上权重：
collection = {A: 5, B:2, C:2, D:1}(1) 策略1
{A,A,A,A,A,B,B,C,C,D}
random.nextInt(10) 缺点就是这个 collection 集合可能会比较大，内存占用大
(2) 策略2
权重换算成长度，先算出总长度，然后再计算出一个偏移量
totalWeight = sum(collection) offset = random.nextInt(totalWeight) 缺点就是选取的时候，需要遍历集合，复杂度 O(n)
轮询策略 如果各个节点权重一致：
[total_request_count + 1] % node_count 如果权重不同，
collection = {A: 5, B:2, C:2, D:1}那么，最高的权重是 5：
[total_request_count + 1] % maxWeight = currentWeight那么 [currentWeight, maxWeight] 就是可用的权重范围。
一致性 Hash 策略 节点数少，节点变动，大量键发生波动，造成数据倾斜，因此可以引入虚拟节点，每个节点通过引入编号计算多个 Hash 值，模拟多个虚拟节点。
限流 漏桶算法 算法类似于餐厅排号就餐，整个餐厅所能容纳的顾客数量是有限的，有出才能有进。
Semaphore sem = new Semaphore(30); if (sem.</description>
    </item>
    
  </channel>
</rss>