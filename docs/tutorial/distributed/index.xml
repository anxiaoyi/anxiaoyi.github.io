<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式系统与架构设计 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/tutorial/distributed/</link>
    <description>Recent content in 分布式系统与架构设计 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://kunzhao.org/docs/tutorial/distributed/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>服务治理</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/it-govern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/it-govern/</guid>
      <description>服务治理 企业治理：对企业 IT 的问题梳理、改进、优化，IT 治理是为业务服务的，涉及到了组织、管理效能、架构、基础资源、应用、数据等治理。
 SOA 治理，技术栈太重
  推荐的微服务工程组织模式
  DevOps 最核心的工作就是构建标准化、规范化和自动化的研发流水线或工具链，实现计划、设计、开发、测试、发布和运维的紧密协同。
 DevOps 通常包含如下工作：
 测试用例管理 测试环境管理 自动化持续构建 (CI) 持续部署 (CD) 发布管理 负载测试 应用系统监控 反馈管理  微服务架构 代理模式 Spring Cloud 使用 Zuul 组件实现代理网关。
缺点：
 网络上多了一次请求，比直连模式慢 网关存在单点隐患  直连模式 缺点：
 服务方、调用方耦合性较强  边车模式 弱耦合 SDK 微服务框架，将直连模式的 SDK 拆分出来，以独立进程和微服务应用部署在同一个操作系统中，使其免受技术选型和开发语言的限制，业界称之为 ServiceMesh。
直连模式架构  服务提供方的 SDK 做了什么?
 将业务逻辑封装成一个远程服务，然后暴露出去。Java 普遍采用的手段是：
 Instrumentation 字节码替换技术 InvocationHandler 动态代理技术，生成代理类，让代理类来负责远程请求的解析匹配和本地真实服务的调用。   服务调用放的 SDK 做了什么?</description>
    </item>
    
    <item>
      <title>服务度量</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/service-measurement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/service-measurement/</guid>
      <description>服务度量  如果你不能度量它，你就无法改进它。&amp;mdash; 彼得德鲁克
 调用量、延时、异常 点: 单次请求指标采集 线：单服务一分钟指标叠加统计 面：单服务时间纬度汇总统计 对性能进行度量 调用耗时分区统计 部分请求落到了远离中心的 256 ~ 512 ms 这个长尾区间，这就意味着系统中存在异常的延时 &amp;ldquo;毛刺&amp;rdquo;，周期性出现的毛刺，和系统脆弱性有关，在高并发、大负载情况下，这种脆弱性会被放大，给系统造成严重影响。
性能横向对比 服务异常纬度 整体错误分部 </description>
    </item>
    
    <item>
      <title>服务管控</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/service-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/service-control/</guid>
      <description>服务管控 服务负载 随机策略 各个服务器处理能力不同，处理性能弱的会被打趴。可以加上权重：
collection = {A: 5, B:2, C:2, D:1}(1) 策略1
{A,A,A,A,A,B,B,C,C,D}
random.nextInt(10) 缺点就是这个 collection 集合可能会比较大，内存占用大
(2) 策略2
权重换算成长度，先算出总长度，然后再计算出一个偏移量
totalWeight = sum(collection) offset = random.nextInt(totalWeight) 缺点就是选取的时候，需要遍历集合，复杂度 O(n)
轮询策略 如果各个节点权重一致：
[total_request_count + 1] % node_count 如果权重不同，
collection = {A: 5, B:2, C:2, D:1}那么，最高的权重是 5：
[total_request_count + 1] % maxWeight = currentWeight那么 [currentWeight, maxWeight] 就是可用的权重范围。
一致性 Hash 策略 节点数少，节点变动，大量键发生波动，造成数据倾斜，因此可以引入虚拟节点，每个节点通过引入编号计算多个 Hash 值，模拟多个虚拟节点。
限流 漏桶算法 算法类似于餐厅排号就餐，整个餐厅所能容纳的顾客数量是有限的，有出才能有进。
Semaphore sem = new Semaphore(30); if (sem.</description>
    </item>
    
    <item>
      <title>APM 及调用链跟踪</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/apm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/apm/</guid>
      <description>APM 及调用链跟踪  APM: Application Performance Management
 日志埋点  字节码适配自动插码埋点 中间件自动埋点 基于环境语义构建 TraceId  日志采集  RingBuffer 作为日志缓存代替 BlockingQueue，避免锁冲突 避免频繁 I/O：秒级刷盘 压缩：LZO 算法或 Snappy 压缩 无 I/O：  </description>
    </item>
    
    <item>
      <title>体系的深度治理</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/deep-govern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/deep-govern/</guid>
      <description>体系的深度治理 服务分层与业务中台 DevOps DevOps 工具生态 脱颖而出的工具：
 持续集成工具和工具流引擎：Jenkins 环境隔离&amp;amp;构建：Docker Iaas、Paas、Cloud 基础设施即代码 版本管理工具：Git 协同开发工具：Jira  </description>
    </item>
    
    <item>
      <title>分布式事务解决方案汇总</title>
      <link>https://kunzhao.org/docs/tutorial/distributed/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed/transaction/</guid>
      <description>分布式事务解决方案汇总  如何保证转账这个操作在两个系统中同时成功呢？
 2PC 每个参与者要实现三个接口：Prepare、Commit、Rollback 三个接口，这就是 XA 协议。
主要的缺点就是：
 性能问题 事务执行到中间，事务协调者宕机，整个事务处于悬而不决的状态。 一个参与者超时了，那么其它参与者应该提交还是回滚呢？ 2PC 主要用在两个数据库之间，而非两个系统之间。   3PC 只是解决了宕机问题，本质上和 2PC 没有区别，不再赘述。
 消息中间件-最终一致性 消息中间件本身如 Kafka 不提供事务消息功能，那么解决步骤如下：
 系统 A 增加一张消息表，消息写入到消息表中和 DB1 的扣钱操作放到一个数据库的事务里，保证原子性。 系统 A 后台程序源源不断地将消息表中的消息传送给消息中间件，失败了也尝试重传。 系统 B 通过消息中间件的 ACK 机制，明确自己是否消费成功。 系统 B 增加判重表，记录处理成功的消息 ID 和消息中间件对应的 offset，实现业务幂等性，应对重复消费问题；如果业务本身有业务数据，可以判断是否重复，那么就无需这个判重表。  消息中间件如 RocketMQ 本身提供事务消息：
RocketMQ 会定期 (默认 1min) 扫描所有的预发送但是还没有确认的消息，回调给发送方，询问这条消息是要发送出去，还是取消。发送方根据自己的业务数，知道这条消息是应该发送出去 (DB 更新成功)，还是应该取消 (DB 更新失败)。
RocketMQ 最大的改变就是把 &amp;ldquo;扫描消息表&amp;rdquo; 这件事不让业务方做，而是让消息中间件完成。
无论什么 MQ，如果消费端一直消费失败，那么是要需要自动回滚整个流程？答案是需要人工介入，更加可靠，更加简单，发生概率极低。
TCC 支付宝提出了 TCC，是为了解决 SOA 系统中的分布式事务问题，这是一个应用层面的 2PC 协议。</description>
    </item>
    
  </channel>
</rss>