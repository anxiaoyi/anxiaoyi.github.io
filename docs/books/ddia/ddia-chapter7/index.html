<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="设计数据密集型应用程序 - 事务"><meta property="og:title" content="设计数据密集型应用程序 - 事务" />
<meta property="og:description" content="设计数据密集型应用程序 - 事务  一些作者声称，一般的两阶段提交由于其带来的性能或可用性问题，支持起来过于昂贵。我们认为，最好让应用程序程序员在瓶颈出现时处理由于过度使用事务而导致的性能问题，而不是总是围绕缺少事务进行编码。 &mdash; James Corbett et al., Spanner: Google’s Globally-Distributed Database (2012)
 在数据系统的严酷现实中，很多事情都会出错：
 数据库软件或硬件可能随时发生故障（包括在写入操作的中间）。 应用程序可能随时崩溃（包括一系列操作的中途）。 网络中断可能会意外地切断应用程序与数据库的连接，或断开一个数据库节点与另一个数据库节点的连接。 多个客户端可能同时写入数据库，覆盖彼此的更改。 客户端可能会读取没有意义的数据，因为它只更新了一部分。 客户端之间的竞争条件可能会导致令人惊讶的错误。  为了可靠，系统必须处理这些故障，并确保它们不会导致整个系统的灾难性故障。然而，实现容错机制需要大量的工作。它需要仔细考虑所有可能出错的地方，并进行大量测试以确保解决方案能够实际工作。
几十年来，事务一直是简化这些问题的首选机制。事务是应用程序将多个读写操作组合到一个逻辑单元中的一种方法。从概念上讲，事务中的所有读写操作都作为一个操作执行：要么整个事务成功（commit），要么失败（abort，rollback）。如果失败，应用程序可以安全地重试。有了事务，应用程序的错误处理就变得简单多了，因为它不需要担心部分失败，也就是说，有些操作成功，有些操作失败（无论什么原因）。
如果你花了数年时间处理事务，它们可能看起来很明显，但我们不应该认为它们是理所当然的。事务不是自然规律；创建事务的目的是为了简化访问数据库的应用程序的编程模型。通过使用事务，应用程序可以自由地忽略某些潜在的错误场景和并发问题，因为数据库会处理它们（我们称之为安全保证）。
并不是每个应用程序都需要事务，有时削弱事务性保证或完全放弃事务性保证有好处（例如，为了获得更高的性能或更高的可用性）。一些安全属性可以在没有事务的情况下实现。
你如何判断你是否需要事务？为了回答这个问题，我们首先需要确切地了解事务可以提供什么样的安全保障，以及与之相关的成本。虽然乍一看事务似乎很简单，但实际上有许多微妙但重要的细节在起作用。
在本章中，我们将研究许多可能出错的例子，并探索数据库用来防范这些问题的算法。我们将特别深入到并发控制领域，讨论可能发生的各种竞争条件，以及数据库如何实现隔离级别，如读提交、快照隔离和串行化。
本章适用于单节点和分布式数据库；在第8章中，我们将重点讨论仅在分布式系统中出现的特定挑战。
事务的模糊概念 现在几乎所有的关系型数据库和一些非关系型数据库都支持事务。其中大多数都遵循ibmsystemr在1975年引入的样式，第一个SQL数据库[1，2，3]。虽然一些实现细节有所改变，但40年来，总体思路基本不变：MySQL、PostgreSQL、Oracle、sqlserver等的事务支持与systemr惊人地相似。
在21世纪末，非关系（NoSQL）数据库开始流行起来。他们希望通过提供新的数据模型（见第2章）和默认的复制（第5章）和分区（第6章）来改善关系现状。事务是这场运动的主要牺牲品：许多新一代数据库完全放弃了事务，或者重新定义了这个词来描述一组比以前理解的要弱得多的保证[4]。
随着这种新的分布式数据库的大肆宣传，人们普遍认为事务是可伸缩性的对立面，任何大型系统都必须放弃事务，以保持良好的性能和高可用性[5,6]。另一方面，事务性保证有时由数据库供应商提出，作为“严肃的应用程序”和“有价值的数据”的基本要求。
事实并非如此简单：与其他技术设计选择一样，事务有其优势和局限性。为了理解这些权衡，让我们详细介绍事务在正常操作和各种极端（但现实）情况下可以提供的保证。
ACID 的意义 事务提供的安全保证通常用众所周知的缩写ACID来描述，它代表原子性、一致性、隔离性和持久性。它是1983年由Theo Härder和Andreas Reuter[7]创造的，目的是为了在数据库。
但是在实践中，一个数据库的ACID实现并不等同于另一个数据库的实现。例如，正如我们将要看到的，孤立的含义有很多模棱两可的地方。高层次的想法是正确的，但魔鬼在于细节。今天，当一个系统声称“符合ACID”时，你还不清楚到底能得到什么样的保证。不幸的是，ACID已经成为一个市场术语。
（不符合ACID标准的系统有时称为BASE，它代表基本可用、软状态和最终一致性[9]。这甚至比ACID的定义更模糊。似乎对base唯一合理的定义是“not ACID”；也就是说，它几乎可以表示任何你想要的东西。）
让我们深入研究原子性、一致性、隔离性和持久性的定义，因为这将使我们完善我们对事务的概念。
（1）原子性
一般来说，原子是指不能分解成更小的东西零件。零件在计算机的不同分支中，单词的意思是相似但又微妙不同的东西。例如，在多线程编程中，如果一个线程执行原子操作，这意味着另一个线程不可能看到该操作的一半finishedresult。系统只能处于操作前或操作后的状态，而不是介于两者之间的状态。
相比之下，在ACID环境中，原子性与并发性无关。它没有描述如果多个进程试图同时访问同一个数据会发生什么，因为这是在字母I下的隔离（参见第225页的“隔离”）。
相反，ACID原子性描述的是，如果客户机想要进行多个写操作，但在处理了一些写入操作之后发生了错误，例如，进程崩溃、网络连接中断、磁盘已满或违反了某些完整性约束。如果写入操作被组合到一个atomic transaction中，并且由于错误而无法完成（提交）事务，则事务将中止，数据库必须放弃或撤消迄今为止在该事务中所做的任何写入操作。
如果没有原子性，如果在进行多次更改的过程中发生了错误，则很难知道哪些更改已生效，哪些更改没有生效。应用程序可以重试，但这有可能使同一更改发生两次，从而导致重复或不正确的数据。原子性简化了这个问题：如果一个事务被中止，应用程序可以确保它没有改变任何东西，所以它可以安全地被中止重试过了。
ACID原子性的定义特性是能够在出错时中止事务并放弃该事务中的所有写操作。也许可终止性比原子性更好，但我们还是坚持原子性，因为这是一个常用的词。
（2）一致性
“一致性”这个词严重超载：
 在第5章中，我们讨论了副本一致性以及异步复制系统中出现的最终一致性问题（请参阅第161页的“复制延迟问题”）。 一致哈希是一些系统用于重新平衡的分区方法（请参阅第204页的“一致哈希”）。 在CAP定理（见第9章）中，一致性一词用于表示线性化（见324页的“线性化能力”）。 在ACID的上下文中，一致性是指数据库处于“良好状态”的特定于应用程序的概念  不幸的是，同一个词至少有四种不同的意思。
ACID一致性的思想是关于数据的某些陈述（不变量）必须始终为真-例如，在一个会计系统中，所有账户的贷方和借方必须总是平衡的。如果事务以根据这些不变量有效的adatabase开始，并且事务期间的任何写入都保持有效性，那么您可以确保这些不变量始终是满意。
不过，这种一致性的思想依赖于应用程序的不变量概念，并且由应用程序负责定义它的事务处理是正确的，以便保留一致性。这不是数据库可以保证的：如果你写的坏数据违反了你的不变量，数据库不能阻止你。（数据库可以检查某些特定类型的不变量，例如使用foreignkey约束或唯一性约束。但是，一般情况下，应用程序会定义哪些数据有效或无效，而数据库只存储这些数据。）
原子性、隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。为了实现一致性，应用程序可能会重新连接数据库的原子性和隔离属性，但这并不仅仅取决于数据库。因此，字母C并不真的属于ACID。
（3）隔离
大多数数据库同时由多个客户机访问。如果他们在读写数据库的不同部分，这是没有问题的，但是如果他们访问相同的数据库记录，你可能会遇到并发问题（竞争条件）。
假设您有两个客户机同时递增存储在数据库中的计数器。每个客户机需要读取当前值，添加1，然后将新值写回（假设数据库中没有内置任何增量操作）。在图7-1中，计数器应该从42增加到44，因为发生了两个增量，但实际上由于竞争条件，它只增加到43。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kunzhao.org/docs/books/ddia/ddia-chapter7/" />

<title>设计数据密集型应用程序 - 事务 | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.a04069c4ba149e24630fa6fbc98cd4da6e386beb4688b0aae5809dbb5660cd77.css" integrity="sha256-oEBpxLoUniRjD6b7yYzU2m44a&#43;tGiLCq5YCdu1ZgzXc=">


<script defer src="/en.search.min.8f15a830c843f820dab8ab37dd53d1d14f9172cde2d3904334c63f3ec743cdd4.js" integrity="sha256-jxWoMMhD&#43;CDauKs33VPR0U&#43;Rcs3i05BDNMY/PsdDzdQ="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      👉招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/beauty_of_mathematics/" >
      数学之美
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/history_of_quantum_physics/" >
      上帝掷骰子吗
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/clean_code/" >
      代码整洁之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the_transformation_of_enterprise_it_architecture/" >
      企业 IT 架构转型之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/redis_5_source_code/" >
      Redis 5 设计与源码分析
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/in-depth_analysis_of_the_core_technology_of_apache_dubbo/" >
      深度剖析 Apache Dubbo 核心技术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/everyone-is-architect/" >
      人人都是架构师 (一)
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-art-of-readable-code/" >
      编写可读代码的艺术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-wisdom-of-trading-stocks/" >
      炒股的智慧
  </a>

</li>
      
    
      
        

  <li >
    
      

  <a href="/docs/books/ddia/" >
      设计数据密集型应用程序
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter1/" >
      设计数据密集型应用程序 - 可靠 &amp; 可扩展 &amp; 可维护
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter2/" >
      设计数据密集型应用程序 - 数据模型 &amp; 查询语言
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter3/" >
      设计数据密集型应用程序 - 存储和读取
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter4/" >
      设计数据密集型应用程序 - 编码与演化
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter5/" >
      设计数据密集型应用程序 - Replication
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter6/" >
      设计数据密集型应用程序 - Partitioning
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter7/"  class="active">
      设计数据密集型应用程序 - 事务
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>设计数据密集型应用程序 - 事务</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#事务的模糊概念">事务的模糊概念</a>
      <ul>
        <li><a href="#acid-的意义">ACID 的意义</a></li>
        <li><a href="#单对象和多对象操作">单对象和多对象操作</a></li>
      </ul>
    </li>
    <li><a href="#弱隔离等级">弱隔离等级</a>
      <ul>
        <li><a href="#读已提交">读已提交</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown"><h1 id="设计数据密集型应用程序---事务">设计数据密集型应用程序 - 事务</h1>
<blockquote>
<p>一些作者声称，一般的两阶段提交由于其带来的性能或可用性问题，支持起来过于昂贵。我们认为，最好让应用程序程序员在瓶颈出现时处理由于过度使用事务而导致的性能问题，而不是总是围绕缺少事务进行编码。 &mdash; James Corbett et al., Spanner: Google’s Globally-Distributed Database (2012)</p>
</blockquote>
<p>在数据系统的严酷现实中，很多事情都会出错：</p>
<ul>
<li>数据库软件或硬件可能随时发生故障（包括在写入操作的中间）。</li>
<li>应用程序可能随时崩溃（包括一系列操作的中途）。</li>
<li>网络中断可能会意外地切断应用程序与数据库的连接，或断开一个数据库节点与另一个数据库节点的连接。</li>
<li>多个客户端可能同时写入数据库，覆盖彼此的更改。</li>
<li>客户端可能会读取没有意义的数据，因为它只更新了一部分。</li>
<li>客户端之间的竞争条件可能会导致令人惊讶的错误。</li>
</ul>
<p>为了可靠，系统必须处理这些故障，并确保它们不会导致整个系统的灾难性故障。然而，实现容错机制需要大量的工作。它需要仔细考虑所有可能出错的地方，并进行大量测试以确保解决方案能够实际工作。</p>
<p>几十年来，事务一直是简化这些问题的首选机制。事务是应用程序将多个读写操作组合到一个逻辑单元中的一种方法。从概念上讲，事务中的所有读写操作都作为一个操作执行：要么整个事务成功（commit），要么失败（abort，rollback）。如果失败，应用程序可以安全地重试。有了事务，应用程序的错误处理就变得简单多了，因为它不需要担心部分失败，也就是说，有些操作成功，有些操作失败（无论什么原因）。</p>
<p>如果你花了数年时间处理事务，它们可能看起来很明显，但我们不应该认为它们是理所当然的。事务不是自然规律；创建事务的目的是为了简化访问数据库的应用程序的编程模型。通过使用事务，应用程序可以自由地忽略某些潜在的错误场景和并发问题，因为数据库会处理它们（我们称之为安全保证）。</p>
<p>并不是每个应用程序都需要事务，有时削弱事务性保证或完全放弃事务性保证有好处（例如，为了获得更高的性能或更高的可用性）。一些安全属性可以在没有事务的情况下实现。</p>
<p>你如何判断你是否需要事务？为了回答这个问题，我们首先需要确切地了解事务可以提供什么样的安全保障，以及与之相关的成本。虽然乍一看事务似乎很简单，但实际上有许多微妙但重要的细节在起作用。</p>
<p>在本章中，我们将研究许多可能出错的例子，并探索数据库用来防范这些问题的算法。我们将特别深入到并发控制领域，讨论可能发生的各种竞争条件，以及数据库如何实现隔离级别，如读提交、快照隔离和串行化。</p>
<p>本章适用于单节点和分布式数据库；在第8章中，我们将重点讨论仅在分布式系统中出现的特定挑战。</p>
<h2 id="事务的模糊概念">事务的模糊概念</h2>
<p>现在几乎所有的关系型数据库和一些非关系型数据库都支持事务。其中大多数都遵循ibmsystemr在1975年引入的样式，第一个SQL数据库[1，2，3]。虽然一些实现细节有所改变，但40年来，总体思路基本不变：MySQL、PostgreSQL、Oracle、sqlserver等的事务支持与systemr惊人地相似。</p>
<p>在21世纪末，非关系（NoSQL）数据库开始流行起来。他们希望通过提供新的数据模型（见第2章）和默认的复制（第5章）和分区（第6章）来改善关系现状。事务是这场运动的主要牺牲品：许多新一代数据库完全放弃了事务，或者重新定义了这个词来描述一组比以前理解的要弱得多的保证[4]。</p>
<p>随着这种新的分布式数据库的大肆宣传，人们普遍认为事务是可伸缩性的对立面，任何大型系统都必须放弃事务，以保持良好的性能和高可用性[5,6]。另一方面，事务性保证有时由数据库供应商提出，作为“严肃的应用程序”和“有价值的数据”的基本要求。</p>
<p>事实并非如此简单：与其他技术设计选择一样，事务有其优势和局限性。为了理解这些权衡，让我们详细介绍事务在正常操作和各种极端（但现实）情况下可以提供的保证。</p>
<h3 id="acid-的意义">ACID 的意义</h3>
<p>事务提供的安全保证通常用众所周知的缩写ACID来描述，它代表原子性、一致性、隔离性和持久性。它是1983年由Theo Härder和Andreas Reuter[7]创造的，目的是为了在数据库。</p>
<p>但是在实践中，一个数据库的ACID实现并不等同于另一个数据库的实现。例如，正如我们将要看到的，孤立的含义有很多模棱两可的地方。高层次的想法是正确的，但魔鬼在于细节。今天，当一个系统声称“符合ACID”时，你还不清楚到底能得到什么样的保证。不幸的是，ACID已经成为一个市场术语。</p>
<p>（不符合ACID标准的系统有时称为BASE，它代表基本可用、软状态和最终一致性[9]。这甚至比ACID的定义更模糊。似乎对base唯一合理的定义是“not ACID”；也就是说，它几乎可以表示任何你想要的东西。）</p>
<p>让我们深入研究原子性、一致性、隔离性和持久性的定义，因为这将使我们完善我们对事务的概念。</p>
<p>（1）原子性</p>
<p>一般来说，原子是指不能分解成更小的东西零件。零件在计算机的不同分支中，单词的意思是相似但又微妙不同的东西。例如，在多线程编程中，如果一个线程执行原子操作，这意味着另一个线程不可能看到该操作的一半finishedresult。系统只能处于操作前或操作后的状态，而不是介于两者之间的状态。</p>
<p>相比之下，在ACID环境中，原子性与并发性无关。它没有描述如果多个进程试图同时访问同一个数据会发生什么，因为这是在字母I下的隔离（参见第225页的“隔离”）。</p>
<p>相反，ACID原子性描述的是，如果客户机想要进行多个写操作，但在处理了一些写入操作之后发生了错误，例如，进程崩溃、网络连接中断、磁盘已满或违反了某些完整性约束。如果写入操作被组合到一个atomic transaction中，并且由于错误而无法完成（提交）事务，则事务将中止，数据库必须放弃或撤消迄今为止在该事务中所做的任何写入操作。</p>
<p><strong>如果没有原子性，如果在进行多次更改的过程中发生了错误，则很难知道哪些更改已生效，哪些更改没有生效</strong>。应用程序可以重试，但这有可能使同一更改发生两次，从而导致重复或不正确的数据。原子性简化了这个问题：如果一个事务被中止，应用程序可以确保它没有改变任何东西，所以它可以安全地被中止重试过了。</p>
<p>ACID原子性的定义特性是能够在出错时中止事务并放弃该事务中的所有写操作。也许可终止性比原子性更好，但我们还是坚持原子性，因为这是一个常用的词。</p>
<p>（2）一致性</p>
<p>“一致性”这个词严重超载：</p>
<ul>
<li>在第5章中，我们讨论了副本一致性以及异步复制系统中出现的最终一致性问题（请参阅第161页的“复制延迟问题”）。</li>
<li>一致哈希是一些系统用于重新平衡的分区方法（请参阅第204页的“一致哈希”）。</li>
<li>在CAP定理（见第9章）中，一致性一词用于表示线性化（见324页的“线性化能力”）。</li>
<li>在ACID的上下文中，一致性是指数据库处于“良好状态”的特定于应用程序的概念</li>
</ul>
<p>不幸的是，同一个词至少有四种不同的意思。</p>
<p>ACID<strong>一致性的思想是关于数据的某些陈述（不变量）必须始终为真</strong>-例如，在一个会计系统中，<strong>所有账户的贷方和借方必须总是平衡的</strong>。如果事务以根据这些不变量有效的adatabase开始，并且事务期间的任何写入都保持有效性，那么您可以确保这些不变量始终是满意。</p>
<p>不过，这种一致性的思想依赖于应用程序的不变量概念，并且由应用程序负责定义它的事务处理是正确的，以便保留一致性。这不是数据库可以保证的：如果你写的坏数据违反了你的不变量，数据库不能阻止你。（数据库可以检查某些特定类型的不变量，例如使用foreignkey约束或唯一性约束。但是，一般情况下，应用程序会定义哪些数据有效或无效，而数据库只存储这些数据。）</p>
<p>原子性、隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。为了实现一致性，应用程序可能会重新连接数据库的原子性和隔离属性，但这并不仅仅取决于数据库。因此，<strong>字母C并不真的属于ACID</strong>。</p>
<p>（3）隔离</p>
<p>大多数数据库同时由多个客户机访问。如果他们在读写数据库的不同部分，这是没有问题的，但是如果他们访问相同的数据库记录，你可能会遇到并发问题（竞争条件）。</p>
<p>假设您有两个客户机同时递增存储在数据库中的计数器。每个客户机需要读取当前值，添加1，然后将新值写回（假设数据库中没有内置任何增量操作）。在图7-1中，计数器应该从42增加到44，因为发生了两个增量，但实际上由于竞争条件，它只增加到43。</p>
<p>ACID意义上的<strong>隔离意味着并发执行的事务是相互隔离的：它们不能相互干涉。<strong>经典的数据库教科书将隔离形式化为</strong>可序列化</strong>，这意味着每个事务都可以假装它是整个数据库上运行的唯一事务。数据库确保当事务提交后，结果与串行运行（一个接一个）相同，即使实际上它们可能同时运行[10]。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_22-45-35.png" alt=""></p>
<p>然而，在实践中，可序列化隔离很少使用，因为它会带来性能损失。一些流行的数据库，比如oracle11g，甚至没有实现它。在Oracle有一个名为“serializable”的隔离级别，但实际上它实现了一种称为snapshot isolation的方法，这比serializability的保证要弱[8,11]。我们将在233页的“弱隔离级别”中探讨快照隔离和其他形式的隔离。</p>
<p>（4）耐久性</p>
<p>数据库系统的目的是提供一个安全的地方来存储数据，而不必担心丢失。持久性是指一旦事务成功提交，它<strong>所写的任何数据都不会被遗忘</strong>，即使存在硬件故障或数据库崩溃。</p>
<p>在单节点数据库中，持久性通常意味着数据已被写入非易失性存储器，如硬盘驱动器或SSD。它通常还需要写一个headlog或类似的（参见第82页的“使B树可靠”），这样可以在磁盘上的数据结构损坏时进行恢复。在复制的数据库中，持久性可能意味着数据已成功复制到一定数量的节点。为了提供持久性保证，数据库必须等到这些写入或复制完成后才能成功地报告事务承诺。</p>
<p>作为在第6页的“可靠性”中讨论过，完美的耐久性是不存在的：如果你的所有硬盘和备份同时被销毁，那么显然什么都没有你的数据库可以帮你保存。</p>
<p><strong>复制和耐用性</strong></p>
<p>历史上，耐用性意味着写入存档磁带。然后它被理解为写入磁盘或SSD。最近，它被改编成复制。哪个执行更好？</p>
<p>事实是，没有什么是完美的：</p>
<ul>
<li>如果您写入磁盘后机器死机，即使您的数据没有丢失，在您修复机器或将磁盘传输到另一台热机器之前，它仍然是不可访问的。复制的系统可以保持可用。</li>
<li>相关故障—停电或使特定输入上的每个节点崩溃的bug可以一次关闭所有副本（请参阅第6页的“可靠性”），从而丢失仅存在于内存中的任何数据。因此，写入磁盘仍然与内存数据库相关。•在异步复制系统中，当读卡器不可用时，最近的写入可能会丢失（请参阅第156页的“处理节点中断”）。</li>
<li>当电源突然中断时，特别是固态硬盘有时会违反它们应该提供的保证：即使是 <code>fsync</code> 也不能保证正常工作[12]。磁盘固件可能有错误，就像任何其他类型的软件一样[13，14]。</li>
<li>存储引擎和文件系统实现之间的细微交互可能导致难以跟踪的错误，并可能导致磁盘上的文件在崩溃后损坏[15,16]。</li>
<li>磁盘上的数据可能会逐渐损坏而不会被检测到[17]。如果数据已损坏一段时间，副本和最近的备份也可能会被破坏。在这种情况下，您需要尝试从历史备份中恢复数据。</li>
<li>对固态硬盘的一项研究发现，30%到80%的硬盘在运行的头四年内至少会出现一个坏块[18]。与固态硬盘相比，磁性硬盘的坏扇区率更低，但完全故障率更高。</li>
<li>如果SSD断开电源，它可能在几周内开始丢失数据，具体取决于温度[19]。</li>
</ul>
<p>实际上，没有一种技术可以提供绝对的保证。只有各种降低风险的技术，包括写入磁盘、复制到远程计算机和备份，它们可以而且应该一起使用。同样，明智的做法是在理论上保证健康。</p>
<h3 id="单对象和多对象操作">单对象和多对象操作</h3>
<p>概括地说，在ACID中，原子性和隔离性描述了如果客户机在同一事务中进行多次写入，数据库应该做什么：</p>
<ul>
<li><strong>原子性</strong>：如果在写入序列的中途发生错误，则应中止事务，并应放弃在此之前进行的写入。换句话说，数据库通过提供<strong>全有或全无</strong>的保证，使您不必担心部分故障。</li>
<li><strong>隔离性</strong>：事务之间不应该相互干扰。例如，如果一个事务进行了多次写入，那么<strong>另一个事务应该看到这些写入的全部或全部</strong>，而不是某个子集。</li>
</ul>
<p>这些定义假定您希望一次修改多个对象（行、文档、记录）。如果多个数据需要保持同步，则通常需要这样的多对象事务。图7-2显示了一个电子邮件示例应用程序。到显示用户的未读邮件数，您可以查询如下内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">FROM</span> emails <span style="color:#66d9ef">WHERE</span> recipient_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">AND</span> unread_flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</code></pre></div><p>但是，如果有许多电子邮件，您可能会发现此查询太慢，并决定将未读邮件的数量存储在单独的字段中（一种非规范化）。现在，每当有新消息传入时，您也必须增加未读计数器，并且每当消息被标记为已读时，您还必须删除未读计数器。</p>
<p>在图7-2中，用户2经历了一个异常：邮箱列表显示一个未读消息，但计数器显示零个未读消息，因为计数器尚未递增发生了。隔离可以通过确保用户2同时看到插入的电子邮件和更新的计数器，或者两者都看不到来防止这个问题，但没有不一致的中间点。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_22-58-57.png" alt=""></p>
<p>图7-3说明了原子性的必要性：如果在事务处理过程中某个地方发生错误，邮箱和未读计数器的内容可能会不同步。在原子事务中，如果对计数器的更新失败，事务将中止，插入的电子邮件将回滚。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_22-59-45.png" alt=""></p>
<p>多对象事务需要某种方法来确定哪些读操作和写操作属于同一事务。在关系数据库中，这通常是基于客户机到数据库服务器的TCP连接的一种方式：在任何特定的连接中，BEGIN事务和COMMIT语句之间的所有内容都被视为同一事务的一部分。</p>
<p>另一方面，许多非关系数据库没有这种将操作分组在一起的方法。即使有一个多对象API（例如，一个key-valuestore可能有一个在一个操作中更新多个键的multi-put操作），也不一定意味着它具有事务语义：对于某些键，命令可能成功，而对于其他键，命令可能会失败，从而使数据库处于部分更新的状态州。</p>
<p>（1）单对象写入</p>
<p>当单个对象被更改时，原子性和隔离性也适用。例如，假设您正在向数据库写入一个20 KB的JSON文档：</p>
<ul>
<li>如果在发送前10 KB后网络连接中断，数据库是否存储了无法解析的10 KB JSON片段？</li>
<li>如果在数据库覆盖磁盘上以前的值的过程中电源出现故障，您是否最终将新旧值拼接在一起？</li>
<li>如果另一个客户端在写入过程中读取该文档，它是否会看到部分更新的值？</li>
</ul>
<p>这些问题会令人难以置信地令人困惑，因此存储引擎几乎普遍都会在一个节点上的单个对象（如keyvalue对）级别上提供原子性和隔离性。原子性可以使用崩溃恢复日志来实现（参见第82页的“使B树可靠”），并且可以通过对每个对象的锁来实现隔离（允许一个线程在任何时候访问一个对象）。</p>
<p>有些数据库还提供了更复杂的原子操作，如增量操作，这就不需要像图7-1所示那样进行 read-modify-write 循环。同样流行的是 compare-and-set 操作，它只允许在值没有被其他人同时更改的情况下进行写入（参见第245页的“比较和设置”）。</p>
<p>这些单对象操作很有用，因为当多个客户机试图同时写入同一个对象时，它们可以防止丢失更新（请参阅第242页的“防止丢失”）。然而，它们并不是通常意义上的事务。出于营销目的，Compare and set和其他单对象操作被称为“轻量级事务”甚至“ACID”[20,21,22]，但这个术语是误导性的。事务通常被理解为将多个对象上的多个操作组合成一个执行单元的机制。</p>
<p>（2）多对象事务的需要</p>
<p>许多分布式数据存储已经放弃了多对象事务，因为它们很难跨分区实现，而且在某些需要非常高可用性或高性能的场景中，它们可能会成为障碍。然而，在分布式数据库中并没有什么能从根本上阻止事务，我们将在第9章讨论分布式事务的实现。</p>
<p>但我们需要多对象事务吗？是否有可能只使用键值数据模型和单对象操作来实现任何应用程序？在一些用例中，单对象插入、更新和删除就足够了。但是，在许多其他情况下，对多个不同对象的写入需要进行协调：</p>
<ul>
<li>在关系数据模型中，一个表中的一行通常具有另一个表中某行的外键引用。（类似地，在类似于图的数据模型中，一个顶点与其他顶点之间存在边。）多对象事务允许您确保这些引用保持有效：当插入多个相互引用的记录时，foreign键必须是正确的和最新的，否则数据将变得毫无意义。</li>
<li>在文档数据模型中，需要一起更新的字段通常位于同一个文档中，该文档被视为单个对象，更新单个文档时不需要多对象事务处理。然而，缺少join功能的document databases也鼓励非规范化（参见第38页的“关系数据库与文档数据库的对比”）。非标准化时
信息需要更新，如图7-2所示，您需要一次性更新多个文档。在这种情况下，事务对于防止非规范化数据不同步非常有用。</li>
<li>在具有二级索引的数据库中（除了纯键值存储区以外的几乎所有内容），每次更改值时都需要更新索引。从事务的角度来看，这些索引是不同的数据库对象：例如，如果没有事务隔离，一个记录可能出现在一个索引中而不是另一个索引中，因为第二个索引的更新还没有发生。</li>
</ul>
<p>这样应用程序仍然可以在没有事务的情况下实现。然而，如果没有原子性，错误处理会变得更加复杂，并且缺乏隔离可能会导致并发问题。我们将在233页讨论“弱隔离级别”中的问题，并在第12章中探讨替代方法。</p>
<p>（3）处理错误和中止</p>
<p>事务的一个关键特性是，如果发生错误，可以中止并安全地重试。ACID数据库基于这样的理念：如果数据库有可能违反其对原子性、隔离性或持久性的保证，那么它宁愿完全放弃事务，也不愿让事务保持半成品状态。</p>
<p>不过，并非所有的系统都遵循这一理念。特别是，使用无 Leader 复制的数据存储（请参阅177页的“无领导复制”）在“尽力而为”的基础上工作得更多，这可以概括为“数据库将尽其所能，如果遇到错误，它不会撤消它已经做过的事情”，所以应用程序有责任从错误中恢复。</p>
<p>错误不可避免地会发生，但是许多软件开发人员宁愿只考虑快乐的道路，而不是复杂的错误处理。例如，流行的对象关系映射（ORM）框架（如Rails的ActiveRecord和django）不会重试中止的事务，错误通常会导致异常冒出堆栈，因此任何用户输入都会被丢弃，用户会收到一条错误消息。这是一种耻辱，因为中止的全部目的是为了确保安全重试。不过重试中止的事务是一种简单有效的错误处理机制，但并不完美：</p>
<ul>
<li>如果事务实际成功，但网络在服务器尝试确认成功提交给客户端时失败（因此客户端认为它失败），则重试事务会导致事务执行两次，除非您有附加的应用程序级重复数据消除机制。</li>
<li>如果错误是由于过载导致的，则重试事务会使问题变得更糟，而不是更好。为了避免这种反馈周期，可以限制重试次数，使用指数回退，并处理与重载相关的错误，这些错误与其他错误不同（如果可能）。</li>
<li>只有在短暂错误（例如由于死锁、隔离冲突、临时网络中断和故障转移）之后才值得重试；在永久性错误（例如，违反约束）之后，重试将毫无意义。</li>
<li>如果事务在数据库之外也有副作用，即使事务被中止，这些副作用也可能发生。例如，如果您要发送电子邮件，您不希望每次重试事务时都再次发送电子邮件。如果您想确保几个不同的系统要么提交要么一起提交，那么两阶段提交会有所帮助（我们将在第354页的“原子提交和两阶段提交（2PC）”中讨论这个问题。</li>
<li>如果客户端进程在重试时失败，它试图写入数据库的任何数据都将丢失。</li>
</ul>
<h2 id="弱隔离等级">弱隔离等级</h2>
<p>如果两个事务不接触相同的数据，它们可以安全地并行运行，因为这两个事务都不依赖于另一个事务。只有当一个事务读取被另一个事务同时修改的数据，或者两个事务试图同时修改samedata时，并发问题（竞争条件）才会起作用。</p>
<p>通过测试很难发现并发性错误，因为只有在时间不走运的情况下才会触发此类bug。这样的时间问题可能很少发生，而且通常很难重现。并发性也是很难推理的，尤其是在大型应用程序中，您不一定知道还有哪些代码正在访问数据库。如果一次只有一个用户，那么应用程序开发就很困难；拥有许多并发用户会使开发变得更加困难，因为任何数据块都可能在任何时候意外地发生更改时间。</p>
<p>所以，数据库长期以来一直试图通过提供事务隔离来向应用程序开发人员隐藏并发问题。从理论上讲，隔离应该让你的生活更轻松，让你假装没有并发发生：serializable isolation意味着数据库保证事务具有与串行运行相同的效果（即，一次一个事务，没有任何并发）。</p>
<p>在实践中，不幸的是，隔离并不是那么简单。可串行化隔离有一个性能代价，许多数据库不想为此付出代价[8]。因此，建议系统使用<strong>较弱级别的隔离</strong>，这样可以防止一些并发问题，但不是全部。这些级别的隔离更难理解，它们可能会导致细微的错误，但它们仍然在实践中使用[23]。</p>
<p>弱事务隔离导致的并发错误不仅仅是一个理论问题。它们造成了巨大的资金损失[24,25]，导致了财务审计师的调查[26]，并导致客户数据被破坏[27]。对于这些问题的揭露，一个普遍的评论是“如果你在处理财务数据，就使用ACID数据库！“-但这没有抓住重点。甚至许多流行的关系数据库系统（通常被认为是“ACID”）都使用弱隔离，因此它们不一定能够阻止这些错误的发生。</p>
<p>我们不必盲目依赖工具，而是需要对存在的各种并发问题以及如何预防它们有一个很好的理解。然后我们就可以使用我们可以使用的工具来构建可靠和正确的应用程序。我们对隔离级别的讨论将是非正式的，使用示例。如果你想对它们的性质进行有趣的定义和分析，你可以在学术文献[28,29,30]中找到它们。</p>
<h3 id="读已提交">读已提交</h3>
<p>最基本的事务隔离级别是read committed。它有两个保证：</p>
<ol>
<li>从数据库读取时，您将只看到已提交的数据（没有脏读）。</li>
<li>写入数据库时，只覆盖已提交的数据（无脏写）。</li>
</ol>
<p>让我们更详细地讨论这两个保证。</p>
<p>（1）没有脏读</p>
<p>假设一个事务已将一些数据写入数据库，但该事务尚未提交或中止。<strong>另一个事务可以看到未提交的数据吗？如果是的，那就叫做脏读</strong>[2]。</p>
<p>在读提交隔离级别运行的事务必须防止脏读。这个意味着只有当事务提交时，事务的任何写入才会对其他事务可见（然后它的所有写操作都会立即可见）。如图7-4所示，其中用户1设置了 <code>x=3</code>，但用户2的 <code>get x</code> 仍然返回oldvalue 2，而用户1尚未提交。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_23-23-22.png" alt=""></p>
<p>防止脏读的原因如下：</p>
<ul>
<li>如果一个事务需要更新多个对象，<strong>脏读意味着另一个事务可能会看到某些更新，而其他事务则看不到其他更新</strong>。例如，在
图7-2，用户看到新的未读邮件，但没有更新的计数器。这是对这封邮件的一个肮脏的解读。看到数据库处于部分更新状态会让用户感到困惑，并可能导致其他事务做出错误的决定。</li>
<li>如果事务中止，则需要回滚它所做的任何写入操作（如图7-3所示）。如果数据库允许脏读，这意味着事务可能会生成稍后回滚的数据，也就是说，它从未真正提交到数据库。对后果的推理很快变得令人费解。</li>
</ul>
<p>（2）没有脏写</p>
<p>如果两个事务同时尝试更新adatabase中的同一对象，会发生什么情况？我们不知道写操作的顺序，但我们通常假设后面的写会覆盖前面的写。</p>
<p>但是，如果前面的写入操作是未提交yetcommitted的事务的一部分，那么后面的写入操作会覆盖未提交的值，会发生什么情况？这叫做dirty write[28]。通常情况下，在第二个已提交的写入事务中，必须通过延迟第二个已提交的写操作来阻止第二个事务的写入操作。</p>
<p>通过防止脏写，此隔离级别避免了某些类型的并发问题：</p>
<ul>
<li>如果事务更新多个对象，脏写可能导致坏结果。例如，考虑图7-5，它展示了一个二手车销售网站，上面有两个人，爱丽丝和鲍勃，同时都在试图买同样的汽车。买一辆车需要两个数据库写入：网站上的列表需要更新以反映买家，销售发票需要发送到买方。输入在图7-5中，销售被授予Bob（因为他对listings表执行了获胜更新），但是发票被发送给Alice（因为她对invoices表执行了winning更新）。读取已提交的可以防止这种不幸。</li>
<li>但是，read committed不会阻止图7-1中的计数器增量之间的竞争条件。在本例中，第二次写入发生在第一个事务已提交之后，因此它不是脏写。这仍然是不正确的，在242页的“防止丢失更新”中，我们将讨论如何使这种计数器增量安全。</li>
</ul>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_23-30-22.png" alt=""></p>
<p>（3）实现读提交</p>
<p>Read committed是一个非常流行的隔离级别。它是Oracle 11g、PostgreSQL、SQL Server 2012、MemSQL和许多其他数据库的默认设置[8]。</p>
<p>最常见的情况是，数据库通过使用<strong>行级锁来防止脏写</strong>：当事务要修改特定对象（行或文档）时，必须首先获取该对象的锁。然后它必须保持该锁，直到事务被提交或中止。只有一个事务可以持有任何给定对象的锁；如果另一个事务要写入同一对象，则必须等到第一个事务被提交或中止后才能获取锁并继续。这种锁定是由数据库以read committed模式（或更强的隔离级别）自动完成的。</p>
<p>我们如何防止脏读？一种选择是使用同一个锁，并要求任何想要读取对象的事务短暂地获取锁，然后在读取后立即释放它。这将确保在对象具有脏的未提交值时不会发生读取（因为在此期间，进行写入的事务将持有锁）。</p>
<p>然而，要求读锁的方法在实践中并不能很好地工作，因为一个长时间运行的写事务会迫使许多只读事务等待长时间运行的事务完成。这会损害只读事务的响应时间，并且不利于可操作性：由于等待锁，应用程序某个部分的速度减慢可能会对应用程序的另一个完全不同的部分产生连锁反应。</p>
<p>因此，大多数数据库都使用图7-4所示的方法来防止脏读：对于写入的每个对象，数据库都会记住旧的提交值和当前持有写锁的事务设置的新值。<strong>当事务正在进行时，读取该对象的任何其他事务都将被简单地赋予旧值</strong>。只有在提交新值时，事务才会切换到读取新值。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  
  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'Hw2fQnNQyghcgeRvQosC5cIy-gzGzoHsz',
        appKey: '0ULuPWcxGRLCaHz84icXvBgn',
        notify: 'false', 
        verify: 'false', 
        avatar:'mm', 
        placeholder: '说点什么吧...',
        visitor: 'true'
    });
  </script></div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#事务的模糊概念">事务的模糊概念</a>
      <ul>
        <li><a href="#acid-的意义">ACID 的意义</a></li>
        <li><a href="#单对象和多对象操作">单对象和多对象操作</a></li>
      </ul>
    </li>
    <li><a href="#弱隔离等级">弱隔离等级</a>
      <ul>
        <li><a href="#读已提交">读已提交</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  

  <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279346965'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279346965%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>



</html>












