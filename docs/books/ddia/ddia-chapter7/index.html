<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="设计数据密集型应用程序 - 事务"><meta property="og:title" content="设计数据密集型应用程序 - 事务" />
<meta property="og:description" content="设计数据密集型应用程序 - 事务  一些作者声称，一般的两阶段提交由于其带来的性能或可用性问题，支持起来过于昂贵。我们认为，最好让应用程序程序员在瓶颈出现时处理由于过度使用事务而导致的性能问题，而不是总是围绕缺少事务进行编码。 &mdash; James Corbett et al., Spanner: Google’s Globally-Distributed Database (2012)
 在数据系统的严酷现实中，很多事情都会出错：
 数据库软件或硬件可能随时发生故障（包括在写入操作的中间）。 应用程序可能随时崩溃（包括一系列操作的中途）。 网络中断可能会意外地切断应用程序与数据库的连接，或断开一个数据库节点与另一个数据库节点的连接。 多个客户端可能同时写入数据库，覆盖彼此的更改。 客户端可能会读取没有意义的数据，因为它只更新了一部分。 客户端之间的竞争条件可能会导致令人惊讶的错误。  为了可靠，系统必须处理这些故障，并确保它们不会导致整个系统的灾难性故障。然而，实现容错机制需要大量的工作。它需要仔细考虑所有可能出错的地方，并进行大量测试以确保解决方案能够实际工作。
几十年来，事务一直是简化这些问题的首选机制。事务是应用程序将多个读写操作组合到一个逻辑单元中的一种方法。从概念上讲，事务中的所有读写操作都作为一个操作执行：要么整个事务成功（commit），要么失败（abort，rollback）。如果失败，应用程序可以安全地重试。有了事务，应用程序的错误处理就变得简单多了，因为它不需要担心部分失败，也就是说，有些操作成功，有些操作失败（无论什么原因）。
如果你花了数年时间处理事务，它们可能看起来很明显，但我们不应该认为它们是理所当然的。事务不是自然规律；创建事务的目的是为了简化访问数据库的应用程序的编程模型。通过使用事务，应用程序可以自由地忽略某些潜在的错误场景和并发问题，因为数据库会处理它们（我们称之为安全保证）。
并不是每个应用程序都需要事务，有时削弱事务性保证或完全放弃事务性保证有好处（例如，为了获得更高的性能或更高的可用性）。一些安全属性可以在没有事务的情况下实现。
你如何判断你是否需要事务？为了回答这个问题，我们首先需要确切地了解事务可以提供什么样的安全保障，以及与之相关的成本。虽然乍一看事务似乎很简单，但实际上有许多微妙但重要的细节在起作用。
在本章中，我们将研究许多可能出错的例子，并探索数据库用来防范这些问题的算法。我们将特别深入到并发控制领域，讨论可能发生的各种竞争条件，以及数据库如何实现隔离级别，如读提交、快照隔离和串行化。
本章适用于单节点和分布式数据库；在第8章中，我们将重点讨论仅在分布式系统中出现的特定挑战。
事务的模糊概念 现在几乎所有的关系型数据库和一些非关系型数据库都支持事务。其中大多数都遵循ibmsystemr在1975年引入的样式，第一个SQL数据库[1，2，3]。虽然一些实现细节有所改变，但40年来，总体思路基本不变：MySQL、PostgreSQL、Oracle、sqlserver等的事务支持与systemr惊人地相似。
在21世纪末，非关系（NoSQL）数据库开始流行起来。他们希望通过提供新的数据模型（见第2章）和默认的复制（第5章）和分区（第6章）来改善关系现状。事务是这场运动的主要牺牲品：许多新一代数据库完全放弃了事务，或者重新定义了这个词来描述一组比以前理解的要弱得多的保证[4]。
随着这种新的分布式数据库的大肆宣传，人们普遍认为事务是可伸缩性的对立面，任何大型系统都必须放弃事务，以保持良好的性能和高可用性[5,6]。另一方面，事务性保证有时由数据库供应商提出，作为“严肃的应用程序”和“有价值的数据”的基本要求。
事实并非如此简单：与其他技术设计选择一样，事务有其优势和局限性。为了理解这些权衡，让我们详细介绍事务在正常操作和各种极端（但现实）情况下可以提供的保证。
ACID 的意义 事务提供的安全保证通常用众所周知的缩写ACID来描述，它代表原子性、一致性、隔离性和持久性。它是1983年由Theo Härder和Andreas Reuter[7]创造的，目的是为了在数据库。
但是在实践中，一个数据库的ACID实现并不等同于另一个数据库的实现。例如，正如我们将要看到的，孤立的含义有很多模棱两可的地方。高层次的想法是正确的，但魔鬼在于细节。今天，当一个系统声称“符合ACID”时，你还不清楚到底能得到什么样的保证。不幸的是，ACID已经成为一个市场术语。
（不符合ACID标准的系统有时称为BASE，它代表基本可用、软状态和最终一致性[9]。这甚至比ACID的定义更模糊。似乎对base唯一合理的定义是“not ACID”；也就是说，它几乎可以表示任何你想要的东西。）
让我们深入研究原子性、一致性、隔离性和持久性的定义，因为这将使我们完善我们对事务的概念。
（1）原子性
一般来说，原子是指不能分解成更小的东西零件。零件在计算机的不同分支中，单词的意思是相似但又微妙不同的东西。例如，在多线程编程中，如果一个线程执行原子操作，这意味着另一个线程不可能看到该操作的一半finishedresult。系统只能处于操作前或操作后的状态，而不是介于两者之间的状态。
相比之下，在ACID环境中，原子性与并发性无关。它没有描述如果多个进程试图同时访问同一个数据会发生什么，因为这是在字母I下的隔离（参见第225页的“隔离”）。
相反，ACID原子性描述的是，如果客户端想要进行多个写操作，但在处理了一些写入操作之后发生了错误，例如，进程崩溃、网络连接中断、磁盘已满或违反了某些完整性约束。如果写入操作被组合到一个atomic transaction中，并且由于错误而无法完成（提交）事务，则事务将中止，数据库必须放弃或撤消迄今为止在该事务中所做的任何写入操作。
如果没有原子性，如果在进行多次更改的过程中发生了错误，则很难知道哪些更改已生效，哪些更改没有生效。应用程序可以重试，但这有可能使同一更改发生两次，从而导致重复或不正确的数据。原子性简化了这个问题：如果一个事务被中止，应用程序可以确保它没有改变任何东西，所以它可以安全地被中止重试过了。
ACID原子性的定义特性是能够在出错时中止事务并放弃该事务中的所有写操作。也许可终止性比原子性更好，但我们还是坚持原子性，因为这是一个常用的词。
（2）一致性
“一致性”这个词严重超载：
 在第5章中，我们讨论了副本一致性以及异步复制系统中出现的最终一致性问题（请参阅第161页的“复制延迟问题”）。 一致哈希是一些系统用于重新平衡的分区方法（请参阅第204页的“一致哈希”）。 在CAP定理（见第9章）中，一致性一词用于表示线性化（见324页的“线性化能力”）。 在ACID的上下文中，一致性是指数据库处于“良好状态”的特定于应用程序的概念  不幸的是，同一个词至少有四种不同的意思。
ACID一致性的思想是关于数据的某些陈述（不变量）必须始终为真-例如，在一个会计系统中，所有账户的贷方和借方必须总是平衡的。如果事务以根据这些不变量有效的adatabase开始，并且事务期间的任何写入都保持有效性，那么您可以确保这些不变量始终是满意。
不过，这种一致性的思想依赖于应用程序的不变量概念，并且由应用程序负责定义它的事务处理是正确的，以便保留一致性。这不是数据库可以保证的：如果你写的坏数据违反了你的不变量，数据库不能阻止你。（数据库可以检查某些特定类型的不变量，例如使用foreignkey约束或唯一性约束。但是，一般情况下，应用程序会定义哪些数据有效或无效，而数据库只存储这些数据。）
原子性、隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。为了实现一致性，应用程序可能会重新连接数据库的原子性和隔离属性，但这并不仅仅取决于数据库。因此，字母C并不真的属于ACID。
（3）隔离
大多数数据库同时由多个客户端访问。如果他们在读写数据库的不同部分，这是没有问题的，但是如果他们访问相同的数据库记录，你可能会遇到并发问题（竞争条件）。
假设您有两个客户端同时递增存储在数据库中的计数器。每个客户端需要读取当前值，添加1，然后将新值写回（假设数据库中没有内置任何增量操作）。在图7-1中，计数器应该从42增加到44，因为发生了两个增量，但实际上由于竞争条件，它只增加到43。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kunzhao.org/docs/books/ddia/ddia-chapter7/" />

<title>设计数据密集型应用程序 - 事务 | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.a04069c4ba149e24630fa6fbc98cd4da6e386beb4688b0aae5809dbb5660cd77.css" integrity="sha256-oEBpxLoUniRjD6b7yYzU2m44a&#43;tGiLCq5YCdu1ZgzXc=">


<script defer src="/en.search.min.c9c7d09125208f45ba615a2688957841c6ac7800b6477e2c231b298174dfdb0c.js" integrity="sha256-ycfQkSUgj0W6YVomiJV4QcaseAC2R34sIxspgXTf2ww="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      👉招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/beauty_of_mathematics/" >
      数学之美
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/history_of_quantum_physics/" >
      上帝掷骰子吗
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/clean_code/" >
      代码整洁之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the_transformation_of_enterprise_it_architecture/" >
      企业 IT 架构转型之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/redis_5_source_code/" >
      Redis 5 设计与源码分析
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/in-depth_analysis_of_the_core_technology_of_apache_dubbo/" >
      深度剖析 Apache Dubbo 核心技术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/everyone-is-architect/" >
      人人都是架构师 (一)
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-art-of-readable-code/" >
      编写可读代码的艺术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-wisdom-of-trading-stocks/" >
      炒股的智慧
  </a>

</li>
      
    
      
        

  <li >
    
      

  <a href="/docs/books/ddia/" >
      设计数据密集型应用程序
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter1/" >
      设计数据密集型应用程序 - 可靠 &amp; 可扩展 &amp; 可维护
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter2/" >
      设计数据密集型应用程序 - 数据模型 &amp; 查询语言
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter3/" >
      设计数据密集型应用程序 - 存储和读取
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter4/" >
      设计数据密集型应用程序 - 编码与演化
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter5/" >
      设计数据密集型应用程序 - Replication
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter6/" >
      设计数据密集型应用程序 - Partitioning
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter7/"  class="active">
      设计数据密集型应用程序 - 事务
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter8/" >
      设计数据密集型应用程序 - 分布式系统的难点
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter9/" >
      设计数据密集型应用程序 - 一致性和共识
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>设计数据密集型应用程序 - 事务</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#事务的模糊概念">事务的模糊概念</a>
      <ul>
        <li><a href="#acid-的意义">ACID 的意义</a></li>
        <li><a href="#单对象和多对象操作">单对象和多对象操作</a></li>
      </ul>
    </li>
    <li><a href="#弱隔离等级">弱隔离等级</a>
      <ul>
        <li><a href="#读已提交">读已提交</a></li>
        <li><a href="#快照隔离和可重复读取">快照隔离和可重复读取</a></li>
        <li><a href="#防止丢失更新">防止丢失更新</a></li>
        <li><a href="#写歪斜和幻影">写歪斜和幻影</a></li>
      </ul>
    </li>
    <li><a href="#序列化">序列化</a>
      <ul>
        <li><a href="#实际串行执行">实际串行执行</a></li>
        <li><a href="#二阶段锁定-2pl">二阶段锁定 (2PL)</a></li>
        <li><a href="#可序列化快照隔离ssi">可序列化快照隔离（SSI）</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown"><h1 id="设计数据密集型应用程序---事务">设计数据密集型应用程序 - 事务</h1>
<blockquote>
<p>一些作者声称，一般的两阶段提交由于其带来的性能或可用性问题，支持起来过于昂贵。我们认为，最好让应用程序程序员在瓶颈出现时处理由于过度使用事务而导致的性能问题，而不是总是围绕缺少事务进行编码。 &mdash; James Corbett et al., Spanner: Google’s Globally-Distributed Database (2012)</p>
</blockquote>
<p>在数据系统的严酷现实中，很多事情都会出错：</p>
<ul>
<li>数据库软件或硬件可能随时发生故障（包括在写入操作的中间）。</li>
<li>应用程序可能随时崩溃（包括一系列操作的中途）。</li>
<li>网络中断可能会意外地切断应用程序与数据库的连接，或断开一个数据库节点与另一个数据库节点的连接。</li>
<li>多个客户端可能同时写入数据库，覆盖彼此的更改。</li>
<li>客户端可能会读取没有意义的数据，因为它只更新了一部分。</li>
<li>客户端之间的竞争条件可能会导致令人惊讶的错误。</li>
</ul>
<p>为了可靠，系统必须处理这些故障，并确保它们不会导致整个系统的灾难性故障。然而，实现容错机制需要大量的工作。它需要仔细考虑所有可能出错的地方，并进行大量测试以确保解决方案能够实际工作。</p>
<p>几十年来，事务一直是简化这些问题的首选机制。事务是应用程序将多个读写操作组合到一个逻辑单元中的一种方法。从概念上讲，事务中的所有读写操作都作为一个操作执行：要么整个事务成功（commit），要么失败（abort，rollback）。如果失败，应用程序可以安全地重试。有了事务，应用程序的错误处理就变得简单多了，因为它不需要担心部分失败，也就是说，有些操作成功，有些操作失败（无论什么原因）。</p>
<p>如果你花了数年时间处理事务，它们可能看起来很明显，但我们不应该认为它们是理所当然的。事务不是自然规律；创建事务的目的是为了简化访问数据库的应用程序的编程模型。通过使用事务，应用程序可以自由地忽略某些潜在的错误场景和并发问题，因为数据库会处理它们（我们称之为安全保证）。</p>
<p>并不是每个应用程序都需要事务，有时削弱事务性保证或完全放弃事务性保证有好处（例如，为了获得更高的性能或更高的可用性）。一些安全属性可以在没有事务的情况下实现。</p>
<p>你如何判断你是否需要事务？为了回答这个问题，我们首先需要确切地了解事务可以提供什么样的安全保障，以及与之相关的成本。虽然乍一看事务似乎很简单，但实际上有许多微妙但重要的细节在起作用。</p>
<p>在本章中，我们将研究许多可能出错的例子，并探索数据库用来防范这些问题的算法。我们将特别深入到并发控制领域，讨论可能发生的各种竞争条件，以及数据库如何实现隔离级别，如读提交、快照隔离和串行化。</p>
<p>本章适用于单节点和分布式数据库；在第8章中，我们将重点讨论仅在分布式系统中出现的特定挑战。</p>
<h2 id="事务的模糊概念">事务的模糊概念</h2>
<p>现在几乎所有的关系型数据库和一些非关系型数据库都支持事务。其中大多数都遵循ibmsystemr在1975年引入的样式，第一个SQL数据库[1，2，3]。虽然一些实现细节有所改变，但40年来，总体思路基本不变：MySQL、PostgreSQL、Oracle、sqlserver等的事务支持与systemr惊人地相似。</p>
<p>在21世纪末，非关系（NoSQL）数据库开始流行起来。他们希望通过提供新的数据模型（见第2章）和默认的复制（第5章）和分区（第6章）来改善关系现状。事务是这场运动的主要牺牲品：许多新一代数据库完全放弃了事务，或者重新定义了这个词来描述一组比以前理解的要弱得多的保证[4]。</p>
<p>随着这种新的分布式数据库的大肆宣传，人们普遍认为事务是可伸缩性的对立面，任何大型系统都必须放弃事务，以保持良好的性能和高可用性[5,6]。另一方面，事务性保证有时由数据库供应商提出，作为“严肃的应用程序”和“有价值的数据”的基本要求。</p>
<p>事实并非如此简单：与其他技术设计选择一样，事务有其优势和局限性。为了理解这些权衡，让我们详细介绍事务在正常操作和各种极端（但现实）情况下可以提供的保证。</p>
<h3 id="acid-的意义">ACID 的意义</h3>
<p>事务提供的安全保证通常用众所周知的缩写ACID来描述，它代表原子性、一致性、隔离性和持久性。它是1983年由Theo Härder和Andreas Reuter[7]创造的，目的是为了在数据库。</p>
<p>但是在实践中，一个数据库的ACID实现并不等同于另一个数据库的实现。例如，正如我们将要看到的，孤立的含义有很多模棱两可的地方。高层次的想法是正确的，但魔鬼在于细节。今天，当一个系统声称“符合ACID”时，你还不清楚到底能得到什么样的保证。不幸的是，ACID已经成为一个市场术语。</p>
<p>（不符合ACID标准的系统有时称为BASE，它代表基本可用、软状态和最终一致性[9]。这甚至比ACID的定义更模糊。似乎对base唯一合理的定义是“not ACID”；也就是说，它几乎可以表示任何你想要的东西。）</p>
<p>让我们深入研究原子性、一致性、隔离性和持久性的定义，因为这将使我们完善我们对事务的概念。</p>
<p>（1）原子性</p>
<p>一般来说，原子是指不能分解成更小的东西零件。零件在计算机的不同分支中，单词的意思是相似但又微妙不同的东西。例如，在多线程编程中，如果一个线程执行原子操作，这意味着另一个线程不可能看到该操作的一半finishedresult。系统只能处于操作前或操作后的状态，而不是介于两者之间的状态。</p>
<p>相比之下，在ACID环境中，原子性与并发性无关。它没有描述如果多个进程试图同时访问同一个数据会发生什么，因为这是在字母I下的隔离（参见第225页的“隔离”）。</p>
<p>相反，ACID原子性描述的是，如果客户端想要进行多个写操作，但在处理了一些写入操作之后发生了错误，例如，进程崩溃、网络连接中断、磁盘已满或违反了某些完整性约束。如果写入操作被组合到一个atomic transaction中，并且由于错误而无法完成（提交）事务，则事务将中止，数据库必须放弃或撤消迄今为止在该事务中所做的任何写入操作。</p>
<p><strong>如果没有原子性，如果在进行多次更改的过程中发生了错误，则很难知道哪些更改已生效，哪些更改没有生效</strong>。应用程序可以重试，但这有可能使同一更改发生两次，从而导致重复或不正确的数据。原子性简化了这个问题：如果一个事务被中止，应用程序可以确保它没有改变任何东西，所以它可以安全地被中止重试过了。</p>
<p>ACID原子性的定义特性是能够在出错时中止事务并放弃该事务中的所有写操作。也许可终止性比原子性更好，但我们还是坚持原子性，因为这是一个常用的词。</p>
<p>（2）一致性</p>
<p>“一致性”这个词严重超载：</p>
<ul>
<li>在第5章中，我们讨论了副本一致性以及异步复制系统中出现的最终一致性问题（请参阅第161页的“复制延迟问题”）。</li>
<li>一致哈希是一些系统用于重新平衡的分区方法（请参阅第204页的“一致哈希”）。</li>
<li>在CAP定理（见第9章）中，一致性一词用于表示线性化（见324页的“线性化能力”）。</li>
<li>在ACID的上下文中，一致性是指数据库处于“良好状态”的特定于应用程序的概念</li>
</ul>
<p>不幸的是，同一个词至少有四种不同的意思。</p>
<p>ACID<strong>一致性的思想是关于数据的某些陈述（不变量）必须始终为真</strong>-例如，在一个会计系统中，<strong>所有账户的贷方和借方必须总是平衡的</strong>。如果事务以根据这些不变量有效的adatabase开始，并且事务期间的任何写入都保持有效性，那么您可以确保这些不变量始终是满意。</p>
<p>不过，这种一致性的思想依赖于应用程序的不变量概念，并且由应用程序负责定义它的事务处理是正确的，以便保留一致性。这不是数据库可以保证的：如果你写的坏数据违反了你的不变量，数据库不能阻止你。（数据库可以检查某些特定类型的不变量，例如使用foreignkey约束或唯一性约束。但是，一般情况下，应用程序会定义哪些数据有效或无效，而数据库只存储这些数据。）</p>
<p>原子性、隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。为了实现一致性，应用程序可能会重新连接数据库的原子性和隔离属性，但这并不仅仅取决于数据库。因此，<strong>字母C并不真的属于ACID</strong>。</p>
<p>（3）隔离</p>
<p>大多数数据库同时由多个客户端访问。如果他们在读写数据库的不同部分，这是没有问题的，但是如果他们访问相同的数据库记录，你可能会遇到并发问题（竞争条件）。</p>
<p>假设您有两个客户端同时递增存储在数据库中的计数器。每个客户端需要读取当前值，添加1，然后将新值写回（假设数据库中没有内置任何增量操作）。在图7-1中，计数器应该从42增加到44，因为发生了两个增量，但实际上由于竞争条件，它只增加到43。</p>
<p>ACID意义上的<strong>隔离意味着并发执行的事务是相互隔离的：它们不能相互干涉。<strong>经典的数据库教科书将隔离形式化为</strong>可序列化</strong>，这意味着每个事务都可以假装它是整个数据库上运行的唯一事务。数据库确保当事务提交后，结果与串行运行（一个接一个）相同，即使实际上它们可能同时运行[10]。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_22-45-35.png" alt=""></p>
<p>然而，在实践中，可序列化隔离很少使用，因为它会带来性能损失。一些流行的数据库，比如oracle11g，甚至没有实现它。在Oracle有一个名为“serializable”的隔离级别，但实际上它实现了一种称为snapshot isolation的方法，这比serializability的保证要弱[8,11]。我们将在233页的“弱隔离级别”中探讨快照隔离和其他形式的隔离。</p>
<p>（4）耐久性</p>
<p>数据库系统的目的是提供一个安全的地方来存储数据，而不必担心丢失。持久性是指一旦事务成功提交，它<strong>所写的任何数据都不会被遗忘</strong>，即使存在硬件故障或数据库崩溃。</p>
<p>在单节点数据库中，持久性通常意味着数据已被写入非易失性存储器，如硬盘驱动器或SSD。它通常还需要写一个headlog或类似的（参见第82页的“使B树可靠”），这样可以在磁盘上的数据结构损坏时进行恢复。在复制的数据库中，持久性可能意味着数据已成功复制到一定数量的节点。为了提供持久性保证，数据库必须等到这些写入或复制完成后才能成功地报告事务承诺。</p>
<p>作为在第6页的“可靠性”中讨论过，完美的耐久性是不存在的：如果你的所有硬盘和备份同时被销毁，那么显然什么都没有你的数据库可以帮你保存。</p>
<p><strong>复制和耐用性</strong></p>
<p>历史上，耐用性意味着写入存档磁带。然后它被理解为写入磁盘或SSD。最近，它被改编成复制。哪个执行更好？</p>
<p>事实是，没有什么是完美的：</p>
<ul>
<li>如果您写入磁盘后机器死机，即使您的数据没有丢失，在您修复机器或将磁盘传输到另一台热机器之前，它仍然是不可访问的。复制的系统可以保持可用。</li>
<li>相关故障—停电或使特定输入上的每个节点崩溃的bug可以一次关闭所有副本（请参阅第6页的“可靠性”），从而丢失仅存在于内存中的任何数据。因此，写入磁盘仍然与内存数据库相关。•在异步复制系统中，当读卡器不可用时，最近的写入可能会丢失（请参阅第156页的“处理节点中断”）。</li>
<li>当电源突然中断时，特别是固态硬盘有时会违反它们应该提供的保证：即使是 <code>fsync</code> 也不能保证正常工作[12]。磁盘固件可能有错误，就像任何其他类型的软件一样[13，14]。</li>
<li>存储引擎和文件系统实现之间的细微交互可能导致难以跟踪的错误，并可能导致磁盘上的文件在崩溃后损坏[15,16]。</li>
<li>磁盘上的数据可能会逐渐损坏而不会被检测到[17]。如果数据已损坏一段时间，副本和最近的备份也可能会被破坏。在这种情况下，您需要尝试从历史备份中恢复数据。</li>
<li>对固态硬盘的一项研究发现，30%到80%的硬盘在运行的头四年内至少会出现一个坏块[18]。与固态硬盘相比，磁性硬盘的坏扇区率更低，但完全故障率更高。</li>
<li>如果SSD断开电源，它可能在几周内开始丢失数据，具体取决于温度[19]。</li>
</ul>
<p>实际上，没有一种技术可以提供绝对的保证。只有各种降低风险的技术，包括写入磁盘、复制到远程计算机和备份，它们可以而且应该一起使用。同样，明智的做法是在理论上保证健康。</p>
<h3 id="单对象和多对象操作">单对象和多对象操作</h3>
<p>概括地说，在ACID中，原子性和隔离性描述了如果客户端在同一事务中进行多次写入，数据库应该做什么：</p>
<ul>
<li><strong>原子性</strong>：如果在写入序列的中途发生错误，则应中止事务，并应放弃在此之前进行的写入。换句话说，数据库通过提供<strong>全有或全无</strong>的保证，使您不必担心部分故障。</li>
<li><strong>隔离性</strong>：事务之间不应该相互干扰。例如，如果一个事务进行了多次写入，那么<strong>另一个事务应该看到这些写入的全部或全部</strong>，而不是某个子集。</li>
</ul>
<p>这些定义假定您希望一次修改多个对象（行、文档、记录）。如果多个数据需要保持同步，则通常需要这样的多对象事务。图7-2显示了一个电子邮件示例应用程序。到显示用户的未读邮件数，您可以查询如下内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">FROM</span> emails <span style="color:#66d9ef">WHERE</span> recipient_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">AND</span> unread_flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</code></pre></div><p>但是，如果有许多电子邮件，您可能会发现此查询太慢，并决定将未读邮件的数量存储在单独的字段中（一种非规范化）。现在，每当有新消息传入时，您也必须增加未读计数器，并且每当消息被标记为已读时，您还必须删除未读计数器。</p>
<p>在图7-2中，用户2经历了一个异常：邮箱列表显示一个未读消息，但计数器显示零个未读消息，因为计数器尚未递增发生了。隔离可以通过确保用户2同时看到插入的电子邮件和更新的计数器，或者两者都看不到来防止这个问题，但没有不一致的中间点。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_22-58-57.png" alt=""></p>
<p>图7-3说明了原子性的必要性：如果在事务处理过程中某个地方发生错误，邮箱和未读计数器的内容可能会不同步。在原子事务中，如果对计数器的更新失败，事务将中止，插入的电子邮件将回滚。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_22-59-45.png" alt=""></p>
<p>多对象事务需要某种方法来确定哪些读操作和写操作属于同一事务。在关系数据库中，这通常是基于客户端到数据库服务器的TCP连接的一种方式：在任何特定的连接中，BEGIN事务和COMMIT语句之间的所有内容都被视为同一事务的一部分。</p>
<p>另一方面，许多非关系数据库没有这种将操作分组在一起的方法。即使有一个多对象API（例如，一个key-valuestore可能有一个在一个操作中更新多个键的multi-put操作），也不一定意味着它具有事务语义：对于某些键，命令可能成功，而对于其他键，命令可能会失败，从而使数据库处于部分更新的状态州。</p>
<p>（1）单对象写入</p>
<p>当单个对象被更改时，原子性和隔离性也适用。例如，假设您正在向数据库写入一个20 KB的JSON文档：</p>
<ul>
<li>如果在发送前10 KB后网络连接中断，数据库是否存储了无法解析的10 KB JSON片段？</li>
<li>如果在数据库覆盖磁盘上以前的值的过程中电源出现故障，您是否最终将新旧值拼接在一起？</li>
<li>如果另一个客户端在写入过程中读取该文档，它是否会看到部分更新的值？</li>
</ul>
<p>这些问题会令人难以置信地令人困惑，因此存储引擎几乎普遍都会在一个节点上的单个对象（如keyvalue对）级别上提供原子性和隔离性。原子性可以使用崩溃恢复日志来实现（参见第82页的“使B树可靠”），并且可以通过对每个对象的锁来实现隔离（允许一个线程在任何时候访问一个对象）。</p>
<p>有些数据库还提供了更复杂的原子操作，如增量操作，这就不需要像图7-1所示那样进行 read-modify-write 循环。同样流行的是 compare-and-set 操作，它只允许在值没有被其他人同时更改的情况下进行写入（参见第245页的“比较和设置”）。</p>
<p>这些单对象操作很有用，因为当多个客户端试图同时写入同一个对象时，它们可以防止丢失更新（请参阅第242页的“防止丢失”）。然而，它们并不是通常意义上的事务。出于营销目的，Compare and set和其他单对象操作被称为“轻量级事务”甚至“ACID”[20,21,22]，但这个术语是误导性的。事务通常被理解为将多个对象上的多个操作组合成一个执行单元的机制。</p>
<p>（2）多对象事务的需要</p>
<p>许多分布式数据存储已经放弃了多对象事务，因为它们很难跨分区实现，而且在某些需要非常高可用性或高性能的场景中，它们可能会成为障碍。然而，在分布式数据库中并没有什么能从根本上阻止事务，我们将在第9章讨论分布式事务的实现。</p>
<p>但我们需要多对象事务吗？是否有可能只使用键值数据模型和单对象操作来实现任何应用程序？在一些用例中，单对象插入、更新和删除就足够了。但是，在许多其他情况下，对多个不同对象的写入需要进行协调：</p>
<ul>
<li>在关系数据模型中，一个表中的一行通常具有另一个表中某行的外键引用。（类似地，在类似于图的数据模型中，一个顶点与其他顶点之间存在边。）多对象事务允许您确保这些引用保持有效：当插入多个相互引用的记录时，foreign键必须是正确的和最新的，否则数据将变得毫无意义。</li>
<li>在文档数据模型中，需要一起更新的字段通常位于同一个文档中，该文档被视为单个对象，更新单个文档时不需要多对象事务处理。然而，缺少join功能的document databases也鼓励非规范化（参见第38页的“关系数据库与文档数据库的对比”）。非标准化时
信息需要更新，如图7-2所示，您需要一次性更新多个文档。在这种情况下，事务对于防止非规范化数据不同步非常有用。</li>
<li>在具有二级索引的数据库中（除了纯键值存储区以外的几乎所有内容），每次更改值时都需要更新索引。从事务的角度来看，这些索引是不同的数据库对象：例如，如果没有事务隔离，一个记录可能出现在一个索引中而不是另一个索引中，因为第二个索引的更新还没有发生。</li>
</ul>
<p>这样应用程序仍然可以在没有事务的情况下实现。然而，如果没有原子性，错误处理会变得更加复杂，并且缺乏隔离可能会导致并发问题。我们将在233页讨论“弱隔离级别”中的问题，并在第12章中探讨替代方法。</p>
<p>（3）处理错误和中止</p>
<p>事务的一个关键特性是，如果发生错误，可以中止并安全地重试。ACID数据库基于这样的理念：如果数据库有可能违反其对原子性、隔离性或持久性的保证，那么它宁愿完全放弃事务，也不愿让事务保持半成品状态。</p>
<p>不过，并非所有的系统都遵循这一理念。特别是，使用无 Leader 复制的数据存储（请参阅177页的“无领导复制”）在“尽力而为”的基础上工作得更多，这可以概括为“数据库将尽其所能，如果遇到错误，它不会撤消它已经做过的事情”，所以应用程序有责任从错误中恢复。</p>
<p>错误不可避免地会发生，但是许多软件开发人员宁愿只考虑快乐的道路，而不是复杂的错误处理。例如，流行的对象关系映射（ORM）框架（如Rails的ActiveRecord和django）不会重试中止的事务，错误通常会导致异常冒出堆栈，因此任何用户输入都会被丢弃，用户会收到一条错误消息。这是一种耻辱，因为中止的全部目的是为了确保安全重试。不过重试中止的事务是一种简单有效的错误处理机制，但并不完美：</p>
<ul>
<li>如果事务实际成功，但网络在服务器尝试确认成功提交给客户端时失败（因此客户端认为它失败），则重试事务会导致事务执行两次，除非您有附加的应用程序级重复数据消除机制。</li>
<li>如果错误是由于过载导致的，则重试事务会使问题变得更糟，而不是更好。为了避免这种反馈周期，可以限制重试次数，使用指数回退，并处理与重载相关的错误，这些错误与其他错误不同（如果可能）。</li>
<li>只有在短暂错误（例如由于死锁、隔离冲突、临时网络中断和故障转移）之后才值得重试；在永久性错误（例如，违反约束）之后，重试将毫无意义。</li>
<li>如果事务在数据库之外也有副作用，即使事务被中止，这些副作用也可能发生。例如，如果您要发送电子邮件，您不希望每次重试事务时都再次发送电子邮件。如果您想确保几个不同的系统要么提交要么一起提交，那么两阶段提交会有所帮助（我们将在第354页的“原子提交和两阶段提交（2PC）”中讨论这个问题。</li>
<li>如果客户端进程在重试时失败，它试图写入数据库的任何数据都将丢失。</li>
</ul>
<h2 id="弱隔离等级">弱隔离等级</h2>
<p>如果两个事务不接触相同的数据，它们可以安全地并行运行，因为这两个事务都不依赖于另一个事务。只有当一个事务读取被另一个事务同时修改的数据，或者两个事务试图同时修改samedata时，并发问题（竞争条件）才会起作用。</p>
<p>通过测试很难发现并发性错误，因为只有在时间不走运的情况下才会触发此类bug。这样的时间问题可能很少发生，而且通常很难重现。并发性也是很难推理的，尤其是在大型应用程序中，您不一定知道还有哪些代码正在访问数据库。如果一次只有一个用户，那么应用程序开发就很困难；拥有许多并发用户会使开发变得更加困难，因为任何数据块都可能在任何时候意外地发生更改时间。</p>
<p>所以，数据库长期以来一直试图通过提供事务隔离来向应用程序开发人员隐藏并发问题。从理论上讲，隔离应该让你的生活更轻松，让你假装没有并发发生：serializable isolation意味着数据库保证事务具有与串行运行相同的效果（即，一次一个事务，没有任何并发）。</p>
<p>在实践中，不幸的是，隔离并不是那么简单。可串行化隔离有一个性能代价，许多数据库不想为此付出代价[8]。因此，建议系统使用<strong>较弱级别的隔离</strong>，这样可以防止一些并发问题，但不是全部。这些级别的隔离更难理解，它们可能会导致细微的错误，但它们仍然在实践中使用[23]。</p>
<p>弱事务隔离导致的并发错误不仅仅是一个理论问题。它们造成了巨大的资金损失[24,25]，导致了财务审计师的调查[26]，并导致客户数据被破坏[27]。对于这些问题的揭露，一个普遍的评论是“如果你在处理财务数据，就使用ACID数据库！“-但这没有抓住重点。甚至许多流行的关系数据库系统（通常被认为是“ACID”）都使用弱隔离，因此它们不一定能够阻止这些错误的发生。</p>
<p>我们不必盲目依赖工具，而是需要对存在的各种并发问题以及如何预防它们有一个很好的理解。然后我们就可以使用我们可以使用的工具来构建可靠和正确的应用程序。我们对隔离级别的讨论将是非正式的，使用示例。如果你想对它们的性质进行有趣的定义和分析，你可以在学术文献[28,29,30]中找到它们。</p>
<h3 id="读已提交">读已提交</h3>
<p>最基本的事务隔离级别是read committed。它有两个保证：</p>
<ol>
<li>从数据库读取时，您将只看到已提交的数据（没有脏读）。</li>
<li>写入数据库时，只覆盖已提交的数据（无脏写）。</li>
</ol>
<p>让我们更详细地讨论这两个保证。</p>
<p>（1）没有脏读</p>
<p>假设一个事务已将一些数据写入数据库，但该事务尚未提交或中止。<strong>另一个事务可以看到未提交的数据吗？如果是的，那就叫做脏读</strong>[2]。</p>
<p>在读提交隔离级别运行的事务必须防止脏读。这个意味着只有当事务提交时，事务的任何写入才会对其他事务可见（然后它的所有写操作都会立即可见）。如图7-4所示，其中用户1设置了 <code>x=3</code>，但用户2的 <code>get x</code> 仍然返回oldvalue 2，而用户1尚未提交。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_23-23-22.png" alt=""></p>
<p>防止脏读的原因如下：</p>
<ul>
<li>如果一个事务需要更新多个对象，<strong>脏读意味着另一个事务可能会看到某些更新，而其他事务则看不到其他更新</strong>。例如，在
图7-2，用户看到新的未读邮件，但没有更新的计数器。这是对这封邮件的一个肮脏的解读。看到数据库处于部分更新状态会让用户感到困惑，并可能导致其他事务做出错误的决定。</li>
<li>如果事务中止，则需要回滚它所做的任何写入操作（如图7-3所示）。如果数据库允许脏读，这意味着事务可能会生成稍后回滚的数据，也就是说，它从未真正提交到数据库。对后果的推理很快变得令人费解。</li>
</ul>
<p>（2）没有脏写</p>
<p>如果两个事务同时尝试更新adatabase中的同一对象，会发生什么情况？我们不知道写操作的顺序，但我们通常假设后面的写会覆盖前面的写。</p>
<p>但是，如果前面的写入操作是未提交yetcommitted的事务的一部分，那么后面的写入操作会覆盖未提交的值，会发生什么情况？这叫做dirty write[28]。通常情况下，在第二个已提交的写入事务中，必须通过延迟第二个已提交的写操作来阻止第二个事务的写入操作。</p>
<p>通过防止脏写，此隔离级别避免了某些类型的并发问题：</p>
<ul>
<li>如果事务更新多个对象，脏写可能导致坏结果。例如，考虑图7-5，它展示了一个二手车销售网站，上面有两个人，爱丽丝和鲍勃，同时都在试图买同样的汽车。买一辆车需要两个数据库写入：网站上的列表需要更新以反映买家，销售发票需要发送到买方。输入在图7-5中，销售被授予Bob（因为他对listings表执行了获胜更新），但是发票被发送给Alice（因为她对invoices表执行了winning更新）。读取已提交的可以防止这种不幸。</li>
<li>但是，read committed不会阻止图7-1中的计数器增量之间的竞争条件。在本例中，第二次写入发生在第一个事务已提交之后，因此它不是脏写。这仍然是不正确的，在242页的“防止丢失更新”中，我们将讨论如何使这种计数器增量安全。</li>
</ul>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_23-30-22.png" alt=""></p>
<p>（3）实现读提交</p>
<p>Read committed是一个非常流行的隔离级别。它是Oracle 11g、PostgreSQL、SQL Server 2012、MemSQL和许多其他数据库的默认设置[8]。</p>
<p>最常见的情况是，数据库通过使用<strong>行级锁来防止脏写</strong>：当事务要修改特定对象（行或文档）时，必须首先获取该对象的锁。然后它必须保持该锁，直到事务被提交或中止。只有一个事务可以持有任何给定对象的锁；如果另一个事务要写入同一对象，则必须等到第一个事务被提交或中止后才能获取锁并继续。这种锁定是由数据库以read committed模式（或更强的隔离级别）自动完成的。</p>
<p>我们如何防止脏读？一种选择是使用同一个锁，并要求任何想要读取对象的事务短暂地获取锁，然后在读取后立即释放它。这将确保在对象具有脏的未提交值时不会发生读取（因为在此期间，进行写入的事务将持有锁）。</p>
<p>然而，要求读锁的方法在实践中并不能很好地工作，因为一个长时间运行的写事务会迫使许多只读事务等待长时间运行的事务完成。这会损害只读事务的响应时间，并且不利于可操作性：由于等待锁，应用程序某个部分的速度减慢可能会对应用程序的另一个完全不同的部分产生连锁反应。</p>
<p>因此，大多数数据库都使用图7-4所示的方法来防止脏读：对于写入的每个对象，数据库都会记住旧的提交值和当前持有写锁的事务设置的新值。<strong>当事务正在进行时，读取该对象的任何其他事务都将被简单地赋予旧值</strong>。只有在提交新值时，事务才会切换到读取新值。</p>
<h3 id="快照隔离和可重复读取">快照隔离和可重复读取</h3>
<p>如果您对read-committed隔离进行了肤浅的研究，那么您认为它做了事务需要做的所有事情：它允许中止（原子性所必需的），它防止读取事务的不完整结果，并防止并发写操作混合在一起。实际上，这些都是有用的特性，而且比没有事务处理的系统能提供的更强大的保证。</p>
<p>但是，在使用这个隔离级别时，仍然有很多方法可以导致并发错误。例如，图7-6说明了在提交读取时可能出现的问题。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-29_13-21-35.png" alt=""></p>
<p>假设爱丽丝在一家银行有1000美元的存款，分成两个账户，每个账户500美元。现在一笔事务将100美元从她的一个账户转到另一个账户。如果她不走运，在事务处理的同一时刻查看账户余额列表，她可能会在收到付款之前一次看到一个账户余额（余额为500美元），另一个账户在转出转账后（新余额为400美元）。对爱丽丝来说，她现在似乎只有900美元在她的帐户上，似乎100美元已经消失在空气中。</p>
<p>这种异常被称为不可重复读取或读取倾斜：如果Alice在事务结束时再次读取account 1的余额，她将看到与她在上一次查询中看到的不同的值（$600）。在Read-committed隔离下，Read-skew被认为是可以接受的：Alice看到的帐户余额确实在她读取时被提交。</p>
<p>在爱丽丝的例子中，这并不是一个持久的问题，因为如果她在几秒钟后重新加载网上银行网站，她很可能会看到稳定的账户余额。但是，有些情况不能容忍这种暂时的不一致：</p>
<ul>
<li>备份</li>
</ul>
<p>备份需要制作整个数据库的副本，在大型数据库上可能需要几个小时。在备份进程运行期间，将继续对数据库进行写入操作。因此，备份的某些部分可能包含旧版本的数据，而其他部分则包含较新版本的数据。如果您需要从这样的备份中恢复，则矛盾（比如消失的钱）成为永久性的。</p>
<ul>
<li>分析查询和完整性检查</li>
</ul>
<p>有时，您可能希望运行一个对数据库的大部分进行扫描的查询。这类查询在分析中很常见（参见“事务处理或分析”？或是定期完整性检查的一部分，以确保一切正常（监控数据损坏）。如果这些查询在不同的时间点观察数据库的某些部分，则可能返回无意义的结果。
快照隔离[28]是解决这个问题的最常见方法。其思想是，每个事务都从数据库的一致快照中读取，也就是说，事务操作会看到在事务开始时提交到数据库中的所有数据。即使数据随后被另一个事务更改，每个事务只看到特定时间点的旧数据。</p>
<p><strong>快照隔离</strong>对于长时间运行的只读查询（如备份和分析）是一个好处。如果查询操作的数据在执行查询的同时发生变化，那么很难对查询的含义进行推理。当事务可以看到数据库的一致快照（在特定时间点冻结）时，更容易理解。</p>
<p>快照隔离是一个流行的特性：PostgreSQL、带有InnoDB存储引擎的MySQL、Oracle、SQL Server等都支持快照隔离[23、31、32]。</p>
<p>（1）实现快照隔离</p>
<p>与读提交隔离一样，快照隔离的实现通常使用写锁来防止脏写（请参阅第236页的“实现已提交读取”），这意味着进行写入的事务可以阻止另一个写入同一对象的事务的进程。但是，读取不需要任何锁。从性能的角度来看，快照隔离的一个关键原则是读者从不阻塞写者，而写者从不阻塞读者。这使得数据库能够在正常处理写操作的同时处理一致性快照上的长时间运行的读查询，而不会在两者之间发生任何锁争用。</p>
<p>为了实现快照隔离，数据库使用了我们在图7-4中看到的防止脏读的机制。数据库可能<strong>必须保留一个对象的几个不同的提交版本</strong>，因为各种正在进行的事务可能需要在不同的时间点查看数据库的状态。因为它并行维护一个对象的多个版本，所以这种技术被称为多版本并发控制（MVCC）。</p>
<p>如果数据库只需要提供读提交隔离，而不需要提供快照隔离，则只需保留对象的两个版本：已提交版本和已覆盖但尚未提交的版本。但是，支持快照隔离的存储引擎通常也将MVCC用于其已提交读取的隔离级别。一种典型的方法是，read committed对每个查询使用单独的快照，而快照隔离对整个事务使用相同的快照。</p>
<p>图7-7说明了在PostgreSQL[31]中如何实现基于MVCC的快照隔离（其他实现类似）。当一个事务启动时，它被赋予一个唯一的、总是递增的事务ID（txid）。每当事务向数据库写入任何内容时，它写入的数据都会被标记为写入程序的事务ID。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-29_13-36-39.png" alt=""></p>
<p>表中的每一行都有一个 <code>created_by</code> 字段，其中包含将此行插入表中的事务的 <code>ID</code>。此外，每一行都有一个 <code>deleted_by</code> 字段，它最初是空的。如果一个事务删除了一行，该行实际上并没有从数据库中删除，而是通过将 <code>deleted_by</code> 字段设置为请求删除的事务的 <code>ID</code> 来标记该行。稍后，当确定没有事务可以再访问已删除的数据时，数据库中的垃圾回收进程将删除标记为删除的所有行并释放它们的空间。</p>
<p>更新在内部转换为删除和创建。例如，在图7-7中，事务13从帐户2中扣除100美元，将余额从500美元更改为400美元。accounts表现在实际上包含account2的两行：一行余额为$500，被事务13标记为deleted；另一行余额为$400，由事务13创建。</p>
<p>（2）观察一致快照的可见性规则</p>
<p>当一个事务从数据库中读取时，事务id用于决定它可以看到哪些对象，哪些对象是不可见的。通过仔细定义可见性规则，数据库可以向应用程序提供数据库的一致快照。其工作原理如下：</p>
<p>1.在每个事务开始时，数据库列出当时正在进行（尚未提交或中止）的所有其他事务的列表。这些事务所做的任何写入都将被忽略，即使这些事务随后提交。
2.中止的事务所做的任何写入都将被忽略。
3.无论事务是否已提交，都将忽略具有事务 ID 较大的事务（即，在当前事务启动之后启动的事务）所做的任何写入。
4.所有其他写入对应用程序的查询可见。</p>
<p>这些规则适用于对象的创建和删除。在图7-7中，当事务12从账户2读取时，它看到的余额是500美元，因为500美元余额的删除是由事务13完成的（根据规则3，事务12看不到事务13所做的删除），并且400美元余额的创建还不可见（根据相同的规则）。</p>
<p>换句话说，如果以下两个条件都为真，则对象是可见的：</p>
<ul>
<li>在 reader 事务启动时，创建对象的事务已经提交。</li>
<li>对象未标记为删除，或已被标记为删除，同时请求删除的事务在 reader 事务启动时尚未提交。</li>
</ul>
<p>一个长时间运行的事务可能会继续使用快照很长一段时间，继续读取（从其他事务的角度来看）已被重写或删除的值。通过从不就地更新值，而是在每次更改值时创建一个新版本，数据库可以提供一致的快照，同时只会产生少量开销。</p>
<p>（3）索引和快照隔离</p>
<p>索引在多版本数据库中如何工作？一种选择是让索引简单地指向对象的所有版本，并需要一个索引查询来过滤掉当前事务不可见的任何对象版本。当垃圾回收删除不再对任何事务可见的旧对象版本时，也可以删除相应的响应索引项。</p>
<p>在实践中，许多实现细节决定了多版本并发控制的性能。例如，如果同一个对象的不同版本可以放在同一页上，PostgreSQL有一些优化，可以避免索引更新[31]。</p>
<p>CouchDB、Datomic和LMDB中使用了另一种方法。尽管它们也使用B树（见第79页的“B树”），但它们使用了一个只追加/写入时复制的变体，在更新树时不会覆盖树的页面，而是为每个修改过的页面创建一个新副本。父页（直到树的根）被复制和更新，以指向其子页的新版本。没有受到写入影响的页，无需拷贝，仍然维持不可变状态 [33,34,35].</p>
<p>使用仅追加B树，每个写入事务（或一批事务）都会创建一个新的B树根，而特定的根是数据库在创建时的一致快照。无法根据现有的根来修改后续的ID树，因为它们不能根据现有的根来创建新的对象。但是，这种方法还需要一个用于压缩和垃圾收集的后台过程。</p>
<p>（4）可重复阅读和命名混乱</p>
<p>快照隔离是一个有用的隔离级别，特别是对于只读事务。然而，许多实现它的数据库使用不同的名称来调用它。在Oracle中称为serializable，在PostgreSQL和MySQL中称为repeatable read[23]。</p>
<p>造成这种命名混乱的原因是SQL标准没有快照隔离的概念，因为该标准是基于systemr 1975年对隔离级别的定义[2]，而快照隔离当时还没有发明。相反，它定义了可重复读取（repeatable read），这在表面上看起来类似于快照隔离。PostgreSQL和MySQL称其快照隔离级别为repeatable read，因为它满足标准的要求，因此它们可以声明符合标准。</p>
<p>不幸的是，SQL标准对隔离级别的定义是有缺陷的——它模糊、不精确，而且不像标准那样独立于实现[28]。尽管有几个数据库实现了可重复读取，但它们实际提供的保证却有很大的不同，尽管表面上是标准化的[23]。在研究文献[29，30]中有一个可重复阅读的正式定义，但大多数实现并不满足这个正式定义。最重要的是，ibmdb2使用“repeatableread”来表示可序列化性[8]。</p>
<p>因此，没有人真正了解可重复阅读的含义。</p>
<h3 id="防止丢失更新">防止丢失更新</h3>
<p>到目前为止，我们讨论的读提交和快照隔离级别主要是为了保证在并发写入的情况下<strong>只读事务可以看到什么</strong>。我们基本上忽略了并发写两个事务的问题，我们只讨论了脏写（参见第235页的“无脏写”），一种可能发生的写-写冲突的特殊类型。</p>
<p>在并发编写事务之间还可能发生其他几种有趣的冲突。其中最著名的是丢失更新问题，图7-1以两个并发计数器增量为例进行了说明。</p>
<p>如果应用程序从数据库中读取某个值，对其进行修改，然后将修改后的值写回（read-modify-write cycle），则可能发生更新丢失问题。如果两个事务同时执行此操作，则其中一个修改可能会丢失，因为第二次写入不包括第一次修改。（我们有时会说，后一个写会比前一个写强。）这种模式出现在各种不同的场景中：</p>
<ul>
<li>增加计数器或更新帐户余额（需要读取当前值、计算新值并回写更新后的值）</li>
<li>对复杂值进行局部更改，例如，在 JSON 文档中向列表中添加元素（需要解析文档、进行更改并写入返回修改后的文档）</li>
<li>两个用户同时编辑wiki页面，每个用户通过将整个页面内容发送到服务器来保存他们的更改，覆盖数据库中当前的内容</li>
</ul>
<p>因为这是一个如此普遍的问题，各种各样的解决方案都被开发出来了。</p>
<p>（1）原子写入操作</p>
<p>许多数据库提供原子更新操作，这就不需要在应用程序代码中实现 read-modify-write cycle。如果你的代码可以用这些操作来表达，它们通常是最好的解决方案。例如，以下指令在大多数关系数据库中是并发安全的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#66d9ef">UPDATE</span> counters <span style="color:#66d9ef">SET</span> value <span style="color:#f92672">=</span> value <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">key</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;foo&#39;</span>;
</code></pre></div><p>类似地，MongoDB等文档数据库支持对JSON文档的一部分进行原子本地修改，Redis为修改数据结构（如优先级队列）提供了原子操作。并不是所有的写操作都可以很容易地用原子操作来表达例如，wiki页面的更新涉及到任意的文本编辑，但是在可以使用原子操作的情况下，它们通常是最好的选择。</p>
<p>原子操作通常是通过在对象被读取时对其进行<strong>独占锁</strong>来实现的，这样在应用更新之前没有其他事务可以读取它。这种技术有时被称为光标稳定性[36，37]。另一个选择是简单地强制在单个线程上执行所有原子操作。</p>
<p>不幸的是，对象关系映射框架很容易意外地编写执行不安全的 read-modify-write cycle 的代码，而不是使用数据库提供的原子操作[38]。如果你知道你在做什么，这不是问题，但它可能是一个微妙的错误来源，很难通过测试找到。</p>
<p>（2）显式锁定</p>
<p>如果数据库的内置原子操作没有提供必要的功能，另一个防止更新丢失的选项是<strong>应用程序显式锁定</strong>要更新的对象。然后，应用程序可以执行read-modify-write cycle，如果任何其他事务试图并发读取同一个对象，它将被迫等待，直到第一个 read-modify-write 循环完成。</p>
<p>例如，考虑一个多人游戏，其中几个玩家可以同时移动同一个图形。在这种情况下，原子操作可能还不够，因为应用程序还需要确保玩家的移动遵守游戏规则，这涉及到一些逻辑，而这些逻辑是您无法合理实现的数据库查询。相反，你可以使用一个锁来防止两个玩家同时移动同一个棋子，如例7-1所示。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#66d9ef">BEGIN</span> <span style="color:#66d9ef">TRANSACTION</span>;

<span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> figures
	<span style="color:#66d9ef">WHERE</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;robot&#39;</span> <span style="color:#66d9ef">AND</span> game_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">222</span>
	<span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">UPDATE</span>;

<span style="color:#75715e">-- Check whether move is valid, then update the position
</span><span style="color:#75715e">-- of the piece that was returned by the previous SELECT.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">UPDATE</span> figures <span style="color:#66d9ef">SET</span> <span style="color:#66d9ef">position</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;c4&#39;</span> <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1234</span>;

<span style="color:#66d9ef">COMMIT</span>;
</code></pre></div><blockquote>
<p><code>FOR UPDATE</code> 告诉数据库<strong>锁定返回的所有行</strong>。</p>
</blockquote>
<p>这是可行的，但是要想正确，您需要仔细考虑您的应用程序逻辑。很容易忘记在代码的某个地方添加必要的锁，从而引入竞争条件。</p>
<p>（3）自动检测丢失的更新</p>
<p>原子操作和锁是通过强制 read-modify-write 周期顺序发生来防止更新丢失的方法。另一种方法是允许它们并行执行，如果事务管理器检测到丢失的更新，则中止事务并强制它重试 read-modify-write 循环。</p>
<p>这种方法的一个优点是，数据库可以与快照隔离一起有效地执行此检查。实际上，PostgreSQL的repeatable read、Oracle的serializable和sqlserver的snapshot隔离级别都会自动检测更新丢失的时间，并中止有问题的事务。但是，MySQL/InnoDB的repeatable read没有检测到丢失的更新[23]。一些作者[28，30]认为数据库必须防止丢失更新，才能符合提供快照隔离的条件，因此MySQL在这个定义下不提供快照隔离。</p>
<p>丢失更新检测是一个很好的特性，因为它不需要应用程序代码来使用任何特殊的数据库功能—您可能会忘记使用锁或原子操作，从而导致错误，但是丢失更新检测会自动发生，因此不易出错。</p>
<p>（4）compare-and-set</p>
<p>在不提供事务的数据库中，有时会发现一个原子 compare-and-set 操作（前面在230页的“单对象写入”中提到过）。此操作的目的是为了避免更新丢失，方法是只允许在值自上次读取后没有更改的情况下进行更新。如果当前值与以前读取的值不匹配，则更新无效，必须重试读-改-写循环。</p>
<p>例如，为了防止两个用户同时更新同一个wiki页面，您可以尝试类似的操作，仅当用户开始编辑页面后该页面的内容没有更改时才会进行更新：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#75715e">-- This may or may not be safe, depending on the database implementation
</span><span style="color:#75715e"></span><span style="color:#66d9ef">UPDATE</span> wiki_pages <span style="color:#66d9ef">SET</span> content <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;new content&#39;</span>
	<span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1234</span> <span style="color:#66d9ef">AND</span> content <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;old content&#39;</span>;
</code></pre></div><p>如果内容已更改且不再与“旧内容”匹配，则此更新将无效，因此您需要检查更新是否生效，必要时重试。但是，如果数据库允许 <code>WHERE</code> 子句从旧快照中读取，则此语句可能无法阻止丢失的更新，因为即使正在发生另一个并发写入，该条件也可能为真。在依赖某个数据库之前，请检查它的 compare-and-set 操作是否安全的。</p>
<p>（5）冲突解决和复制</p>
<p>在复制的数据库中（见第5章），防止丢失更新具有另一个维度：由于它们在多个节点上有数据的副本，并且数据可能在不同的节点上被并发修改，因此需要采取一些额外的步骤来防止丢失更新。</p>
<p>Locks、compare和set操作假定只有一个数据的最新副本。但是，具有多 Leader 或无 Leader 复制的数据库通常允许多个写操作同时发生，并以异步方式复制它们，因此它们不能保证有一个数据的最新副本。因此，基于锁或 compare-and-set 的技术不适用于这种情况。（我们将在第324页的“线性化”中更详细地讨论这个问题。）</p>
<p>相反，正如第184页“检测并发写入”中所讨论的，这种复制数据库中的一种常见方法是允许并发写入创建一个值的多个冲突版本（也称为同级），并在事后使用应用程序代码或特殊数据结构来解析和合并这些版本。</p>
<p>原子操作在复制的上下文中可以很好地工作，特别是当它们是可变的（也就是说，您可以在不同的副本上以不同的顺序应用它们，但仍然得到相同的结果）。例如，递增计数器或向集合中添加元素都是交换操作。这就是RIAK2.0数据类型背后的思想，它可以防止跨副本丢失更新。当一个值由不同的客户端同时更新时，Riak会自动合并更新，这样就不会丢失更新[39]。</p>
<p>另一方面，last write wins（LWW）冲突解决方法容易丢失更新，如第186页“last write wins（丢弃并发写入）”中所述。不幸的是，LWW 是许多复制数据库中的默认值。</p>
<h3 id="写歪斜和幻影">写歪斜和幻影</h3>
<p>在前面的部分中，我们看到了脏写和丢失更新，当不同的事务同时试图写入同一个对象时，会出现两种竞争情况。为了避免数据损坏，需要防止这些竞争条件——要么由数据库自动阻止，要么通过使用锁或原子写入操作等手动保护措施来防止。</p>
<p>但是，这并不是并发写入之间可能发生的潜在争用条件列表的末尾。在本节中，我们将看到一些更微妙的冲突例子。</p>
<p>首先，想象一下这个例子：您正在编写一个应用程序，让医生管理医院的随叫随到轮班。医院通常会在同一时间安排几名医生随叫随到，但绝对必须至少有一名医生随叫随到。医生可以放弃轮班（例如，如果他们自己生病了），前提是至少有一名同事在轮班时随时待命[40，41]。</p>
<p>现在想象一下爱丽丝和鲍勃是某个特定班次的两个随叫随到的医生。两人都觉得不舒服，所以决定请假。不幸的是，他们碰巧在差不多同一时间按一下按钮就关机了。接下来的发生的如图7-8所示。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-29_14-35-19.png" alt=""></p>
<p>在每个事务处理中，应用程序首先检查两个或多个医生当前正在呼叫；如果是，则假定一个医生停止呼叫是安全的。由于数据库使用快照隔离，所以两个检查都返回2，因此这两个事务都将继续进行下一个阶段。爱丽丝更新了自己的记录以取消通话，鲍勃也更新了自己的记录。两个事务都提交了，现在没有医生随叫随到。这违反了你要求至少有一名医生随叫随到的要求。</p>
<p>（1）描述写入倾斜</p>
<p>这种异常称为写倾斜[28]。这既不是脏写也不是丢失更新，因为这两个事务正在更新两个不同的对象（分别是Alice和Bob的oncall记录）。在这里发生冲突并不那么明显，但这绝对是一个竞争条件：如果两个事务一个接一个地运行，那么第二个医生就不会停止通话。异常行为是可能的，因为事务同时运行。</p>
<p>您可以将write skew看作是丢失更新问题的一个概括。如果两个事务读取相同的对象，然后更新其中的一些对象（不同的事务可能会更新不同的对象），则可能会发生写入倾斜。在不同事务更新同一对象的特殊情况下，会出现脏写或更新丢失异常（取决于时间）。</p>
<p>我们看到有各种不同的方法来防止更新丢失。对于写倾斜，我们的选项更受限制：</p>
<ul>
<li>原子单对象操作没有帮助，因为涉及多个对象。</li>
<li>在快照隔离的某些实现中，自动检测丢失的更新也没有帮助：在PostgreSQL的repeatable read、MySQL/InnoDB的repeatable read、Oracle的serializable或SQL Server的snapshot isolation level[23]中，不会自动检测到写倾斜。自动防止写入倾斜需要真正的可序列化隔离（请参阅第251页的“可序列化性”）。</li>
<li>某些数据库允许您配置约束，然后由数据库强制执行（例如，唯一性、外键约束或对特定值的限制）。但是，为了指定至少一个医生必须随叫随到，您需要一个涉及多个对象的约束。大多数数据库都没有对此类约束的内置支持，但是您可以使用触发器或物化视图来实现它们，具体取决于数据库[42]。</li>
<li>如果不能使用可序列化的隔离级别，在这种情况下，第二个最佳选择可能是<strong>显式锁定事务所依赖的行</strong>。在doctors示例中，您可以编写如下内容：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#66d9ef">BEGIN</span> <span style="color:#66d9ef">TRANSACTION</span>;

<span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> doctors
	<span style="color:#66d9ef">WHERE</span> on_call <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
	<span style="color:#66d9ef">AND</span> shift_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1234</span> <span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">UPDATE</span>;

<span style="color:#66d9ef">UPDATE</span> doctors
	<span style="color:#66d9ef">SET</span> on_call <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
	<span style="color:#66d9ef">WHERE</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Alice&#39;</span>
	<span style="color:#66d9ef">AND</span> shift_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1234</span>;

<span style="color:#66d9ef">COMMIT</span>;
</code></pre></div><blockquote>
<p><code>FOR UPDATE</code> 告诉数据库<strong>锁定返回的所有行</strong>。</p>
</blockquote>
<p>（２）写歪斜的更多例子</p>
<p>写歪斜一开始看起来像是一个深奥的问题，但是一旦你意识到它，你可能会注意到它可能发生的更多情况。这里还有一些例子：</p>
<p>－　会议室预订系统</p>
<p>假设您要强制执行同一会议室不能同时有两个预订[43]。如果有人想预约，你先检查是否有任何冲突的预订（例如，同一房间的预订时间范围重叠），如果没有找到，则创建会议（请参见例7-2）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#66d9ef">BEGIN</span> <span style="color:#66d9ef">TRANSACTION</span>;

<span style="color:#75715e">-- Check for any existing bookings that overlap with the period of noon-1pm
</span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">FROM</span> bookings
	<span style="color:#66d9ef">WHERE</span> room_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span> <span style="color:#66d9ef">AND</span>
	end_time <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2015-01-01 12:00&#39;</span> <span style="color:#66d9ef">AND</span> start_time <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;2015-01-01 13:00&#39;</span>;

<span style="color:#75715e">-- If the previous query returned zero:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> bookings
	(room_id, start_time, end_time, user_id)
	<span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">123</span>, <span style="color:#e6db74">&#39;2015-01-01 12:00&#39;</span>, <span style="color:#e6db74">&#39;2015-01-01 13:00&#39;</span>, <span style="color:#ae81ff">666</span>);

<span style="color:#66d9ef">COMMIT</span>;
</code></pre></div><p>不幸的是，<strong>快照隔离并不能阻止另一个用户同时插入冲突的会议</strong>。为了保证你不会再发生冲突，你就不需要再把它序列化了。</p>
<ul>
<li>多人游戏</li>
</ul>
<p>在例7-1中，我们使用了一个锁来防止更新丢失（也就是说，确保两个玩家不能同时移动同一个图形）。然而，让另一个棋盘上的两个不同的棋盘上的棋盘上的两个棋子的移动可能会违反规则。根据您正在实施的规则类型，您可能能够使用唯一约束，但否则您很容易出现写歪。</p>
<ul>
<li>申请用户名</li>
</ul>
<p>在一个每个用户都有一个唯一用户名的网站上，两个用户可以尝试同时使用相同的用户名创建帐户。您可以使用事务来检查是否使用了某个名称，如果没有，则使用该名称创建一个帐户。但是，与前面的示例一样，在快照隔离下这是不安全的。幸运的是，唯一约束在这里是一个简单的解决方案（尝试注册用户名的第二个事务将因违反约束而中止）。</p>
<ul>
<li>防止双重支出</li>
</ul>
<p>允许用户花钱或积分的服务需要检查用户的消费是否超过了他们的支出。您可以通过在用户帐户中插入一个10个暂定支出项目来实现这一点，列出帐户中的所有项目，并检查总和是否为正[44]。使用write skew时，可能会同时插入两个支出项，它们一起导致余额变为负数，但两个事务都不会注意到另一个。</p>
<p>（3）导致写入倾斜的幻影</p>
<p>所有这些例子都遵循类似的模式：</p>
<p>1.SELECT 查询通过搜索符合某些搜索条件的行来检查是否满足了某些要求（至少有两个医生在打电话，当时该房间没有现有的预订，董事会上的职位上没有其他数字，用户名还没有被占用，还有钱在账户）。
2.根据第一个查询的结果，应用程序代码决定如何继续（可能继续执行操作，或者向用户报告错误并中止）。
3.如果应用程序决定继续，它将对数据库进行写入（插入、更新或删除）并提交事务。</p>
<p>此写入的效果改变了第2步决策的前提条件。换言之，如果在提交写入操作后重复步骤1中的 SELECT 查询，则会得到不同的结果，因为<strong>写入操作更改了与搜索条件匹配的行集</strong>（现在，随叫随到的医生减少了一位，此时会议室已被预订，board 位置上的现在是被刚移动的棋子占据了，用户名现在被占用，帐户中的钱现在减少了）。</p>
<p>这些步骤可能以不同的顺序出现。例如，您可以先执行 write，然后执行 SELECT 查询，最后根据查询的结果决定是中止还是提交。</p>
<p>在医生随叫随到的例子中，步骤3中修改的行是步骤1中返回的行之一，因此我们可以通过在步骤1中锁定行（SELECT FOR UPDATE）来保证事务的安全性并避免写歪斜。但是，其他四个例子是不同的：它们检查是否缺少与某些搜索条件匹配的行，而write则添加一个与相同条件匹配的行。如果步骤1中的<strong>查询未返回任何行</strong>，则 SELECT FOR UPDATE 无法将锁附加到任何内容。</p>
<p><strong>当一个事务中的写入操作更改另一个事务中的搜索查询结果时，这种效果称为幻影</strong>[3]。快照隔离避免了只读查询中的幻影，但是在读写事务中，像我们讨论的例子一样，幻影可能导致特别棘手的写倾斜情况。</p>
<p>（4）物化冲突</p>
<p>如果<strong>幻影的问题是没有可以附加锁的对象</strong>，也许我们可以人为地将锁对象引入数据库？</p>
<p>例如，在会议室预订案例中，您可以想象创建一个时间表和房间。此表中的每一行对应于特定时间段（例如，15分钟）的特定房间。您可以提前为房间和时间段的所有可能组合创建行，例如在接下来的六个月内。现在，想要创建预订的事务可以锁定（选择更新）表中与所需房间和时间段相对应的行。在获得锁之后，它可以检查重叠预订并像以前一样插入新预订。请注意，附加表并不是用来存储有关预订的信息，它只是一个锁的集合，用于防止在同一房间和时间范围内的预订同时被修改。</p>
<p>这种方法被称为<strong>物化冲突</strong>，因为它<strong>采用了一个幻象</strong>，并将其转化为数据库中存在的一组具体行的锁冲突[11]。不幸的是，很难找出如何将冲突具体化，并且很容易出错，并且让并发控制机制泄漏到应用程序数据模型中是很难看的。出于这些原因，如果没有其他办法，应将具体化的冲突视为最后手段。在大多数情况下，可序列化的隔离级别更可取。</p>
<h2 id="序列化">序列化</h2>
<p>在本章中，我们看到了几个容易出现竞争条件的事务的示例。某些争用条件可以通过 read committed 和 snapshot 隔离级别来阻止，但其他一些则不是。我们遇到了一些特别棘手的考试题，有书写歪斜和幻影。这是一个可悲的情况：</p>
<ul>
<li>隔离级别很难理解，并且在不同的数据库中实现不一致（例如，“可重复读取”的含义差别很大）。</li>
<li>如果您查看应用程序代码，很难判断在特定隔离级别运行是否安全，尤其是在大型应用程序中，您可能没有意识到可能同时发生的所有事情。</li>
<li>没有好的工具来帮助我们检测竞态情况。原则上，静态分析可能会有所帮助[26]，但研究技术尚未找到实际应用的途径。测试并发性问题是很困难的，因为它们通常是不确定的问题，只有在时间安排不好的情况下才会发生。</li>
</ul>
<p>自从20世纪70年代以来，隔离问题就不再是新的了。一直以来，研究人员的答案都是简单的：使用<strong>可序列化隔离</strong>！</p>
<p>串行隔离通常被认为是最强的隔离级别。它保证即使事务可以并行执行，最终结果也与它们一次执行一个事务一样，<strong>串行执行，没有任何并发性</strong>。因此，数据库保证，如果事务在单独运行时行为正确，那么它们在并发运行时仍然是正确的，换句话说，数据库可以防止所有可能的竞争条件。</p>
<p>但是，如果可序列化的隔离比糟糕的弱隔离级别要好得多，那么为什么每个人都不使用它呢？为了回答这个问题，我们需要研究实现序列化的选项，以及它们的执行方式。目前大多数提供可序列化性的数据库都使用以下三种技术之一，我们将在本章的其余部分中探讨这些技术：</p>
<ul>
<li>按串行顺序逐字执行事务（参见第252页的“实际串行执行”）</li>
<li>二阶段锁定（见第257页的“二阶段锁定（2PL）”），几十年来，这是唯一可行的选择</li>
<li>乐观并发控制技术，如可序列化快照隔离（请参阅第261页的“可序列化快照隔离（SSI）”）</li>
</ul>
<p>现在，我们将主要在单节点数据库的上下文中讨论这些技术；在第9章中，我们将研究如何将这些技术推广到分布式系统中涉及多个节点的事务。</p>
<h3 id="实际串行执行">实际串行执行</h3>
<p>避免并发问题的最简单方法是完全消除并发性：在一个线程上一次只执行一个事务，按串行顺序。通过这样做，我们可以完全防止事务之间的冲突。</p>
<p>尽管这似乎是一个显而易见的想法，但数据库设计者直到最近才——大约在2007年左右——才认为执行事务的单线程循环是可行的[45]。如果在过去的30年中，多线程并发被认为是获得良好性能的关键，那么，为了使单线程执行成为可能，有什么变化呢？</p>
<p>有两个发展引起了这种反思：</p>
<ul>
<li>RAM变得足够便宜，对于许多用例来说，将整个活动数据集保存在内存中是可行的（请参见第页的“将所有数据都保存在内存中”）
88页）。当一个事务需要访问的所有数据都在内存中时，事务的执行速度比必须等待从磁盘加载数据的速度快得多。</li>
<li>数据库设计者意识到，OLTP事务通常很短，只进行少量的读写操作（参见“事务处理或分析“第90页）。相比之下，长时间运行的分析查询通常是只读的，因此可以在串行执行循环之外的一致快照上运行（使用快照隔离）。</li>
</ul>
<p>串行执行事务的方法在VoltDB/H-Store、Redis和Datomic中实现[46，47，48]。为单线程执行而设计的系统有时比支持并发的系统性能更好，因为它可以避免锁的协调开销。然而，它的吞吐量仅限于单个CPU核心的吞吐量。为了充分利用单线程，事务需要与传统形式不同的结构。</p>
<p>（1）在存储过程中封装事务</p>
<p>在数据库的早期，其目的是数据库事务可以包含整个用户活动流。例如，预订机票是一个多阶段的过程（搜索路线、票价和可用座位；决定行程；预订行程中每个航班的座位；输入乘客详细信息；付款）。数据库设计人员认为，如果整个过程是一个事务，这样就可以以原子方式提交。</p>
<p>不幸的是，人类做出决定和做出反应的速度非常慢。如果数据库事务需要等待用户的输入，则数据库需要支持大量的并发事务，其中大多数事务是空闲的。大多数数据库无法有效地做到这一点，因此几乎所有的OLTP应用程序都通过避免在事务中交互地等待用户来缩短事务处理时间。在web上，这意味着在同一个HTTP请求中提交一个事务—一个事务不跨越多个请求。一个新的HTTP请求开启一个新的事务。</p>
<p>即使人类已经脱离了关键路径，事务仍然以交互的客户端/服务器风格执行，一次只执行一个语句。应用程序进行查询，读取结果，或者进行另一个查询
取决于第一次查询的结果，依此类推。查询和结果在应用程序代码（在一台机器上运行）和数据库服务器（在另一台机器上）之间来回发送。</p>
<p>在这种交互式事务风格中，应用程序和数据库之间的网络通信花费了大量时间。如果不允许数据库中的并发，并且一次只处理一个事务，那么吞吐量将非常糟糕，因为数据库将花费大部分时间等待应用程序为当前事务发出下一个查询。在这种数据库中，为了获得合理的性能，需要同时处理多个事务。</p>
<p>因此，具有单线程串行事务处理的系统不允许交互式多语句事务。相反，应用程序必须提前将整个事务代码作为存储过程提交到数据库。这些方法之间的差异如图7-9所示。如果事务所需的所有数据都在内存中，则存储过程可以非常快速地执行，而无需等待任何网络或磁盘I/O。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-29_15-08-02.png" alt=""></p>
<p>（2）存储过程的利弊</p>
<p>存储过程在关系数据库中已经存在了一段时间，自1999年以来，它们已经成为SQL标准（SQL/PSM）的一部分。他们的名声有点不好，原因有很多：</p>
<ul>
<li>每个数据库供应商都有自己的存储过程语言（Oracle有PL/SQL，SQL Server有T-SQL，PostgreSQL有PL/pgSQL等）。这些语言
没有跟上通用编程语言的发展，因此，从今天的角度来看，它们看起来非常丑陋和过时，而且它们缺乏大多数编程语言所能找到的库的生态系统。</li>
<li>数据库中运行的代码很难管理：与应用服务器相比，调试更困难，版本控制和部署更困难，测试更困难，并且难以与度量收集系统集成以进行监视。</li>
<li>数据库通常比应用程序服务器对性能敏感得多，因为单个数据库实例通常由多个应用程序服务器共享。数据库中写得不好的存储过程（例如，使用大量内存或CPU时间）比在应用服务器中编写得不好的代码引起的麻烦要多得多。</li>
</ul>
<p>然而，这些问题是可以克服的。存储过程的现代实现已经放弃了PL/SQL，而是使用现有的通用编程语言：VoltDB使用Java或Groovy，Datomic使用Java或Clojure，Redis使用Lua。</p>
<p>使用存储过程和内存中的数据，可以在单个线程上执行所有事务。由于它们不需要等待I/O，并且避免了其他并发控制机制的开销，所以它们在单线程上可以获得相当好的吞吐量。</p>
<p>VoltDB还使用存储过程进行复制：它不是将事务的写操作从一个节点复制到另一个节点，而是在每个replica上执行相同的存储过程。因此，VoltDB要求存储过程是确定性的（当在不同的节点上运行时，它们必须产生相同的结果）。例如，如果一个事务需要使用当前的日期和时间，它必须通过特殊的确定性api来使用。</p>
<p>（3）分区</p>
<p>串行地执行所有事务使并发控制更加简单，但它使数据库的事务吞吐量达到单台计算机上单个CPU核心的速度。只读事务可以使用快照隔离在其他地方执行，但对于具有高写入吞吐量的应用程序，单线程事务处理器可能成为严重的瓶颈。</p>
<p>为了扩展到多个CPU核和多个节点，您可以潜在地划分数据（见第6章），这是VoltDB支持的。如果您能找到一种方法来对数据集进行分区，使每个事务只需要在一个分区中读写数据，那么每个分区都可以有自己独立于其他分区运行的事务处理线程。在这种情况下，您可以为每个CPU核心分配自己的分区，这样您的事务吞吐量就可以随着CPU核心的数量线性扩展[47]。</p>
<p>但是，对于任何需要访问多个分区的事务，数据库必须在它所涉及的所有分区之间协调事务。存储过程需要在所有分区中以锁步执行，以确保整个系统的可序列化性。</p>
<p>由于跨分区事务有额外的协调开销，因此它们比单分区事务慢得多。VoltDB报告的吞吐量大约为每秒1000次跨分区写入，这比它的单分区吞吐量低一个数量级，并且不能通过添加更多的机器来提高[49]。</p>
<p>事务是否可以是单个分区在很大程度上取决于应用程序使用的数据结构。简单的键值数据通常可以非常容易地进行分区，但是具有多个二级索引的数据可能需要大量的跨分区协调（请参见第206页的“分区和辅助索引”）。</p>
<p>（4）串行执行摘要</p>
<p>在某些限制条件下，事务的串行执行已成为实现可串行化隔离的可行方法：</p>
<ul>
<li>每一笔事务都必须是小而快的，因为只需一次缓慢的事务就可以拖延所有的事务处理。</li>
<li>仅限于活动数据集可以放入内存的用例。很少访问的数据可能会被移动到磁盘上，但是如果需要在单线程事务中访问它，系统将变得非常慢</li>
<li>写入吞吐量必须足够低，以便在单个CPU核心上处理，否则需要在不需要跨分区协调的情况下对事务进行分区。</li>
<li>跨分区事务是可能的，但它们的使用范围有一个硬限制。</li>
</ul>
<h3 id="二阶段锁定-2pl">二阶段锁定 (2PL)</h3>
<p>在大约30年的时间里，只有一种广泛使用的数据库可串行化算法：两阶段锁定（2PL）。</p>
<p>我们之前已经看到锁经常被用来防止脏写（见第235页的“无脏写”）：如果两个事务同时试图写入同一个对象，锁确保第二个 writer 必须等到第一个事务完成（中止或提交）后才能继续。</p>
<p>2PL 与此类似，但使锁的要求更高。只要没有人在写同一个对象，就允许多个事务同时读取该对象。但只要有人想写（修改或删除）对象，就需要独占访问：</p>
<ul>
<li>如果事务A已读取对象，而事务B希望写入该对象，则B必须等到A提交或中止后才能继续。（这个确保B不会在A背后意外更改对象。）</li>
<li>如果事务A已写入对象，而事务B要读取该对象，则B必须等到A提交或中止后才能继续。（在2PL下，读取对象的旧版本，如图7-1所示，是不可接受的。）</li>
</ul>
<p>在2PL中，写 writer 不仅仅阻止其他 writer；他们还阻止 reader，反之亦然。快照隔离有这样一个咒语： reader 从不阻止 writer，writer 从不阻止 reader（请参阅第239页的“实现快照隔离”），它抓住了快照隔离和两阶段锁定之间的关键区别。另一方面，由于2PL提供了可序列化性，因此它可以防止前面讨论的所有竞争条件，包括丢失更新和写入倾斜。</p>
<p>（1）两阶段锁的实现</p>
<p>2PL用于MySQL（InnoDB）和SQL Server中的可序列化隔离级别，以及DB2中的可重复读取隔离级别[23，36]。</p>
<p>对 reader 和 writer 的阻塞是通过对数据库中的每个对象都有一个锁来实现的。锁可以是共享模式，也可以是独占模式。锁的用途如下：</p>
<ul>
<li>如果事务要读取对象，必须首先在共享模式下获取锁。允许多个事务同时在共享模式下持有锁，但如果另一个事务已经对对象拥有独占锁，则这些事务必须等待。</li>
<li>如果事务要写入对象，则必须首先以独占模式获取锁。没有其他事务可以同时持有锁（在共享或独占模式下），因此如果对象上存在任何现有锁，则该事务必须等待。</li>
<li>如果事务先读后写对象，它可能会将其共享锁升级为独占锁。升级的工作原理与直接获得独占锁的方式相同。</li>
<li>事务获得锁后，它必须继续持有锁，直到事务结束（提交或中止）。这就是“two phase”这个名称的由来：第一阶段（在事务执行期间）是在获取锁的时候，第二阶段（在事务结束时）是在释放所有锁的时候。
由于使用了如此多的锁，很容易发生事务A被卡住等待事务B释放其锁，反之亦然。这种情况称为死锁。数据库自动检测事务之间的死锁，并中止其中一个事务，以便其他事务可以继续进行。应用程序需要重试中止的事务。</li>
</ul>
<p>（2）两阶段锁性能</p>
<p>两阶段锁的一大缺点，以及自20世纪70年代以来没有被所有人使用的原因是性能：在两阶段锁定下，事务吞吐量和查询响应时间比在弱隔离下要差得多。</p>
<p>这部分是由于获取和释放所有这些锁的开销，但更重要的是由于减少了并发性。按照设计，如果两个并发事务试图做任何可能以任何方式导致争用条件的操作，则一个事务必须等待另一个事务完成。</p>
<p>传统的关系数据库不限制事务的持续时间，因为它们是为等待人工输入的交互式应用程序设计的。</p>
<p>因此，当一个事务必须等待另一个事务时，它可能需要等待的时间没有限制。即使您确保您的所有事务都很短，如果多个事务要访问同一个对象，则可能会形成一个队列，因此一个事务可能必须等待其他几个事务完成才能执行任何操作。由于这个原因，运行2PL的数据库可能有相当不稳定的延迟，如果工作负载中存在争用，那么它们在高百分位（请参阅第13页的“描述性能”）时会非常慢。它可能只需要一个缓慢的事务，或者一个访问大量数据并获取许多锁的事务，就会导致系统的其余部分陷入停顿。当需要稳健的操作时，这种不稳定性是有问题的。</p>
<p>虽然死锁可以在基于锁的读提交隔离级别下发生，但在2PL可序列化隔离下（取决于事务的访问模式），死锁发生的频率要高得多。这可能是一个额外的性能问题：当事务因死锁而中止并重试时，它需要重新执行其工作。如果死锁频繁发生，这可能意味着大量的精力浪费。</p>
<p>（3）谓词锁</p>
<p>在前面对锁的描述中，我们忽略了一个微妙但重要的细节。在第250页的“导致写入倾斜的幻影”中，我们讨论了幻影的问题，也就是说，一个事务改变了另一个事务的搜索查询结果。具有可序列化隔离的数据库必须防止幻影。</p>
<p>在会议室预订示例中，这意味着如果一个事务在特定时间窗口内搜索房间的现有预订（请参见例7-2），不允许另一个事务同时插入或更新同一房间和时间范围的另一个预订。（可以同时插入其他房间的预订，或在不影响拟定预订的不同时间插入同一房间的预订。）</p>
<p>我们如何实现这一点？从概念上讲，我们需要一个<strong>谓词锁</strong>[3]。它类似于前面描述的共享/独占锁，但它不属于特定对象（例如，表中的一行），而是<strong>属于与某些搜索条件匹配的所有对象</strong>，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> bookings
	<span style="color:#66d9ef">WHERE</span> room_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span> <span style="color:#66d9ef">AND</span>
	end_time <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2018-01-01 12:00&#39;</span> <span style="color:#66d9ef">AND</span>
	start_time <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;2018-01-01 13:00&#39;</span>;
</code></pre></div><p>谓词锁的限制访问，如下所示：</p>
<ul>
<li>如果事务 A 想要读取与某个条件匹配的对象，比如在那个 SELECT 查询中，它必须获得对查询条件的共享模式谓词锁。如果另一个事务B当前对任何符合这些条件的对象具有排他锁，则 A 必须等到 B 释放其锁后才允许进行查询。</li>
<li>如果事务A要插入、更新或删除任何对象，它必须首先检查旧值还是新值与任何现有谓词锁匹配。如果事务B持有匹配的谓词锁，那么A必须等到B提交或中止后才能继续。</li>
</ul>
<p>这里的关键思想是谓词锁甚至适用于数据库中尚不存在但将来可能添加的对象（幻影）。如果两阶段锁包括谓词锁，则数据库将防止所有形式的写倾斜和其他竞争条件，因此它的隔离将变为可序列化的。</p>
<p>（4）Index-range 锁</p>
<p>不幸的是，谓词锁的性能不好：如果活动事务有很多锁，那么检查匹配的锁就会非常耗时。因此，大多数使用2PL的数据库实际上实现了 Index-range 锁（也称为 next-key 锁），这是谓词锁的简化近似值[41，50]。</p>
<p>通过使谓词与更大的对象集相匹配来简化谓词是安全的。例如，如果您有一个谓词锁，用于在中午到下午1点之间预订123号房间，您可以随时锁定123号房间的预订，或者您可以通过在中午到下午1点之间锁定所有房间（不仅仅是123号房间）来近似模拟它。这是安全的，因为任何与原始谓词匹配的 write 肯定也会匹配近似值。</p>
<p>在room bookings数据库中，您可能会在 <code>room_id</code> 列上有索引，和/或在 <code>start_time</code>和 <code>end_time</code> 上有索引（否则前面的查询在大型数据库上会非常慢）：</p>
<ul>
<li>假设您的索引在 <code>room_id</code> 上，数据库使用该索引查找123房间的现有预订。现在，数据库可以简单地将一个共享锁附加到这个索引项上，这表明一个事务已经搜索了123房间的预订。</li>
<li>或者，如果数据库使用基于时间的索引来查找现有预订，则可以为该索引中的一系列值附加一个共享锁，表示事务已搜索到与2018年1月1日中午至下午1点重叠的预订。</li>
</ul>
<p>不管怎样，搜索条件的近似值都会附加到其中一个索引上。现在，如果另一个事务要插入、更新或删除同一房间和/或重叠时间段的预订，则必须更新索引的相同部分。在这样做的过程中，它将遇到<strong>共享锁</strong>，并将被迫等待，直到锁被释放。</p>
<p>这为防止幻影和写歪斜提供了有效的保护。Index-range 锁并不像谓词锁那样精确（它们可能会锁定更大范围的对象，而不是严格地维护可序列化性所必需的），但是由于索引范围锁的开销要低得多，所以它们是一个很好的折衷方案。</p>
<p>如果没有合适的索引可以附加一个范围锁，那么数据库可以退回到整个表上的共享锁。这对性能没有好处，因为它将停止所有其他事务写入表，但这是一个安全的后备位置。</p>
<h3 id="可序列化快照隔离ssi">可序列化快照隔离（SSI）</h3>
<p>本章描绘了数据库中并发控制的惨淡图景。一方面，我们的可串行化实现不能很好地执行（两阶段锁定）或伸缩性不好（串行执行）。另一方面，我们有弱隔离级别，这些级别具有良好的性能，但是容易出现各种竞争情况（丢失更新、写入倾斜、幻影等）。串行隔离和良好的性能在根本上是相互矛盾的吗？</p>
<p>也许不是这样：一种叫做串行化快照隔离（SSI）的算法非常有效。它提供了完全的可序列化性，但与快照隔离相比，性能损失很小。SSI是相当新的：它在2008年首次被描述[40]，是迈克尔·卡希尔博士论文[51]的主题。</p>
<p>如今，SSI既用于单节点数据库（PostgreSQL自9.1[41]版本以来的可串行化隔离级别）也用于分布式数据库（FoundationDB使用类似的算法）。由于与其他并发控制机制相比，SSI还很年轻，它仍在实践中证明它的性能，但它有可能以足够快的速度成为未来新的默认机制。</p>
<p>（1）悲观与乐观并发控制</p>
<p>两阶段锁是一种所谓的悲观并发控制机制：它基于这样一个原则：如果任何事情可能出错（如另一个事务持有的锁所示），最好等到情况再次安全后再做任何事情。它就像互斥，在多线程编程中用于保护数据结构。</p>
<p>从某种意义上讲，串行执行是悲观到极端的：它本质上相当于每个事务在事务持续期间对整个数据库（或数据库的一个分区）具有排他锁。我们通过使每个事务的执行速度非常快来补偿这种悲观情绪，因此它只需要在短时间内保持“锁”。</p>
<p>相比之下，可串行化快照隔离是一种乐观的并发控制技术。在这种情况下，乐观意味着，如果发生了非常危险的事情，事务将继续进行，希望一切都会好起来。当一个事务需要提交时，数据库会检查是否发生了任何不好的事情（例如，是否违反了隔离）；如果发生了，事务操作将被中止并必须重试。只允许提交可序列化执行的事务。</p>
<p>乐观并发控制是一个古老的概念[52]，它的优缺点已经争论了很长时间[53]。如果存在高冲突（许多事务试图访问相同的对象），那么它的性能会很差，因为这会导致大量事务需要中止。如果系统已经接近其最大吞吐量，则重试事务的额外事务负载可能会使性能更差。</p>
<p>然而，如果有足够的空闲容量，并且事务之间的争用不是太高，乐观并发控制技术往往比悲观并发控制技术性能更好。通过交换原子操作可以减少争用：例如，如果多个事务并发地想要增加一个计数器，那么递增的应用顺序无关紧要（只要计数器不是在同一事务中读取的），因此并发的增量可以全部应用而不会发生冲突。</p>
<p>顾名思义，SSI基于快照隔离，也就是说，事务中的所有读取都是从数据库的一致快照进行的（请参阅第237页的“快照隔离和可重复读取”）。这是与早期的乐观并发控制技术相比的主要区别。在快照隔离的基础上，SSI添加了一个算法，用于检测写入之间的序列化冲突并确定要中止哪些事务。</p>
<p>（2）基于过时前提的决策</p>
<p>当我们先前讨论快照隔离中的写歪斜（请参阅246页的“write skew and Phantoms”）时，我们观察到了一个反复出现的模式：事务从数据库中读取一些数据，检查查询的结果，并决定根据所看到的结果采取一些操作（写入数据库）。但是，在快照隔离下，原始查询的结果可能在事务提交时不再是最新的，因为数据可能同时被修改。</p>
<p>换言之，事务是基于一个前提（在事务开始时这一事实是正确的，例如，“目前有两名医生随时待命”）。以后，当事务要提交时，原来的数据可能已经改变，前提可能不再是真的。</p>
<p>当应用程序进行查询时（例如，“当前有多少医生在待命？），数据库不知道应用程序逻辑如何使用该查询的结果。为了安全起见，数据库需要假定查询结果（前提）中的任何更改都意味着在该事务中的写入可能无效。换句话说，在事务中的查询和写入之间可能存在因果依赖关系。为了提供可序列化的隔离，数据库必须检测事务可能在过时的前提下执行的情况，并在这种情况下中止事务。</p>
<p>数据库如何知道查询结果是否已更改？有两种情况需要考虑：</p>
<ul>
<li>检测对过时的 MVCC 对象版本的读取（在读取之前发生未提交的写入）</li>
<li>检测影响先前读取的写入（写入发生在读取之后）</li>
</ul>
<p>（3）检测过时的MVCC读取</p>
<p>回想一下快照隔离通常是通过多版本并发控制（MVCC）实现的，见图7-10。当一个事务从MVCC数据库中的一致快照中读取时，它将忽略在拍摄快照时尚未提交的任何其他事务所做的写入操作。在图7-10，事务43将Alice视为 <code>on_call = true</code>，因为事务42（修改了Alice的 <code>on-call</code> 状态）是未提交的。然而，当事务43想要提交时，事务42已经提交。这意味着从一致快照读取时被忽略的写操作现在已经生效，事务43的前提不再正确。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-29_15-51-39.png" alt=""></p>
<p>为了防止这种异常，数据库需要跟踪一个事务何时由于 MVCC 可见性规则而忽略另一个事务的写操作。当事务需要提交时，数据库会检查是否有任何被忽略的写操作已经提交。如果是，则必须中止事务。</p>
<p>为什么必须要在提交之前一直等待？为什么不在检测到过时读取时立即中止事务 43？好吧，如果事务43是一个只读事务，它就不需要被中止，因为没有写歪斜的风险。当事务43进行读取时，数据库还不知道该事务是否将在以后执行写入。此外，事务42在提交事务43时可能尚未中止或仍然是未提交的，因此读取可能最终没有过时。通过避免对快照的长时间隔离而中止快照的不必要的隔离。</p>
<p>（4）检测影响先前读取的写入</p>
<p>要考虑的第二种情况是当另一个事务在读取数据后修改它。这种情况如图7-11所示。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-29_15-54-26.png" alt=""></p>
<p>在两阶段锁的上下文中，我们讨论了索引范围锁（请参阅第260页的“索引范围锁”），它允许数据库锁定对与某些搜索查询匹配的所有行的访问，例如 <code>WHERE shift_id = 1234</code>。我们可以在这里使用类似的技术，除了SSI锁不阻止其他事务。</p>
<p>在图7-11中，事务42和事务43都搜索1234班次期间的随叫随到医生。如果 <code>shift_id</code> 上有索引，数据库可以使用索引条目1234记录事务42和43读取此数据的事实。（如果没有索引，则可以在表级别跟踪此信息。）此信息只需保留一段时间：在一个事务完成（提交或中止），并且所有并发事务完成后，数据库可以忘记它读取的数据。</p>
<p>当事务写入数据库时，它必须在索引中查找最近读取受影响数据的任何其他事务。这个过程类似于在受影响的 Key 范围内获取写锁，但它并不是在 reader 提交之前阻塞，而是充当一个tripwire：它只是通知事务，它们读取的数据可能不再是最新的。</p>
<p>在图7-11中，事务43通知事务42其先前的读取已过时，反之亦然。事务42是第一个提交的事务，它是成功的：虽然事务43的写入影响了42，但是43还没有提交，所以写操作还没有生效。但是，当事务43要提交时，来自42的冲突写入已经提交，因此43必须中止。</p>
<p>（5）可串行化快照隔离的性能</p>
<p>和往常一样，许多工程细节会影响算法在实践中的工作效果。例如，一个权衡是跟踪事务读写的粒度。如果数据库非常详细地跟踪每个事务的活动，就可以精确地知道哪些事务需要中止，但是簿记开销可能会变得很大。不太详细的跟踪会更快，但可能会导致比严格要求更多的事务被中止。</p>
<p>在某些情况下，事务可以读取被另一个事务覆盖的信息：根据发生的其他情况，有时可以证明执行的结果仍然是可序列化的。PostgreSQL使用这个理论来减少不必要的中止[11,41]。</p>
<p>与两阶段锁定相比，可序列化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务持有的锁。与快照隔离下一样，写入程序不会阻止 reader，反之亦然。这种设计原则使查询延迟更具可预测性和更少的可变性。特别是，只读查询可以在一致的快照上运行，而不需要任何锁，这对于读重的工作负载非常有吸引力。</p>
<p>与串行执行相比，可串行化快照隔离不限于单个CPU内核的吞吐量：FoundationDB将串行化冲突的检测分布在多台机器上，使其能够扩展到非常高的吞吐量。即使数据可以跨多台机器进行分区，事务也可以在多个分区中读写数据，同时确保可序列化的隔离[54]。</p>
<p>中止率显著影响SSI的整体性能。对于一个长时间的事务来说，可能只需要很长的时间来执行读操作，所以可能只需要很长时间的读操作。但是，与两阶段锁定或串行执行相比，SSI对慢事务的敏感度可能更低。</p>
<h2 id="总结">总结</h2>
<p>事务是一个抽象层，允许应用程序假装某些并发问题和某些类型的硬件和软件故障不存在。一大类错误被简化为一个简单的事务中止，应用程序只需要再试一次。</p>
<p>在本章中，我们看到了许多事务有助于预防的问题的示例。并非所有的应用程序都容易受到这些问题的影响：具有非常简单的访问模式（例如只读取和写入单个记录）的应用程序可能不需要事务就可以进行管理。但是，对于更复杂的访问模式，事务可以极大地减少您需要考虑的潜在错误情况的数量。</p>
<p>如果没有事务，各种错误场景（进程崩溃、网络中断、电源中断、磁盘已满、意外并发等）意味着数据可能会以各种方式变得不一致。例如，可以很容易地与非规范化数据源同步。如果没有事务，就很难推断复杂的交互访问对数据库的影响。</p>
<p>在本章中，我们特别深入地讨论了并发控制的主题。我们讨论了几种广泛使用的隔离级别，特别是提交读取、快照隔离（有时称为可重复读取）和可序列化。我们通过讨论各种种族状况的例子来描述这些孤立程度：</p>
<ul>
<li>脏读：一个客户端在另一个客户端的写操作提交之前读取它们。read committed 隔离级别和更高级别可防止脏读。</li>
<li>肮写：一个客户端覆盖另一个客户端已写入但尚未提交的数据。几乎所有事务实现都防止脏写。</li>
<li>读倾斜（不可重复读取）：客户端在不同的时间点看到数据库的不同部分。此问题通常通过<strong>快照隔离</strong>来防止，快照隔离允许事务在一个时间点从一致的快照中读取。它通常通过多版本并发控制（MVCC）来实现。</li>
<li>丢失的更新：两个客户端同时执行一个读-改-写循环。一个重写另一个的写操作而不合并其更改，因此数据丢失。快照隔离的一些实现可以自动防止这种异常，而其他实现则需要手动锁定（选择进行更新）。</li>
<li>写倾斜：事务读取某些内容，根据所看到的值做出决策，然后将决策写入数据库。然而，到了发稿的时候，这个决定的前提已经不成立了。只有<strong>可序列化的隔离</strong>才能防止这种异常。</li>
<li>幻影读：事务读取与某些搜索条件匹配的对象。另一个客户端执行的写入操作会影响搜索结果。快照隔离可防止直接的幻影读取，但写倾斜上下文中的幻影需要特殊处理，例如索引范围锁。</li>
</ul>
<p>弱隔离级别可防止某些异常，但让应用程序开发人员手动处理其他异常（例如，使用显式锁定）。只有可序列化的隔离才能防止所有这些问题。我们讨论了实现可序列化事务的三种不同方法：</p>
<ul>
<li>按顺序执行事务：如果你能让每一个事务执行得非常快、吞吐量足够低，可以在单个CPU内核上处理，这是一个简单而有效的选择。</li>
<li>两阶段锁定：几十年来，这一直是实现串行化的标准方法，但由于其性能特点，许多应用程序都避免使用它。</li>
<li>可序列化快照隔离（SSI）：一个相当新的算法，它避免了以前算法的大部分缺点。它使用了一种乐观的方法，允许事务在不阻塞的情况下继续进行。当一个事务需要提交时，它会被检查，如果执行不可序列化，它将被中止。</li>
</ul>
<p>本章中的示例使用关系数据模型。然而，正如第231页“多对象事务的需要”中所讨论的，无论使用哪种数据模型，事务都是一种有价值的数据库特性。</p>
<p>在这一章中，我们主要在数据库运行在<strong>一台机器上</strong>的环境中探索思想和算法。分布式数据库中的事务打开了一系列新的难题，我们将在下两章中讨论这些挑战。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  
  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'Hw2fQnNQyghcgeRvQosC5cIy-gzGzoHsz',
        appKey: '0ULuPWcxGRLCaHz84icXvBgn',
        notify: 'false', 
        verify: 'false', 
        avatar:'mm', 
        placeholder: '说点什么吧...',
        visitor: 'true'
    });
  </script></div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#事务的模糊概念">事务的模糊概念</a>
      <ul>
        <li><a href="#acid-的意义">ACID 的意义</a></li>
        <li><a href="#单对象和多对象操作">单对象和多对象操作</a></li>
      </ul>
    </li>
    <li><a href="#弱隔离等级">弱隔离等级</a>
      <ul>
        <li><a href="#读已提交">读已提交</a></li>
        <li><a href="#快照隔离和可重复读取">快照隔离和可重复读取</a></li>
        <li><a href="#防止丢失更新">防止丢失更新</a></li>
        <li><a href="#写歪斜和幻影">写歪斜和幻影</a></li>
      </ul>
    </li>
    <li><a href="#序列化">序列化</a>
      <ul>
        <li><a href="#实际串行执行">实际串行执行</a></li>
        <li><a href="#二阶段锁定-2pl">二阶段锁定 (2PL)</a></li>
        <li><a href="#可序列化快照隔离ssi">可序列化快照隔离（SSI）</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  

  <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279346965'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279346965%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>



</html>












