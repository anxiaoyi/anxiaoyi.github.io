<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="设计数据密集型应用程序 - 分布式系统的难点"><meta property="og:title" content="设计数据密集型应用程序 - 分布式系统的难点" />
<meta property="og:description" content="设计数据密集型应用程序 - 分布式系统的难点 在最后几章中，一个反复出现的主题是系统如何处理出错的事情。例如，我们讨论了副本故障转移（第156页的“处理节点中断”）、复制延迟（“复制延迟的问题”，第161页）和事务的通用控制（“弱隔离级别”，第233页）。随着我们逐渐了解实际系统中可能出现的各种边缘情况，我们会更好地处理它们。
然而，尽管我们谈了很多关于错误的话题，但最后几章仍然过于乐观。现实更加黑暗。我们现在将把我们的悲观情绪最大化，并假设任何可能出错的事情都会出错。我（经验丰富的系统运营商会告诉你这是一个合理的假设。如果你问得好的话，他们可能会一边给你讲一些可怕的故事，一边抚摸着过去战争留下的伤疤。）
在分布式系统中工作与在一台计算机上编写软件有着根本的不同，主要的区别在于有许多新的和令人兴奋的方法来解决问题[1,2]。在这一章中，我们将领略到实践中出现的问题，并理解我们可以依赖和不能依赖的东西。
最后，作为工程师，我们的任务是构建能够完成其工作的系统（即，满足用户期望的保证），尽管一切都出了问题。在第9章中，我们将看到一些在分布式系统中可以提供这种保证的算法的例子。但首先，在本章中，我们必须了解我们面临的挑战。
本章对分布式系统中可能出现的问题进行了彻底的悲观和令人沮丧的概述。我们将研究网络问题（第277页“不可靠的网络”）；时钟和计时问题（“287页不可靠的时钟”）；并讨论它们在多大程度上是可以避免的。所有这些问题的后果都会让人迷失方向，所以我们将探讨如何思考一个分散的系统的状态，以及如何对已经发生的事情进行推理（“知识、真理和谎言”，第300页）
故障和部分故障 当您在单台计算机上编写程序时，它通常会以相当可预测的方式运行：要么起作用，要么不起作用。 Buggy软件可能会显示出计算机有时“日子不好过”（此问题通常通过重新启动得以解决），但这主要是软件编写不当造成的。
单台计算机上的软件应该是片状的并没有根本原因：当硬件正常工作时，相同的操作总是产生相同的结果（这是确定性的）。如果出现硬件问题（例如内存损坏或连接器松动），其后果通常是整个系统故障（例如，kernel panic，“蓝屏死机”，“启动失败”）。一台拥有良好软件的个人计算机通常要么功能完全正常，要么完全坏掉，但不能介于两者之间。
在设计计算机时，这是一个经过深思熟虑的选择：如果发生内部故障，我们宁愿计算机完全崩溃，而不是返回错误的结果，因为错误的结果很难处理并且令人困惑。因此，计算机隐藏了实现它们的模糊物理现实，并提供了一个数学上完美运作的理想化系统模型。CPU指令总是做同样的事情；如果您将一些数据写入内存或磁盘，这些数据将保持完整，不会随机损坏。这种始终正确计算的设计目标可以追溯到第一台数字计算机[3]。
当你写的软件运行在多台计算机上，通过一个网络连接起来，情况就完全不同了。在分布式系统中，我们不再是在一个理想化的系统模型中运行，我们别无选择，只能面对物理世界的混乱现实。在现实世界中，很多事情都可能出问题，正如这则轶事所说明的那样：
 以我有限的经验，我曾处理过单个数据中心（DC）中长期存在的网络分区，PDU [配电单元]故障，交换机故障，整个机架的意外重启，整个DC骨干网故障，整个DC 停电，降血糖的司机将他的福特皮卡车砸到DC的HVAC（加热，通风和空调）系统中。 而且我甚至都不是行动主义者。 &ndash; Coda Hale
 在分布式系统中，即使系统的其他部分工作正常，也很有可能以某些无法预测的方式破坏了系统的某些部分。 这称为部分故障。 困难在于部分故障是不确定的：如果您尝试执行涉及多个节点和网络的任何操作，则该故障有时可能会工作，并且有时会出现无法预测的故障。
正如我们将看到的，您甚至可能不知道某事是否成功，因为消息在网络上传输所花费的时间也是不确定的！ 这种不确定性和部分故障的可能性使分布式系统难以使用[5]。
云计算和超级计算 关于如何构建大型计算系统，存在一系列哲学：
 一方面是高性能计算（HPC）领域。 具有数千个CPU的超级计算机通常用于计算密集型科学计算任务，例如天气预报或分子计算 动力学（模拟原子和分子的运动）。 另一个极端是云计算，它的定义不是很明确[6]，但通常与多租户数据中心，与IP网络连接的商用计算机（通常是以太网），弹性/按需资源分配和计量相关帐单。 传统企业数据中心位于这些极端之间。  这些哲学带来了处理错误的不同方法。在超级计算机中，作业通常会不时地将其计算状态检查点确定为持久存储。 如果一个节点发生故障，一种常见的解决方案是简单地停止整个集群工作负载。 修复故障节点后，从最后一个检查点[7，8]重新开始计算。 因此，与分布式系统相比，超级计算机更像是单节点计算机：超级计算机通过使其逐步升级为完全故障来处理部分故障-如果系统的任何部分发生故障，则只需让所有程序崩溃（就像单个计算机上的内核崩溃一样） 机）。
在本书中，我们重点介绍用于实现Internet服务的系统，这些系统通常看起来与超级计算机有很大的不同：
 从某种意义上讲，许多与Internet相关的应用程序都是在线的，它们需要能够随时为用户提供低延迟的服务。使服务不可用（例如，停止群集进行修复）是不可接受的。相反，可以停止和重新启动离线（批处理）作业（如天气模拟），而影响却很小。 超级计算机通常由专用硬件构建，其中每个节点都非常可靠，并且节点通过共享内存和远程进行通信 直接内存访问（RDMA）。另一方面，云服务中的节点是由商用机器构建，由于规模经济，它们可以以较低的成本提供同等的性能，但故障率也更高。 大型数据中心网络通常基于IP和以太网，以Clos拓扑排列以提供较高的对等带宽[9]。超级计算机通常使用专门的网络拓扑，例如多维网格和圆环[10]，对于具有已知通信模式的HPC工作负载，它们会产生更好的性能。 系统越大，其组件之一损坏的可能性就越大。随着时间的流逝，破碎的事物会得到修复，而新的事物会破碎，但是在具有数千个节点的系统中，可以合理地假设某些事物总是破碎的[7]。当错误处理策略仅由放弃组成时，大型系统最终可能会花费大量时间从故障中恢复，而不是做有用的工作[8]。 如果系统可以容忍发生故障的节点并且仍然可以整体正常工作，那么这对于操作和维护是非常有用的功能：例如，您可以执行滚动升级（请参见第4章），一次重新启动一个节点，服务将继续为用户提供服务而不会中断。在云环境中，如果一台虚拟机性能不佳，则可以将其杀死并请求新的虚拟机（希望新的虚拟机更快）。 在地理上分散的部署中（将数据保持在地理上靠近您的用户以减少访问延迟），通信很可能通过Internet进行，与本地网络相比，这种通信速度慢且不可靠。超级计算机通常假定其所有节点都靠近在一起。  如果要使分布式系统正常工作，我们必须接受部分故障的可能性，并在软件中建立容错机制。 换句话说，我们需要使用不可靠的组件来构建可靠的系统。 （如第6页上的“可靠性”所述，没有完美的可靠性之类的东西，因此我们需要理解我们可以实际承诺的限制。）
即使在仅包含几个节点的小型系统中，也要考虑部分故障。 在小型系统中，大多数组件很可能在大多数时间都能正常工作。 但是，系统的某些部分迟早会出现故障，软件必须以某种方式进行处理。 故障处理必须是软件设计的一部分，并且您（作为软件的操作员）需要知道发生故障时软件会带来什么行为。
认为错误很少发生并希望每次获得的都是最好的结果是不明智的。 重要的是要考虑各种可能的故障，甚至是不太可能的故障，并在测试环境中人为地创建此类情况以查看会发生什么。 在分布式系统中，怀疑，悲观和偏执会产生回报。
从不可靠的组件构建可靠的系统
您可能想知道这是否有意义—直观上看，系统似乎只能与最不可靠的组件（最薄弱的环节）一样可靠。事实并非如此：实际上，从较不可靠的基础结构构建更可靠的系统是计算中的旧想法[11]。例如：
 纠错码允许通过通信信道准确传输数字数据，例如由于无线网络上的无线电干扰，这种通信信道偶尔会出错一些[12]。 IP（Internet协议）不可靠：它可能会丢弃，延迟，重复或重新排序数据包。 TCP（传输控制协议）提供了更可靠的 IP上的传输层：它确保丢失的数据包被重新传输，重复数据被消除以及数据包按照发送的顺序重新组装。  尽管系统可能比其基础部分更可靠，但始终可以限制其可靠性。例如，纠错码可以处理少量的单位错误，但是如果您的信号被干扰淹没，则可以通过通信通道获取多少数据就受到了根本的限制[13]。 TCP可以向您隐藏数据包丢失，重复和重新排序的过程，但是它不能神奇地消除网络中的延迟。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kunzhao.org/docs/books/ddia/ddia-chapter8/" />

<title>设计数据密集型应用程序 - 分布式系统的难点 | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.a04069c4ba149e24630fa6fbc98cd4da6e386beb4688b0aae5809dbb5660cd77.css" integrity="sha256-oEBpxLoUniRjD6b7yYzU2m44a&#43;tGiLCq5YCdu1ZgzXc=">


<script defer src="/en.search.min.27a25520fb8dd438162fda88d2c72028009aeb155bd64b1038ccb5d4e16f46d6.js" integrity="sha256-J6JVIPuN1DgWL9qI0scgKACa6xVb1ksQOMy11OFvRtY="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      👉招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/beauty_of_mathematics/" >
      数学之美
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/history_of_quantum_physics/" >
      上帝掷骰子吗
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/clean_code/" >
      代码整洁之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the_transformation_of_enterprise_it_architecture/" >
      企业 IT 架构转型之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/redis_5_source_code/" >
      Redis 5 设计与源码分析
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/in-depth_analysis_of_the_core_technology_of_apache_dubbo/" >
      深度剖析 Apache Dubbo 核心技术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/everyone-is-architect/" >
      人人都是架构师 (一)
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-art-of-readable-code/" >
      编写可读代码的艺术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-wisdom-of-trading-stocks/" >
      炒股的智慧
  </a>

</li>
      
    
      
        

  <li >
    
      

  <a href="/docs/books/ddia/" >
      设计数据密集型应用程序
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter1/" >
      设计数据密集型应用程序 - 可靠 &amp; 可扩展 &amp; 可维护
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter2/" >
      设计数据密集型应用程序 - 数据模型 &amp; 查询语言
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter3/" >
      设计数据密集型应用程序 - 存储和读取
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter4/" >
      设计数据密集型应用程序 - 编码与演化
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter5/" >
      设计数据密集型应用程序 - Replication
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter6/" >
      设计数据密集型应用程序 - Partitioning
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter7/" >
      设计数据密集型应用程序 - 事务
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter8/"  class="active">
      设计数据密集型应用程序 - 分布式系统的难点
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>设计数据密集型应用程序 - 分布式系统的难点</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#故障和部分故障">故障和部分故障</a>
      <ul>
        <li><a href="#云计算和超级计算">云计算和超级计算</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown"><h1 id="设计数据密集型应用程序---分布式系统的难点">设计数据密集型应用程序 - 分布式系统的难点</h1>
<p>在最后几章中，一个反复出现的主题是系统如何处理出错的事情。例如，我们讨论了副本故障转移（第156页的“处理节点中断”）、复制延迟（“复制延迟的问题”，第161页）和事务的通用控制（“弱隔离级别”，第233页）。随着我们逐渐了解实际系统中可能出现的各种边缘情况，我们会更好地处理它们。</p>
<p>然而，尽管我们谈了很多关于错误的话题，但最后几章仍然过于乐观。现实更加黑暗。我们现在将把我们的悲观情绪最大化，并假设任何可能出错的事情都会出错。我（经验丰富的系统运营商会告诉你这是一个合理的假设。如果你问得好的话，他们可能会一边给你讲一些可怕的故事，一边抚摸着过去战争留下的伤疤。）</p>
<p>在分布式系统中工作与在一台计算机上编写软件有着根本的不同，主要的区别在于有许多新的和令人兴奋的方法来解决问题[1,2]。在这一章中，我们将领略到实践中出现的问题，并理解我们可以依赖和不能依赖的东西。</p>
<p>最后，作为工程师，我们的任务是构建能够完成其工作的系统（即，满足用户期望的保证），尽管一切都出了问题。在第9章中，我们将看到一些在分布式系统中可以提供这种保证的算法的例子。但首先，在本章中，我们必须了解我们面临的挑战。</p>
<p>本章对分布式系统中可能出现的问题进行了彻底的悲观和令人沮丧的概述。我们将研究网络问题（第277页“不可靠的网络”）；时钟和计时问题（“287页不可靠的时钟”）；并讨论它们在多大程度上是可以避免的。所有这些问题的后果都会让人迷失方向，所以我们将探讨如何思考一个分散的系统的状态，以及如何对已经发生的事情进行推理（“知识、真理和谎言”，第300页）</p>
<h2 id="故障和部分故障">故障和部分故障</h2>
<p>当您在单台计算机上编写程序时，它通常会以相当可预测的方式运行：要么起作用，要么不起作用。 Buggy软件可能会显示出计算机有时“日子不好过”（此问题通常通过重新启动得以解决），但这主要是软件编写不当造成的。</p>
<p>单台计算机上的软件应该是片状的并没有根本原因：当硬件正常工作时，相同的操作总是产生相同的结果（这是确定性的）。如果出现硬件问题（例如内存损坏或连接器松动），其后果通常是整个系统故障（例如，kernel panic，“蓝屏死机”，“启动失败”）。一台拥有良好软件的个人计算机通常要么功能完全正常，要么完全坏掉，但不能介于两者之间。</p>
<p>在设计计算机时，这是一个经过深思熟虑的选择：如果发生内部故障，我们宁愿计算机完全崩溃，而不是返回错误的结果，因为错误的结果很难处理并且令人困惑。因此，计算机隐藏了实现它们的模糊物理现实，并提供了一个数学上完美运作的理想化系统模型。CPU指令总是做同样的事情；如果您将一些数据写入内存或磁盘，这些数据将保持完整，不会随机损坏。这种始终正确计算的设计目标可以追溯到第一台数字计算机[3]。</p>
<p>当你写的软件运行在多台计算机上，通过一个网络连接起来，情况就完全不同了。在分布式系统中，我们不再是在一个理想化的系统模型中运行，我们别无选择，只能面对物理世界的混乱现实。在现实世界中，很多事情都可能出问题，正如这则轶事所说明的那样：</p>
<blockquote>
<p>以我有限的经验，我曾处理过单个数据中心（DC）中长期存在的网络分区，PDU [配电单元]故障，交换机故障，整个机架的意外重启，整个DC骨干网故障，整个DC 停电，降血糖的司机将他的福特皮卡车砸到DC的HVAC（加热，通风和空调）系统中。 而且我甚至都不是行动主义者。 &ndash; Coda Hale</p>
</blockquote>
<p>在分布式系统中，即使系统的其他部分工作正常，也很有可能以某些无法预测的方式破坏了系统的某些部分。 这称为<strong>部分故障</strong>。 困难在于部分故障是不确定的：如果您尝试执行涉及多个节点和网络的任何操作，则该故障有时可能会工作，并且有时会出现无法预测的故障。</p>
<p>正如我们将看到的，您甚至可能不知道某事是否成功，因为消息在网络上传输所花费的时间也是不确定的！
这种不确定性和部分故障的可能性使分布式系统难以使用[5]。</p>
<h3 id="云计算和超级计算">云计算和超级计算</h3>
<p>关于如何构建大型计算系统，存在一系列哲学：</p>
<ul>
<li>一方面是高性能计算（HPC）领域。 具有数千个CPU的超级计算机通常用于计算密集型科学计算任务，例如天气预报或分子计算
动力学（模拟原子和分子的运动）。</li>
<li>另一个极端是云计算，它的定义不是很明确[6]，但通常与多租户数据中心，与IP网络连接的商用计算机（通常是以太网），弹性/按需资源分配和计量相关帐单。</li>
<li>传统企业数据中心位于这些极端之间。</li>
</ul>
<p>这些哲学带来了处理错误的不同方法。在超级计算机中，作业通常会不时地将其计算状态检查点确定为持久存储。 如果一个节点发生故障，一种常见的解决方案是简单地停止整个集群工作负载。 修复故障节点后，从最后一个检查点[7，8]重新开始计算。 因此，<strong>与分布式系统相比，超级计算机更像是单节点计算机</strong>：超级计算机通过使其逐步升级为完全故障来处理部分故障-如果系统的任何部分发生故障，则只需让所有程序崩溃（就像单个计算机上的内核崩溃一样） 机）。</p>
<p>在本书中，我们重点介绍用于实现Internet服务的系统，这些系统通常看起来与超级计算机有很大的不同：</p>
<ul>
<li>从某种意义上讲，许多与Internet相关的应用程序都是在线的，它们需要能够随时为用户提供低延迟的服务。使服务不可用（例如，停止群集进行修复）是不可接受的。相反，可以停止和重新启动离线（批处理）作业（如天气模拟），而影响却很小。</li>
<li>超级计算机通常由专用硬件构建，其中每个节点都非常可靠，并且节点通过共享内存和远程进行通信
直接内存访问（RDMA）。另一方面，云服务中的节点是由商用机器构建，由于规模经济，它们可以以较低的成本提供同等的性能，但故障率也更高。</li>
<li>大型数据中心网络通常基于IP和以太网，以Clos拓扑排列以提供较高的对等带宽[9]。超级计算机通常使用专门的网络拓扑，例如多维网格和圆环[10]，对于具有已知通信模式的HPC工作负载，它们会产生更好的性能。</li>
<li>系统越大，其组件之一损坏的可能性就越大。随着时间的流逝，破碎的事物会得到修复，而新的事物会破碎，但是在具有数千个节点的系统中，可以合理地假设某些事物总是破碎的[7]。当错误处理策略仅由放弃组成时，大型系统最终可能会花费大量时间从故障中恢复，而不是做有用的工作[8]。</li>
<li>如果系统可以容忍发生故障的节点并且仍然可以整体正常工作，那么这对于操作和维护是非常有用的功能：例如，您可以执行滚动升级（请参见第4章），一次重新启动一个节点，服务将继续为用户提供服务而不会中断。在云环境中，如果一台虚拟机性能不佳，则可以将其杀死并请求新的虚拟机（希望新的虚拟机更快）。</li>
<li>在地理上分散的部署中（将数据保持在地理上靠近您的用户以减少访问延迟），通信很可能通过Internet进行，与本地网络相比，这种通信速度慢且不可靠。超级计算机通常假定其所有节点都靠近在一起。</li>
</ul>
<p>如果<strong>要使分布式系统正常工作，我们必须接受部分故障的可能性，并在软件中建立容错机制</strong>。 换句话说，我们需要使用<strong>不可靠的组件来构建可靠的系统</strong>。 （如第6页上的“可靠性”所述，没有完美的可靠性之类的东西，因此我们需要理解我们可以实际承诺的限制。）</p>
<p>即使在仅包含几个节点的小型系统中，也要考虑部分故障。 在小型系统中，大多数组件很可能在大多数时间都能正常工作。 但是，系统的某些部分迟早会出现故障，软件必须以某种方式进行处理。 故障处理必须是软件设计的一部分，并且您（作为软件的操作员）需要知道发生故障时软件会带来什么行为。</p>
<p>认为错误很少发生并希望每次获得的都是最好的结果是不明智的。 重要的是要考虑各种可能的故障，甚至是不太可能的故障，并在测试环境中人为地创建此类情况以查看会发生什么。 在分布式系统中，怀疑，悲观和偏执会产生回报。</p>
<p><strong>从不可靠的组件构建可靠的系统</strong></p>
<p>您可能想知道这是否有意义—直观上看，系统似乎只能与最不可靠的组件（最薄弱的环节）一样可靠。事实并非如此：实际上，从较不可靠的基础结构构建更可靠的系统是计算中的旧想法[11]。例如：</p>
<ul>
<li>纠错码允许通过通信信道准确传输数字数据，例如由于无线网络上的无线电干扰，这种通信信道偶尔会出错一些[12]。</li>
<li>IP（Internet协议）不可靠：它可能会丢弃，延迟，重复或重新排序数据包。 TCP（传输控制协议）提供了更可靠的
IP上的传输层：它确保丢失的数据包被重新传输，重复数据被消除以及数据包按照发送的顺序重新组装。</li>
</ul>
<p>尽管系统可能比其基础部分更可靠，但始终可以限制其可靠性。例如，纠错码可以处理少量的单位错误，但是如果您的信号被干扰淹没，则可以通过通信通道获取多少数据就受到了根本的限制[13]。 TCP可以向您隐藏数据包丢失，重复和重新排序的过程，但是它不能神奇地消除网络中的延迟。</p>
<p>尽管可靠性更高的高级系统并不完美，但它仍然有用，因为它可以解决一些棘手的低级故障，因此通常可以更容易地推理和处理其余的故障。我们将在第519页的“端到端参数”中进一步探讨此问题。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  
  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'Hw2fQnNQyghcgeRvQosC5cIy-gzGzoHsz',
        appKey: '0ULuPWcxGRLCaHz84icXvBgn',
        notify: 'false', 
        verify: 'false', 
        avatar:'mm', 
        placeholder: '说点什么吧...',
        visitor: 'true'
    });
  </script></div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#故障和部分故障">故障和部分故障</a>
      <ul>
        <li><a href="#云计算和超级计算">云计算和超级计算</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  

  <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279346965'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279346965%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>



</html>












