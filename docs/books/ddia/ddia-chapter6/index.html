<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="设计数据密集型应用程序 - Partitioning"><meta property="og:title" content="设计数据密集型应用程序 - Partitioning" />
<meta property="og:description" content="设计数据密集型应用程序 - Partitioning  在上一章中，我们讨论了复制，即在不同的节点上拥有相同数据的多个副本。对于非常大的数据集或非常高的查询吞吐量，这是不够的：我们需要将数据分成多个分区，也称为分片。
 通常，分区的定义方式是，每一条数据（每个记录、行或文档）只属于一个分区。实现这一点有多种方法，我们将在本章中深入讨论。实际上，每个分区都是自己的小数据库，尽管数据库可能支持同时接触多个分区的操作。
想要分区数据的主要原因是可伸缩性。不同的分区可以放在一个无共享集群中的不同节点。因此，大型数据集可以分布在多个磁盘上，查询负载可以分布在多个处理器上。
对于在单个分区上操作的查询，每个节点都可以独立地为自己的分区执行查询，因此可以通过添加更多的节点来扩展查询吞吐量。大型、复杂的查询可以跨多个节点并行化，尽管这会变得非常困难。
分区数据库在20世纪80年代由 Teradata 和 Tandem NonStop SQL[1] 等产品开创，最近又被 NoSQL 数据库和基于 Hadoop 的数据仓库重新发现。有些系统是为事务性工作负载而设计的，而其他系统则是为分析而设计的：这种差异会影响系统的优化方式，但是分区的基本原理适用于这两种工作负载。
在这一章中，我们将首先了解划分大型数据集的不同方法，并观察数据索引与分区之间的交互作用。然后我们将讨论负载均衡，如果您想在集群中添加或删除节点，这是必需的。最后，我们将概述数据库如何将请求路由到正确的分区并执行查询。
分区和复制 每个分区通常与复制节点的多个副本合并存储。尽管每个记录的容错性可能仍属于一个不同的节点，但这意味着每个记录的容错性仍然不同。
一个节点可以存储多个分区。如果使用主从复制模型，分区和复制的组合可以如下图所示。每个分区的 Leader 被分配给一个节点，它的跟随者被分配给其他节点。每个节点可能是某些分区的 Leader 节点和其他分区的跟随节点。
我们在第5章中讨论的关于数据库复制的所有内容都同样适用于分区的复制。分区方案的选择主要与复制方案的选择无关，因此在本章中我们将保持简单，而忽略复制。
键值对数据的分区 假设你有大量的数据，你想对它进行分区。如何决定在哪些节点上存储哪些记录？
我们分区的目标是将数据和查询负载均匀地分布在节点上。如果每个节点都得到公平的共享，那么理论上10个节点应该能够处理10倍于单个节点的数据量和10倍的读写吞吐量（暂时忽略复制）。
如果分区不公平，使得一些分区比其他分区拥有更多的数据或查询，我们称之为倾斜分区。倾斜的存在使得分区变得更少有效。在一个极端的情况是，所有的负载都可能在一个分区上结束，因此10个节点中有9个是空闲的，而您的瓶颈是单个繁忙的节点。具有不成比例的高负载的分区称为热点。
避免热点的最简单方法是将记录随机分配给节点。这样可以将数据均匀地分布在各个节点上，但它有一个很大的缺点：当您试图读取一个特定的项时，您无法知道它在哪个节点上，所以必须并行地查询所有节点。
我们可以做得更好。现在我们假设您有一个简单的键值数据模型，在这个模型中，您总是通过主键访问记录。例如，在一本老式的纸质百科全书中，您按标题查找条目；由于所有条目都是按标题字母顺序排序的，因此您可以很快找到要查找的条目。
根据键的范围分区 分区的一种方法是给每个分区分配一个连续的键范围（从最小值到最大值），就像纸质百科全书一样。如果知道范围之间的边界，就可以很容易地确定哪个分区包含给定的键。如果您还知道哪个分区分配给哪个节点，那么您可以直接向适当的节点提出请求（或者，对于百科全书，从书架上挑选正确的书）。
键的范围不一定均匀分布，因为数据可能不均匀分布。例如，在图6-2中，卷1包含以A和B开头的单词，而第12卷包含以T、U、V、X、Y和Z开头的单词。如果字母表中每两个字母有一个卷，则某些卷会比其他的大得多。为了使数据均匀分布，分区边界需要与数据相适应。
分区边界可以由管理员手动选择，也可以由数据库自动选择（我们将在第209页的“重新平衡分区”中更详细地讨论分区边界的选择）。Bigtable、它的开源等价HBase[2，3]、reinstdb和2.4[4]之前的MongoDB都使用这种分区策略。
在每个分区中，我们可以按排序顺序保存键（参见第76页的“SSTables和LSMTrees”）。这样做的优点是范围扫描很容易，您可以将键视为一个连接索引，以便在一个查询中获取多个相关记录（请参阅第87页的“多列索引”）。例如，考虑一个存储来自传感器网络的数据的应用程序，其中的键是测量的时间戳（年-月-日-时-分-秒）。在这种情况下，范围扫描非常有用，因为它们可以让你很容易地获取某个月的所有读数。
但是，键范围划分的缺点是某些访问模式可能导致热点。如果键是时间戳，则分区对应于时间范围，例如，每天一个分区。不幸的是，由于我们在测量时将数据从传感器写入数据库，所以所有的写入操作最终都会转到同一个分区（今天的分区），这样分区就可以在其他分区空闲的情况下进行写操作[5]。
为了避免传感器数据库中的这个问题，您需要使用时间戳以外的东西作为 Key 的第一个元素。例如，您可以在每个时间戳前面加上传感器名称，以便首先按传感器名称，然后按时间进行分区。假设有多个传感器同时处于活动状态，那么写入负载最终将更加均匀地分布在各个分区上。现在，当您想要在一个时间范围内获取多个传感器的值时，需要对每个传感器名称执行单独的范围查询。
根据键的 Hash 进行分区 由于存在倾斜和热点的风险，许多分布式数据存储使用哈希函数来确定给定 Key 的分区。
一个好的散列函数接受倾斜的数据并使其均匀分布。假设您有一个32位哈希函数，它接受一个字符串。无论何时给它一个新字符串，它都会返回一个介于0和232-1之间的随机数。即使输入字符串非常相似，它们的哈希值也均匀地分布在这个数字范围内。
出于分区的目的，散列函数不需要加密性强：例如，Cassandra 和 MongoDB 使用 MD5，而 Voldemort 使用 Fowler–Noll–Vo 函数。许多编程语言都内置了简单的哈希函数（因为它们用于哈希表），但是它们可能不适合分区：例如，在 Java 中 Object.hashCode（）和 Ruby 的 Object# 哈希，同一个键在不同的进程中可能有不同的哈希值[6]。
一旦你有了一个合适的 Key 哈希函数，你就可以为每个分区分配一个哈希范围（而不是一个Key范围），哈希在分区范围内的每个 Key 都将存储在该分区中。如图6-3所示。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kunzhao.org/docs/books/ddia/ddia-chapter6/" />

<title>设计数据密集型应用程序 - Partitioning | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.c8ac34190f548946cdf00c75980f55bfec0ade2e9e49918cccdcace897f8b279.css" integrity="sha256-yKw0GQ9UiUbN8Ax1mA9Vv&#43;wK3i6eSZGMzNys6Jf4snk=">


<script defer src="/en.search.min.7edde1c7c0cec69be3f17c936c12b56c6b3967da602c4bd11478a7bb6794110e.js" integrity="sha256-ft3hx8DOxpvj8XyTbBK1bGs5Z9pgLEvRFHinu2eUEQ4="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/beauty_of_mathematics/" >
      数学之美
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/history_of_quantum_physics/" >
      上帝掷骰子吗
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/clean_code/" >
      代码整洁之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the_transformation_of_enterprise_it_architecture/" >
      企业 IT 架构转型之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/redis_5_source_code/" >
      Redis 5 设计与源码分析
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/in-depth_analysis_of_the_core_technology_of_apache_dubbo/" >
      深度剖析 Apache Dubbo 核心技术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/everyone-is-architect/" >
      人人都是架构师 (一)
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-art-of-readable-code/" >
      编写可读代码的艺术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-wisdom-of-trading-stocks/" >
      炒股的智慧
  </a>

</li>
      
    
      
        

  <li >
    
      

  <a href="/docs/books/ddia/" >
      设计数据密集型应用程序
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter1/" >
      设计数据密集型应用程序 - 可靠 &amp; 可扩展 &amp; 可维护
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter2/" >
      设计数据密集型应用程序 - 数据模型 &amp; 查询语言
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter3/" >
      设计数据密集型应用程序 - 存储和读取
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter4/" >
      设计数据密集型应用程序 - 编码与演化
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter5/" >
      设计数据密集型应用程序 - Replication
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter6/"  class="active">
      设计数据密集型应用程序 - Partitioning
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter7/" >
      设计数据密集型应用程序 - 事务
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter8/" >
      设计数据密集型应用程序 - 分布式系统的难点
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia/ddia-chapter9/" >
      设计数据密集型应用程序 - 一致性和共识
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        <li>

  <a href="/docs/books/google-sre/" >
      Google SRE
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>设计数据密集型应用程序 - Partitioning</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#设计数据密集型应用程序---partitioning">设计数据密集型应用程序 - Partitioning</a></li>
    <li><a href="#分区和复制">分区和复制</a></li>
    <li><a href="#键值对数据的分区">键值对数据的分区</a>
      <ul>
        <li><a href="#根据键的范围分区">根据键的范围分区</a></li>
        <li><a href="#根据键的-hash-进行分区">根据键的 Hash 进行分区</a></li>
        <li><a href="#工作负荷倾斜缓解热点">工作负荷倾斜，缓解热点</a></li>
      </ul>
    </li>
    <li><a href="#分区和二级索引">分区和二级索引</a>
      <ul>
        <li><a href="#基于文档的二级索引分区">基于文档的二级索引分区</a></li>
        <li><a href="#基于术语的二级索引分区">基于术语的二级索引分区</a></li>
      </ul>
    </li>
    <li><a href="#分区重平衡">分区重平衡</a>
      <ul>
        <li><a href="#重平衡的策略">重平衡的策略</a></li>
        <li><a href="#操作自动或手动重新平衡">操作：自动或手动重新平衡</a></li>
      </ul>
    </li>
    <li><a href="#请求路由">请求路由</a>
      <ul>
        <li><a href="#并行查询执行">并行查询执行</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  
<ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-8950855178079071"
data-ad-slot="6142361626"
data-ad-format="auto"
data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h2 id="设计数据密集型应用程序---partitioning">设计数据密集型应用程序 - Partitioning</h2>
<blockquote>
<p>在上一章中，我们讨论了复制，即在不同的节点上拥有相同数据的多个副本。对于非常大的数据集或非常高的查询吞吐量，这是不够的：我们需要将数据分成多个分区，也称为分片。</p>
</blockquote>
<p>通常，分区的定义方式是，每一条数据（每个记录、行或文档）只属于一个分区。实现这一点有多种方法，我们将在本章中深入讨论。实际上，每个分区都是自己的小数据库，尽管数据库可能支持同时接触多个分区的操作。</p>
<p>想要分区数据的主要原因是可伸缩性。不同的分区可以放在一个无共享集群中的不同节点。因此，大型数据集可以分布在多个磁盘上，查询负载可以分布在多个处理器上。</p>
<p>对于在单个分区上操作的查询，每个节点都可以独立地为自己的分区执行查询，因此可以通过添加更多的节点来扩展查询吞吐量。大型、复杂的查询可以跨多个节点并行化，尽管这会变得非常困难。</p>
<p>分区数据库在20世纪80年代由 Teradata 和 Tandem NonStop SQL[1] 等产品开创，最近又被 NoSQL 数据库和基于 Hadoop 的数据仓库重新发现。有些系统是为事务性工作负载而设计的，而其他系统则是为分析而设计的：这种差异会影响系统的优化方式，但是分区的基本原理适用于这两种工作负载。</p>
<p>在这一章中，我们将首先了解划分大型数据集的不同方法，并观察数据索引与分区之间的交互作用。然后我们将讨论负载均衡，如果您想在集群中添加或删除节点，这是必需的。最后，我们将概述数据库如何将请求路由到正确的分区并执行查询。</p>
<h2 id="分区和复制">分区和复制</h2>
<p>每个分区通常与复制节点的多个副本合并存储。尽管每个记录的容错性可能仍属于一个不同的节点，但这意味着每个记录的容错性仍然不同。</p>
<p>一个节点可以存储多个分区。如果使用主从复制模型，分区和复制的组合可以如下图所示。每个分区的 Leader 被分配给一个节点，它的跟随者被分配给其他节点。每个节点可能是某些分区的 Leader 节点和其他分区的跟随节点。</p>
<p>我们在第5章中讨论的关于数据库复制的所有内容都同样适用于分区的复制。分区方案的选择主要与复制方案的选择无关，因此在本章中我们将保持简单，而忽略复制。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-27_22-57-40.png" alt=""></p>
<h2 id="键值对数据的分区">键值对数据的分区</h2>
<p>假设你有大量的数据，你想对它进行分区。如何决定在哪些节点上存储哪些记录？</p>
<p>我们分区的目标是将数据和查询负载均匀地分布在节点上。如果每个节点都得到公平的共享，那么理论上10个节点应该能够处理10倍于单个节点的数据量和10倍的读写吞吐量（暂时忽略复制）。</p>
<p>如果分区不公平，使得一些分区比其他分区拥有更多的数据或查询，我们称之为<strong>倾斜分区</strong>。倾斜的存在使得分区变得更少有效。在一个极端的情况是，所有的负载都可能在一个分区上结束，因此10个节点中有9个是空闲的，而您的瓶颈是单个繁忙的节点。具有不成比例的高负载的分区称为<strong>热点</strong>。</p>
<p>避免热点的最简单方法是将记录随机分配给节点。这样可以将数据均匀地分布在各个节点上，但它有一个很大的缺点：当您试图读取一个特定的项时，您无法知道它在哪个节点上，所以必须并行地查询所有节点。</p>
<p>我们可以做得更好。现在我们假设您有一个简单的键值数据模型，在这个模型中，您总是通过主键访问记录。例如，在一本老式的纸质百科全书中，您按标题查找条目；由于所有条目都是按标题字母顺序排序的，因此您可以很快找到要查找的条目。</p>
<h3 id="根据键的范围分区">根据键的范围分区</h3>
<p>分区的一种方法是给每个分区分配一个连续的键范围（从最小值到最大值），就像纸质百科全书一样。如果知道范围之间的边界，就可以很容易地确定哪个分区包含给定的键。如果您还知道哪个分区分配给哪个节点，那么您可以直接向适当的节点提出请求（或者，对于百科全书，从书架上挑选正确的书）。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-27_23-03-32.png" alt=""></p>
<p>键的范围不一定均匀分布，因为数据可能不均匀分布。例如，在图6-2中，卷1包含以A和B开头的单词，而第12卷包含以T、U、V、X、Y和Z开头的单词。如果字母表中每两个字母有一个卷，则某些卷会比其他的大得多。为了使数据均匀分布，分区边界需要与数据相适应。</p>
<p>分区边界可以由管理员手动选择，也可以由数据库自动选择（我们将在第209页的“重新平衡分区”中更详细地讨论分区边界的选择）。Bigtable、它的开源等价HBase[2，3]、reinstdb和2.4[4]之前的MongoDB都使用这种分区策略。</p>
<p>在每个分区中，我们可以按排序顺序保存键（参见第76页的“SSTables和LSMTrees”）。这样做的优点是范围扫描很容易，您可以将键视为一个连接索引，以便在一个查询中获取多个相关记录（请参阅第87页的“多列索引”）。例如，考虑一个存储来自传感器网络的数据的应用程序，其中的键是测量的时间戳（年-月-日-时-分-秒）。在这种情况下，范围扫描非常有用，因为它们可以让你很容易地获取某个月的所有读数。</p>
<p>但是，键范围划分的缺点是某些访问模式可能导致热点。如果键是时间戳，则分区对应于时间范围，例如，每天一个分区。不幸的是，由于我们在测量时将数据从传感器写入数据库，所以所有的写入操作最终都会转到同一个分区（今天的分区），这样分区就可以在其他分区空闲的情况下进行写操作[5]。</p>
<p>为了避免传感器数据库中的这个问题，您需要使用时间戳以外的东西作为 Key 的第一个元素。例如，您可以在每个时间戳前面加上传感器名称，以便首先按传感器名称，然后按时间进行分区。假设有多个传感器同时处于活动状态，那么写入负载最终将更加均匀地分布在各个分区上。现在，当您想要在一个时间范围内获取多个传感器的值时，需要对每个传感器名称执行单独的范围查询。</p>
<h3 id="根据键的-hash-进行分区">根据键的 Hash 进行分区</h3>
<p>由于存在倾斜和热点的风险，许多分布式数据存储使用哈希函数来确定给定 Key 的分区。</p>
<p>一个好的散列函数接受倾斜的数据并使其均匀分布。假设您有一个32位哈希函数，它接受一个字符串。无论何时给它一个新字符串，它都会返回一个介于0和232-1之间的随机数。即使输入字符串非常相似，它们的哈希值也均匀地分布在这个数字范围内。</p>
<p>出于分区的目的，散列函数不需要加密性强：例如，Cassandra 和 MongoDB 使用 MD5，而 Voldemort 使用 Fowler–Noll–Vo 函数。许多编程语言都内置了简单的哈希函数（因为它们用于哈希表），但是它们可能不适合分区：例如，在 Java 中 Object.hashCode（）和 Ruby 的 Object# 哈希，同一个键在不同的进程中可能有不同的哈希值[6]。</p>
<p>一旦你有了一个合适的 Key 哈希函数，你就可以为每个分区分配一个哈希范围（而不是一个Key范围），哈希在分区范围内的每个 Key 都将存储在该分区中。如图6-3所示。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-27_23-10-09.png" alt=""></p>
<p>这种技术很擅长在分区之间公平地分配 Key。分区边界可以均匀分布，也可以伪随机选择（在这种情况下，这种技术有时被称为一致哈希）。</p>
<p>一致性哈希，由Karger等人定义。[7] ，是一种在internet范围的缓存系统（如内容交付网络（CDN））上均匀分配负载的方法。它使用随机选择的分区边界来避免中央控制或分布式共识的需要。注意，这里的一致性与副本一致性（见第5章）或ACID一致性（见第7章）无关，而是描述了一种重新平衡的特殊方法。</p>
<p>正如我们将在209页的“重新平衡分区”中看到的，这种特殊的方法实际上对数据库[8]不是很有效，因此在实践中很少使用（一些数据库的文档仍然引用一致的哈希，但它通常是不准确的）。因为这太令人费解了，所以最好避免使用术语一致性散列，而将其称为散列分区。</p>
<p>然而不幸的是，通过使用键的散列进行分区，我们失去了键范围分区的一个很好的特性：进行有效<strong>范围查询</strong>的能力。曾经相邻的键现在分散在所有分区中，因此它们的排序顺序将丢失。在 MongoDB 中，如果启用了基于散列的分片模式，那么任何范围查询都必须发送到所有分区[4]。Riak[9]、Couchbase[10]或Voldemort不支持对主键的范围查询。</p>
<p>Cassandra在两种分区策略之间达成了妥协[11,12,13]。Cassandra中的表可以用由多个列组成的复合主键声明。只有该键的第一部分被散列以确定分区，但其他列用作连接索引，用于对Cassandra的SSTables中的数据进行排序。因此，查询无法在复合键的第一列中搜索值的范围，但如果它为第一列指定了固定值，则可以对键的其他列执行有效的范围扫描。</p>
<p><strong>串联索引方法</strong>支持一对多关系的优雅数据模型。例如，在一个社交媒体网站上，一个用户可以发布许多更新。如果更新的主键选择为（user_id，update_timestamp），则可以有效地检索特定用户在某个时间间隔内所做的所有更新，并按时间戳排序。不同的用户可以存储在不同的分区上，但是在每个用户中，更新是按时间戳顺序存储在单个分区上的。</p>
<h3 id="工作负荷倾斜缓解热点">工作负荷倾斜，缓解热点</h3>
<p>如前所述，散列键以确定其分区可以帮助减少热斑点 (hot spots)。但是，它不能完全避免它们：在极端情况下，所有的读和写都是针对同一个键的，但最终还是会将所有请求路由到同一个分区。</p>
<p>这种工作量可能不寻常，但并非闻所未闻：例如，在一个社交媒体网站上，一个拥有数百万粉丝的名人用户在做某件事时可能会引发一场活动风暴[14]。此事件可能导致对同一个键的大量写入（其中该键可能是名人的用户ID，或者是人们评论的动作的ID）。散列键没有帮助，因为两个相同的 id 的散列仍然是相同的。</p>
<p>今天，大多数数据系统都无法自动补偿这种高度倾斜的工作负载，因此应用程序有责任减少这种偏差。例如，如果知道一个键非常热，一个简单的技术就是在键的开头或结尾添加一个随机数。只要一个两位数的十进制随机数，就可以在100个不同的键上平均分配对该键的写入，从而允许这些键分布到不同的分区。</p>
<p>但是，在将写操作拆分到不同的键之后，任何读取操作都必须执行额外的工作，因为它们必须从所有100个键中读取数据并将其合并。这种技术还需要额外的簿记：只有为少数热键追加随机数才有意义；对于大多数写吞吐量较低的键，这将是不必要的开销。因此，您还需要某种方法来跟踪哪些键被拆分。</p>
<p>也许在将来，数据系统将能够自动检测并补偿不均衡的工作负载；但是现在，您需要考虑一下您自己的应用程序的权衡。</p>
<h2 id="分区和二级索引">分区和二级索引</h2>
<p>到目前为止，我们讨论的分区方案依赖于键值数据模型。如果只通过主键访问记录，我们可以从该键确定分区，并使用它将读写请求路由到负责该键的分区。</p>
<p>如果涉及二级索引，情况会变得更加复杂（另请参阅第85页的“其他索引结构”）。二级索引通常不会唯一地标识记录，而是一种搜索特定值出现的方法：查找用户123的所有操作、查找包含hogwash一词的所有文章、查找所有颜色为红色的汽车等。</p>
<p>二级索引是关系数据库的主要组成部分，在文档数据库中也很常见。许多键值存储（如HBase和Voldemort）都避免使用二级索引，因为它们增加了实现的复杂性，但是有些（如Riak）已经开始添加它们，因为它们对于数据建模非常有用。最后，二级索引是Solr和Elasticsearch等搜索服务器存在的理由。</p>
<p>二级索引的问题是它们不能整齐地映射到分区。使用二级索引对数据库进行分区有两种主要方法：基于文档的分区和基于术语的分区。</p>
<h3 id="基于文档的二级索引分区">基于文档的二级索引分区</h3>
<p>例如，假设您正在运营一个销售二手车的网站（如图6-4所示）。每个列表都有一个惟一的ID，称之为documentid，您可以根据文档ID对数据库进行分区（例如，分区0中的id0到499，分区1中的ids500到999，等等）。</p>
<p>您希望让用户搜索汽车，允许他们按颜色和make进行筛选，所以您需要一个关于color和make的二级索引（在文档数据库中，这些是字段；在关系数据库中，它们是列）。如果已声明索引，则数据库可以执行索引自动。例如，每当一辆红色汽车添加到数据库中时，数据库分区会自动将其添加到索引项的文档ID列表中 color:red。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_10-33-32.png" alt=""></p>
<p>在这种索引方法中，每个分区都是完全独立的：每个分区维护自己的辅助索引，只覆盖该分区中的文档。它不关心存储在其他分区中的数据。每当您需要写入数据库以添加、删除或更新文档时，您只需要处理包含您正在编写的文档ID的分区。因此，文档分区索引也称为本地索引（与下一节中描述的全局索引相反）。</p>
<p>但是，从文档分区索引中读取需要小心：除非您对文档id做了一些特殊处理，否则没有理由将具有特定颜色或特定品牌的所有汽车放在同一个分区中。在图6-4中，0区和1区都出现了红色的汽车。因此，如果您想搜索redcars，您需要将<strong>查询发送到所有分区</strong>，并合并返回的所有结果。</p>
<p>这种查询分区数据库的方法有时被称为分散/聚集（scatter/gather），它会使对辅助索引的读取查询变得非常昂贵。即使您并行地查询分区，分散/聚集也容易导致尾部延迟放大（参见第16页的“实践中的百分位”）。然而，它被广泛使用：MongoDB、Riak[15]、Cassandra[16]、Elasticsearch[17]、SolrCloud[18]和VoltDB[19]都使用文档分区的二级索引。大多数数据库供应商建议您构建分区方案，以便从单个分区为二级索引查询提供服务，但这并不总是可行的，尤其是当您在一个查询中使用多个二级索引时（例如同时按颜色和make筛选汽车）。</p>
<h3 id="基于术语的二级索引分区">基于术语的二级索引分区</h3>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_10-36-22.png" alt=""></p>
<p>我们可以构造一个覆盖所有分区中数据的全局索引，而不是每个分区都有自己的辅助索引（本地索引）。但是，我们不能只在一个节点上存储该索引，因为它很可能会成为瓶颈，并破坏分区的目的。全局索引也必须进行分区，但可以与主键索引进行不同的分区。</p>
<p>图6-5说明了这可能是什么样子：所有分区的红色汽车都显示在下面颜色：红色索引，但是索引是分区的，这样以字母a到r开头的颜色出现在分区0中，以s到z开头的颜色出现在分区1中。对汽车品牌的索引进行了类似的划分（分区边界在f和h之间）。</p>
<p>我们称这种索引项是分区的，因为我们要查找的项决定了索引的分区。在这里，一个术语是 color:red 例如。名称 term来自全文索引（一种特殊的二级索引），其中的术语是文档中出现的所有单词。</p>
<p>如前所述，我们可以通过术语本身或者使用术语的散列来划分索引。按术语本身进行分区对于范围扫描（例如，在数字属性上，如汽车的要价）是有用的，而对术语的散列进行分区可以提供更均匀的负载分布。</p>
<p>与文档分区索引相比，全局（术语分区）索引的优点是它可以使读取更高效：客户机只需向包含所需术语的分区发出请求，而不必对所有分区执行分散/聚集操作。但是，全局索引的缺点是写入速度较慢且更复杂，因为对单个文档的写入现在可能会影响索引的多个分区（文档中的每个术语可能位于不同的分区、不同的节点上）。</p>
<p>在理想情况下，索引总是最新的，写入数据库的每个文档都会立即反映在索引中。但是，在term分区索引中，这将需要在受写操作影响的所有分区上进行分布式事务处理，而这并不是所有数据库都支持的（参见第7章和第9章）。</p>
<p>实际上，对全局二级索引的更新通常是异步的（也就是说，如果您在写入后不久就读取了索引，那么您刚才所做的更改可能还没有反映在索引中）。例如，Amazon DynamoDB声明，在正常情况下，它的全局二级索引会在几分之一秒内更新，但在基础设施出现故障的情况下，可能会经历更长的传播延迟[20]。</p>
<p>全局术语分区索引的其他用途包括Riak的搜索功能[21]和Oracle数据仓库，它允许您在本地索引和全局索引之间进行选择[22]。我们将在第12章回到实现术语分区二级索引的主题。</p>
<h2 id="分区重平衡">分区重平衡</h2>
<p>随着时间的推移，数据库中的情况会发生变化：</p>
<ul>
<li>查询吞吐量增加，因此需要添加更多CPU来处理负载。</li>
<li>数据集大小增加，因此您需要添加更多磁盘和RAM来存储它。</li>
<li>一台机器发生故障，其他机器需要接管故障机器的责任。</li>
</ul>
<p>所有这些更改都需要将数据和请求从一个节点移动到另一个节点。将负载从群集中的一个节点移动到另一个节点的过程称为重新平衡。</p>
<p>无论使用哪种分区方案，重新平衡通常需要满足一些最低要求：</p>
<ul>
<li>重新平衡后，负载（数据存储、读写请求）应该在集群中的节点之间公平地共享。</li>
<li>在进行重新平衡时，数据库应继续接受读写操作。</li>
<li>不应在节点之间移动超过需要的数据，以便快速重新平衡，并将网络和磁盘I/O负载降至最低。</li>
</ul>
<h3 id="重平衡的策略">重平衡的策略</h3>
<p>（1）如何不这样做：hash mod N</p>
<p>当按一个键的散列进行分区时，我们前面说过（图6-3），最好将可能的散列划分成范围，并将每个范围分配给一个分区（例如，如果 <code>0≤hash（key）&lt;b0</code>，则将 key 分配给分区0；如果 <code>b0≤hash（key）&lt;b1</code>，则将key分配给分区1，等等）。</p>
<p>也许你想知道为什么我们不只用mod（许多编程语言中的%运算符）。例如，hash（key）mod 10将返回一个介于0和9之间的数字（如果我们将哈希写为十进制数，hash mod 10将是最后一个数字）。如果我们有10个节点，编号为0到9，这似乎是一种将每个键分配给一个节点的简单方法。</p>
<p><strong>mod N 方法的问题是，如果节点 N 的数量发生变化，则大多数键将需要从一个节点移动到另一个节点</strong>。例如，假设<code>hash（key）= 123456</code>。如果最初有10个节点，则该键从节点6开始（因为<code>123456 mod 10=6</code>）。当您增长到11个节点时，Key需要移动到节点3（<code>123456 mod 11=3</code>），当您增长到12个节点时，它需要移动到节点0（<code>123456 mod 12=0</code>）。如此频繁的变动使得再平衡成本过高。</p>
<p>我们需要一种方法，它不需要移动数据。</p>
<p>（2）固定分区数</p>
<p>幸运的是，有一个相当简单的解决方案：创建比节点多得多的分区，并为每个节点分配多个分区。例如，在一个由10个节点组成的集群上运行的数据库可以从一开始就分成1000个分区，这样每个节点就可以分配大约100个分区。</p>
<p>现在，如果将一个节点添加到集群中，新节点可以从每个现有节点中窃取一些分区，直到分区再次公平分布为止。该过程如图6-6所示。如果从集群中删除了一个节点，则会发生相反的情况。</p>
<p>只有整个分区在节点之间移动。分区的数目不会改变，对分区的键的分配也不会改变。唯一改变的是将分区分配给节点。这种分配的改变不是立即的&ndash;它需要一些时间来通过网络传输大量的数据，因此旧的分区分配用于在传输过程中发生的任何读写操作。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_11-16-23.png" alt=""></p>
<p>原则上，您甚至可以考虑集群中不匹配的硬件：通过为功能更强大的节点分配更多分区，可以强制这些节点承担更大的负载份额。</p>
<p>Riak[15]、Elasticsearch[24]、Couchbase[10]和Voldemort [25]都使用了这种重新平衡的方法。</p>
<p>在这种配置中，分区的数量通常在数据库第一次设置时是固定的，之后不会更改。虽然原则上可以分割和合并分区（见下一节），但是固定数量的分区在操作上更简单，因此许多固定分区数据库选择不实现分区分割。因此，在开始时配置的分区数量是您可以拥有的最大节点数，因此您需要选择足够高的分区以适应将来的增长。然而，每个分区也有管理开销，所以选择过高的数字会适得其反。</p>
<p>如果数据集的总大小是高度可变的（例如，如果它开始时很小，但随着时间的推移可能会增长得更大），那么选择正确的分区数就很困难了。由于每个分区包含总数据的固定部分，因此每个分区的大小与集群中的数据总量成比例增长。如果分区非常大，重新平衡和从节点故障中恢复将变得非常昂贵。但是如果分区太小，则会产生太多的开销。当分区的大小“恰到好处”，既不太大也不太小时，就可以获得最佳性能；如果分区的数量固定，但数据集大小不同，则很难实现这一点。</p>
<p>（3）动态分区</p>
<p>对于使用<strong>键范围</strong>分区的数据库（请参阅第202页的“按键范围划分”），使用固定边界的固定数量的分区将非常不方便：如果边界设置错误，可能会导致一个分区中的所有数据都为空，而所有其他分区都为空。手动重新配置分区边界将非常繁琐。</p>
<p>因此，键范围分区数据库（如 HBase 和 rejectdb ）会动态地创建分区。当一个分区增长到超过配置的大小（在 HBase 上，默认值为10gb），它将被拆分为两个分区，这样大约一半的数据最终会在分割的每一侧结束[26]。相反，如果删除了大量数据，并且一个分区收缩到某个阈值以下，则可以将其与相邻分区合并。这个过程类似于B树的顶层（见第79页的“BTrees”）。</p>
<p>每个分区分配给一个节点，每个节点可以处理多个分区，就像在固定数量的分区情况下一样。在一个大的分区被分割后，它的两个部分中的一个可以被转移到另一个节点，以平衡负载。对于HBase，分区文件的传输是通过HDFS进行的，HDFS是底层的分布式文件系统[3]。</p>
<p>动态分区的一个优点是分区的数量与总数据量相适应。如果只有少量的数据，那么少量的分区就足够了，因此开销也很小；如果数据量很大，则每个单独分区的大小限制为可配置的最大值[23]。</p>
<p>但是，需要注意的是，空数据库从一个分区开始，因为没有关于在哪里绘制分区边界的先验信息。当数据集很小，直到它到达第一个分区被拆分的点时，所有的写操作都必须由一个节点处理，而其他节点则处于空闲状态。为了缓解这个问题，HBase 和 MongoDB 允许在空数据库上配置一组初始分区（这称为预拆分）。在Key范围划分的情况下，预分割要求您已经知道 Key 分布是什么样子的[4，26]。</p>
<p>动态分区不仅适用于键范围分区的数据，而且同样可以用于散列分区数据。MongoDB从2.4版开始支持key-range和hash分区，在任何一种情况下，它都会动态地分割分区。</p>
<p>（4）按比例划分节点</p>
<p>对于动态分区，分区的数量与数据集的大小成正比，因为拆分和合并过程将每个分区的大小保持在某个固定的最小值和最大值之间。另一方面，对于固定数量的分区，每个分区的大小与数据集的大小成正比。在这两种情况下，分区数与节点数无关。</p>
<p>Cassandra 和 Ketama 使用的第三个选项是<strong>使分区的数量与节点的数量成比例</strong>，换句话说，每个节点有固定数量的分区[23,27,28]。在这种情况下，每个分区的大小与数据集的大小成比例增长，而节点数保持不变，但是当增加节点数时，分区又会变小。由于更大的数据量通常需要更多的节点来存储，因此这种方法还可以使每个分区的大小保持相当稳定。</p>
<p>当一个新节点加入集群时，它会随机选择一个固定数量的现有分区进行拆分，然后在保留每个分区的另一半的同时，获得每个分区的一半的所有权。随机化可以产生不公平的分割，但是当在较大数量的分区（在Cassandra中，默认情况下每个节点256个分区）上取平均值时，新节点最终会从现有节点获得公平的负载份额。Cassandra3.0引入了一种替代的再平衡算法，避免了不公平的分割[29]。</p>
<p>随机选择分区边界需要使用基于哈希的分区（因此可以从哈希函数产生的数字范围中选择边界）。实际上，这种方法最接近于一致哈希的原始定义[7]（参见第204页的“一致哈希”）。较新的哈希函数可以用较低的元数据开销实现类似的效果[8]。</p>
<h3 id="操作自动或手动重新平衡">操作：自动或手动重新平衡</h3>
<p>关于再平衡，有一个重要的问题我们一直在回避：重新平衡是自动进行还是手动进行？</p>
<p>在完全自动的重新平衡（系统自动决定何时将分区从一个节点移动到另一个节点，而不需要任何管理员交互）和完全手动（将分区分配给节点是由管理员显式配置的，只有在管理员显式地重新配置分区时才会更改）。例如，Couchbase、Riak和Voldemort会自动生成一个建议的分区分配，但是需要管理员在它生效之前提交它。</p>
<p>全自动再平衡可以很方便，因为正常维护的操作工作较少。然而，它可能是不可预测的。重新平衡是一项代价高昂的操作，因为它需要重新路由请求并将大量数据从一个节点移动到另一个节点。如果不小心进行，此过程可能会使网络或节点过载，并在重新平衡过程中损害其他请求的性能。</p>
<p>这种自动化与自动故障检测结合起来可能是危险的。例如，假设一个节点过载，对请求的响应暂时较慢。其他节点得出结论，重载的节点是死的，并自动重新平衡集群以转移负载。这会给过载的节点、其他节点和网络带来额外的负载，使情况变得更糟，并可能导致级联故障。</p>
<p>出于这个原因，有人参与再平衡可能是件好事。它比全自动过程慢，但它有助于防止操作上的意外。</p>
<h2 id="请求路由">请求路由</h2>
<p>我们现在已经在多台机器上运行的多个节点上对数据集进行了分区。但是仍然存在一个悬而未决的问题：当客户机想要发出请求时，它如何知道要连接到哪个节点？当分区重新平衡时，分配给节点的分区也会发生变化。有人需要掌握这些变化，才能回答这个问题：如果我想读或写键“foo”，我需要连接到哪个IP地址和端口号？</p>
<p>这是一个称为服务发现（service discovery）的更普遍问题的一个实例，它不仅限于数据库。任何可以通过网络访问的软件都有这个问题，特别是如果它的目标是高可用性（在多台机器上以冗余配置运行）。许多公司都编写了自己的内部服务发现工具，其中许多已经作为开源发布[30]。</p>
<p>在高层次上，有几种不同的方法来解决这个问题（如图6-7所示）：</p>
<ul>
<li>允许<strong>客户端联系任何节点</strong>（例如，通过循环负载平衡器）。如果该节点碰巧拥有应用请求的分区，那么它可以直接处理请求；否则，它将请求转发到适当的节点，接收应答，并将应答传递给客户机。</li>
<li>首先将来自客户端的所有请求发送到<strong>路由层</strong>，路由层确定应该处理每个请求的节点并相应地转发它。此路由层本身不处理任何请求；它只充当分区感知负载平衡器。</li>
<li>要求<strong>客户机知道分区和将分区分配给节点</strong>。在这种情况下，客户机可以直接连接到适当的节点，而不需要任何中介。</li>
</ul>
<p>在所有情况下，关键问题是：做出路由决策的组件（可能是节点之一、路由层或客户端）如何了解将分区分配给节点的更改？</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_21-15-15.png" alt=""></p>
<p>这是一个具有挑战性的问题，因为重要的是所有参与者都同意，否则请求将被发送到错误的节点，并且不能得到正确的处理。在分布式系统中有一些协议可以达成共识，但是很难正确实现（见第9章）。</p>
<p>许多分布式数据系统依赖于一个单独的协调服务（如ZooKeeper）来跟踪集群元数据，如图6-8所示。每个节点在ZooKeeper中注册自己，ZooKeeper维护分区到节点的权威映射。其他参与者，如路由层或支持分区的客户端，可以在ZooKeeper中订阅此信息。每当分区更改所有权，或添加或删除节点时，ZooKeeper会通知路由层，以便它可以保持其路由信息的最新状态。</p>
<p><img src="/images/docs/books/ddia/Snipaste_2020-11-28_21-17-23.png" alt=""></p>
<p>例如，LinkedIn的Espresso使用Helix[31]进行集群管理（反过来依赖ZooKeeper），实现了如图6-8所示的路由层。HBase、SolrCloud和Kafka还使用ZooKeeper跟踪分区分配。MongoDB有一个类似的架构，但它依赖于自己的配置服务器实现和mongos守护进程作为路由层。</p>
<p>Cassandra和Riak采取了不同的方法：他们在节点之间使用 gossip 协议来传播集群状态的任何变化。请求可以发送到任何节点，该节点将请求转发给请求分区的相应节点（图6-7中的方法1）。这种模型增加了数据库节点的复杂性，但避免了对外部协调服务（如ZooKeeper）的依赖。</p>
<p>Couchbase不会自动重新平衡，这简化了设计。通常它配置有一个名为moxi的路由层，它从集群节点了解路由变化[32]。</p>
<p>当使用路由层或向随机节点发送请求时，客户端仍然需要找到要连接的IP地址。它们的变化不如将分区分配给节点那样快，因此通常使用DNS就足够了。</p>
<h3 id="并行查询执行">并行查询执行</h3>
<p>到目前为止，我们关注的是读写单个键的非常简单的查询（在文档分区的二级索引的情况下，加上分散/聚集查询）。这与大多数NoSQL分布式数据存储支持的访问级别有关。</p>
<p>然而，通常用于分析的大规模并行处理（MPP）关系数据库产品在它们支持的查询类型方面要复杂得多。典型的数据仓库查询包含几个连接、筛选、分组和聚合操作。MPP查询优化器将这个复杂的查询划分为许多执行阶段和分区，其中许多可以在数据库集群的不同节点上并行执行。涉及对数据集的大部分进行扫描的查询特别受益于这种并行执行。</p>
<p>数据仓库查询的快速并行执行是一个专门的课题，鉴于分析的业务重要性，它受到了很多商业兴趣。我们将在第10章讨论一些并行查询执行的技术。有关并行数据库中使用的技术的更详细的概述，请参阅参考文献[1,33]。</p>
<h2 id="总结">总结</h2>
<p>分区的目标是将数据和查询负载均匀地分布在多台机器上，避免热点（负载过高的节点）。这需要选择适合您的数据的分区方案，并在向集群添加或从集群中删除节点时重新平衡分区。</p>
<p>我们讨论了两种主要的分区方法：</p>
<ul>
<li><strong>Key 范围分区</strong>，其中Key被排序，分区拥有从最小值到最大值的所有Key。排序的优点是可以进行有效的范围查询，但是如果应用程序经常访问排序顺序相近的键，则存在热点的风险。在这种方法中，当一个分区太大时，分区通常通过将范围分成两个子范围来动态地重新平衡。</li>
<li><strong>哈希分区</strong>，其中每个键都应用一个哈希函数，一个分区拥有一系列哈希值。此方法破坏了键的顺序，使范围查询效率低下，但可以更均匀地分配负载。当使用哈希进行分区时，通常会预先创建固定数量的分区，为每个节点分配多个分区，并在添加或删除节点时将整个分区从一个节点移动到另一个节点。也可以使用动态分区。</li>
</ul>
<p>混合方法也是可能的，例如使用复合键：<strong>使用键的一部分来标识分区，另一部分用于排序顺序。</strong></p>
<p>我们还讨论了分区和二级索引之间的交互作用。二级索引也需要分区，有两种方法：</p>
<ul>
<li><strong>文档分区索引（本地索引）</strong>，其中辅助索引与主键和值存储在同一个分区中。这意味着只有一个分区需要在写入时更新，但是读取辅助索引需要分散/聚集所有分区。</li>
<li><strong>术语分区索引（全局索引）</strong>，其中使用索引值分别对二级索引进行分区。辅助索引中的一个条目可以包括来自主键所有分区的记录。在编写文档时，需要更新辅助索引的几个分区；但是，可以从单个分区执行读取。</li>
</ul>

<ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-8950855178079071"
data-ad-slot="6142361626"
data-ad-format="auto"
data-full-width-responsive="true"></ins>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  </div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#设计数据密集型应用程序---partitioning">设计数据密集型应用程序 - Partitioning</a></li>
    <li><a href="#分区和复制">分区和复制</a></li>
    <li><a href="#键值对数据的分区">键值对数据的分区</a>
      <ul>
        <li><a href="#根据键的范围分区">根据键的范围分区</a></li>
        <li><a href="#根据键的-hash-进行分区">根据键的 Hash 进行分区</a></li>
        <li><a href="#工作负荷倾斜缓解热点">工作负荷倾斜，缓解热点</a></li>
      </ul>
    </li>
    <li><a href="#分区和二级索引">分区和二级索引</a>
      <ul>
        <li><a href="#基于文档的二级索引分区">基于文档的二级索引分区</a></li>
        <li><a href="#基于术语的二级索引分区">基于术语的二级索引分区</a></li>
      </ul>
    </li>
    <li><a href="#分区重平衡">分区重平衡</a>
      <ul>
        <li><a href="#重平衡的策略">重平衡的策略</a></li>
        <li><a href="#操作自动或手动重新平衡">操作：自动或手动重新平衡</a></li>
      </ul>
    </li>
    <li><a href="#请求路由">请求路由</a>
      <ul>
        <li><a href="#并行查询执行">并行查询执行</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279346965'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279346965%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>



</html>












