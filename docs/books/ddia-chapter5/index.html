<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="设计数据密集型应用程序 - Replication"><meta property="og:title" content="设计数据密集型应用程序 - Replication" />
<meta property="og:description" content="设计数据密集型应用程序 - Replication Replication 就是将相同数据的拷贝防止在多个通过网络连接在一起的机器上。
为什么需要 Replication  让数据在地理位置上更靠近用户 部分数据坏掉的时候，系统依然能持续工作 可伸缩，增加机器即可增加吞吐量  如果你需要 replication 的数据不发生变化，那么 replication 的过程是及其简单的，你只需拷贝到其它各个机器上，然后你的任务就完成了。然而 replication 最难的地方也就在这个地方，如何处理变化的数据？接下来就介绍三种常见的处理 replication 中数据变化的算法: single-leader、multi-leader、leaderless。
Leaders 和 Followers 每一个存储一份数据库拷贝的节点称之为: replica。每一个 replica 都需要处理写数据的操作，久而久之，每一个节点之间存储的数据也就不再一致了。解决这种问题最常见的办法就是: leader-based replication (active/passive 或 master-slave replication)，它的工作原理如下:
 其中某个 replica 被指定为 leader (master 或 primary)，客户端想要写数据，那么必须将它们的写数据的请求发送给 leader，然后 leader 随后写入到自己的本地磁盘中。 其余的 replica 称之为 follower (read replicas, slaves, secondaries, hot standbys)，当 leader 写入数据到本地磁盘的时候，同时将数据改变的部分作为 replication log 或者 change stream 发送给它的 followers。每一个 follower 根据收到的 log 按照和 leader 处理不同写操作之间的相同的顺序，来更新它自己本地的数据。 当一个客户端想要读取数据的时候，它可以发送读请求给 leader 或者任意一个 follower。但是写请求的话只能发送给 leader。  这种模式的 replication 内置在许多数据库中，例如: PostgreSQL、MySQL、Oracle Data Guard、SQL Server 的 AlwaysOn Availability Groups，甚至在许多非关系型数据库中也有它的身影，例如: MongoDB、RethinkDB、Espresso，这种模式也局限于数据库，像消息中间件 Kafka 和 RabbitMQ 高可用的队列都依赖它，一些网络文件系统和 replicated block devices 例如 DRBD 也是同样的道理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kunzhao.org/docs/books/ddia-chapter5/" />

<title>设计数据密集型应用程序 - Replication | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.a04069c4ba149e24630fa6fbc98cd4da6e386beb4688b0aae5809dbb5660cd77.css" integrity="sha256-oEBpxLoUniRjD6b7yYzU2m44a&#43;tGiLCq5YCdu1ZgzXc=">


<script defer src="/en.search.min.d310051fb06b83fbb9760c9d02fb684083cc92561f72d855183ec6ba62296569.js" integrity="sha256-0xAFH7Brg/u5dgydAvtoQIPMklYfcthVGD7GumIpZWk="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      👉招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/books/beauty_of_mathematics/" >
      数学之美
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/history_of_quantum_physics/" >
      上帝掷骰子吗
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/clean_code/" >
      代码整洁之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the_transformation_of_enterprise_it_architecture/" >
      企业 IT 架构转型之道
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/redis_5_source_code/" >
      Redis 5 设计与源码分析
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/in-depth_analysis_of_the_core_technology_of_apache_dubbo/" >
      深度剖析 Apache Dubbo 核心技术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/everyone-is-architect/" >
      人人都是架构师 (一)
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-art-of-readable-code/" >
      编写可读代码的艺术
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/the-wisdom-of-trading-stocks/" >
      炒股的智慧
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia-chapter1/" >
      设计数据密集型应用程序 - 可靠 &amp; 可扩展 &amp; 可维护
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia-chapter2/" >
      设计数据密集型应用程序 - 数据模型 &amp; 查询语言
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia-chapter3/" >
      设计数据密集型应用程序 - 存储和读取
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia-chapter4/" >
      设计数据密集型应用程序 - 编码与演化
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/books/ddia-chapter5/"  class="active">
      设计数据密集型应用程序 - Replication
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>设计数据密集型应用程序 - Replication</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#为什么需要-replication">为什么需要 Replication</a></li>
    <li><a href="#leaders-和-followers">Leaders 和 Followers</a></li>
    <li><a href="#同步和异步-replication">同步和异步 Replication</a></li>
    <li><a href="#配备新的-follower">配备新的 follower</a></li>
    <li><a href="#处理节点中断">处理节点中断</a>
      <ul>
        <li><a href="#follower-失败-赶快恢复">follower 失败: 赶快恢复</a></li>
        <li><a href="#leader-失败-故障转移">leader 失败: 故障转移</a></li>
      </ul>
    </li>
    <li><a href="#实现-replication-log">实现 replication log</a>
      <ul>
        <li><a href="#面向语句的-replication">面向语句的 replication</a></li>
        <li><a href="#逻辑基于行-的-log-replication">逻辑(基于行) 的 log replication</a></li>
        <li><a href="#基于触发的-replication">基于触发的 replication</a></li>
      </ul>
    </li>
    <li><a href="#复制延迟问题">复制延迟问题</a>
      <ul>
        <li><a href="#读取你自己写入的数据">读取你自己写入的数据</a></li>
        <li><a href="#单调读">单调读</a></li>
        <li><a href="#一致的前缀读取">一致的前缀读取</a></li>
        <li><a href="#复制滞后的解决方案">复制滞后的解决方案</a></li>
      </ul>
    </li>
    <li><a href="#多-leader-复制">多 Leader 复制</a>
      <ul>
        <li><a href="#多-leader-复制的案例">多 Leader 复制的案例</a></li>
        <li><a href="#处理写入冲突">处理写入冲突</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown"><h1 id="设计数据密集型应用程序---replication">设计数据密集型应用程序 - Replication</h1>
<p><strong>Replication</strong> 就是将相同数据的拷贝防止在多个通过网络连接在一起的机器上。</p>
<h2 id="为什么需要-replication">为什么需要 Replication</h2>
<ul>
<li>让数据在地理位置上更靠近用户</li>
<li>部分数据坏掉的时候，系统依然能持续工作</li>
<li>可伸缩，增加机器即可增加吞吐量</li>
</ul>
<p>如果你需要 replication 的数据不发生变化，那么 replication 的过程是及其简单的，你只需拷贝到其它各个机器上，然后你的任务就完成了。然而 replication 最难的地方也就在这个地方，如何处理变化的数据？接下来就介绍三种常见的处理 replication 中数据变化的算法: single-leader、multi-leader、leaderless。</p>
<h2 id="leaders-和-followers">Leaders 和 Followers</h2>
<p>每一个存储一份数据库拷贝的节点称之为: <strong>replica</strong>。每一个 replica 都需要处理<strong>写数据</strong>的操作，久而久之，每一个节点之间存储的数据也就不再一致了。解决这种问题最常见的办法就是: leader-based replication (active/passive 或 master-slave replication)，它的工作原理如下:</p>
<ul>
<li>其中某个 replica 被指定为 leader (master 或 primary)，客户端想要<strong>写数据</strong>，那么必须将它们的写数据的请求发送给 leader，然后 leader 随后写入到自己的本地磁盘中。</li>
<li>其余的 replica 称之为 follower (read replicas, slaves, secondaries, hot standbys)，当 leader 写入数据到本地磁盘的时候，同时将数据改变的部分作为 replication log 或者 change stream 发送给它的 followers。每一个 follower 根据收到的 log 按照和 leader 处理<strong>不同写操作</strong>之间的<strong>相同的顺序</strong>，来更新它自己本地的数据。</li>
<li>当一个客户端想要读取数据的时候，它可以发送读请求给 leader 或者任意一个 follower。但是写请求的话只能发送给 leader。</li>
</ul>
<p><img src="/images/docs/books/ddia/leader-based-replication.png" alt=""></p>
<p>这种模式的 replication 内置在许多数据库中，例如: PostgreSQL、MySQL、Oracle Data Guard、SQL Server 的 AlwaysOn Availability Groups，甚至在许多非关系型数据库中也有它的身影，例如: MongoDB、RethinkDB、Espresso，这种模式也局限于数据库，像消息中间件 Kafka 和 RabbitMQ 高可用的队列都依赖它，一些网络文件系统和 replicated block devices 例如 DRBD 也是同样的道理。</p>
<h2 id="同步和异步-replication">同步和异步 Replication</h2>
<p>replication 数据的过程可以分为同步或者异步。如下图所示，follower 1 配置为<strong>同步</strong>的，leader 等待 follower 1 确认它收到了 log 之后，才向 client 反馈更新成功；而被配置为异步的 follower 2 则无须这一步，leader 可以直接反馈更新成功。</p>
<p><img src="/images/docs/books/ddia/leader-based-sync-async.png" alt=""></p>
<p>显然在 leader 响应 OK 与 follower 2 接受并处理完毕 write 请求之间是存在延迟的，尽管多数数据库系统的 replication 的过程是非常快的，然而这个时间的上限谁也并没有保证。follower 可能刚刚重启、follower 系统满负载了、leader 到 follower 之间的网络出现故障了等等，都有可能导致 follower 的数据落后 leader 1分钟或者多分钟。</p>
<p>同步 replication 的优势在于 follower 总能保持和 leader 实时的一致性的数据，如果 leader 突然不可用了，我们可以确保数据在 follower 上仍然是可用的。缺点在于如果 follower 出现了问题，比如 crash 了，网络故障了，写这个操作就没办法进行下去了，leader 此刻必须阻塞等待 replica 变为可用状态才能继续处理其他 write 操作。</p>
<p>所以，维持整个系统的所有 replica 一致性状态是不切实际的。实际上，如果你在数据库中启用了同步 replication，它通常是指指定一个 follower 变为同步的，其它的 follower 依然是异步的，如果同步的 follower 变得不可用或者速度变慢，那么某一个异步的 follower 将会晋升为同步的 follower，这保证了总是有两个节点 leader 和一个 follower 始终维持最新的数据。这种配置有时候也称之为 <strong>semi-synchronous</strong>。</p>
<p>通常，leader-based replication 被配置为全部是异步的，如果 leader 一旦失败不可恢复，那么所有的还未同步给 follower 节点的写数据将会丢失，这也就意味着写不保证一定写成功。它的优势在于即使所有的 follower 都不可用，leader 依然可以处理写请求。</p>
<blockquote>
<p>对于异步 replication 来说，leader 失败后的数据丢失是很严重的，所以当前也有针对其不丢失数据同时提供良好性能和可用性的方法。例如链 replication ，其是同步复制的一个变种，它已经成功应用在 Microsoft Azure Storage 系统中。</p>
</blockquote>
<h2 id="配备新的-follower">配备新的 follower</h2>
<ul>
<li>定时对 leader 的数据库构建快照。</li>
<li>将快照拷贝到 follower 机器上。</li>
<li>follower 连接上 leader，请求所有自快照到最新版本之间变更的数据，这就需要快照本身关联到 leader 的 replication log 的一个精确的位置上。PostgreSQL 称之为 log sequence number，MySQL 称之为 binlog coordinates。</li>
<li>当 follower 处理完自 snapshot 创建之后堆积的数据变化后，我们称它追赶上了 leader。接下来，它继续处理来自 leader 发送过来的 log 即可。</li>
</ul>
<h2 id="处理节点中断">处理节点中断</h2>
<p>我们的目标是在单个节点发生故障的情况下，保持系统作为一个整体运行，并使节点中断的影响尽可能小。</p>
<h3 id="follower-失败-赶快恢复">follower 失败: 赶快恢复</h3>
<p>follower 每次收到 log 之后，都会先记录在本地磁盘中，所以当它恢复之后也能很快知道它发生故障时正在处理的最后一个事务，它可以继续连接上 leader，然后请求在这之间发生的数据变更的 log ，当它应用这些 log 后，也就追上了 leader，意味着可以继续像之前一样继续接受数据流了。</p>
<h3 id="leader-失败-故障转移">leader 失败: 故障转移</h3>
<p>leader 失败后: 某一个 follower 被提拔为 leader，客户端需要将 write 请求发送至新的 leader，其它 follower 需要从新的 leader 消费数据，这个过程称之为 failover (故障转移)。</p>
<p>failover 既可以自动执行，也可以手动执行，一个自动执行的 failover 包含如下步骤:</p>
<ul>
<li>检测 leader 是否失败了。多数都是使用<strong>超时时间</strong>来检测节点是否存活。</li>
<li>选择新的 leader。这可以通过一个选举过程来完成（在这种过程中，leader 是由剩余副本的大多数选择的），也可以由先前选择的控制器节点指定新的 leader。leader 的最佳人选通常是具有最新数据更改的副本（以尽量减少数据丢失）。让所有节点都同意一个新的 leader 是一个共识问题。</li>
<li>重新配置系统以使用新的领导者。client 现在需要将他们的写请求发送给新的 leader 。如果原来的 leader 恢复了，它可能仍然相信自己是 leader，却没有意识到其他 replicas 已经迫使它下台了。系统需要确保旧的 leader 成为 follower，并识别新的 leader。</li>
</ul>
<p>故障切换充满了风险：</p>
<ul>
<li>如果采用的是异步 replication，那么新推选出来的 leader 可能还没有接收完所有的 old leader 在失败前发送的写请求。如果前一个 leader 又回来了，那么应该如何协调？新的 leader 同样可能收到写请求。最常见的做法是，直接丢弃 old leader 未被 replicated 的写请求，但这可能和客户端的高可用性原则相违背。</li>
<li>如果数据库之外的其他存储系统需要和数据库内容进行协调，丢弃写请求则是非常危险的行为。</li>
<li>某些情况下，可能出现两个节点都认为自己是 leader 的情况，这称之为 split brain。这是及其危险的，如果二者均接受到了写的请求，而又没有其他进程去协调，那么数据有可能出现混乱或者丢失。作为一种安全保护，部分系统在检测到出现了两个 leader 的时候，会强制性关闭某个 leader，但是如果设计的不好的话，也可能会出现两个 leader 都被关闭的尴尬状态。</li>
<li>宣告 leader 死亡的合适的超时时间是多久？时间久一点的意味着久一点才能恢复，时间短一点的，会造成不必要的故障切换，占用不必要的网络带宽和系统资源。</li>
</ul>
<p>这些问题并没有简单的方法来去解决。鉴于此，部分系统默认需要手动进行故障切换，即使它本身能够支持自动鼓掌切换。</p>
<h2 id="实现-replication-log">实现 replication log</h2>
<h3 id="面向语句的-replication">面向语句的 replication</h3>
<p>最简单的是，将每次需要执行的语句 (statement) 的 log 发送给 follower。在关系型数据库中，每一次的 INSERT、UPDATE、DELETE 等语句需要发送给 follower，follower 需要解析并处理这些语句。这种方式听起来还可以，然而还是有一些情况会出现问题:</p>
<ul>
<li>某些语句调用了 <code>NOW()</code> 或者 <code>RAND()</code> 这样的函数，每次得到的都是不同的数值，应该如何同步过去？</li>
<li>如果语句使用了自增列，或者他们依赖数据中已有的数据进行判断 (UPDATE &hellip; WHERE 某些条件)，他们就必须在每一个 replica 上严格按照顺序执行，否则就可能产生不同的结果，这显然不利于并发事务的执行。</li>
<li>有副作用的语句 (触发器、存储过程、用户自定义函数等) 可能在不同节点上会造成不同的副作用，除非这种副作用是明确的，能提前预测到的。</li>
</ul>
<p>解决这些问题是可能的，例如，当记录语句时，leader 可以用一个固定的返回值替换任何不确定的函数调用，以便 follower 都获得相同的值。但是，由于存在太多的边缘情况，现在通常首选其他复制方法。</p>
<p>基于语句的复制在 5.1 版之前的MySQL中使用。由于它非常紧凑，所以现在仍然使用它，但是默认情况下，如果语句中存在任何不确定性，MySQL 现在会切换到<strong>基于行的复制</strong>。</p>
<p><strong>预写日志 (WAL)</strong></p>
<p>WAL 中的内容: <strong>哪一块磁盘的哪几个字节的数据被修改了</strong>，这使得 WAL 日志和存储引擎关联到一起了。如果数据库将存储格式换为另外一个版本，那么不太可能运行不同的数据库软件。</p>
<p>如果复制协议允许 follower 使用更新的软件版本与 leader 相比，您可以执行数据库软件的零停机升级，方法是先升级 follower，然后执行故障转移，使升级的节点之一成为新的leader。如果复制协议不允许这种版本不匹配，就像 WAL-shipping 的情况一样，这种升级需要停机。</p>
<h3 id="逻辑基于行-的-log-replication">逻辑(基于行) 的 log replication</h3>
<p>另一种方法是对复制和存储使用不同的日志格式引擎，它允许复制日志与存储引擎内部分离。这种复制日志称为<strong>逻辑日志</strong>，以区别于存储引擎的（物理）数据表示。</p>
<p>关系数据库的逻辑日志通常是一系列记录，以行的粒度描述对数据库表的写入：</p>
<ul>
<li>对于 INSERT 的行，日志包含所有列的新值。</li>
<li>对于 DELETE 的行，日志包含的信息足以唯一标识已删除的行。通常这是主键，但如果表上没有主键，则需要记录所有列的旧值。</li>
<li>对于 UPDATE 的行，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少是更改的所有列的新值）。</li>
</ul>
<p>一个修改多行的事务会生成多个这样的日志记录，后面跟着一个指示事务已提交的记录。MySQL的 binlog（当配置为使用基于行的复制时）使用的就是这种方法。</p>
<p>由于逻辑日志与存储引擎内部分离，因此可以更容易地保持向后兼容，从而允许 leader 和 follower 运行不同版本的数据库软件，甚至不同的存储引擎。</p>
<p>逻辑日志格式也更易于外部应用程序解析。如果要将数据库的内容发送到外部系统（如用于脱机分析的数据仓库或用于构建自定义索引和缓存）的话，此特性非常有用。这种技术称为变更数据捕获。</p>
<h3 id="基于触发的-replication">基于触发的 replication</h3>
<p>到目前为止描述的复制方法是由数据库系统实现的，不涉及任何应用程序代码。在许多情况下，这正是您想要的，但有些情况下需要更大的灵活性。例如，如果您只想复制数据的一个子集，或者想从一种数据库复制到另一种数据库，或者需要冲突解决逻辑，则可能需要将复制向上移动到应用程序层。</p>
<p>一些工具，如 Oracle GoldenGate，可以通过读取数据库日志使数据更改对应用程序可用。另一种方法是使用许多关系数据库中可用的特性：触发器和存储过程。</p>
<p>触发器允许您注册在数据库系统中发生数据更改（写入事务）时自动执行的自定义应用程序代码。可以把它从一个外部进程读成一个独立的进程，这个进程可以从这个进程中读出来。然后，该外部进程可以应用任何必要的应用程序逻辑，并将数据更改复制到另一个系统。例如，Oracle的 Databus 和 Postgres 的 Bucardo 都是这样工作的。</p>
<p>基于触发器的复制通常比其他复制方法的开销更大，而且比数据库的内置复制更容易出现错误和限制。然而，由于其灵活性，它仍然是有用的。</p>
<h2 id="复制延迟问题">复制延迟问题</h2>
<p>基于 Leader 的复制要求所有写操作都通过单个节点，但只读查询可以转到任何副本。对于主要由读操作和少量写入操作组成的工作负载（web上的一种常见模式），有一个很有吸引力的选项：创建许多 follower，并在这些 follower 之间分发读取请求。这将从 leader 中移除负载，并允许附近的副本为读请求提供服务。</p>
<p>在这种读扩展架构中，只需添加更多 follower，就可以增加为只读请求提供服务的容量。但是，这种方法只适用于<strong>异步复制</strong>，如果您尝试同步复制到所有 follower，单个节点故障或网络中断将使整个系统无法写入。你拥有的节点越多，就越有可能出现故障，因此完全同步的配置就非常不可靠。</p>
<p>不幸的是，如果应用程序从异步 follower 读取数据，那么如果 follower 落后，它可能会看到过时的信息。这会导致数据库中明显的不一致性：如果同时对 leader 和 follower 运行相同的查询，可能会得到不同的结果，因为并非所有的写入都能即时地反映在 follower 中。这种不一致只是一种暂时的状态，如果你停止对数据库的写入并等待一段时间，follower 最终会赶上并与 leader 保持一致。因此，这种效果被称为<strong>最终一致性</strong>。</p>
<p>“最终”一词故意含糊其辞：一般来说，replica 节点的落后程度没有限制。在正常操作中，在主服务器上执行写入操作与在从服务器上反映复制延迟之间的延迟可能只有几秒钟，在实践中并不明显。但是，如果系统在接近负载容量的情况下运行，或者网络出现问题，延迟很容易增加到几秒钟甚至几分钟。</p>
<p>当滞后如此之大时，它所带来的不一致性不仅仅是一个理论问题，而是一个实际的应用问题。在本节中，我们将重点介绍三个复制延迟时可能出现的问题，并概述一些解决这些问题的方法。</p>
<h3 id="读取你自己写入的数据">读取你自己写入的数据</h3>
<p>许多应用程序允许用户提交一些数据，然后查看他们提交的内容。这可能是客户数据库中的一条记录，或者是论坛上的评论，或者其他类似的东西。当新数据被提交时，它必须被发送给 leader，但是当用户查看数据时，它可以从 follower 那里读取。如果经常查看数据但只是偶尔写入数据，这一点尤其合适。</p>
<p><img src="/images/docs/books/ddia/user-makes-comment.png" alt=""></p>
<p>在这种情况下，我们需要 read-after-write 一致性，也称为 read-your-writes 一致性。这是一个保证，如果用户重新加载页面，他们将始终看到自己提交的任何更新。它对其他用户不做任何承诺：其他用户的更新可能要等到以后才能看到。但是，它保证用户自己的输入已经正确保存。</p>
<p>如何在 leader-based 系统中实现 read-after-write 一致性:</p>
<ul>
<li>读取用户可能已修改的内容时，请从 leader 那读取；否则，从 follower 那里读。这需要您有某种方法来知道某些内容是否已被修改，而无需实际查询它。例如，社交网络上的用户配置文件信息通常只能由个人资料的所有者编辑，而不能由其他任何人编辑。因此，一个简单的规则是：始终从 leader 处读取用户自己的配置文件，从 follower 读取任何其他用户的配置文件。</li>
<li>如果应用程序中的大多数内容都有可能被用户编辑，那么这种方法就不会有效，因为大多数内容都必须从 leader 那里读取（否定了读伸缩的好处）。在这种情况下，可以使用其他标准来决定是否向 leader 读取。例如，您可以跟踪最后一次更新的时间，并在最后一次更新后的一分钟内，从 leader 读取所有数据。您还可以监视 followers 上的复制延迟，并防止对任何落后于 leader 一分钟以上的 follower 进行查询。</li>
<li>客户端可以记住其最近写入的时间戳，然后系统可以确保服务于该用户的任何读取的副本，至少要能够反映出那个时间点之前的更新都是最新的。如果副本不够及时，则可以由另一个副本处理读取，或者查询可以等到复制副本追上那个时间点为止。时间戳可以是逻辑时间戳（指示写入顺序的东西，例如日志序列号）或实际系统时钟（在这种情况下时钟同步变得至关重要）。</li>
<li>如果您的副本分布在多个数据中心（地理位置上更接近用户或更可用），还有额外的复杂性。任何需要由 leader 提供服务的请求都必须路由到包含该 leader 的数据中心。</li>
</ul>
<p>当同一个用户从多个设备（例如桌面 web 浏览器和移动应用程序）访问您的服务时，另一个复杂的问题就会出现。在这种情况下，您可能需要提供<strong>跨设备的 read-after-write 一致性</strong>：如果用户在一个设备上输入一些信息，然后在另一个设备上查看它，那么他们应该看到他们刚刚输入的信息。</p>
<p>这种情况下，还需要考虑其它问题:</p>
<ul>
<li>需要记住用户上次更新的时间戳的方法变得更加困难，因为在一个设备上运行的代码不知道另一个设备上发生了什么更新。这个元数据需要<strong>集中化</strong>。</li>
<li>如果复制副本分布在不同的数据中心，则无法保证来自不同设备的连接将路由到同一个数据中心。（例如，如果用户的桌面计算机使用家庭宽带连接，而他们的移动设备使用蜂窝数据网络，则设备的网络路由可能完全不同。）如果您的方法需要从 leader 处读取，则您可能首先需要将请求从用户的所有设备路由到同一数据中心。</li>
</ul>
<h3 id="单调读">单调读</h3>
<p>我们的第二个例子是，当从异步 follower 读取数据时，可能会发生异常，即用户可能会看到时间线上<strong>向后移动</strong>的东西。</p>
<p>如果用户从不同的副本进行多次读取，就会发生这种情况。例如，图 5-4 显示用户 2345 对同一个查询进行了两次，首先是对延迟较小的 follower，然后是延迟较大的 follower。（如果用户刷新一个网页，并且每个请求都被路由到一个随机服务器，这种情况很可能发生。）第一个查询返回用户 1234 最近添加的评论，但是第二个查询没有返回任何内容，因为滞后的 follower 还没有接收到该写入。实际上，第二个查询是在比第一个查询更早的时间点来观察系统。如果第一个查询没有返回任何内容，这不会太糟糕，因为用户 2345 可能不知道用户 1234 最近添加了一个评论。然而，如果用户 2345 首先看到用户 1234 的评论出现，然后又看到它消失，这会让他们非常困惑。</p>
<p><img src="/images/docs/books/ddia/fresh-stale-replica.png" alt=""></p>
<p>单调读保证了这种异常不会发生。这是比强一致性弱的保证，但比最终一致性更有力的保证。当您读取数据时，您可能会看到一个旧值；单调读取仅意味着如果一个用户按顺序进行多次读取，他们将看不到时间倒流，也就是说，在先前读取了较新的数据之后，他们不会再读取较旧的数据。</p>
<p>实现单调读取的一种方法是<strong>确保每个用户总是从同一个副本进行读取</strong>（不同的用户可以从不同的副本读取）。例如，可以根据用户 ID 的哈希值选择副本，而不是随机选择。但是，如果该复制副本失败，则需要将用户的查询重新路由到另一个副本。</p>
<h3 id="一致的前缀读取">一致的前缀读取</h3>
<p>复制滞后异常的第三个例子涉及违反因果关系。你有可能先看到答案而非问题：</p>
<p><img src="/images/docs/books/ddia/see-answer-before-question.png" alt=""></p>
<p>防止这种异常需要另一种类型的保证：一致的前缀读取。这个保证说，如果一个<strong>写入序列按一定的顺序发生</strong>，那么任何阅读这些写入的人都会看到它们以相同的顺序出现。</p>
<p>这是分区（分片）数据库中的一个特殊问题，我们将在第 6 章中讨论。如果数据库总是以相同的顺序应用写操作，那么读取总是会看到一致的前缀，因此不会发生这种异常情况。但是，在许多分布式数据库中，不同的分区是独立运行的，因此没有全局写入顺序：当用户从数据库中读取时，他们可能会看到数据库的某些部分处于旧状态，而另一些部分处于较新状态。</p>
<p>一种解决方案是确保任何与彼此有因果关系的写操作都<strong>写入同一个分区</strong>，但在某些应用程序中无法有效地执行。还有一些算法可以明确地跟踪因果依赖关系，我们后续继续讨论。</p>
<h3 id="复制滞后的解决方案">复制滞后的解决方案</h3>
<p>在使用最终一致的系统时，如果复制延迟增加到几分钟甚至几个小时，那么应该考虑应用程序的行为。如果答案是“没问题”，那就太好了。但是，如果结果对用户来说是一种不好的体验，那么重要的是要设计出一个更强大的保证，比如先读后写。假装复制是同步的，而实际上它是异步的，这是导致问题的根本原因。</p>
<p>如前所述，应用程序可以提供比底层数据库更强的保证，例如，通过对 leader 只执行某些类型的读取。然而，在应用程序代码中处理这些问题很复杂，而且很容易出错。</p>
<p>如果应用程序开发人员不必担心细微的复制问题，而只需信任他们的数据库“做正确的事情”，那就更好了。这就是为什么存在事务：事务是数据库提供更强大保证的一种方式，这样应用程序可以更简单。</p>
<p>单节点事务已经存在很久了。然而，在向分布式（复制和分区）数据库转移的过程中，许多系统放弃了它们，声称事务在性能和可用性方面过于昂贵，并断言在可伸缩系统中，最终的一致性是不可避免的。这句话有些道理，但过于简单化了，我们将在本书的其余部分形成一个更细致的观点。</p>
<h2 id="多-leader-复制">多 Leader 复制</h2>
<p>Leader-based 的复制有一个主要的缺点：只有一个 leader，所有写入都必须经过它。如果你因为任何原因无法连接到 leader，例如由于你和 leader 之间的网络中断，你就不能写入数据库。</p>
<p>基于 leader 的复制模型的一个自然扩展是允许多个节点接受写操作。复制仍然以同样的方式进行：每个处理写操作的节点都必须将数据更改转发给所有其他节点。我们称之为多 leader 配置（也称为主-主或主动/主动复制）。在此设置中，每个 leader 同时充当其他 leader 的 follower。</p>
<h3 id="多-leader-复制的案例">多 Leader 复制的案例</h3>
<p>（1）<strong>多数据中心</strong></p>
<p>假设您有一个数据库，在多个不同的数据中心中都有副本（可能是为了让您能够容忍整个数据中心的故障，或者是为了更接近您的用户）。对于普通的基于 leader 的复制设置，leader 必须位于其中一个数据中心中，并且所有的写操作都必须经过该数据中心。</p>
<p>在多 leader 配置中，每个数据中心都可以有一个 leader。下图显示了这个架构可能是什么样子。在每个数据中心内，使用常规的主从复制；在数据中心之间，每个数据中心的领导者将其更改复制到其他数据中心的领导者。</p>
<p><img src="/images/docs/books/ddia/multi-leader-replication.png" alt=""></p>
<p>让我们比较一下 single-leader 和多 leader 配置在多数据中心部署中的表现：</p>
<ul>
<li>性能</li>
</ul>
<p>在单 leader 配置中，每次写入都必须通过网络发送到数据中心。这可能会给写入操作增加很大的延迟，并且可能与首先拥有多个数据中心的目的相抵触。在多 leader 配置中，每个写入都可以在本地数据中心进行处理，并异步复制到其他数据中心。因此，数据中心间的网络延迟对用户是隐藏的，这意味着感知性能可能更好。</p>
<ul>
<li>数据中心中断容忍度</li>
</ul>
<p>在单 leader 配置中，如果具有该 leader 的数据中心发生故障，则进行故障转移，可以将另一个数据中心的 follower 提升为 leader。在多 leader 配置中，每个数据中心都可以独立于其他数据中心继续运行，当出现故障的数据中心恢复联机时，复制将迎头赶上。</p>
<ul>
<li>网络问题容忍度</li>
</ul>
<p>数据中心之间的通信通常通过公共互联网，这可能不如数据中心内的本地网络可靠。单 leader 配置对这个数据中心间链路中的问题非常敏感，因为写操作是在这个链路上同步进行的。具有异步复制的多 leader 配置通常可以更好地容忍网络问题：临时网络中断不会阻止正在处理的写操作。</p>
<p>一些数据库默认支持多 leader 配置，但也经常使用外部工具来实现，例如用于 MySQL 的 Tungsten Replicator、用于 PostgreSQL 的 BDR 和用于 Oracle 的 GoldenGate。</p>
<p>虽然多 leader 复制有其优点，但也有一个很大的缺点：相同的数据可能在两个不同的数据中心中被并发修改，并且这些<strong>写入冲突</strong>必须得到解决。</p>
<p>（2）<strong>脱机操作的客户端</strong></p>
<p>另一种适合多 leader 复制的情况是，如果您的应用程序需要在与网络断开连接的情况下继续工作。</p>
<p>例如，考虑一下手机、笔记本电脑和其他设备上的日历应用程序。您需要能够随时查看您的会议（发出读取请求）和输入新会议（发出写入请求），而不管您的设备当前是否具有网络连接。如果在脱机时进行了任何更改，则需要在设备下次联机时与服务器和其他设备同步。</p>
<p>在这种情况下，每个设备都有一个本地数据库充当 leader 服务器（它接受写入请求），并且在所有设备上的日历副本之间有一个异步多 leader 复制过程（sync）。复制延迟可能是数小时甚至几天，这取决于您何时可以访问网络。</p>
<p>从体系结构的角度来看，这种设置本质上与数据中心之间的多 leader 复制相同，达到了极致：每个设备都是一个“数据中心”，它们之间的网络连接极其不可靠。正如有很多历史记录需要同步，复制是一个棘手的问题。</p>
<p>有一些工具旨在使这种多 leader 配置更容易。例如，CouchDB 就是为这种操作模式而设计的。</p>
<p>（3）<strong>协同编辑</strong></p>
<p>实时协作编辑应用程序允许多人同时编辑文档。例如，Etherpad 和 Google Docs 允许多人同时编辑文本文档或电子表格。</p>
<p>我们通常不认为协作编辑是数据库复制问题，但它与前面提到的脱机编辑用例有很多共同之处。当一个用户编辑文档时，更改会立即应用到其本地副本（文档在其web浏览器或客户端应用程序中的状态），并异步复制到服务器和正在编辑同一文档的任何其他用户。</p>
<p>如果要保证不会发生编辑冲突，则应用程序必须先获得文档的锁定，然后用户才能编辑它。如果另一个用户想要编辑同一个文档，他们首先必须等到第一个用户提交了他们的更改并释放了锁。此协作模型相当于在主节点上使用事务进行单 leader 复制。</p>
<p>但是，为了更快的协作，您可能希望将更改单元设置得非常小（例如，一次击键）并避免锁定。这种方法允许多个用户同时编辑，但也带来了多 leader 复制的所有挑战，包括需要解决冲突。</p>
<h3 id="处理写入冲突">处理写入冲突</h3>
<p>多 leader 复制的最大问题是可能会发生写入冲突，这意味着需要解决冲突。</p>
<p>例如，考虑一个由两个用户同时编辑的 wiki 页面，如图所示。用户1将页面标题从A更改为B，用户2同时将标题从A更改为C。每个用户的更改都成功地应用于其本地 leader。但是，当异步复制更改时，会检测到冲突。此问题不会出现在单个 leader 数据库中。</p>
<p><img src="/images/docs/books/ddia/write-conflict.png" alt=""></p>
<p>（1）<strong>同步冲突检测与异步冲突检测</strong></p>
<p>在单 leader 数据库中，第二个写入程序将阻塞并等待第一次写入完成，或者中止第二次写入事务，迫使用户重试写入。另一方面，在多 leader 设置中，两次写入都是成功的，并且冲突只在稍后的某个时间点异步检测到。此时，要求用户解决冲突可能为时已晚。</p>
<p>原则上，您可以使冲突检测同步，即等待写入复制到所有副本，然后再告诉用户写入成功。但是，这样做，您将失去多 leader 复制的主要优势：允许每个复制副本独立地接受写操作。如果您希望使用单次复制，那么也可以使用单次复制。</p>
<p>（2）<strong>避免冲突</strong></p>
<p>处理冲突的最简单策略是避免冲突：如果应用程序可以确保对特定记录的所有写入都经过同一个 leader，那么就不会发生冲突。由于许多多 leader 复制的实现处理冲突的能力相当差，因此避免冲突是一种经常被推荐的方法。</p>
<p>例如，在一个用户可以编辑自己的数据的应用程序中，可以确保来自特定用户的请求始终路由到同一个数据中心，并使用该数据中心中的 leader 进行读写。不同的用户可能有不同的“家庭”数据中心（可能是根据地理位置与用户的接近程度来选择的），但是从任何一个用户的角度来看，配置基本上是单一 leader 的。</p>
<p>但是，有时您可能需要更改记录的指定 leader，可能是因为一个数据中心发生故障，您需要将流量重新路由到另一个数据中心，或者可能是因为某个用户已移动到另一个位置，现在离另一个数据中心更近。在这种情况下，避免冲突就会失效，您必须处理在不同领导人身上并发写的可能性。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  
  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'Hw2fQnNQyghcgeRvQosC5cIy-gzGzoHsz',
        appKey: '0ULuPWcxGRLCaHz84icXvBgn',
        notify: 'false', 
        verify: 'false', 
        avatar:'mm', 
        placeholder: '说点什么吧...',
        visitor: 'true'
    });
  </script></div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#为什么需要-replication">为什么需要 Replication</a></li>
    <li><a href="#leaders-和-followers">Leaders 和 Followers</a></li>
    <li><a href="#同步和异步-replication">同步和异步 Replication</a></li>
    <li><a href="#配备新的-follower">配备新的 follower</a></li>
    <li><a href="#处理节点中断">处理节点中断</a>
      <ul>
        <li><a href="#follower-失败-赶快恢复">follower 失败: 赶快恢复</a></li>
        <li><a href="#leader-失败-故障转移">leader 失败: 故障转移</a></li>
      </ul>
    </li>
    <li><a href="#实现-replication-log">实现 replication log</a>
      <ul>
        <li><a href="#面向语句的-replication">面向语句的 replication</a></li>
        <li><a href="#逻辑基于行-的-log-replication">逻辑(基于行) 的 log replication</a></li>
        <li><a href="#基于触发的-replication">基于触发的 replication</a></li>
      </ul>
    </li>
    <li><a href="#复制延迟问题">复制延迟问题</a>
      <ul>
        <li><a href="#读取你自己写入的数据">读取你自己写入的数据</a></li>
        <li><a href="#单调读">单调读</a></li>
        <li><a href="#一致的前缀读取">一致的前缀读取</a></li>
        <li><a href="#复制滞后的解决方案">复制滞后的解决方案</a></li>
      </ul>
    </li>
    <li><a href="#多-leader-复制">多 Leader 复制</a>
      <ul>
        <li><a href="#多-leader-复制的案例">多 Leader 复制的案例</a></li>
        <li><a href="#处理写入冲突">处理写入冲突</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  

  <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279346965'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279346965%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</body>



</html>












