<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/programmer-interview/java/</link>
    <description>Recent content in Java on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://kunzhao.org/docs/programmer-interview/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>并发 - 多线程的实现方式</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/multi-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/multi-thread/</guid>
      <description>多线程的实现方式 Java多线程实现方式主要有四种：
 继承 Thread 类 实现 Runnable 接口 实现 Callable 接口 使用线程池  继承 Thread 类 class MyThread extends Thread { @Override public void run() { System.out.println(&amp;#34;MyThread.run()&amp;#34;); } } MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.start(); myThread2.start(); 实现 Runnable 接口 class MyTask implements Runnable { @Override public void run() { System.out.println(&amp;#34;MyTask running....&amp;#34;); } } new Thread(new MyTask()).start(); 实现 Callable 接口 Callable 接口可以在任务执行完之后获取结果：
public class MyCallable implements Callable&amp;lt;String&amp;gt; { @Override public String call() throws Exception { return String.</description>
    </item>
    
    <item>
      <title>并发 - synchronized</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/synchronized/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/synchronized/</guid>
      <description>synchronized 锁的对象是谁 当你使用 synchronized 关键字的时候，JVM 底层使用 Monitor 锁来实现同步。而锁的对象可以分为：
 如果 synchronized 的是普通方法，那么锁是当前实例 如果 synchronized 的是静态方法，那么锁是当前类的 Class 如果 synchronized 的是同步块，那么锁是括号里面的对象  synchronized 同步块 底层基于 monitorenter 和 monitorexit 这一对指令实现的。
public void foo(Object lock) { synchronized (lock) { lock.hashCode(); } } 上面的Java代码将编译为下面的字节码：
public void foo(java.lang.Object); Code: 0: aload_1 1: dup 2: astore_2 3: monitorenter 4: aload_1 5: invokevirtual java/lang/Object.hashCode:()I 8: pop 9: aload_2 10: monitorexit 11: goto 19 14: astore_3 15: aload_2 16: monitorexit 17: aload_3 18: athrow 19: return Exception table: from to target type 4 11 14 any 14 17 14 any synchronized 方法 方法标记为 ACC_SYNCHRONIZED，同样需要进行 monitorenter 操作。</description>
    </item>
    
    <item>
      <title>并发 - ThreadLocal</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/threadlocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/threadlocal/</guid>
      <description>ThreadLocal 作用 有一个比喻：
学生需要在签字墙签字，锁 相当于只有一个签字笔，学生们需要争抢这个签字笔；而 ThreadLocal 相当于给每个学生发了一个签字笔，每人一个，效率大大提升。
底层原理 假如你自己需要实现 ThreadLocal&amp;lt;T&amp;gt; 相关的 API，请问你会怎么做？
 你可能会使用 ConcurrentHashMap&amp;lt;Thread, T&amp;gt;，以 Thread.currentThread() 作为 key，这完全可以。但是缺点明显：1. 处理并发问题；2. 必须有指针指向 Thraed 和 这个对象，即使 Thraed 已经结束了，可以被 GC 了。 那我们改为  Collections.synchronizedMap(new WeakHashMap&amp;lt;Thread, T&amp;gt;()) 怎样？ 可以解决 GC 问题，但是多线程问题仍然没有解决。  Java 实现的想法，没有用 &amp;lt;Thread, T&amp;gt; ，而是大概如下：
new WeakHashMap&amp;lt;ThreadLocal,T&amp;gt;() 而事实上，在每个 Thread 内部也的确有这么一个 Map 指针：
public class Thread implements Runnable { ThreadLocal.ThreadLocalMap threadLocals = null; } 虽然 ThreadLocalMap 并不是一个 WeakHashMap，但是它的设计类似 WeakHashMap，它的 Key 是由 Weak Reference 引用的。</description>
    </item>
    
    <item>
      <title>并发 - 线程池</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/threadpool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/threadpool/</guid>
      <description>线程池 好处 说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。
设计哲学 将任务的提交与执行解耦开，从而无须太大的困难就能为某种类型的任务指定和修改执行策略。
用法 任务无须返回值，调用这个方法：
public void execute(Runnable command) {} 需要返回值的任务，调用 submit：
Future&amp;lt;Object&amp;gt; future = executor.submit(hasReturnValuetask); try { Object s = future.get(); } catch (InterruptedException e) { // ... } catch (ExecutionException e) { // ... } 构造器参数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { // ... } execute() 方法运行原理 （1） 如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务。部分代码片段如下：
if (workerCountOf(c) &amp;lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.</description>
    </item>
    
    <item>
      <title>基础 - finally</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/finally/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/finally/</guid>
      <description>finally 常见疑惑代码片段 （1）下面代码中的 finally 块会执行吗？
try { // do something  System.exit(1); } finally{ System.out.println(“Print from finally”); } 答案：不会。
（2）finally 会执行吗？
public static int test() { try { return 0; } finally { System.out.println(&amp;#34;finally trumps return.&amp;#34;); } } 答案：
finally trumps return. 0 （3）这个方法返回的值是 10 还是 12？
public static int getMonthsInYear() { try { return 10; } finally { return 12; } } 答案：12
（4）执行顺序
try{ int divideByZeroException = 5 / 0; } catch (Exception e){ System.</description>
    </item>
    
  </channel>
</rss>