<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/programmer-interview/java/</link>
    <description>Recent content in Java on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://kunzhao.org/docs/programmer-interview/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>并发 - 多线程的实现方式</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/multi-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/multi-thread/</guid>
      <description>多线程的实现方式 Java多线程实现方式主要有四种：
 继承 Thread 类 实现 Runnable 接口 实现 Callable 接口 使用线程池  继承 Thread 类 class MyThread extends Thread { @Override public void run() { System.out.println(&amp;#34;MyThread.run()&amp;#34;); } } MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.start(); myThread2.start(); 实现 Runnable 接口 class MyTask implements Runnable { @Override public void run() { System.out.println(&amp;#34;MyTask running....&amp;#34;); } } new Thread(new MyTask()).start(); 实现 Callable 接口 Callable 接口可以在任务执行完之后获取结果：
public class MyCallable implements Callable&amp;lt;String&amp;gt; { @Override public String call() throws Exception { return String.</description>
    </item>
    
    <item>
      <title>并发 - synchronized</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/synchronized/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/synchronized/</guid>
      <description>synchronized 锁的对象是谁 当你使用 synchronized 关键字的时候，JVM 底层使用 Monitor 锁来实现同步。而锁的对象可以分为：
 如果 synchronized 的是普通方法，那么锁是当前实例 如果 synchronized 的是静态方法，那么锁是当前类的 Class 如果 synchronized 的是同步块，那么锁是括号里面的对象  synchronized 同步块 底层基于 monitorenter 和 monitorexit 这一对指令实现的。
public void foo(Object lock) { synchronized (lock) { lock.hashCode(); } } 上面的Java代码将编译为下面的字节码：
public void foo(java.lang.Object); Code: 0: aload_1 1: dup 2: astore_2 3: monitorenter 4: aload_1 5: invokevirtual java/lang/Object.hashCode:()I 8: pop 9: aload_2 10: monitorexit 11: goto 19 14: astore_3 15: aload_2 16: monitorexit 17: aload_3 18: athrow 19: return Exception table: from to target type 4 11 14 any 14 17 14 any synchronized 方法 方法标记为 ACC_SYNCHRONIZED，同样需要进行 monitorenter 操作。</description>
    </item>
    
    <item>
      <title>并发 - ThreadLocal</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/threadlocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/threadlocal/</guid>
      <description>ThreadLocal 作用 有一个比喻：
学生需要在签字墙签字，锁 相当于只有一个签字笔，学生们需要争抢这个签字笔；而 ThreadLocal 相当于给每个学生发了一个签字笔，每人一个，效率大大提升。
底层原理 假如你自己需要实现 ThreadLocal&amp;lt;T&amp;gt; 相关的 API，请问你会怎么做？
 你可能会使用 ConcurrentHashMap&amp;lt;Thread, T&amp;gt;，以 Thread.currentThread() 作为 key，这完全可以。但是缺点明显：1. 处理并发问题；2. 必须有指针指向 Thraed 和 这个对象，即使 Thraed 已经结束了，可以被 GC 了。 那我们改为  Collections.synchronizedMap(new WeakHashMap&amp;lt;Thread, T&amp;gt;()) 怎样？ 可以解决 GC 问题，但是多线程问题仍然没有解决。  Java 实现的想法，没有用 &amp;lt;Thread, T&amp;gt; ，而是大概如下：
new WeakHashMap&amp;lt;ThreadLocal,T&amp;gt;() 而事实上，在每个 Thread 内部也的确有这么一个 Map 指针：
public class Thread implements Runnable { ThreadLocal.ThreadLocalMap threadLocals = null; } 虽然 ThreadLocalMap 并不是一个 WeakHashMap，但是它的设计类似 WeakHashMap，它的 Key 是由 Weak Reference 引用的。</description>
    </item>
    
    <item>
      <title>并发 - 线程池</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/threadpool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/threadpool/</guid>
      <description>线程池 好处 说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。
设计哲学 将任务的提交与执行解耦开，从而无须太大的困难就能为某种类型的任务指定和修改执行策略。
用法 任务无须返回值，调用这个方法：
public void execute(Runnable command) {} 需要返回值的任务，调用 submit：
Future&amp;lt;Object&amp;gt; future = executor.submit(hasReturnValuetask); try { Object s = future.get(); } catch (InterruptedException e) { // ... } catch (ExecutionException e) { // ... } 构造器参数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { // ... } execute() 方法运行原理 （1） 如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务。部分代码片段如下：
if (workerCountOf(c) &amp;lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.</description>
    </item>
    
    <item>
      <title>并发 - volatile</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/volatile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/volatile/</guid>
      <description>volatile 作用  在多处理器中，保证共享变量的 “可见性”（一个线程修改后，另外一个线程能立即读取到这个最新修改的值） 禁止对指令进行重排序  对比 synchronized  volatile 无法保证原子性 volatile 不会使线程陷入阻塞，不会引起线程上下文的切换和调度  典型用法 数绵羊程序：
volatile boolean sleep; while (!sleep) { countSleep(); } 底层原理 有 volatile 变量修饰的共享变量进行写操作的时候会多出一行以 lock;  指令开头的汇编代码。而 lock;  指令相当于一个内存屏障，其作用如下所示：
 将当前处理器缓存行的数据写回到系统内存。 这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。  </description>
    </item>
    
    <item>
      <title>ConcurrentHashMap 1.8</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/concurrenthashmap-18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/concurrenthashmap-18/</guid>
      <description>ConcurrentHashMap 1.8 计算 size() final long sumCount() { CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) { for (int i = 0; i &amp;lt; as.length; ++i) { if ((a = as[i]) != null) sum += a.value; } } return sum; } public int size() { long n = sumCount(); return ((n &amp;lt; 0L) ? 0 : (n &amp;gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n); } </description>
    </item>
    
    <item>
      <title>ArrayList</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/arraylist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/arraylist/</guid>
      <description>ArrayList add() public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; } 放满了会发生什么 </description>
    </item>
    
    <item>
      <title>基础 - finally</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/finally/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/finally/</guid>
      <description>finally 常见疑惑代码片段 （1）下面代码中的 finally 块会执行吗？
try { // do something  System.exit(1); } finally{ System.out.println(“Print from finally”); } 答案：不会。
（2）finally 会执行吗？
public static int test() { try { return 0; } finally { System.out.println(&amp;#34;finally trumps return.&amp;#34;); } } 答案：
finally trumps return. 0 （3）这个方法返回的值是 10 还是 12？
public static int getMonthsInYear() { try { return 10; } finally { return 12; } } 答案：12
（4）执行顺序
try{ int divideByZeroException = 5 / 0; } catch (Exception e){ System.</description>
    </item>
    
    <item>
      <title>Kafka 高吞吐量怎么实现的</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/kafka-high-throughput/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/kafka-high-throughput/</guid>
      <description>Kafka 高吞吐量怎么实现的 顺序读写 Producer 发送的消息顺序追加到文件中，Consumer 从 Broker 自带偏移量读取消息。这两者可以充分利用磁盘的顺序写和顺序读性能，速度远快于随机读写。
   零拷贝 mmap 持久化文件 Broker 写入数据，并非真正的 flush 到磁盘上了，而是写入到 mmap 中。
sendfile 读取 Customer 从 Broker 读取数据，采用 sendfile，将磁盘文件读到 OS 内核缓冲区后，直接转到 socket buffer 进行网络发送。
分区 Kafka 将消息分成多个 partition，增加了并行处理的能力。
批量发送 Producer 发送多个消息到同一分区，通过批量发送可以减少系统性能开销。
 batch.size：默认积压到 16K 就会批量发送 linger.ms：设置一定延迟来收集更多消息。默认 0ms ，即有消息就立马发送。  上述两个条件有任一条件满足，就会触发批量发送。
数据压缩 Kafka 支持三种压缩算法：
 gzip snappy lz4  /*compressType有四种取值:none lz4 gzip snappy*/ props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, compressType); 参考  Kafka为什么吞吐量大、速度快？  </description>
    </item>
    
    <item>
      <title>为什么阿里要自研 RocketMQ ?</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/why-develop-rocketmq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/why-develop-rocketmq/</guid>
      <description>为什么阿里要自研 RocketMQ ? 为什么要重写一个类似于 Kafka 的消息队列，而非基于 Kafka 作二次开发？
初衷 Kafka is a distributed streaming platform, which was born from logging aggregation cases. 它并不需要太高的并发. In some large scale cases in alibaba, we found that the original model 无法满足我们的实际需求.
无法支持更多分区  Each partition stores the whole message data. 尽管单个分区是顺序写的, 随着越来越多的针对不同分区的写入, 在操作系统层面已经变为随机写了. Due to the scattered data files, it is difficult to use the Linux IO Group Commit mechanism.  RocketMQ 支持更多分区  所有消息数据都存储在 Commit Log 文件中。所有写入都是完全顺序的，而读取是随机的。对磁盘的访问是完全顺序的，这避免了磁盘锁争用，并且在创建大量队列时不会导致高磁盘 IO 等待。 ConsumeQueue 存储实际的用户消费位置信息，这些信息也以顺序方式刷新到磁盘。  参考  How to Support More Queues in RocketMQ?</description>
    </item>
    
    <item>
      <title>Sentinel 与 Hystrix 的对比</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/sentinel-vs-hystrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/sentinel-vs-hystrix/</guid>
      <description>Sentinel 与 Hystrix 的对比 对比     Sentinel Hystrix     隔离策略 信号量隔离 线程池隔离/信号量隔离   熔断降级策略 基于响应时间或失败比率 基于失败比率   实时指标实现 滑动窗口 滑动窗口（基于 RxJava）   规则配置 支持多种数据源 支持多种数据源   扩展性 多个扩展点 插件的形式   基于注解的支持 支持 支持   限流 基于 QPS，支持基于调用关系的限流 有限的支持   流量整形 支持慢启动、匀速器模式 不支持   系统负载保护 支持 不支持   控制台 开箱即用，可配置规则、查看秒级监控、机器发现等 不完善   常见框架的适配 Servlet、Spring Cloud、Dubbo、gRPC 等 Servlet、Spring Cloud Netflix    参考  Sentinel 与 Hystrix 的对比  </description>
    </item>
    
  </channel>
</rss>