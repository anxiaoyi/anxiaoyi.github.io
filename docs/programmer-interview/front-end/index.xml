<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/programmer-interview/front-end/</link>
    <description>Recent content in 前端 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://kunzhao.org/docs/programmer-interview/front-end/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>CSS 垂直居中</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-center/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-center/</guid>
      <description>CSS 垂直居中 有固定的高度和宽度 主要是依靠 absolute 属性置于距离左上角 50% 的位置，然后再利用 margin 调整位置。
.parent { position: relative; } .child { width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px; } 效果如下  假如不添加 margin   无固定的高度和宽度 使用 transform 属性：
.parent { position: relative; } .child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 使用 flexbox 布局 .container { display: flex; justify-content: center; align-items: center; } </description>
    </item>
    
    <item>
      <title>移动端响应式布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/mobile-responsive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/mobile-responsive/</guid>
      <description>移动端响应式布局 1px 的坑  1px 的坑：CSS 中的 1px 并不是固定的大小，它是一个跟设备大小有关系的单位。PC 端的 5px 单位看到的视觉效果并不等同于移动端看到的 5px 的效果。
 1 CSS 像素与屏幕物理像素的换算公式：
1 CSS 像素 = 物理像素 / 分辨率 rem rem 是一种相对于根字体大小的相对单位。根字体就是 &amp;lt;html&amp;gt; 元素的字体，改变了 &amp;lt;html&amp;gt; 字体的大小，那么整个页面上基于 rem 的大小都会改变。一般初始值是 16px。
这种方案需要监听屏幕窗口大小的变化，然后动态地改变 &amp;lt;html&amp;gt; 的 font-size，这个 font-size 一变化，整个页面的其他元素的大小也会跟着变化，从而达到适配的效果。
function refreshRem() { var docEl = doc.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + &amp;#39;px&amp;#39;; flexible.rem = win.rem = rem; } win.addEventListener(&amp;#39;resize&amp;#39;, refreshRem); 有了这个函数，再使用 CSS 预编译插件 px2rem 将 CSS 中定义的 px 转为 rem 单位即可。</description>
    </item>
    
    <item>
      <title>position 属性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/position/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/position/</guid>
      <description>position 属性 作用：决定一个元素放在页面的哪个位置。
static 这是默认值。含义：不要以任何特殊的方式摆放这个元素的位置。
relative 这个属性同 static 的表现一致。如果你加了其它的属性比如 top、right、bottom、left 属性，那么就会导致它相应的偏离自己原来的默认位置。
fixed 让元素相对于浏览器的窗口摆放位置。这个元素不会随着页面的滚动而滚动。
absolute 让元素相对于离自己最近的 position 属性的值是非 static 的祖先元素摆放位置。如果实在找不到 position 属性是非 static 的祖先，那么就会相对于 body 元素摆放位置，随着页面的滚动而滚动。
sticky sticky 是粘性定位 (动态定位)。它依据滚动的位置动态地在 fixed 定位和 relative 定位之间切换。
参考  CSS position explained  </description>
    </item>
    
    <item>
      <title>CSS 盒模型</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/box-sizing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/box-sizing/</guid>
      <description>CSS 盒模型 作用 决定一个元素占据多大的矩形面积。
W3C 盒模型 （标准模型） .myClass { box-sizing: content-box; }  box-sizing 属性的默认值是：content-box
 IE 盒模型 .myClass { box-sizing: border-box; } W3C VS IE 对比 </description>
    </item>
    
    <item>
      <title>BFC 和 IFC</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/bfc_ifc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/bfc_ifc/</guid>
      <description>BFC 和 IFC BFC - Block formatting context 简介 BFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context 提供了一个环境，HTML 元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。
何时触发 BFC  &amp;lt;html&amp;gt; float 属性不为 none position 属性是 absolute 或 fixed overflow 属性不为 visible display 属性为 inline-block display 属性为 table-cell、table-caption、table、table-row 等表格元素 display 属性为 flow-root display 属性为 flex、inline-flex display 属性为 grid、inline-grid column-count 或 column-width 属性不为 auto 的 column-span 属性为 all  BFC 作用 消除外边距重叠 发生外边距重叠 &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;margin-bottom: 100px&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;margin-top: 100px&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;   分别放在不同的 BFC 容器中 &amp;lt;div style=&amp;#34;overflow: hidden;&amp;#34;&amp;gt; &amp;lt;p style=&amp;#34;margin-bottom: 100px;&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;overflow: hidden;&amp;#34;&amp;gt; &amp;lt;p style=&amp;#34;margin-top: 100px;&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;    包含浮动的元素 包含 float 孩子，容器高度变窄 &amp;lt;div style=&amp;#34;border: 1px solid #000;&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;width: 100px; height: 100px; float: left;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;   触发容器的 BFC，正常计算高度 &amp;lt;div style=&amp;#34;border: 1px solid #000; overflow: hidden&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;width: 100px; height: 100px; float: left;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;    阻止元素被浮动元素覆盖 div B 被 float div A 覆盖 &amp;lt;div class=&amp;#34;A&amp;#34; style=&amp;#34;float: left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;B&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;   触发容器的 BFC &amp;lt;div class=&amp;#34;A&amp;#34; style=&amp;#34;float: left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;B&amp;#34; style=&amp;#34;overflow: hidden&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;    IFC - Inline formatting context 什么时候触发 IFC 当一个 block 容器只包含 inline 元素的时候就会触发 IFC</description>
    </item>
    
    <item>
      <title>左固定右自适应</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/layout-left-fix-right-responsive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/layout-left-fix-right-responsive/</guid>
      <description>两列布局：左固定，右自适应 &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p&amp;gt;这是左边的盒子&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt; &amp;lt;p&amp;gt;这是右边的盒子&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 双 float .container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } .left, .right { box-sizing: border-box; float: left; } .right { width: calc(100% - 120px); } float + margin-left .container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } .left { box-sizing: border-box; float: left; } .right { margin-left: 120px; } absolute + margin-left .left { box-sizing: border-box; position: absolute; } .</description>
    </item>
    
    <item>
      <title>flex 布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/flex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/flex/</guid>
      <description>flex 布局 flex 容器 开启 flex 容器 .myClass { /** inline-flex 也可以开启 */ display: flex; } flex-direction flex-direction 定义了 main axis，其决定容器内的元素是横向布局还是纵向布局，其可选值如下：
 row (默认) row-reverse column column-reverse  flex-wrap flex-wrap 指定容器内的元素如何换行，默认情况下是挤在一行。其可选值如下：
 nowrap (默认) wrap：from top to bottom wrap-reverse：from bottom to top  flex-flow flex-flow 是 flex-direction 和 flex-wrap 这两个属性的缩写，能够同时定义这两个属性。
.myClass { flex-flow: flex-direction flex-wrap; }  flex-flow 的默认值：row nowrap
 justify-content 在 main axis 轴上如何利用剩余空间：
align-items 在 cross axis 轴上如何利用空间：</description>
    </item>
    
    <item>
      <title>CSS 九宫格</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-jiugongge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-jiugongge/</guid>
      <description>CSS 九宫格 公共 CSS 属性 .square{ position: relative; width: 100%; height: 0; padding-bottom: 100%; /* padding百分比是相对父元素宽度计算的 */ margin-bottom: 30px; } .square-inner{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; /* 铺满父元素容器，这时候宽高就始终相等了 */ } .square-inner&amp;gt;li{ width: calc(98% / 3); /* calc里面的运算符两边要空格 */ height: calc(98% / 3); margin-right: 1%; margin-bottom: 1%; overflow: hidden; } FlexBox HTML：
&amp;lt;div class=&amp;#34;square&amp;#34;&amp;gt; &amp;lt;ul class=&amp;#34;square-inner flex&amp;#34;&amp;gt; &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;6&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;7&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;8&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;9&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt;   CSS：</description>
    </item>
    
    <item>
      <title>清除浮动</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/clear-float/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/clear-float/</guid>
      <description>清除浮动 clear:both 给浮动元素后面的元素添加 clear: both 属性。
.element { clear: both; } 空 DIV &amp;lt;div style=&amp;#34;clear: both;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; overflow：触发 BFC 给浮动元素的容器添加 overflow:hidden; 或 overflow:auto; 可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。
:after 添加一个 :after 伪元素来清除浮动。
.clearfix:after { content: &amp;#34;.&amp;#34;; visibility: hidden; display: block; height: 0; clear: both; } 参考  All About Floats CSS - 清除浮动  </description>
    </item>
    
    <item>
      <title>CSS 画三角形</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-triangle/</guid>
      <description>CSS 画三角形 上三角形 #triangle-up { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; } 下三角形 #triangle-down { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } 左三角形 #triangle-left { width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; } 右三角形 #triangle-right { width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; } 左上朝向的直角三角形 #triangle-topleft { width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; } 右上朝向的直角三角形 #triangle-topright { width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; } 左下朝向的直角三角形 #triangle-bottomleft { width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; } 右下朝向的直角三角形 #triangle-bottomright { width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; } 参考  The Shape of CSS  </description>
    </item>
    
    <item>
      <title>HTML 语义化</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/html-semantic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/html-semantic/</guid>
      <description>HTML 语义化 作用 Web语义化是指使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。 简单来说就是利于 SEO，便于阅读维护理解。
常见语义化标签  i：专业术语 em：强调文本 strong：这个文本非常重要 section：文档中的一个区域、一节 article：文档、页面、网站中的独立结构 aside：附属信息 nav：页面的导航链接区域 footer：页脚 hgroup：文章的标题 header：页眉  dl、dt、dd &amp;lt;dl&amp;gt; 代表 description list，这个 list 封装了若干个 terms (&amp;lt;dt&amp;gt;) 以及 descriptions (&amp;lt;dd&amp;gt;) 信息。
&amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt;火狐浏览器&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 由 Mozilla 组织以及数百个志愿者一起开发的一款免费、开源、跨平台的 Web 浏览器。 &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt;Chrome 浏览器&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 谷歌浏览器，是一个由Google（谷歌）公司开发的开放源代码网页浏览器。 &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; </description>
    </item>
    
    <item>
      <title>HTML5 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/html5-new-feature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/html5-new-feature/</guid>
      <description>HTML5 新特性 新的 HTML5 语义 章节、轮廓等语义标签 &amp;lt;section&amp;gt;、&amp;lt;article&amp;gt;、&amp;lt;nav&amp;gt;、&amp;lt;header&amp;gt;、&amp;lt;footer&amp;gt;、&amp;lt;aside&amp;gt;
音频、视频 &amp;lt;audio&amp;gt;、&amp;lt;video&amp;gt;
input 校验 &amp;lt;input&amp;gt; 标签引入了新的属性：
 required：表单的这个字段不为空 minlength 和 maxlength：文本的长度要求 min 和 max：数值类型的大小值约束 type：是否是数值？邮件地址？或其它类型 pattern：输入的内容必须符合整个正则表达式  新的语义元素 &amp;lt;mark&amp;gt;、&amp;lt;figure&amp;gt;、&amp;lt;figcaption&amp;gt;、&amp;lt;data&amp;gt;、&amp;lt;time&amp;gt;、&amp;lt;output&amp;gt;、&amp;lt;progress&amp;gt;、&amp;lt;meter&amp;gt;、&amp;lt;main&amp;gt;
iframe 安全  sandbox 属性：附加更多限制 srcdoc 属性：内嵌的 HTML 内容  MathML 数学公式 使用 MathML 直接插入数学公式
数据传输 Web Sockets 浏览器和服务器建立一个长久连接，双方都可以发送信息给对方。
Server-sent events Server 推送 event 给客户端：
const evtSource = new EventSource(&amp;#39;ssedemo.php&amp;#39;) WebRTC RTC：Real-Time Communication
存储 IndexedDB 选择多个文件 &amp;lt;input type = &#39;file&#39;&amp;gt; 新增 multiple 属性，可选择多个文件。
多媒体 Camera API &amp;lt;input type=&amp;#34;file&amp;#34; id=&amp;#34;take-picture&amp;#34; accept=&amp;#34;image/*&amp;#34;&amp;gt; Graphics canvas 画布</description>
    </item>
    
    <item>
      <title>JavaScript 检测数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/js-detect-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/js-detect-array/</guid>
      <description>JavaScript 检测数组 Array.isArray Array.isArray(obj) 兼容旧版本：
if (typeof Array.isArray === &amp;#39;undefined&amp;#39;) { Array.isArray = function(obj) { return Object.prototype.toString.call(obj) === &amp;#39;[object Array]&amp;#39;; } } constructor function isArray(obj) { return !!obj &amp;amp;&amp;amp; obj.constructor === Array; } </description>
    </item>
    
    <item>
      <title>JavaScript 继承</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/js-extend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/js-extend/</guid>
      <description>JavaScript 继承 原型链 function Parent() {} function Child() {} Child.prototype = new Parent(); Child.prototype.constructor = Child; 构造器 function Parent() {} function Child() { Parent.call(this); } 原型链 + 构造器 function Parent() {} function Child() { Parent.call(this); } Child.prototype = new Parent(); 原型式 function extendObject(obj) { function F() {} F.prototype = obj; return new F(); } 其实上述代码就是 Object.create() 的兼容方法。
寄生组合 function inheritPrototype(child, parent) { var prototype = extendObject(parent.prototype); prototype.constructor = child; child.prototype = prototype; } function Child() { Parent.</description>
    </item>
    
    <item>
      <title>typeof</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/typeof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/typeof/</guid>
      <description>typeof 用法 typeof operand typeof(operand) typeof null &amp;gt; typeof null &amp;#34;object&amp;#34; 为什么 typeof null 是 object 根据 Why is typeof null “object”?，这是 JavaScript 实现上的一个 Bug，如果修正这个 Bug，会导致现有代码出现更多的 Bug。
JavaScript 底层的 object 的 type 是使用 0 来表示的，而 null 在多数平台上也是使用 0 来表示，所以 null 的 type 也是 0，因此返回 object。
null 是 object 吗 null 不是 object，它是 primitive value 。
typeof typeof null &amp;gt; typeof typeof null &amp;#34;string&amp;#34; typeof Array &amp;gt; typeof Array &amp;#34;function&amp;#34; typeof 5 &amp;gt; typeof 5 &amp;#34;number&amp;#34; typeof false &amp;#34;boolean&amp;#34; typeof undefined typeof undefined &amp;#34;undefined&amp;#34; 更多 </description>
    </item>
    
    <item>
      <title>new 关键字</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/new/</guid>
      <description>new 关键字 new 做了什么  创建一个对象 设置 __proto__ 属性 设置 this 指向这个对象 执行构造函数 返回对象  function New(func) { var res = {}; if (func.prototype !== null) { res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === &amp;#34;object&amp;#34; || typeof ret === &amp;#34;function&amp;#34;) &amp;amp;&amp;amp; ret !== null) { return ret; } return res; } 参考  What is the &amp;lsquo;new&amp;rsquo; keyword in JavaScript?  </description>
    </item>
    
    <item>
      <title>数据类型</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/data-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/data-types/</guid>
      <description>数据类型 8 种数据类型  Primitive values 原始类型: Boolean、Null、Undefined、Number、BigInt、String、Symbol Object：Object  null vs undefined undefined 指已经声明，但是未赋值：
let testVar; alert(testVar); // undefined null 是已经赋值的变量：
let tetVar = null; alert(testVar); // null </description>
    </item>
    
    <item>
      <title>instanceof</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/instanceof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/instanceof/</guid>
      <description>instanceof 作用 检测构造器函数的 prototype 是否位于某个对象的 __proto__ 原型链上。
原理 function instance_of(V, F) { var O = F.prototype; V = V.__proto__; while (true) { if (V === null) return false; if (O === V) return true; V = V.__proto__; } } 为什么下列 instanceof 返回 false console.log(true instanceof Boolean); // false console.log(0 instanceof Number); // false console.log(&amp;#34;&amp;#34; instanceof String); // false console.log(new Boolean(true) instanceof Boolean); // true console.log(new Number(0) instanceof Number); // true console.</description>
    </item>
    
    <item>
      <title>柯里化 - Currying</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/currying/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/currying/</guid>
      <description>柯里化 - Currying 作用 将 f(a, b, c) 调用形式转为 f(a)(b)(c) 调用形式，它对函数只做转换，不做执行。
实现 function curry(func) { return function curried(...args) { if (args.length &amp;gt;= func.length) { return func.apply(this, args); } else { return function(...args2) { return curried.apply(this, args.concat(args2)); } } }; } 优点  多参数复用性 函数式编程  参考  Currying  </description>
    </item>
    
    <item>
      <title>跨域</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/cors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/cors/</guid>
      <description>跨域 定义 跨域：指一个 domain 下的 HTML 或脚本试图去请求另一个 domain 下的资源。
同源策略 同源策略 （Same origin policy）：两个 URL 的协议、域名、端口相同。
同源限制访问资源  Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js 对象无法获得 AJAX 请求不能发送  JSONP &amp;lt;script&amp;gt; var script = document.createElement(&amp;#39;script&amp;#39;); script.type = &amp;#39;text/javascript&amp;#39;; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数  script.src = &amp;#39;http://www.domain2.com:8080/login?user=admin&amp;amp;callback=handleCallback&amp;#39;; document.head.appendChild(script); // 回调执行函数  function handleCallback(res) { alert(JSON.stringify(res)); } &amp;lt;/script&amp;gt; 后端返回的内容如下所示，即返回后立即执行 handleCallback：
handleCallback({&amp;#34;status&amp;#34;: true, &amp;#34;user&amp;#34;: &amp;#34;admin&amp;#34;})  JSONP 只能进行 GET 调用
 跨域资源共享 (CORS) 服务端设置 Access-Control-Allow-Origin:* 头即可，前端无须设置。如果想要进行 cookie 的读写，那么前端需要设置这个属性为 true：</description>
    </item>
    
    <item>
      <title>节流和防抖</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/throttle-and-debounce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/throttle-and-debounce/</guid>
      <description>节流和防抖 作用 解决页面卡顿等性能问题
节流函数 一定时间内，某个函数只执行一次。By using throttle function, we don&amp;rsquo;t allow to our function to execute more than once every X milliseconds.
function throttle (callback, limit) { var waiting = false; // 一开始，处于非等待状态  return function () { // 返回一个节流函数  if (!waiting) { // 如果没有等待  callback.apply(this, arguments); // 执行函数  waiting = true; // 等待置位 true  setTimeout(function () { // limit 时间之后  waiting = false; // 重新置位 false  }, limit); } } }  callback 函数：哪个函数需要节流？ limit：多长时间之后可以重新调用  也可以基于时间判断来实现：</description>
    </item>
    
    <item>
      <title>浏览器缓存</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/cache/</guid>
      <description>浏览器缓存 强缓存 HTTP 1.0 Expires Expires: Wed, 11 May 2018 07:20:00 GMT  缺点：时间是绝对时间，很难保证用户计算机时间和服务器时间一致
 HTTP 1.1 Cache-Control Cache-Control: max-age=315360000  优先级高于 Expires
 Cache-Control 取值如下：
 no-store：不缓存到本地 public：多用户共享 private：只能被终端浏览器缓存 no-cache：缓存到本地，但是使用这个缓存之前，必须与服务器进行新鲜度验证  （1）禁用缓存
Cache-Control: no-store （2）缓存静态资源
Cache-Control: public, max-age=604800, immutable （3）重新校验资源
Cache-Control: no-cache Cache-Control: no-cache, max-age=0 协商缓存 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP 状态为 304 并且会显示一个 Not Modified 的字符串。
那么浏览器如何询问服务器？
If-Modified-Since 浏览器请求服务器的时候带上这个头 If-Modified-Since，它的值是这个文件上一次服务器返回来的时候携带的 Last-Modified 的 HTTP 头的值。如果服务器有新的资源，那么会返回新的资源，否则响应 304。
If-None-Match If-Modified-Since 是根据文件的修改时间定的，而 If-None-Match 携带的值是这个文件的指纹，即上一次服务器返回这个文件携带的 ETag HTTP 头的值。浏览器将这个信息发送给服务器，可以更为精确地知道这个文件有没有变化。如果服务器有新的资源，返回新的，否则响应 304 状态码。</description>
    </item>
    
    <item>
      <title>事件循环</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/eventloop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/eventloop/</guid>
      <description>事件循环 Event Loop JS 是单线程的。在 JavaScript 引擎里，取 task 和执行 task 的代码封装在一个死循环里面，JavaScript 引擎等待 tasks 的出现，有则执行，无则 sleep。异步任务分为宏任务和微任务。
Macro Task 宏任务 宏任务示例：&amp;lt;script&amp;gt;、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI 渲染
Micro Task 微任务 微任务示例：process.nextTick、Promises、queueMicrotask、MutationObserver
 Micro is like macro but with higher priority.
 Event Loop 算法 while (true) { // 执行宏任务  let task = macroTaskQueue.getOldestTask(); execute(task); // 执行微任务  while (microTaskQueue.length &amp;gt; 0) { execute(microTaskQueue.getOldestTask()) } // 渲染  if (isRenderTime()) { render(); } } Node EventLoop vs 浏览器 EventLoop 参考  浏览器与Node的事件循环(Event Loop)有何区别?</description>
    </item>
    
    <item>
      <title>浏览器存储</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/storage/</guid>
      <description>浏览器存储 Web Storage  Web Storage 也叫 DOM Storage.
 浏览器提供了两种支持 Web Storage 的对象：
 window.localStorage：数据没有过期时间 window.sessionStorage：仅仅会话期间有效，关闭当前浏览器 Tab 页面的时候，数据消失  注意，这两个 Storage 对象存储的 value 只支持 String 类型，你存储其他类型，浏览器也会自动转为 String 类型存储进去。
sessionStorage.setItem(&amp;#39;key&amp;#39;, &amp;#39;value&amp;#39;) localStorage.setItem(&amp;#39;key&amp;#39;, &amp;#39;value&amp;#39;) 存储大小  Cookie 允许 4KB Opera 10.50+ 允许 5MB Safari 8 允许 5MB Firefox 34 允许 10MB Chrome 允许 10MB IE 允许 10MB  数据可见性 （1）LocalStorage
只有相同协议、相同 Host、相同端口，这三个都相同，才能算作是同一个 Origin。 只要两个页面处于同一 Origin ，那么存储在这一 Origin 的 LocalStorage 数据便可以自由访问。
（2）SessionStorage</description>
    </item>
    
    <item>
      <title>VUE 生命周期</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/vue-lifecycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/vue-lifecycle/</guid>
      <description>VUE 生命周期 </description>
    </item>
    
    <item>
      <title>Vue.nextTick</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/nexttick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/nexttick/</guid>
      <description>Vue.nextTick 作用 在 DOM 更新后，执行一个回调。
// DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) Vue 何时更新 DOM Vue 在修改数据后，DOM 不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行 DOM 更新。
应用场景 created/mounted 操作 DOM mounted: function () { this.$nextTick(function () { // Code that will run only after the  // entire view has been rendered  }) } 显示输入框并获取焦点 showInput() { this.show = true this.$nextTick(function () { // DOM 更新了  document.getElementById(&amp;#34;keywords&amp;#34;).focus() }) } </description>
    </item>
    
    <item>
      <title>VUE 面试题</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/vue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/vue/</guid>
      <description>VUE 面试题 整理 VUE 相关的常见面试题
介绍一下 VUE 介绍一下 VUEX VUE 2.X 和 3.0 的区别 （1）数据监听方式变化
VUE 2.X 使用 ES5 的 Object.defineProperty() 的 get() 和 set(newValue) 实现，VUE 3.0 基于 Proxy 监听实现，同时更为强大：
 可以检测属性的新增和删除 可以检测数组索引的变化和 length 的变化 支持 Map、Set、WeakMap 和 WeakSet   优点：速度加倍，内存占用减半。
 （2）体积更小
支持 Tree Shaking，内置组件、内置指令按需引入。
（3）速度更快
参考：vue3.0和vue2.x的区别、Vue 3.0 和 Vue 2.0的对比以及Vue 2.0精讲以及Vue全家桶精讲
VUE 的生命周期 VUE 数据双向绑定原理 VUE 采用发布者-订阅者模式的方式来实现双向绑定。
（1）视图更新数据：
input 标签监听 input 事件即可。
（2）数据更新视图：
Object.defineProperty() 监听数据变化，通过消息订阅器发布消息，订阅者收到消息执行相应的操纵 DOM 的函数，从而更新视图。</description>
    </item>
    
  </channel>
</rss>