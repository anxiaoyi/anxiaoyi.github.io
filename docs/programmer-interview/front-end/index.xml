<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/programmer-interview/front-end/</link>
    <description>Recent content in 前端 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://kunzhao.org/docs/programmer-interview/front-end/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CSS 垂直居中</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-center/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-center/</guid>
      <description>CSS 垂直居中 有固定的高度和宽度 主要是依靠 absolute 属性置于距离左上角 50% 的位置，然后再利用 margin 调整位置。
.parent { position: relative; } .child { width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px; } 效果如下 假如不添加 margin 无固定的高度和宽度 使用 transform 属性：
.parent { position: relative; } .child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 使用 flexbox 布局 .container { display: flex; justify-content: center; align-items: center; }  justify-content: center：水平居中 align-items: center：垂直居中  单行文本水平垂直居中 transform .</description>
    </item>
    
    <item>
      <title>移动端响应式布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/mobile-responsive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/mobile-responsive/</guid>
      <description>移动端响应式布局 1px 的坑  1px 的坑：CSS 中的 1px 并不是固定的大小，它是一个跟设备大小有关系的单位。PC 端的 5px 单位看到的视觉效果并不等同于移动端看到的 5px 的效果。
 1 CSS 像素与屏幕物理像素的换算公式：
1 CSS 像素 = 物理像素 / 分辨率rem rem 是一种相对于根字体大小的相对单位。根字体就是 &amp;lt;html&amp;gt; 元素的字体，改变了 &amp;lt;html&amp;gt; 字体的大小，那么整个页面上基于 rem 的大小都会改变。一般初始值是 16px。
这种方案需要监听屏幕窗口大小的变化，然后动态地改变 &amp;lt;html&amp;gt; 的 font-size，这个 font-size 一变化，整个页面的其他元素的大小也会跟着变化，从而达到适配的效果。
function refreshRem() { var docEl = doc.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + &amp;#39;px&amp;#39;; flexible.rem = win.rem = rem; } win.addEventListener(&amp;#39;resize&amp;#39;, refreshRem); 有了这个函数，再使用 CSS 预编译插件 px2rem 将 CSS 中定义的 px 转为 rem 单位即可。</description>
    </item>
    
    <item>
      <title>position 属性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/position/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/position/</guid>
      <description>position 属性 作用：决定一个元素放在页面的哪个位置。
static 这是默认值。含义：不要以任何特殊的方式摆放这个元素的位置。
relative 这个属性同 static 的表现一致。如果你加了其它的属性比如 top、right、bottom、left 属性，那么就会导致它相应的偏离自己原来的默认位置。
fixed 让元素相对于浏览器的窗口摆放位置。这个元素不会随着页面的滚动而滚动。
absolute 让元素相对于离自己最近的 position 属性的值是非 static 的祖先元素摆放位置。如果实在找不到 position 属性是非 static 的祖先，那么就会相对于 body 元素摆放位置，随着页面的滚动而滚动。
sticky sticky 是粘性定位 (动态定位)。它依据滚动的位置动态地在 fixed 定位和 relative 定位之间切换。
参考  CSS position explained  </description>
    </item>
    
    <item>
      <title>CSS 盒模型</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/box-sizing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/box-sizing/</guid>
      <description>CSS 盒模型 作用 决定一个元素占据多大的矩形面积。
W3C 盒模型 （标准模型） .myClass { box-sizing: content-box; }  box-sizing 属性的默认值是：content-box
 IE 盒模型 .myClass { box-sizing: border-box; } W3C VS IE 对比 </description>
    </item>
    
    <item>
      <title>BFC 和 IFC</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/bfc_ifc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/bfc_ifc/</guid>
      <description>BFC 和 IFC BFC - Block formatting context 简介 BFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context 提供了一个环境，HTML 元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。
何时触发 BFC  &amp;lt;html&amp;gt; float 属性不为 none position 属性是 absolute 或 fixed overflow 属性不为 visible display 属性为 inline-block display 属性为 table-cell、table-caption、table、table-row 等表格元素 display 属性为 flow-root display 属性为 flex、inline-flex display 属性为 grid、inline-grid column-count 或 column-width 属性不为 auto 的 column-span 属性为 all  BFC 作用 消除外边距重叠 发生外边距重叠 &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;margin-bottom: 100px&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;margin-top: 100px&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; 分别放在不同的 BFC 容器中 &amp;lt;div style=&amp;#34;overflow: hidden;&amp;#34;&amp;gt; &amp;lt;p style=&amp;#34;margin-bottom: 100px;&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;overflow: hidden;&amp;#34;&amp;gt; &amp;lt;p style=&amp;#34;margin-top: 100px;&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; 包含浮动的元素 包含 float 孩子，容器高度变窄 &amp;lt;div style=&amp;#34;border: 1px solid #000;&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;width: 100px; height: 100px; float: left;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 触发容器的 BFC，正常计算高度 &amp;lt;div style=&amp;#34;border: 1px solid #000; overflow: hidden&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;width: 100px; height: 100px; float: left;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 阻止元素被浮动元素覆盖 div B 被 float div A 覆盖 &amp;lt;div class=&amp;#34;A&amp;#34; style=&amp;#34;float: left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;B&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 触发容器的 BFC &amp;lt;div class=&amp;#34;A&amp;#34; style=&amp;#34;float: left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;B&amp;#34; style=&amp;#34;overflow: hidden&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; IFC - Inline formatting context 什么时候触发 IFC 当一个 block 容器只包含 inline 元素的时候就会触发 IFC</description>
    </item>
    
    <item>
      <title>左固定右自适应</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/layout-left-fix-right-responsive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/layout-left-fix-right-responsive/</guid>
      <description>两列布局：左固定，右自适应 &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p&amp;gt;这是左边的盒子&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt; &amp;lt;p&amp;gt;这是右边的盒子&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 双 float .container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } .left, .right { box-sizing: border-box; float: left; } .right { width: calc(100% - 120px); } float + margin-left .container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } .left { box-sizing: border-box; float: left; } .right { margin-left: 120px; } absolute + margin-left .left { box-sizing: border-box; position: absolute; } .</description>
    </item>
    
    <item>
      <title>flex 布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/flex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/flex/</guid>
      <description>flex 布局 flex 容器 开启 flex 容器 .myClass { /** inline-flex 也可以开启 */ display: flex; } flex-direction flex-direction 定义了 main axis，其决定容器内的元素是横向布局还是纵向布局，其可选值如下：
 row (默认) row-reverse column column-reverse  flex-wrap flex-wrap 指定容器内的元素如何换行，默认情况下是挤在一行。其可选值如下：
 nowrap (默认) wrap：from top to bottom wrap-reverse：from bottom to top  flex-flow flex-flow 是 flex-direction 和 flex-wrap 这两个属性的缩写，能够同时定义这两个属性。
.myClass { flex-flow: flex-direction flex-wrap; }  flex-flow 的默认值：row nowrap
 justify-content 在 main axis 轴上如何利用剩余空间：
align-items 在 cross axis 轴上如何利用空间：</description>
    </item>
    
    <item>
      <title>CSS 九宫格</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-jiugongge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-jiugongge/</guid>
      <description>CSS 九宫格 公共 CSS 属性 .square{ position: relative; width: 100%; height: 0; padding-bottom: 100%; /* padding百分比是相对父元素宽度计算的 */ margin-bottom: 30px; } .square-inner{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; /* 铺满父元素容器，这时候宽高就始终相等了 */ } .square-inner&amp;gt;li{ width: calc(98% / 3); /* calc里面的运算符两边要空格 */ height: calc(98% / 3); margin-right: 1%; margin-bottom: 1%; overflow: hidden; } FlexBox HTML：
&amp;lt;div class=&amp;#34;square&amp;#34;&amp;gt; &amp;lt;ul class=&amp;#34;square-inner flex&amp;#34;&amp;gt; &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;6&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;7&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;8&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;9&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; CSS：</description>
    </item>
    
    <item>
      <title>清除浮动</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/clear-float/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/clear-float/</guid>
      <description>清除浮动 clear:both 给浮动元素后面的元素添加 clear: both 属性。
.element { clear: both; } 空 DIV &amp;lt;div style=&amp;#34;clear: both;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; overflow：触发 BFC 给浮动元素的容器添加 overflow:hidden; 或 overflow:auto; 可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。
:after 添加一个 :after 伪元素来清除浮动。
.clearfix:after { content: &amp;#34;.&amp;#34;; visibility: hidden; display: block; height: 0; clear: both; } 参考  All About Floats CSS - 清除浮动  </description>
    </item>
    
    <item>
      <title>CSS 画三角形</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-triangle/</guid>
      <description>CSS 画三角形 上三角形 #triangle-up { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; } 下三角形 #triangle-down { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } 左三角形 #triangle-left { width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; } 右三角形 #triangle-right { width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; } 左上朝向的直角三角形 #triangle-topleft { width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; } 右上朝向的直角三角形 #triangle-topright { width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; } 左下朝向的直角三角形 #triangle-bottomleft { width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; } 右下朝向的直角三角形 #triangle-bottomright { width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; } 参考  The Shape of CSS  </description>
    </item>
    
    <item>
      <title>CSS 选择器</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-selector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-selector/</guid>
      <description>CSS 选择器 选择器类型    选择器 示例     ID #id   class .class   标签 p   通用 *   属性 [type=&amp;quot;text&amp;quot;]   伪类 :hover   伪元素 ::first-line   子选择器、相邻选择器     权重优先级 important &amp;gt; 内嵌样式 &amp;gt; ID &amp;gt; 类 &amp;gt; 标签 | 伪类 | 属性选择 &amp;gt; 伪元素 &amp;gt; 继承 &amp;gt; 通配符
权重赋值  内联样式如 style=XXX：1000 ID 选择器：100 类、伪类、属性选择器：10 标签、伪元素选择器：1 通配符、子选择器、相邻选择器等：0  比较规则：逐级比较。权重一样的 CSS 表达式，在样式表中后声明的优先。</description>
    </item>
    
    <item>
      <title>CSS 两边固定中间自适应布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/fixed-side-responsive-middle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/fixed-side-responsive-middle/</guid>
      <description>CSS 两边固定中间自适应布局 中间 float BFC 布局 &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;center&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;浮动布局&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; .container &amp;gt; div{ height: 200px; } .left { float: left; width: 300px; background: red; } .right { float: right; width: 300px; background: blue; } .center { overflow: hidden; background: yellow; }  缺点：中间浮动布局的内容最后才加载
 圣杯布局  父元素：需要内边距 三个孩子全部是：float: left 左右分别是相对布局  &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;center&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;圣杯布局&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; .container { padding: 0 300px; } .</description>
    </item>
    
    <item>
      <title>CSS3 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css3-new-feature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css3-new-feature/</guid>
      <description>CSS3 新特性 新特性概览    新特性 说明     新的选择器    阴影 Box 阴影、文本阴影   圆角    渐变    透明度    Transitions    Transformations 旋转、缩放、扭曲、平移等   动画    多列布局    Flexbox 构建 Flex 布局   Grids 构建二维布局   @font face 嵌入更多字体   @media 响应式设计    阴影：box-shadow 圆角：border-radius .</description>
    </item>
    
    <item>
      <title>ES6 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/es6-new-feature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/es6-new-feature/</guid>
      <description>ES6 新特性 var =&amp;gt; let/const var 是 function-scoped 的 var x = 3; function func(randomize) { if (randomize) { var x = Math.random(); // (A) scope: whole function  return x; } return x; // accesses the x from line A } func(false); // undefined let/const 是 block-scoped 的 let x = 3; function func(randomize) { if (randomize) { let x = Math.random(); return x; } return x; } func(false); // 3 IIFE =&amp;gt; block ES5 使用 IIFE 限制 tmp 作用域 (function () { // open IIFE  var tmp = ···; ··· }()); // close IIFE  console.</description>
    </item>
    
    <item>
      <title>display</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/display/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/display/</guid>
      <description>display 常设置的值 div { display: inline; display: inline-block; display: block; display: run-in; display: none; } Flexbox .header { display: flex; } Flow-Root  flow-root 创建了一个新的 BFC 。
 .group { display: flow-root; } Grid body { display: grid; } Table div { display: table; display: table-cell; display: table-column; display: table-colgroup; display: table-header-group; display: table-row-group; display: table-footer-group; display: table-row; display: table-caption; } </description>
    </item>
    
    <item>
      <title>ES2020 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/es2020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/es2020/</guid>
      <description>ES2020 新特性 BigInt JavaScript 最大数值 Number.MAX_SAFE_INTEGER，那么如何表达比这个数值更大的数字呢？
// 注意后缀有 n：表示 large number const bigNum = 10000000000000n; console.log(bigNum * 2n); 动态 import const doMath = async (num1, num2) =&amp;gt; { if (num1 &amp;amp;&amp;amp; num2) { const math = await import(&amp;#39;./math.js&amp;#39;) console.log(math.add(5, 10)) } } doMath(4, 2) Nullish Coalescing let person = { profile: { name: &amp;#34;&amp;#34;, age: 0 } }; // 默认值 console.log(person.profile.name || &amp;#34;Anonymous&amp;#34;) console.log(person.profile.age || 18) 现在可以不使用 ||，而用 ?? 来指定默认值了：</description>
    </item>
    
    <item>
      <title>创建对象</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/create-object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/create-object/</guid>
      <description>创建对象 new Object() var d = new Object(); Object.create() var a = Object.create(null); 内部原理 Object.create = function (proto, propertiesObject) { if (typeof proto !== &amp;#39;object&amp;#39; &amp;amp;&amp;amp; typeof proto !== &amp;#39;function&amp;#39;) { throw new TypeError(&amp;#39;Object prototype may only be an Object: &amp;#39; + proto); } else if (proto === null) { throw new Error(&amp;#34;This browser&amp;#39;s implementation of Object.create is a shim and doesn&amp;#39;t support &amp;#39;null&amp;#39; as the first argument.&amp;#34;); } if (typeof propertiesObject !</description>
    </item>
    
    <item>
      <title>Object.freeze()</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/object-freeze/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/object-freeze/</guid>
      <description>Object.freeze() 作用  可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。
 行为 Object.freeze() 是浅冻结，浅不可变。
var ob1 = { foo : 1, bar : { value : 2 } }; Object.freeze( ob1 ); const ob2 = { foo : 1, bar : { value : 2 } } ob1.foo = 4; // (frozen) ob1.foo not modified ob2.foo = 4; // (const) ob2.foo modified  ob1.bar.value = 4; // (frozen) modified, because ob1.bar is nested ob2.bar.value = 4; // (const) modified  ob1.</description>
    </item>
    
    <item>
      <title>Cookie 和 Session</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/cookie-session/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/cookie-session/</guid>
      <description>Cookie 和 Session Cookie 作用  登录、购物车、游戏分数 用户个性化信息、主题、其他设置 记录和分析用户行为  创建 Cookie 服务器在返回网页内容的时候，使用 Set-Cookie 头来创建 Cookie：
HTTP/2.0 200 OKContent-Type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content]Cookie 的有效期  Session：浏览器关闭当前 Tab 页就过期 Expires 和 Max-Age  Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Expires=&amp;lt;date&amp;gt;Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Max-Age=&amp;lt;non-zero-digit&amp;gt;Cookie 访问权限 Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2021 07:28:00 GMT; Secure; HttpOnly Secure：只有 HTTPS 协议的时候，浏览器端的 Cookie 才会上传到 Server HttpOnly：声明这个的 Cookie，使用 Document.cokie 无法读和写  JavaScript 读写 Cookie document.</description>
    </item>
    
    <item>
      <title>call、apply、bind</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/call-apply-bind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/call-apply-bind/</guid>
      <description>call、apply、bind call func.call([thisArg[, arg1, arg2, ...argN]]) 底层原理 /** * 每个函数都可以调用call方法，来改变当前这个函数执行的this关键字，并且支持传入参数 */ Function.prototype.myCall = function(context) { //第一个参数为调用call方法的函数中的this指向  var context = context || global; //将this赋给context的fn属性  context.fn = this;//此处this是指调用myCall的function  var arr = []; for (var i=0,len=arguments.length;i&amp;lt;len;i++) { arr.push(&amp;#34;arguments[&amp;#34; + i + &amp;#34;]&amp;#34;); } //执行这个函数，并返回结果  var result = eval(&amp;#34;context.fn(&amp;#34; + arr.toString() + &amp;#34;)&amp;#34;); //将this指向销毁  delete context.fn; return result; } apply func.apply(thisArg, [ argsArray]) 底层原理 /** * apply函数传入的是this指向和参数数组 */ Function.prototype.myApply = function(context, arr) { var context = context || global; context.</description>
    </item>
    
    <item>
      <title>画正方形</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-square/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-square/</guid>
      <description>画正方形 实现一个正方形，拖拽窗口，正方形等比例缩放
vw &amp;lt;div class=&amp;#34;square&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;This is a Square&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; .square { background: #000; width: 50vw; height: 50vw; } .square h1 { color: #fff; } padding-bottom &amp;lt;div style=&amp;#34;height:0;width:20%;padding-bottom:20%;background-color:red&amp;#34;&amp;gt; &amp;lt;div&amp;gt; Content goes here &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 参考  [How to style a div to be a responsive square?(https://stackoverflow.com/questions/19068070/how-to-style-a-div-to-be-a-responsive-square)  </description>
    </item>
    
    <item>
      <title>CSS 画圆</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-draw-circle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-draw-circle/</guid>
      <description>CSS 画圆 border-radius #circle { width: 200px; height: 200px; background: #f00; border-radius: 50%; } </description>
    </item>
    
    <item>
      <title>CSS 画扇形</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-sector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-sector/</guid>
      <description>CSS 画扇形 #cone { width: 0; height: 0; border-left: 70px solid transparent; border-right: 70px solid transparent; border-top: 100px solid red; border-radius: 50%; } </description>
    </item>
    
    <item>
      <title>三栏等宽布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/three-equal-layout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/three-equal-layout/</guid>
      <description>三栏等宽布局 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;111&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;222&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;333&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; float ul { width: 500px; background: #ccc; overflow: hidden; } li { list-style: none; width: 33.33%; float: left; background: red; } flex ul { width: 500px; background: #ccc; display: flex; } li { list-style: none; flex: 1; background: red; } </description>
    </item>
    
    <item>
      <title>CSS 画半圆</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-draw-half-circle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-draw-half-circle/</guid>
      <description>CSS 画半圆 $size: 45px; div { background: #9e978e; display: inline-block; margin: 0 1em 1em 0; } .top, .bottom { height: $size; width: $size * 2; } .right, .left { height: $size * 2; width: $size; } .top { border-top-left-radius: $size * 2; border-top-right-radius: $size * 2; } .right { border-bottom-right-radius: $size * 2; border-top-right-radius: $size * 2; } .bottom { border-bottom-left-radius: $size * 2; border-bottom-right-radius: $size * 2; } .left { border-bottom-left-radius: $size * 2; border-top-left-radius: $size * 2; } 效果：</description>
    </item>
    
    <item>
      <title>动画</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/animation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/animation/</guid>
      <description>动画 CSS animation .element { animation: pulse 5s infinite; } @keyframes pulse { 0% { background-color: #001F3F; } 100% { background-color: #FF4136; } } 在 @keyframes 中，0% 代表动画的开始，100% 代表动画的结束。animation 可用的子属性：
.element { animation-name: stretch; animation-duration: 1.5s; animation-timing-function: ease-out; animation-delay: 0s; animation-direction: alternate; animation-iteration-count: infinite; animation-fill-mode: none; animation-play-state: running; } CSS transition transition 控制的是从一种状态/阶段/样式，转变为另外一种状态/阶段/样式，animation 控制的是整个动画的每一帧。
.example { transition: [transition-property] [transition-duration] [transition-timing-function] [transition-delay]; } 鼠标悬浮在 div 的时候，转变 background 和 padding 的状态：
div { transition: all 0.</description>
    </item>
    
    <item>
      <title>CSS 单位</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-units/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-units/</guid>
      <description>CSS 单位 绝对单位    单位 描述     cm 厘米   mm 毫米   in 英寸   px 像素   pt points   pc picas (1pc = 12pt)    相对单位    单位 描述     em 相对于当前元素的 font-size，2em 意味着两倍 font-size 的大小   ex 相对于当前字体的 x-height   ch 相对于 &amp;lsquo;0&amp;rsquo; 的宽度   rem 相对于根元素的字体大小   vw 相当于 viewport 宽度的 1%   vh 相当于 viewport 高度的 1%   vmin 相当于 viewport 较短边的 1%   vmax 相当于 viewport 较长边的 1%   % 相对于父元素    参考  CSS Units  </description>
    </item>
    
    <item>
      <title>prototype、__proto__、[[prototype]]</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/prototype/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/prototype/</guid>
      <description>prototype、proto、[[prototype]] prototype 谁创建的 当你创建一个 Function object 的时候，一个名字为 prototype 的属性也会自动创建，并附着在 function object 上。
function Foo() { this.name = &amp;#34;Zhao Kun&amp;#34;; } Foo.hasOwnProperty(&amp;#39;prototype&amp;#39;); // true [[prototype]] 谁创建的 使用 new 关键字创建一个新的对象，那么这个对象本身会有一个内部的/私有的或指针指向 Foo 的 prototype：
function Foo() { this.name = &amp;#34;Zhao Kun&amp;#34;; } let b = new Foo(); b.[[Prototype]] === Foo.prototype // true proto 谁创建的 __proto__ 是 [[prototype]] 的 public 形式的指针：
let b = new Foo(); b.__proto___ === Foo.prototype // true 自 ECMAScript5 起，你有另外一种选择，可以拿到这个对象内部的私有的 [[prototype]] 的这个指针：</description>
    </item>
    
    <item>
      <title>HTML 语义化</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/html-semantic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/html-semantic/</guid>
      <description>HTML 语义化 作用 Web语义化是指使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。 简单来说就是利于 SEO，便于阅读维护理解。
常见语义化标签  i：专业术语 em：强调文本 strong：这个文本非常重要 section：文档中的一个区域、一节 article：文档、页面、网站中的独立结构 aside：附属信息 nav：页面的导航链接区域 footer：页脚 hgroup：文章的标题 header：页眉  dl、dt、dd &amp;lt;dl&amp;gt; 代表 description list，这个 list 封装了若干个 terms (&amp;lt;dt&amp;gt;) 以及 descriptions (&amp;lt;dd&amp;gt;) 信息。
&amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt;火狐浏览器&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 由 Mozilla 组织以及数百个志愿者一起开发的一款免费、开源、跨平台的 Web 浏览器。 &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt;Chrome 浏览器&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 谷歌浏览器，是一个由Google（谷歌）公司开发的开放源代码网页浏览器。 &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; </description>
    </item>
    
    <item>
      <title>HTML5 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/html5-new-feature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/html5-new-feature/</guid>
      <description>HTML5 新特性 新的 HTML5 语义 章节、轮廓等语义标签 &amp;lt;section&amp;gt;、&amp;lt;article&amp;gt;、&amp;lt;nav&amp;gt;、&amp;lt;header&amp;gt;、&amp;lt;footer&amp;gt;、&amp;lt;aside&amp;gt;
音频、视频 &amp;lt;audio&amp;gt;、&amp;lt;video&amp;gt;
input 校验 &amp;lt;input&amp;gt; 标签引入了新的属性：
 required：表单的这个字段不为空 minlength 和 maxlength：文本的长度要求 min 和 max：数值类型的大小值约束 type：是否是数值？邮件地址？或其它类型 pattern：输入的内容必须符合整个正则表达式  新的语义元素 &amp;lt;mark&amp;gt;、&amp;lt;figure&amp;gt;、&amp;lt;figcaption&amp;gt;、&amp;lt;data&amp;gt;、&amp;lt;time&amp;gt;、&amp;lt;output&amp;gt;、&amp;lt;progress&amp;gt;、&amp;lt;meter&amp;gt;、&amp;lt;main&amp;gt;
iframe 安全  sandbox 属性：附加更多限制 srcdoc 属性：内嵌的 HTML 内容  MathML 数学公式 使用 MathML 直接插入数学公式
数据传输 Web Sockets 浏览器和服务器建立一个长久连接，双方都可以发送信息给对方。
Server-sent events Server 推送 event 给客户端：
const evtSource = new EventSource(&amp;#39;ssedemo.php&amp;#39;) WebRTC RTC：Real-Time Communication
存储 IndexedDB 选择多个文件 &amp;lt;input type = &#39;file&#39;&amp;gt; 新增 multiple 属性，可选择多个文件。
多媒体 Camera API &amp;lt;input type=&amp;#34;file&amp;#34; id=&amp;#34;take-picture&amp;#34; accept=&amp;#34;image/*&amp;#34;&amp;gt; Graphics canvas 画布</description>
    </item>
    
    <item>
      <title>meta</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/meta/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/meta/</guid>
      <description>meta 作用 提供 Document 的元信息。
charset 属性 &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; content 属性 &amp;lt;head&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;Free Web tutorials&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;keywords&amp;#34; content=&amp;#34;HTML,CSS,XML,JavaScript&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; http-equiv &amp;lt;!-- Redirect page after 3 seconds --&amp;gt; &amp;lt;meta http-equiv=&amp;#34;refresh&amp;#34; content=&amp;#34;3;url=https://www.mozilla.org&amp;#34;&amp;gt; name &amp;lt;head&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;Free Web tutorials&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;keywords&amp;#34; content=&amp;#34;HTML,CSS,JavaScript&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;author&amp;#34; content=&amp;#34;John Doe&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; </description>
    </item>
    
    <item>
      <title>JavaScript 检测数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/js-detect-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/js-detect-array/</guid>
      <description>JavaScript 检测数组 Array.isArray Array.isArray(obj) 兼容旧版本：
if (typeof Array.isArray === &amp;#39;undefined&amp;#39;) { Array.isArray = function(obj) { return Object.prototype.toString.call(obj) === &amp;#39;[object Array]&amp;#39;; } } constructor function isArray(obj) { return !!obj &amp;amp;&amp;amp; obj.constructor === Array; } </description>
    </item>
    
    <item>
      <title>JavaScript 继承</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/js-extend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/js-extend/</guid>
      <description>JavaScript 继承 原型链 function Parent() {} function Child() {} Child.prototype = new Parent(); Child.prototype.constructor = Child; 构造器 function Parent() {} function Child() { Parent.call(this); } 原型链 + 构造器 function Parent() {} function Child() { Parent.call(this); } Child.prototype = new Parent(); 原型式 function extendObject(obj) { function F() {} F.prototype = obj; return new F(); } 其实上述代码就是 Object.create() 的兼容方法。
寄生组合 function inheritPrototype(child, parent) { var prototype = extendObject(parent.prototype); prototype.constructor = child; child.prototype = prototype; } function Child() { Parent.</description>
    </item>
    
    <item>
      <title>数组乱序</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/array-shuffle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/array-shuffle/</guid>
      <description>数组乱序 Fisher-Yates 乱序算法 /** * Shuffles array in place. * @param {Array} a items An array containing the items. */ function shuffle(a) { var j, x, i; for (i = a.length - 1; i &amp;gt; 0; i--) { j = Math.floor(Math.random() * (i + 1)); x = a[i]; a[i] = a[j]; a[j] = x; } return a; } ES6 /** * Shuffles array in place. ES6 version * @param {Array} a items An array containing the items.</description>
    </item>
    
    <item>
      <title>typeof</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/typeof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/typeof/</guid>
      <description>typeof 用法 typeof operand typeof(operand) typeof null &amp;gt; typeof null &amp;#34;object&amp;#34; 为什么 typeof null 是 object 根据 Why is typeof null “object”?，这是 JavaScript 实现上的一个 Bug，如果修正这个 Bug，会导致现有代码出现更多的 Bug。
JavaScript 底层的 object 的 type 是使用 0 来表示的，而 null 在多数平台上也是使用 0 来表示，所以 null 的 type 也是 0，因此返回 object。
null 是 object 吗 null 不是 object，它是 primitive value 。
typeof typeof null &amp;gt; typeof typeof null &amp;#34;string&amp;#34; typeof Array &amp;gt; typeof Array &amp;#34;function&amp;#34; typeof [1,2,3] &amp;gt; typeof [1,2,3] &amp;#34;object&amp;#34; typeof 5 &amp;gt; typeof 5 &amp;#34;number&amp;#34; typeof false &amp;#34;boolean&amp;#34; typeof undefined typeof undefined &amp;#34;undefined&amp;#34; typeof String(&amp;ldquo;asdfasdf&amp;rdquo;) typeof String(&amp;#34;asdfasdf&amp;#34;) &amp;#34;string&amp;#34; 更多 </description>
    </item>
    
    <item>
      <title>数组去重</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/array-unique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/array-unique/</guid>
      <description>数组去重 indexOf function onlyUnique(value, index, self) { return self.indexOf(value) === index; } filter var myArray = [&amp;#39;a&amp;#39;, 1, &amp;#39;a&amp;#39;, 2, &amp;#39;1&amp;#39;]; var unique = myArray.filter((v, i, a) =&amp;gt; a.indexOf(v) === i); Set function uniqueArray(a) { return [...new Set(a)]; } 参考  Get all unique values in a JavaScript array (remove duplicates)  </description>
    </item>
    
    <item>
      <title>数组扁平化</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/flattern-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/flattern-array/</guid>
      <description>数组扁平化 递归实现 const flatten = function(arr, result = []) { for (let i = 0, length = arr.length; i &amp;lt; length; i++) { const value = arr[i]; if (Array.isArray(value)) { flatten(value, result); } else { result.push(value); } } return result; }; ES2015 reduce function flatten(arr) { return arr.reduce(function (flat, toFlatten) { return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten); }, []); } 示例：
flatten([[1, 2, 3], [4, 5]]); // [1, 2, 3, 4, 5] flatten([[[1, [1.</description>
    </item>
    
    <item>
      <title>new 关键字</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/new/</guid>
      <description>new 关键字 new 做了什么  创建一个对象 设置 __proto__ 属性 设置 this 指向这个对象 执行构造函数 返回对象  function New(func) { var res = {}; if (func.prototype !== null) { res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === &amp;#34;object&amp;#34; || typeof ret === &amp;#34;function&amp;#34;) &amp;amp;&amp;amp; ret !== null) { return ret; } return res; } 参考  What is the &amp;lsquo;new&amp;rsquo; keyword in JavaScript?  </description>
    </item>
    
    <item>
      <title>数据类型</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/data-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/data-types/</guid>
      <description>数据类型 8 种数据类型  Primitive values 原始类型: Boolean、Null、Undefined、Number、BigInt、String、Symbol Object：Object  null vs undefined undefined 指已经声明，但是未赋值：
let testVar; alert(testVar); // undefined null 是已经赋值的变量：
let tetVar = null; alert(testVar); // null </description>
    </item>
    
    <item>
      <title>instanceof</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/instanceof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/instanceof/</guid>
      <description>instanceof 作用 检测构造器函数的 prototype 是否位于某个对象的 __proto__ 原型链上。
原理 function instance_of(V, F) { var O = F.prototype; V = V.__proto__; while (true) { if (V === null) return false; if (O === V) return true; V = V.__proto__; } } 为什么下列 instanceof 返回 false console.log(true instanceof Boolean); // false console.log(0 instanceof Number); // false console.log(&amp;#34;&amp;#34; instanceof String); // false console.log(new Boolean(true) instanceof Boolean); // true console.log(new Number(0) instanceof Number); // true console.</description>
    </item>
    
    <item>
      <title>let、var、const</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/let-vs-const-vs-var/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/let-vs-const-vs-var/</guid>
      <description>let、var、const var  var 作用域：在整个 function 内有效 在声明之前就可以引用  function run() { console.log(foo) // 声明之前就可以引用，值：undefined 	var foo = &amp;#34;Foo&amp;#34;; }  function 外定义会创建全局对象  var foo = &amp;#34;Foo&amp;#34;; console.log(window.foo) // Foo，附着在 window 对象  可以再次定义相同变量  &amp;#39;use strict&amp;#39; var foo = &amp;#34;foo1&amp;#34; var foo = &amp;#34;foo2&amp;#34; // foo 值替换为 foo2  闭包引用问题  // 打印 3 次 3 for (var i = 0; i &amp;lt; 3; i++) { setTimeout(() =&amp;gt; console.</description>
    </item>
    
    <item>
      <title>柯里化 - Currying</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/currying/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/currying/</guid>
      <description>柯里化 - Currying 作用 将 f(a, b, c) 调用形式转为 f(a)(b)(c) 调用形式，它对函数只做转换，不做执行。
实现 function curry(func) { return function curried(...args) { if (args.length &amp;gt;= func.length) { return func.apply(this, args); } else { return function(...args2) { return curried.apply(this, args.concat(args2)); } } }; } 优点  多参数复用性 函数式编程  参考  Currying  </description>
    </item>
    
    <item>
      <title>setTimeout</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/settimeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/settimeout/</guid>
      <description>setTimeout 用 setTimeout 实现 setInterval { const intervals = new Map(); function setInterval(fn, time, context, ...args) { // 随机生成一个 ID  const id = Math.floor(Math.random() * 10000); intervals.set(id, setTimeout(function next() { intervals.set(id, setTimeout(next, time)); fn.apply(context, args); }, time)); return id; } function clearInterval(id) { clearTimeout(intervals.get(id)); } } 如何使用：
const interval = setInterval(console.log, 100, console, &amp;#34;hi&amp;#34;); clearInterval(interval); requestAnimationFrame  作用：告诉浏览器在下一次 repaint 的时候，更新你的动画，也就是说这个是转为动画设计的 API requestAnimationFrame 的调用时机：浏览器的 repaint 阶段 使用 requestAnimationFrame，只有你的网站页面的 Tab 页处于 visible 的时候，浏览器才会去运行你的动画。更省 CPU、更省 GPU、更省内存、更节约电量。 动画至少 60帧/秒，看起来才更流畅：  setInterval(function() { // animiate something }, 1000/60); </description>
    </item>
    
    <item>
      <title>Strict Mode</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/strict-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/strict-mode/</guid>
      <description>Strict Mode 作用  Strict Mode is a new feature in ECMAScript 5 that allows you to place a program, or a function, in a &amp;ldquo;strict&amp;rdquo; operating context. 这种严格的上下文能够禁掉一些行为以及抛出更多地错误.
 为什么需要它  Strict mode makes it easier to write &amp;ldquo;secure&amp;rdquo; JavaScript.
 如何开启  文件顶部：  // File: myscript.js  &amp;#39;use strict&amp;#39;; var a = 2; ...  function 顶部：  function doSomething() { &amp;#39;use strict&amp;#39;; ... } 约束  禁止全局变量  &amp;#39;use strict&amp;#39;; // Assignment to a non-writable global var undefined = 5; // throws a TypeError var Infinity = 5; // throws a TypeError  delete 不可删除的属性，会抛出异常。例如尝试 delete Object.</description>
    </item>
    
    <item>
      <title>实现 sleep 函数</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/implement-sleep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/implement-sleep/</guid>
      <description>实现 sleep 函数 const sleep = (milliseconds) =&amp;gt; { return new Promise(resolve =&amp;gt; setTimeout(resolve, milliseconds)) } 如何使用：
sleep(500).then(() =&amp;gt; { //do stuff }) 在 async 函数中使用：
const doSomething = async () =&amp;gt; { await sleep(2000) //do stuff } doSomething() </description>
    </item>
    
    <item>
      <title>JS 深浅拷贝</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/js-copy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/js-copy/</guid>
      <description>JS 深浅拷贝 浅拷贝 ES6 Object assign var A1 = { a: &amp;#34;2&amp;#34; }; var A2 = Object.assign({}, A1); Object assign 的兼容写法 if (!Object.assign) { Object.defineProperty(Object, &amp;#39;assign&amp;#39;, { enumerable: false, configurable: true, writable: true, value: function(target) { &amp;#39;use strict&amp;#39;; if (target === undefined || target === null) { throw new TypeError(&amp;#39;Cannot convert first argument to object&amp;#39;); } var to = Object(target); for (var i = 1; i &amp;lt; arguments.length; i++) { var nextSource = arguments[i]; if (nextSource === undefined || nextSource === null) { continue; } nextSource = Object(nextSource); var keysArray = Object.</description>
    </item>
    
    <item>
      <title>实现 Promise.all</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/implement-promise-all/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/implement-promise-all/</guid>
      <description>实现 Promise.all 借助 async/await Promise.all = async (promises) =&amp;gt; { const results = []; for (p of promises) { results.push(await p); } return results; } 不借助 async/await Promise.all = (promises) =&amp;gt; { let resolved = 0; let results = []; return new Promise((resolve, reject) =&amp;gt; { for (let promise of promises) { promise .then((result) =&amp;gt; { results.push(result); if (++resolved === promises.length) resolve(results); }) .catch((e) =&amp;gt; { reject(e); }); } }) } 参考  How to Implement Promise.</description>
    </item>
    
    <item>
      <title>实现 retry</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/implement-retry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/implement-retry/</guid>
      <description>实现 retry 只要没有 resolve，就一直 retry
方法 const wait = ms =&amp;gt; new Promise(r =&amp;gt; setTimeout(r, ms)); const retryOperation = (operation, delay, times) =&amp;gt; new Promise((resolve, reject) =&amp;gt; { return operation() .then(resolve) .catch((reason) =&amp;gt; { if (times - 1 &amp;gt; 0) { return wait(delay) .then(retryOperation.bind(null, operation, delay, times - 1)) .then(resolve) .catch(reject); } return reject(reason); }); }); 如何使用：
如果没有 resolve 或 reject，那么就每隔 1 秒重试一次，最多重试 5 秒：
retryOperation(func, 1000, 5) .then(console.log) .catch(console.log); 参考  Promise Retry Design Patterns  </description>
    </item>
    
    <item>
      <title>跨域</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/cors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/cors/</guid>
      <description>跨域 定义 跨域：指一个 domain 下的 HTML 或脚本试图去请求另一个 domain 下的资源。
同源策略 同源策略 （Same origin policy）：两个 URL 的协议、域名、端口相同。
同源限制访问资源  Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js 对象无法获得 AJAX 请求不能发送  JSONP &amp;lt;script&amp;gt; var script = document.createElement(&amp;#39;script&amp;#39;); script.type = &amp;#39;text/javascript&amp;#39;; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数  script.src = &amp;#39;http://www.domain2.com:8080/login?user=admin&amp;amp;callback=handleCallback&amp;#39;; document.head.appendChild(script); // 回调执行函数  function handleCallback(res) { alert(JSON.stringify(res)); } &amp;lt;/script&amp;gt; 后端返回的内容如下所示，即返回后立即执行 handleCallback：
handleCallback({&amp;#34;status&amp;#34;: true, &amp;#34;user&amp;#34;: &amp;#34;admin&amp;#34;})  JSONP 只能进行 GET 调用
 跨域资源共享 (CORS) 服务端设置 Access-Control-Allow-Origin:* 头即可，前端无须设置。如果想要进行 cookie 的读写，那么前端需要设置这个属性为 true：</description>
    </item>
    
    <item>
      <title>节流和防抖</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/throttle-and-debounce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/throttle-and-debounce/</guid>
      <description>节流和防抖 作用 解决页面卡顿等性能问题
节流函数 一定时间内，某个函数只执行一次。By using throttle function, we don&amp;rsquo;t allow to our function to execute more than once every X milliseconds.
function throttle (callback, limit) { var waiting = false; // 一开始，处于非等待状态  return function () { // 返回一个节流函数  if (!waiting) { // 如果没有等待  callback.apply(this, arguments); // 执行函数  waiting = true; // 等待置位 true  setTimeout(function () { // limit 时间之后  waiting = false; // 重新置位 false  }, limit); } } }  callback 函数：哪个函数需要节流？ limit：多长时间之后可以重新调用  也可以基于时间判断来实现：</description>
    </item>
    
    <item>
      <title>浏览器缓存</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/cache/</guid>
      <description>浏览器缓存 强缓存 HTTP 1.0 Expires Expires: Wed, 11 May 2018 07:20:00 GMT 缺点：时间是绝对时间，很难保证用户计算机时间和服务器时间一致
 HTTP 1.1 Cache-Control Cache-Control: max-age=315360000 优先级高于 Expires
 Cache-Control 取值如下：
 no-store：不缓存到本地 public：多用户共享 private：只能被终端浏览器缓存 no-cache：缓存到本地，但是使用这个缓存之前，必须与服务器进行新鲜度验证  （1）禁用缓存
Cache-Control: no-store（2）缓存静态资源
Cache-Control: public, max-age=604800, immutable（3）重新校验资源
Cache-Control: no-cacheCache-Control: no-cache, max-age=0协商缓存 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP 状态为 304 并且会显示一个 Not Modified 的字符串。
那么浏览器如何询问服务器？
If-Modified-Since 浏览器请求服务器的时候带上这个头 If-Modified-Since，它的值是这个文件上一次服务器返回来的时候携带的 Last-Modified 的 HTTP 头的值。如果服务器有新的资源，那么会返回新的资源，否则响应 304。
If-None-Match If-Modified-Since 是根据文件的修改时间定的，而 If-None-Match 携带的值是这个文件的指纹，即上一次服务器返回这个文件携带的 ETag HTTP 头的值。浏览器将这个信息发送给服务器，可以更为精确地知道这个文件有没有变化。如果服务器有新的资源，返回新的，否则响应 304 状态码。</description>
    </item>
    
    <item>
      <title>事件循环</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/eventloop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/eventloop/</guid>
      <description>事件循环 Event Loop JS 是单线程的。在 JavaScript 引擎里，取 task 和执行 task 的代码封装在一个死循环里面，JavaScript 引擎等待 tasks 的出现，有则执行，无则 sleep。异步任务分为宏任务和微任务。
Macro Task 宏任务 宏任务示例：&amp;lt;script&amp;gt;、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI 渲染
Micro Task 微任务 微任务示例：process.nextTick、Promises、queueMicrotask、MutationObserver
 Micro is like macro but with higher priority.
 Event Loop 算法 while (true) { // 执行宏任务  let task = macroTaskQueue.getOldestTask(); execute(task); // 执行微任务  while (microTaskQueue.length &amp;gt; 0) { execute(microTaskQueue.getOldestTask()) } // 渲染  if (isRenderTime()) { render(); } } Node EventLoop vs 浏览器 EventLoop  microtask 的执行时机不同。</description>
    </item>
    
    <item>
      <title>浏览器存储</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/storage/</guid>
      <description>浏览器存储 Web Storage  Web Storage 也叫 DOM Storage.
 浏览器提供了两种支持 Web Storage 的对象：
 window.localStorage：数据没有过期时间 window.sessionStorage：仅仅会话期间有效，关闭当前浏览器 Tab 页面的时候，数据消失  注意，这两个 Storage 对象存储的 value 只支持 String 类型，你存储其他类型，浏览器也会自动转为 String 类型存储进去。
sessionStorage.setItem(&amp;#39;key&amp;#39;, &amp;#39;value&amp;#39;) localStorage.setItem(&amp;#39;key&amp;#39;, &amp;#39;value&amp;#39;) 存储大小  Cookie 允许 4KB Opera 10.50+ 允许 5MB Safari 8 允许 5MB Firefox 34 允许 10MB Chrome 允许 10MB IE 允许 10MB  数据可见性 （1）LocalStorage
只有相同协议、相同 Host、相同端口，这三个都相同，才能算作是同一个 Origin。 只要两个页面处于同一 Origin ，那么存储在这一 Origin 的 LocalStorage 数据便可以自由访问。
（2）SessionStorage</description>
    </item>
    
    <item>
      <title>DOM 操作 API</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/dom-operate-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/dom-operate-api/</guid>
      <description>JavaScript 常见原生 DOM 操作 API 总结 节点查找 API    方法 示例 描述     querySelector var el = document.querySelector(&amp;quot;.myclass&amp;quot;); 返回第一个匹配 selector 的元素   querySelectorAll var matches = document.querySelectorAll(&amp;quot;p&amp;quot;); 返回一个匹配的 NodeList 数组   getElementById var elem = document.getElementById(&#39;para&#39;); 返回匹配 ID 的 Element   getElementsByClassName document.getElementsByClassName(&#39;red test&#39;) 返回匹配 class 的一个 array-like 的元素数组   getElementsByTagName var allParas = document.getElementsByTagName(&#39;p&#39;); 返回指定 Tag 的 HTMLCollection   getElementsByName var up_names = document.</description>
    </item>
    
    <item>
      <title>Event</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/event/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/event/</guid>
      <description>Event target 和 currentTarget  target：哪个元素触发了事件？ currentTarget：哪个元素监听了这个事件  事件代理/委托 原因 添加的事件监听器数量，影响页面的整体运行性能，因为访问 DOM 的次数越多，引起浏览器的重绘和重排的次数也就越多。通过事件委托，可以减少添加的事件监听器数量，提高页面性能。
原理 利用事件冒泡。
示例 &amp;lt;ul id=&amp;#34;list&amp;#34;&amp;gt; &amp;lt;li id=&amp;#34;item1&amp;#34;&amp;gt;item1&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;#34;item2&amp;#34;&amp;gt;item2&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;#34;item3&amp;#34;&amp;gt;item3&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;#34;item4&amp;#34;&amp;gt;item4&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 目的：点击 li 然后弹出这个 li 的内容：
window.onload=function(){ var ulNode=document.getElementById(&amp;#34;list&amp;#34;); ulNode.addEventListener(&amp;#39;click&amp;#39;,function(e){ if(e.target &amp;amp;&amp;amp; e.target.nodeName.toUpperCase() == &amp;#34;LI&amp;#34;){/*判断目标事件是否为li*/ alert(e.target.innerHTML); } },false); }; </description>
    </item>
    
    <item>
      <title>冒泡捕获</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/event-bubble-capture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/event-bubble-capture/</guid>
      <description>冒泡捕获 冒泡 &amp;lt;style&amp;gt; body * { margin: 10px; border: 1px solid blue; } &amp;lt;/style&amp;gt; &amp;lt;form onclick=&amp;#34;alert(&amp;#39;form&amp;#39;)&amp;#34;&amp;gt;FORM &amp;lt;div onclick=&amp;#34;alert(&amp;#39;div&amp;#39;)&amp;#34;&amp;gt;DIV &amp;lt;p onclick=&amp;#34;alert(&amp;#39;p&amp;#39;)&amp;#34;&amp;gt;P&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/form&amp;gt;  冒泡：点击 p 元素，首先 alert p，其次 alert div，最后 alert form。从最内层的元素冒泡到最外层的元素。
 阻止冒泡 stopPropagation 阻止向父元素冒泡：
event.stopPropagation() 示例：
&amp;lt;body onclick=&amp;#34;alert(`the bubbling doesn&amp;#39;t reach here`)&amp;#34;&amp;gt; &amp;lt;button onclick=&amp;#34;event.stopPropagation()&amp;#34;&amp;gt;Click me&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; 阻止冒泡 stopImmediatePropagation 阻止向父元素冒泡，并且当前元素绑定的其它事件也不会执行：
event.stopImmediatePropagation() 举例：
$(&amp;#39;p&amp;#39;).click(event =&amp;gt; event.stopImmediatePropagation()) $(&amp;#39;p&amp;#39;).click(event =&amp;gt; console.log(&amp;#39;这个事件不会执行&amp;#39;)) 但是如果你调整一下顺序，这个事件就会执行了：
$(&amp;#39;p&amp;#39;).click(event =&amp;gt; console.log(&amp;#39;这个事件会执行&amp;#39;)) $(&amp;#39;p&amp;#39;).click(event =&amp;gt; event.stopImmediatePropagation()) 捕获 事件传播的三个阶段 DOM Events 描述了事件传播的三个阶段：</description>
    </item>
    
    <item>
      <title>重绘和重排</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/repaint-reflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/repaint-reflow/</guid>
      <description>重绘和重排 网页渲染  &amp;ldquo;生成布局&amp;rdquo;（flow）和&amp;quot;绘制&amp;quot;（paint）这两步，合称为&amp;quot;渲染&amp;quot;（render）。
 重绘 repint 重绘：某种操作改变了某个元素的外观，但并未改变这个元素的布局，从而需要重新绘制。例如对 outline、visibility、background、color 的改变。重绘不一定会引起重排。
重排/回流 reflow 重排/回流：某种操作改变了某个元素、网页的一部分或整个网页的布局，其对于性能的影响更为严重。重排必会导致重绘。
重排触发机制 重排发生的根本原理就是元素的几何属性发生了改变，那么我们就从能够改变元素几何属性的角度入手
 添加或删除可见的 DOM 元素 元素位置改变 元素本身的尺寸发生改变 内容改变 页面渲染器初始化 浏览器窗口大小发生改变  如何优化 浏览器自身优化 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。
主要包括以下属性或方法：
offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightwidth、heightgetComputedStyle()getBoundingClientRect()所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。
合并读操作/写操作 不要这样：
// bad div.style.left = div.offsetLeft + 10 + &amp;#34;px&amp;#34;; div.style.top = div.offsetTop + 10 + &amp;#34;px&amp;#34;; 读写分离合并：
// good var left = div.offsetLeft; var top = div.offsetTop; div.style.left = left + 10 + &amp;#34;px&amp;#34;; div.</description>
    </item>
    
    <item>
      <title>浏览器如何渲染页面 ?</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/how-browser-render-html/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/how-browser-render-html/</guid>
      <description>浏览器如何渲染页面 ? 渲染主流程 Webkit 渲染流程 Mozilla 的 Gecko 渲染流程 构建 DOM 树 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1&amp;#34;&amp;gt; &amp;lt;link href=&amp;#34;style.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Critical Path&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;Hello &amp;lt;span&amp;gt;web performance&amp;lt;/span&amp;gt; students!&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;img src=&amp;#34;awesome-photo.jpg&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 对于上述 HTML 片段，浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符，然后分析出各个 HTML 标签、各个标签对应的属性等。最后，根据标签之间的关系，构建 DOM 树。
构建 CSSOM 树 在浏览器构建我们这个简单页面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：
body { font-size: 16px } p { font-weight: bold } span { color: red } p span { display: none } img { float: right } 与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML：</description>
    </item>
    
    <item>
      <title>Web 安全</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/web_security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/web_security/</guid>
      <description>Web 安全 点击劫持 点击劫持 (Clickjacking) 技术又称为界面伪装攻击 (UI redress attack )，是一种视觉上的欺骗手段。攻击者使用一个或多个透明的 iframe 覆盖在一个正常的网页上，然后诱使用户在该网页上进行操作，当用户在不知情的情况下点击透明的 iframe 页面时，用户的操作已经被劫持到攻击者事先设计好的恶意按钮或链接上。攻击者既可以通过点击劫持设计一个独立的恶意网站，执行钓鱼攻击等；也可以与 XSS 和 CSRF 攻击相结合，突破传统的防御措施，提升漏洞的危害程度。
Cross-site request forgery (CSRF) CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
一个典型的CSRF攻击有着如下的流程：
 受害者登录 a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了 b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。 a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com 以受害者的名义执行了 act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。  CSRF 的特点  攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。  CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。
防护策略 （1）同源检测（Origin 和 Referer 验证）
既然 CSRF 大多来自第三方网站，那么我们就**直接禁止外域（或者不受信任的域名）**对我们发起请求。在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：origin 和 referer。
（2）CSRF Token
CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击。具体步骤：</description>
    </item>
    
    <item>
      <title>VUE 生命周期</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/vue-lifecycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/vue-lifecycle/</guid>
      <description>VUE 生命周期 </description>
    </item>
    
    <item>
      <title>Vue.nextTick</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/nexttick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/nexttick/</guid>
      <description>Vue.nextTick 作用 在 DOM 更新后，执行一个回调。
// DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) Vue 何时更新 DOM Vue 在修改数据后，DOM 不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行 DOM 更新。
应用场景 created/mounted 操作 DOM mounted: function () { this.$nextTick(function () { // Code that will run only after the  // entire view has been rendered  }) } 显示输入框并获取焦点 showInput() { this.show = true this.$nextTick(function () { // DOM 更新了  document.getElementById(&amp;#34;keywords&amp;#34;).focus() }) } </description>
    </item>
    
    <item>
      <title>VUE 面试题</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/vue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/vue/</guid>
      <description>VUE 面试题 整理 VUE 相关的常见面试题
介绍一下 VUE 介绍一下 VUEX VUE 2.X 和 3.0 的区别 （1）数据监听方式变化
VUE 2.X 使用 ES5 的 Object.defineProperty() 的 get() 和 set(newValue) 实现，VUE 3.0 基于 Proxy 监听实现，同时更为强大：
 可以检测属性的新增和删除 可以检测数组索引的变化和 length 的变化 支持 Map、Set、WeakMap 和 WeakSet   优点：速度加倍，内存占用减半。
 （2）体积更小
支持 Tree Shaking，内置组件、内置指令按需引入。
（3）速度更快
参考：vue3.0和vue2.x的区别、Vue 3.0 和 Vue 2.0的对比以及Vue 2.0精讲以及Vue全家桶精讲
VUE 的生命周期 VUE 数据双向绑定原理 VUE 采用发布者-订阅者模式的方式来实现双向绑定。
（1）视图更新数据：
input 标签监听 input 事件即可。
（2）数据更新视图：
Object.defineProperty() 监听数据变化，通过消息订阅器发布消息，订阅者收到消息执行相应的操纵 DOM 的函数，从而更新视图。</description>
    </item>
    
  </channel>
</rss>
