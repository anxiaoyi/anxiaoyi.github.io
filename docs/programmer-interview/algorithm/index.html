<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="算法"><meta property="og:title" content="算法" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://kunzhao.org/docs/programmer-interview/algorithm/" />

<title>算法 | 赵坤的个人网站</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.7ebac727e739c3b4aee6328926e3b77ac1ddd5e9035221b7ec206fda1a413a4d.css" integrity="sha256-frrHJ&#43;c5w7Su5jKJJuO3esHd1ekDUiG37CBv2hpBOk0=">


<script defer src="/en.search.min.38852997086bec92501dbb454e27cd5aa4c6b906a23c80a51572a09eb3562155.js" integrity="sha256-OIUplwhr7JJQHbtFTifNWqTGuQaiPIClFXKgnrNWIVU="></script>
<script>
var _hmt = _hmt || [];
(function() {
  if (location.hostname === "localhost" || 
    location.hostname === "127.0.0.1") {
    return;
  }

  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d04ff9e23cec6cb39ebbee1b4883e269";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script data-ad-client="ca-pub-8950855178079071" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<link rel="alternate" type="application/rss+xml" href="https://kunzhao.org/docs/programmer-interview/algorithm/index.xml" title="赵坤的个人网站" />

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>赵坤的个人网站</span>
  </a>
</h2>








  

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/tutorial/" >
      💡 教程
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/" >
      👍 程序员面试题
  </a>


    

    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/java/" >
      Java
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/front-end/" >
      前端
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/data-structure/" >
      数据结构
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/algorithm/"  class="active">
      算法
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/" >
      Best Time to Buy and Sell Stock
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/" >
      Best Time to Buy and Sell Stock Ⅱ
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/" >
      Best Time to Buy and Sell Stock Ⅲ
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/" >
      Best Time to Buy and Sell Stock Ⅳ
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/" >
      Best Time to Buy and Sell Stock With Cooldown
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/" >
      Best Time to Buy and Sell Stock with Transaction Fee
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/binary-search/" >
      Binary Search 二分搜索
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/circular-array/" >
      Circular Array (循环数组)
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/container-with-most-water/" >
      Container With Most Water
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/countofsmallerafterself/" >
      Count Of Smaller After Self
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/designcircularqueue/" >
      设计循环队列
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/" >
      有序数组查找最小和最大元素的位置
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/findmedianfromdatastream/" >
      数据流寻找中位数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/" >
      旋转有序数组中寻找最小数字
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/findpeakelement/" >
      寻找峰值元素
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/findtheduplicatenumber/" >
      寻找重复数字
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/firstmissingpositive/" >
      第一个缺失的最小正数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/firstuniquenumberindatastream/" >
      数据流的第一个唯一数字
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/insertinterval/" >
      插入区间
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/intersectionoftwoarrays/" >
      数组交集
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/ksmallestnuminanarray/" >
      最小的K个数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/kdiffpairsinanarray/" >
      绝对值差为K的数对数量
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/kthlargestelement/" >
      第 K 个最大的数字
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/kthsmallestelement/" >
      第 K 个最小的数字
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/largestnumber/" >
      数组元素所能拼成的最大数字
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/largestrectangleinhistogram/" >
      柱状图中最大的矩形
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/longestsequence/" >
      最长序列
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/majorityelement/" >
      找出过半数的元素
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/maxareaofisland/" >
      最大的岛屿
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/maxpointsonaline/" >
      直线上最多的点数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/maximalrectangle/" >
      最大的矩形
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/maximumaveragesubarray/" >
      子数组的最大平均值
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/maximumproductsubarray/" >
      连续子数组最大乘积
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/maximumsizesubarraysumequalsk/" >
      最大子数组之和为 K
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/maximumsubmatrix/" >
      最大子矩阵
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/maximumswap/" >
      最大的交换
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/medianoftwosortedarrays/" >
      两个有序数组合并后的中位数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/mergeintervals/" >
      合并区间
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/mergeksortedarrays/" >
      合并 K 个有序数组
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/minimumsizesubarraysum/" >
      长度最小的子数组
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/movingaveragefromdatastream/" >
      数据流滑动窗口平均值
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/nextgreaterelementii/" >
      下一个更大元素 II
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/nextpermutation/" >
      下一个排列
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/numberofairplanesinthesky/" >
      数飞机
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/partitionequalsubsetsum/" >
      分割等和子集
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/productofarrayexceptself/" >
      数组除了自身的乘积
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/queuereconstructionbyheight/" >
      根据身高重建队列
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/ratelimiter/" >
      限流器
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/removeduplicatesfromsortedarray/" >
      删除排序数组中的重复项
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/kth-of-two-sorted-array/" >
      两个有序数组第 K 大的数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/removeelement/" >
      移除元素
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/reversepairs/" >
      逆序对
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/rotateimage/" >
      旋转图像
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/searcha2dmatrix/" >
      二维数组中的查找
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/searchforarange/" >
      搜索区间
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/searchinrotatedsortedarray/" >
      搜索旋转排序数组
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/slidingwindowmaximum/" >
      滑动窗口最大值
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/slidingwindowmedian/" >
      滑动窗口中位数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/sortcolors/" >
      颜色分类
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/spiralmatrix/" >
      螺旋矩阵
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/splitarraylargestsum/" >
      分割数组的最大值
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/sqrt/" >
      X 的平方根
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/subarrayproductlessthank/" >
      乘积小于K的子数组
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/subarraysumequalsk/" >
      和为K的子数组
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/subarrayswithkdifferentintegers/" >
      K 个不同整数的子数组
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/sum/" >
      2、3、4个数之和
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/sumofsubarrayminimums/" >
      子数组的最小值之和
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/thirdmaximumnumber/" >
      第三大的数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/topklargestnumbers/" >
      前K大数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/validmountainarray/" >
      有效的山脉数组
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/validsudoku/" >
      有效的数独
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/validtrianglenumber/" >
      有效三角形的个数
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/combinationsum/" >
      组合总和
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/combinations/" >
      组合
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/differentwaystoaddparentheses/" >
      为运算表达式设计优先级
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/game24/" >
      快算 24
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/generateparentheses/" >
      生成括号对
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/lettercasepermutation/" >
      字母大小写全排列
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/lettercombinationsofaphonenumber/" >
      电话号码的字母组合
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/nqueues/" >
      N 皇后
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/delete-node-in-bst/" >
      二叉搜索树中删除一个节点
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/insert-into-bst/" >
      二叉搜索树中新增一个节点
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/diameter-of-binary-tree/" >
      二叉树的直径
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/next-node-of-inorder-traverse/" >
      中序遍历的下一个节点
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/binary-tree-maximum-path-sum/" >
      二叉树最大路径和
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/binary-tree-inorder-traversal/" >
      二叉树非递归中序遍历
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/lowest-common-ancestor-of-a-binary-search-tree/" >
      二叉树的公共祖先
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/is-subtree-another-tree/" >
      一颗二叉树是否是另外一颗的子树
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/binary-tree-right-side-view/" >
      二叉树右视图
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/word-ladder/" >
      WordLadder
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/longest-increasing-path-in-a-matrix/" >
      二维数组寻找最长的单调递增序列
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/pancake-sorting/" >
      PancakeSorting
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/heap-sort/" >
      堆排序
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/linkedlist-mergesort/" >
      链表归并排序
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/quicksort/" >
      快排序
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/mergesort/" >
      归并排序
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/sort-stack/" >
      栈排序
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/disk-merge-sort/" >
      磁盘多路归并排序
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/evaluate-reverse-polish-notation/" >
      求解逆波兰表达式
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/minstack/" >
      MinStack
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/longest-substring-with-at-most-k-distinct-characters/" >
      找出最多 K 个不同字符的最长子串
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/add-strings/" >
      两个字符串整数相加
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/minimum-path-sum/" >
      二维矩阵数值和最小的路径
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/minimum-cost-for-tickets/" >
      最小火车票费用
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/lis/" >
      最长递增子序列 (LIS)
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/linkedlist-has-cycle/" >
      链表是否有环
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/find-linkedlist-cycle-start-node/" >
      找出链表环的入口节点
  </a>

</li>
      
    
      
        <li>

  <a href="/docs/programmer-interview/algorithm/5-read-1-write/" >
      5 个线程读 1 个线程写
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/programmer-interview/design-pattern/" >
      设计模式
  </a>


    

    






  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/rocketmq/" >
      RocketMQ 源码分析
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/books/" >
      书籍
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/javascript/" >
      JavaScript 专栏
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/it-zone/" >
      IT 圈
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/hire/" >
      招聘
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/cloud-plus-bbs/" >
      云&#43;社区技术沙龙
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/docs/tools/" >
      实用工具
  </a>


    

    






  </li>


      
    
  </ul>
  



  












<ul>
  
  <li>
    <a href="/posts/" >
        博客
      </a>
  </li>
  
</ul>



</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>算法</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
 
      </header>

      
<article class="markdown"><h1 id="算法面试题">算法面试题</h1>
<p>本专栏的面试题来自于牛客网、一亩三分地、LeetCode、LintCode等网站，覆盖了一线互联网如BAT、TMD、微软、亚马逊等巨头，在校招或者社招的时候最容易出的算法面试题。</p>
<div class="book-columns flex flex-wrap">
  
  <div class="flex-even markdown-inner">
    <h3 id="美团">美团</h3>
<ul>
<li><a href="https://leetcode.com/problems/lru-cache/">1.1 LRU 缓存</a></li>
<li><a href="https://leetcode.com/problems/min-stack/">1.2 Min Stack</a></li>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/">1.3 字符串最长回文子串的长度</a></li>
<li>[1.4 长度为 N 内容 <code>1 ~ N</code> 的数组排序]</li>
<li><a href="https://leetcode.com/problems/balanced-binary-tree/">1.5 是否是平衡二叉树</a></li>
<li>[1.6 节点值之和最大的路径的和是多少]</li>
<li>[1.7 float 数的立方根]</li>
<li>[1.8 之字遍历二叉树]</li>
</ul>

  </div>
  
  <div class="flex-even markdown-inner">
    <h3 id="快手">快手</h3>
<ul>
<li><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=0&amp;tqId=0&amp;tab=answerKey">2.1 正则表达式匹配</a></li>
<li><a href="https://leetcode.com/problems/reverse-linked-list-ii/">2.2 反转链表 m 到 n 节点</a></li>
<li>[2.3 二叉树非递归先序遍历]</li>
<li>[2.4 旋转有序数组的最小值（含重复元素）]</li>
<li>[2.5 括号生成]</li>
</ul>

  </div>
  
  <div class="flex-even markdown-inner">
    <h3 id="猿辅导">猿辅导</h3>
<ul>
<li>[3.1 旋转数组]</li>
<li>[3.2 整数转换英文表示]</li>
</ul>

  </div>
  
</div>

<div class="book-columns flex flex-wrap">
  
  <div class="flex-even markdown-inner">
    <h3 id="拼多多">拼多多</h3>
<ul>
<li>[4.1 二叉树的层次遍历]</li>
</ul>

  </div>
  
  <div class="flex-even markdown-inner">
    <h3 id="头条">头条</h3>
<ul>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">5.1 最长不重复的连续子串</a></li>
<li>[5.2 所有相加之和为 n 的 k 个数的组合]</li>
</ul>

  </div>
  
  <div class="flex-even markdown-inner">
    <h3 id="滴滴">滴滴</h3>
<ul>
<li>[6.1 环形链表的环的长度]</li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">6.2 二叉树最近公共祖先</a></li>
</ul>

  </div>
  
</div>

<div class="book-columns flex flex-wrap">
  
  <div class="flex-even markdown-inner">
    <h3 id="京东">京东</h3>
<ul>
<li>[7.1 树的左视图]</li>
<li>[7.2 链表求和]</li>
</ul>

  </div>
  
  <div class="flex-even markdown-inner">
    <h3 id="其他">其他</h3>
<ul>
<li><a href="https://leetcode.com/problems/longest-increasing-subsequence/">8.1 最长上升子序列</a></li>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">8.2 删除排序链表中的重复元素</a></li>
<li><a href="https://www.nowcoder.com/activity/oj">8.3 牛客网面试高频算法题</a></li>
</ul>

  </div>
  
  <div class="flex-even markdown-inner">
    
  </div>
  
</div>

<ul>
<li><strong>1.1</strong> 算法题，最近最少访问，看起来我们得需要维护一个<strong>次数</strong>，而实际上 <code>LRU</code> 算法中的 <code>Recenctly</code> 是不统计的单个 <code>key</code> 的次数的，比如过去访问了 3 次 <code>keyA</code>，然后接着访问了 1 次 <code>keyB</code>，下次淘汰的依然是 <code>keyA</code>，只是因为 <code>keyA</code> 更加的 <code>Recently</code>。因此我们可以使用双向链表来维护一个<strong>淘汰的顺序</strong>即可，比如头部永远都是最近访问的，尾部永远都是很长时间没有访问的 <code>key</code>，每次 <code>get</code> 和 <code>put</code> 的时候都需要将相应的 <code>key</code> 移动到<strong>头部</strong>即可。Java 自带的 <strong><code>LinkedList</code> 没有带 <code>capacity</code> 的构造函数</strong>，<strong><code>LinkedList</code> 的底层是双向循环链表</strong>，因为 <code>LinkedList</code> 的 <code>remove</code> 方法的复杂度是 <code>O(n)</code>，因此我们得需要自己实现这个<strong>双向链表</strong>，才能达到一个 <code>get</code> 和 <code>put</code> 都是 <code>O(1)</code> 复杂度的算法。在具体实现细节上，维护双向链表的删除，<code>head</code> 和 <code>tail</code> (<code>tail</code> 指针必须进行维护，否则无法达到 <code>O(1)</code> 查找到要删除的 <code>Key</code> 的复杂度要求) 的维护更新最好也是需要 <code>DUMMY</code> 节点的，这样的话就无须额外维护 <code>head</code> 和 <code>tail</code> 的边界点。如果不使用 <code>DUMMY</code>，那么删除 <code>node</code> 的算法大致如下，显得非常的小心翼翼，极易出错。另外，维护节点访问的顺序，可以分为两个步骤：先删除该节点，然后插入到头部，通过分为两个函数，也可以简化算法的实现。该题的示例写法<a href="https://leetcode.com/submissions/detail/461655688/">参考</a>。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// 删除 p
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">!=</span>  <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
    p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    head <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>另外牛客网上这道题，返回的是多次 <code>get</code> 的值存放到一个 <code>int[]</code> 数组里面的这个数组序列，那么我们会用 <code>List&lt;Integer&gt;</code> 来存储，并转为 <code>int[]</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">().</span><span style="color:#a6e22e">mapToInt</span><span style="color:#f92672">(</span>i <span style="color:#f92672">-&gt;</span> i<span style="color:#f92672">).</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">();</span>
</code></pre></div><p>另外还有一个需要注意的点就是，到达最大容量 <code>k</code>，需要删除尾巴节点的代码，千万不要像下面这样写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// 这一步之后，TAIL.prev 指向的指针已经变化了，所以应该先把 TAIL.prev 这个使用 tmp 保存下来
</span><span style="color:#75715e"></span>deleteNode<span style="color:#f92672">(</span>TAIL<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">);</span>
map<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>TAIL<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
</code></pre></div><ul>
<li>
<p><strong>1.3</strong> 这道题目，看了<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">官方的很多实现</a>，感觉<strong>中心扩展</strong>法的做法还是较为容易理解的。<strong>动态规划</strong>法的公式也比较容易理解，定义 <code>dp[i][j]</code> 表示字符串 <code>s[i...j]</code> 是否是回文字符串，一个回文字符串，两头肯定一样：<code>dp[i] == dp[j]</code>，并且去掉两头以后，里面也同样得需要是回文字符串：<code>dp[i + 1][j - 1] == true</code>，那么有边界条件：<code>i + 1 &lt; j - 1</code>，问题是填充二维数组的顺序不是很好理解，可能记不住。中心扩展法从左到右依次选则 1 到 2 个字符，然后以这两个字符为中心，向左向右进行扩展，记录最大的回文字符串的长度。</p>
</li>
<li>
<p><strong>5.1</strong> 这道题，我们需要维护一个 <code>Map</code>，这个 <code>Map</code> 记录了遇到的各个最新<strong>字符的位置和字符的映射关系</strong>，同时我们还需要一个 <code>left</code> 来标识当前在 <code>map</code> 中维护的字符串的最左侧开端的索引，当遇见重复字符的时候，我们需要<strong>将 <code>left</code> 到这个字符存在 <code>map</code> 中的旧的索引位置 <code>oldPosition</code> 的这段字符，从 <code>map</code> 中都给移除掉</strong> (最新<a href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4">刷了一遍</a>，结果写成了将 <code>oldPosition -&gt; i</code> 之间的给删除了，写错了)，以便放进来新的字符，开始新的字符串，并更新 <code>left</code> 的值为 <code>oldPosition + 1</code>。</p>
</li>
<li>
<p><strong>8.1</strong> 这道题，为了能容纳更多的数字到一个递增序列中，那么对于固定长度的递增序列，其<strong>末尾的数字越小越好</strong>，比如长度为两位的递增序列 <code>[2, 101]</code>，假设下一个数字遇到的是 3，那么应该用 3 来代替 101，来构成一个长度为 2 的递增序列，以便后续能够容纳更多的元素进来。还有一个地方是如何处理这种情况，比如 <code>[7, 8, 1, 2, 3, 4]</code>， 我们记录了 <code>[7, 8]</code>，但是下一个是 1，1 可能是一个新的递增序列的开始，因为它比 7 更适合作为一个序列的开始，所以遇到 1 的时候要更新一维数组的最小的值，由 7 变为 1，所以我们需要维护一个<strong>动态的递增数组</strong>，第一位记录的是长度为 1 的数组的末尾的最小值，第二位记录的是长度为 2 的数组的末尾的最小值……。这道题为了实现 <code>O(nlogn)</code> 的解法，需要实现一个在递增数组中，查找第一个大于 <code>num</code> 的这个索引，这就涉及到二分搜索的算法。</p>
</li>
</ul>
<p>而最关键的查找合适的替换位置的算法，因为二分搜索算法不好写，容易写错，所以面试的时候可以先写一个 <code>O(n)</code> 的查找算法 (注意此处可以写作 <strong><code>arr[hi]</code> 大于等于 <code>i</code></strong>，也就是等于的时候 <code>hi</code> 也往后退一下，这样下一步可以直接写 <code>arr[hi + 1] = nums[i]</code>)：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// len 是辅助数组 arr 的长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> hi <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
<span style="color:#75715e">// 注意此处可以写作 arr[hi] 大于等于 i
</span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> arr<span style="color:#f92672">[</span>hi<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;=</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    hi<span style="color:#f92672">--;</span>
<span style="color:#f92672">}</span>

arr<span style="color:#f92672">[</span>hi <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</code></pre></div><p>而我们在面试过程中，还需要将上述算法改为如下的二分搜索。其中有几点需要注意，(1) 使用 <strong><code>lo + ((hi - lo) &gt;&gt; 1)</code></strong> 计算 <code>lo</code> 和 <code>hi</code> 的中间索引。(2) 对于 <code>arr[mid]</code> 和 <code>nums[i]</code> 的对比关系，我们首先问一下，假设 <code>nums[i]</code> 大于 <code>arr[mid]</code>，那么这个 <code>mid</code> 有没有可能成为我们要寻找的目标索引？很明显，是不可能的，因为我们是要用小的 <code>nums[i]</code> 替换大 <code>arr[mid]</code> 的，而非大值替换小值，而大值位于 <code>mid</code> 索引的右侧，所以当 <code>nums[i]</code> 大于 <code>arr[mid]</code> 的时候，我们应该将 <code>lo</code> 调整为 <code>mid + 1</code>。参考上面 <code>O(n)</code> 的思路，此处等于的时候，我们<strong>也归为大于</strong>的情况，让其走 <code>else</code> 分支。在 <code>else</code> 分支中，此时 <code>mid</code> 这个索引有可能刚好满足需要查找的位置，那么怎么算<strong>刚好</strong>？这里刚好指的是 <code>arr[mid - 1] &lt; nums[i] &lt; arr[mid]</code>，此时 <code>nums[i]</code> 替换 <code>arr[mid]</code> 是我们想要的结果，这里因为涉及到了 <code>mid - 1</code>，因此判断 <code>mid</code> 是否为 <code>0</code> 的特殊情况，也是情理之中的时候。如果不满足这两个条件，那么说明当前 <code>mid</code> 的值还是太大，因此我们尝试向 <code>mid</code> 的左侧，即值相对来说稍微小一点的地方挪动一下，<code>hi = mid - 1</code>，来继续查找。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">int</span> hi <span style="color:#f92672">=</span> currentArrLength <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>lo <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> lo <span style="color:#f92672">+</span> <span style="color:#f92672">((</span>hi <span style="color:#f92672">-</span> lo<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;&gt;</span> 1<span style="color:#f92672">);</span>
    
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;=</span> arr<span style="color:#f92672">[</span>mid<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
        lo <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>mid <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> arr<span style="color:#f92672">[</span>mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            arr<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            hi <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p><strong>8.2</strong> 算法题，<strong>当 <code>next</code> 和 <code>p</code> 指针相同的时候，这个时候 <code>p</code> 不要往后移动；不相同的时候，<code>p</code> 才向后移动</strong>。如果相同的时候也移动，会漏掉节点。</p>
</li>
<li>
<p><strong>8.3</strong> 是牛客网根据网友发布的帖子里面的算法题，整理出来的一些高频算法题。能链接到 LeetCode 上的题目，都链接到了上面，不能链接的，也链接到了 NowCoder 上面。下面着重讲述做题心得。</p>
</li>
</ul>
<p>(1) <strong><a href="https://leetcode.com/problems/reverse-linked-list/">翻转单链表</a></strong>: 这道题，可以换一个描述，将原链表的每一个节点，从头部开始全部拆下来，以<strong>头插法</strong>逐次插入到另外一个新的链表的头部，而这个新的链表一开始只是一个空指针 <code>anotherHead = null</code>。</p>
<p>(2) <strong><a href="https://leetcode.com/problems/sort-an-array/">数组排序</a></strong>：对于这道题，我觉得至少应该掌握<a href="https://github.com/anxiaoyi/algorithm/blob/master/src/main/java/com/zk/algorithm/sort/HeapSort.java">堆排序</a>、<a href="https://github.com/anxiaoyi/algorithm/blob/master/src/main/java/com/zk/algorithm/sort/QuickSort.java">快速排序</a>、<a href="https://github.com/anxiaoyi/algorithm/blob/master/src/main/java/com/zk/algorithm/sort/MergeSort.java">归并排序</a>，三种排序算法的写法。其中<strong>快速排序</strong>，首先需要进行 <code>partition</code>，然后递归调用 <code>sort</code> 函数，以便将 <code>left ~ index - 1</code>，以及 <code>index + 1 ~ right</code> 都排好序，对于 <code>partition</code> 算法，一种较为简单的写法是，定义 <code>i</code> 指针指向左侧小于 <code>pivot</code> 的数字序列的最后一个索引，然后 <code>j</code> 负责在前面探路，只要遇到小于等于(只小于也是可以的) <code>pivot</code> 的值，那么 <code>i</code> 指针就加 <code>1</code>，否则不变，这样当 <code>i</code> 不等于 <code>j</code> 的时候，就可以交换 <code>i</code> 和 <code>j</code> 的值。对于<strong>归并排序</strong>，首先从中间切割，然后递归对 <code>begin ~ middle</code> 和 <code>middle + 1 ~ end</code> 进行排序，最后进行 <code>merge</code>，在 <code>merge</code> 阶段，一般会创建一个长度为 <code>end - begin + 1</code> 的数组，将合并的结果临时存放到这个数组里面，最后再将数字从这个数组中拷贝到原数组中。对于<strong>堆排序</strong>，首先第一步<strong>建立最大堆</strong>，这个建立过程索引 <code>i</code> 的取值范围 <code>n/2 -&gt; 0</code>，为什么是一半？因为<strong>堆是树状</strong>的，堆建立好以后，每一节点都会与自己的孩子进行对比，进行一个下调或者上升，确保每一个节点的值都大于或者等于孩子的值，而 <code>n/2 + 1 ~ n</code> 都是<strong>叶子节点</strong>，这部分节点无须进行堆的调整。另外一个问题，为什么堆需要<strong>倒着</strong>建立堆？这是为了，每一次对于堆节点的调整后，都保证该节点的子树是满足堆的定义的，以如下树为例，假设从堆顶 <code>5</code> 开始调整，那么调整完，<code>34</code> 将会放到堆顶，这很明显是不正确的。建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 <code>n</code> 的位置。当堆顶元素移除之后，我们把下标为 <code>n</code> 的元素放到堆顶，然后再通过堆化的方法，将剩下的 <code>n−1</code> 个元素重新构建成堆。</p>
<pre><code>     5
   /   \
  12   34
  / \  / \
100 43 6  7
</code></pre><p>(3) <strong><a href="https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tab=answerKey">含有重复数字的二分查找</a></strong>：这道题的坑的地方在于可能会出现重复数字，那么，当遇见重复数字的时候，需要 <code>O(n)</code> 从 <code>mid</code> 往索引 <code>0</code> 的地方去查找看是否都等于：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>mid <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> nums<span style="color:#f92672">[</span>mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> mid<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        i<span style="color:#f92672">--;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> i <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>一开始采用的是这种 <code>for</code> 的方式去写的，一旦 <code>i == 0</code> 的时候，那么还是会走到最后的一行，即返回的是 <code>mid</code> 而非 <code>0</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>mid <span style="color:#f92672">!=</span> 0 <span style="color:#f92672">&amp;&amp;</span> nums<span style="color:#f92672">[</span>mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> mid<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> mid<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>(4) <strong>数组中最小的 K 个数</strong>。这道题可以用快速排序中的 <code>partition</code> 算法来做，经过一次 <code>partition</code> 算法，返回的是 <code>pivot</code> 所在的索引 <code>i</code> 的位置，所有小于 <code>pivot</code> 的都在数组左边，大于 <code>pivot</code> 的都在数组右边；除了这一点，还有就是 <code>pivot</code> 在这个数组里面所处的位置也确定了，如果排序这个数组，那么 <code>pivot</code> 现在已经放到了正确的位置上，那就是处在第 <code>i + 1</code> 的位置。所以可以依托二分排序的结构，每一趟 <code>partition</code>，可以对比 <code>pivotIndex</code> 和 <code>k - 1</code> 是否相等，相等则返回前 K 个即可，不相等，则相应的调整 <code>lo</code> 和 <code>hi</code> 的值即可，这个算法的复杂度平均 <code>O(n)</code> 最坏 <code>O(n^2)</code>。平均时间复杂度为：</p>
<pre><code>n + n/2 + n/4 + ... + 8 + 4 + 2 + 1 = 2n
</code></pre><p>如果每次选取的 <code>pivot</code> 不合适，复杂度退化为：</p>
<pre><code>N + (N-1) + (N-2) + (N-3) .... = O(N^2)
</code></pre><p>那么应该如何进行优化，使用 <code>random</code> 与 <code>hi</code> 进行一个交换：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> nums<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> random <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Random<span style="color:#f92672">().</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">(</span>hi <span style="color:#f92672">-</span> lo <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> lo<span style="color:#f92672">;</span>
    swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span> random<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>

    <span style="color:#75715e">// 此时才开始我们以前的写法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>hi<span style="color:#f92672">];</span>
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>另外这道题还可以使用堆来做，不过这个堆应该是自己构造的，算法复杂度 <code>O(NlogK)</code>。</p>
<p>(4) <strong>寻找第 K 大</strong>。这道题注意的是，这里的第 <code>K</code> 大，指的是<strong>从大到小排序</strong>的第 <code>K</code> 个数字，所以第 <code>K</code> 大，相当于<strong>从小到大</strong>的第 <code>N - K + 1</code> 小，所以在查找之前一定要对 <code>K</code> 做上述公式的转换。</p>
<p>(5) <strong>两数之和</strong>。这道题注意的是，看最终返回的是这两个数，还是两个数的索引，如果是两个数的索引，那么可能采用排序然后二分搜索目标值的方法不太合适。应该采用哈希的方式来尝试，边遍历边判断即可，题目只是要求 <code>index1</code> 要小于 <code>index2</code>，如果含有重复数字的话，那么用第一小的数字，还是用第二小的数字，并未做要求。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> numbers<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    Integer index <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>target <span style="color:#f92672">-</span> numbers<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
    
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>index <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// target - numbers[i] 在之前出现过
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span> index <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> 1 <span style="color:#f92672">};</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>numbers<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> i<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>(6) <strong><a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e">链表中的节点每 K 个一组翻转</a></strong>。① 注意有多少 <code>group</code> 这个 <code>group</code> 不要求错了 ② 写一个 <code>findKthNode(curHead)</code> 的方法来找第 <code>k</code> 个节点 ③ 用一个新的节点作为最后的节点 <code>head</code>，一组翻转后，然后挂到这个新节点的末尾，然后进行下一组。</p>
<p>(7) <strong><a href="https://www.nowcoder.com/practice/6e630519bf86480296d0f1c868d425ad">求链表环的入口</a></strong>。① 探测 <code>meetNode</code> ② 根据 <code>meetNode</code> 求出环的节点个数 <code>cycleLen</code> ③ <code>faster</code> 从 <code>head</code> 移动 <code>cycleLen</code> ④ <code>slower</code> 和 <code>faster</code> 一起移动，直到相遇 ⑤ 最后返回 <code>slower</code></p>
<p>(8) <strong>sqrt</strong> 这道题。① <code>x</code> 小于等于 <code>1</code> 的时候，直接返回 <code>x</code> 即可。② 下限 <code>lo = 1</code>，上限，<code>hi = x / 2</code>。③ 使用 <code>mid * mid</code> 和 <code>x</code> 来对比大小关系，会<strong>溢出</strong>，即使使用 <code>long</code> 来存储也不行，因为 <code>int * int = int</code>。</p>
<p>(9) <strong><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46">两个链表的第一个公共节点</a></strong>。① 不能通过翻转链表，然后尾巴变成头部，从头部开始遍历的做法，因为两个链表是共用尾巴的，一个翻转了，另外一个跟着也翻转了，它们共用内存。② 思路：找到长度 <code>diff</code>，然后一起向后走，直到遇到相同节点。</p>
<p>(10) <strong><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362">二叉树前序遍历</a></strong>。① 设置一个指针 <code>curr</code> 沿着左树一直往左走，边走边放到栈里面，同时添加到 <code>result</code> 列表中。② 走到头，只要右树一直为空，就一直从栈里面 <code>pop</code>。③ 直到 <code>curr</code> 指针可以转到右树。</p>
<p>(11) <strong>二叉树中序遍历</strong>。① 设置一个指针 <code>curr</code> 沿着左树一直往左走，边走边放到栈里面。② 走到头，只要右树一直为空，就一直从栈里面开始 <code>pop</code>，边 <code>pop</code> 边放入 <code>res</code>。③ 直到 <code>curr</code> 指针可以转到右树。</p>
<p>(12) <strong>二叉树后序遍历</strong>。① 设置一个指针 <code>curr</code> 沿着左树一直往右走，边走边放到栈里面，同时通过 <code>add(0, node)</code> 头插到 <code>result</code> 列表中。② 走到头，只要左树一直为空，就一直从栈里面 <code>pop</code>。③ 直到 <code>curr</code> 指针可以转到左树。</p>
<p>(13) <strong>最长公共子串</strong>。① <code>dp[i][j]</code> 表示以 <code>A[i]</code> 结尾和以 <code>B[j]</code> 结尾的最长连续字符串长度。② <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>，<code>i - 1</code> 和 <code>j - 1</code> 必须大于等于 0。</p>
<p>(14) <strong><a href="https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31">螺旋矩阵</a></strong>。① <code>while</code> 循环条件是 <code>rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd</code>。② 每次走一行或一列，都需要 <code>rowBegin++</code>，<code>colEnd--</code>，<code>rowEnd--</code>，<code>colBegin++</code>。③ 因为 <code>rowBegin++</code> 可能会导致 <code>rowBegin &gt; rowEnd</code>，因此第三次从右往左走的时候，需要加上 <code>rowBegin &lt;= rowEnd</code> 这个条件；第四次从下往上走的时候，需要加上 <code>colEnd &gt;= colBegin</code> 这个条件。</p>
<p>(15) <strong>合并 K 个有序链表</strong>。介绍一下 <code>PriorityQueue</code> 的几个<strong>构造器</strong>和重要<strong>方法</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// 默认 capacity 11，顺序按照元素的自然顺序
</span><span style="color:#75715e"></span>PriorityQueue<span style="color:#f92672">();</span>
<span style="color:#75715e">// 按照指定的 capacity，以及指定的 Comparator 来创建堆
</span><span style="color:#75715e"></span>PriorityQueue<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">,</span> Comparator<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> E<span style="color:#f92672">&gt;</span> comparator<span style="color:#f92672">);</span>

<span style="color:#75715e">// 插入 e 到优先级队列中
</span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">offer</span><span style="color:#f92672">(</span>E e<span style="color:#f92672">);</span>
<span style="color:#75715e">// 从堆顶获取，但是不移除
</span><span style="color:#75715e"></span>E <span style="color:#a6e22e">peek</span><span style="color:#f92672">();</span>
<span style="color:#75715e">// 从堆顶获取并移除
</span><span style="color:#75715e"></span>E <span style="color:#a6e22e">poll</span><span style="color:#f92672">();</span>
</code></pre></div><p>另外就是 <code>Integer</code> 实现大小排序的原来：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Integer</span> <span style="color:#66d9ef">implements</span> Comparable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>Integer anotherInteger<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> compare<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">,</span> anotherInteger<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 小于返回 -1， 大于返回 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">&lt;</span> y<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">:</span> <span style="color:#f92672">((</span>x <span style="color:#f92672">==</span> y<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> 1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>另外就是 <code>Comparator&lt;T&gt;</code> 的定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Comparator</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>T o1<span style="color:#f92672">,</span> T o2<span style="color:#f92672">);</span>
    
<span style="color:#f92672">}</span>
</code></pre></div><p>(16) <strong><a href="https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711">三个数字和等于0</a></strong>。① 这道题整体思路，首先排序，使用 <code>i</code> 指针指向第一个数字，然后使用 <code>lo</code> 和 <code>hi</code>，一个从低处，一个从高处，从两端向中间聚拢。② 如果 <code>i + 1</code> 和 <code>i</code> 指向的数字是重复的，则跳过。③ <code>lo++</code> 和 <code>hi--</code> 的时候，也需要判断 <code>lo + 1</code> 和 <code>hi - 1</code> 位置的数字是否和 <code>lo</code> 和 <code>hi</code> 有重复。</p>
<p>(17) <strong><a href="https://www.nowcoder.com/practice/7cd13986c79d4d3a8d928d490db5d707">在转动(旋转)过的有序数组中寻找 <code>target</code></a></strong>: 重要的是确定 <strong><code>A[mid]</code> 位于哪一半</strong>，而非 <code>target</code> 位于哪一半。① 如果 <strong><code>lo &lt; hi</code></strong>，那么可以使用两个指针 <code>lo</code> 永远指向前半段，<code>hi</code> 永远指向后半段，当 <code>lo + 1 == hi</code> 的时候，那么说明 <code>lo</code> 指向的恰好是前半段的结尾，<code>hi</code> 恰好是后半段的开头，这个时候返回 <code>hi</code> 即可。如果 <code>lo &gt;= hi</code>，那么直接返回 <code>0</code> 即可。② 如果 <code>A[mid]</code> 大于等于 <code>A[0]</code>， 那么证明 <code>mid</code> 在前半段，所以可以 <code>lo = mid</code>。③ 反之，<code>hi = mid</code>。</p>
<hr>
<p><strong>LeetCode-Cn</strong> 遇到的情况：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a>：<code>int[]</code> 如何转为 <code>Integer[]</code>：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">Integer<span style="color:#f92672">[]</span> numArr <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">(</span>nums<span style="color:#f92672">).</span><span style="color:#a6e22e">boxed</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">(</span>Integer<span style="color:#f92672">[]::</span><span style="color:#66d9ef">new</span><span style="color:#f92672">);</span>
</code></pre></div><ul>
<li><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a>：判断是否是奇数、偶数的高效写法：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// 是否是奇数
</span><span style="color:#75715e"></span>nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;</span> 1 <span style="color:#f92672">==</span> 1
<span style="color:#75715e">// 是否是偶数
</span><span style="color:#75715e"></span>nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">%</span> 1 <span style="color:#f92672">==</span> 0
</code></pre></div><ul>
<li>
<p><a href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度</a>，这道题最关键的就是如何高效的在数组中寻找排列在后面的、并且比自己数值大的值。而这个需要借助一个数据结构，<strong><a href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">单调栈</a></strong>，栈里面存放的是索引，只要栈里面的数组比当前数字小，那么栈里面的数字就一直 <code>pop()</code>。</p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">两个有序数组的中位数</a>。TODO</p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">字符串的排列</a></p>
</li>
</ul>
<p>上述算法题来自：</p>
<ul>
<li><a href="https://www.nowcoder.com/discuss/598314">社招阿里字节美团等公司一二面凉经</a></li>
<li><a href="https://www.nowcoder.com/discuss/594676">社招一年半面经分享(含阿里美团头条京东滴滴)</a></li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>数组</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/circular-array/">环形数组</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/maximumsizesubarraysumequalsk/">最大子数组之和为 K</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/nextpermutation/">下一个排列</a>（<strong>微软</strong>）</td>
</tr>
<tr>
<td><a href="/docs/programmer-interview/algorithm/medianoftwosortedarrays/">两个有序数组合并后的中位数</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/">买卖股票</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/spiralmatrix/">生成螺旋矩阵</a>（<strong>微软</strong>）</td>
</tr>
<tr>
<td><a href="/docs/programmer-interview/algorithm/kth-of-two-sorted-array/">两个有序数组第 K 大的数</a>（<strong>微软</strong>）</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>树</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/delete-node-in-bst/">二叉搜索树中删除一个节点</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/insert-into-bst/">二叉搜索树中新增一个节点</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/diameter-of-binary-tree/">二叉树的直径</a>（<strong>微软、头条</strong>）</td>
</tr>
<tr>
<td><a href="/docs/programmer-interview/algorithm/next-node-of-inorder-traverse/">中序遍历的下一个节点</a></td>
<td><a href="/docs/programmer-interview/algorithm/binary-tree-maximum-path-sum/">二叉树最大路径和</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/binary-tree-inorder-traversal/">二叉树非递归中序遍历</a>（<strong>微软</strong>）</td>
</tr>
<tr>
<td><a href="/docs/programmer-interview/algorithm/lowest-common-ancestor-of-a-binary-search-tree/">二叉树最近公共祖先</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/is-subtree-another-tree/">一颗二叉树是否是另外一颗的子树</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/binary-tree-right-side-view/">二叉树右视图</a>（<strong>微软</strong>）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>DFS</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/word-ladder/">WordLadder</a>（<strong>微软、阿里</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/longest-increasing-path-in-a-matrix/">二维数组寻找最长的单调递增序列</a>（<strong>微软</strong>）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>栈</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/evaluate-reverse-polish-notation/">写一个计算器(逆波兰表达式)</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/minstack/">MinStack</a>（<strong>微软</strong>）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>排序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/pancake-sorting/">PancakeSorting</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/sortcolors/">颜色排序</a>（<strong>网易</strong>、<strong>阿里</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/heap-sort/">堆排序</a>（<strong>微软</strong>）</td>
</tr>
<tr>
<td><a href="/docs/programmer-interview/algorithm/linkedlist-mergesort/">链表归并排序</a></td>
<td><a href="/docs/programmer-interview/algorithm/quicksort/">快排序</a></td>
<td><a href="/docs/programmer-interview/algorithm/mergesort/">归并排序</a></td>
</tr>
<tr>
<td><a href="/docs/programmer-interview/algorithm/sort-stack/">栈排序</a>（<strong>美团</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/disk-merge-sort/">磁盘归并排序</a>（<strong>微软</strong>）</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>字符串</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/longest-substring-with-at-most-k-distinct-characters/">找出最多 K 个不同字符的最长子串</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/add-strings/">两个字符串整数相加</a>（<strong>微软</strong>）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>动态规划</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/minimum-path-sum/">二维矩阵数值和最小的路径</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/minimum-cost-for-tickets/">最小火车票费用</a>（<strong>亚马逊</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/lis/">最长递增子序列 LIS</a>（<strong>微软</strong>）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>链表</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/linkedlist-has-cycle/">链表是否有环</a>（<strong>微软</strong>）</td>
<td><a href="/docs/programmer-interview/algorithm/find-linkedlist-cycle-start-node/">找出链表环的入口节点</a>（<strong>微软</strong>）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>回溯</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/combinationsum/">组合总和</a></td>
<td><a href="/docs/programmer-interview/algorithm/differentwaystoaddparentheses/">为运算表达式设计优先级</a>（<strong>头条</strong>）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>数学</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/sqrt/">开根号</a>（<strong>微软</strong>）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/docs/programmer-interview/algorithm/5-read-1-write/">读写：5 个线程读 1 个线程写</a>（<strong>微软</strong>）</td>
</tr>
</tbody>
</table>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">  </div>
  
 
      </footer>
      
    </div>

    
  </main>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</body>



</html>












