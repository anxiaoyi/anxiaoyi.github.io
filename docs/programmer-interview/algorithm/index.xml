<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/programmer-interview/algorithm/</link>
    <description>Recent content in 算法 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://kunzhao.org/docs/programmer-interview/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/</guid>
      <description>Best Time to Buy and Sell Stock 题目 LeetCode 地址：Best Time to Buy and Sell Stock
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行一次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 这道题有两个简单做法：状态机和动态规划。
使用状态机的做法的好处是，这种思路可以延续到其它几个买卖股票的问题上。关键是要想清楚，某一天有几种状态，在这道题是三种：
 状态 s0: 不买也不卖，无操作。s0 的值只能有一个来源，就是和昨天保持一致，不买也不卖 状态 s1: 买入了股票。s1 的值有两个来源：1. 与昨天一致，即已经买入了，且只能买一次，所以不能再买了，s1 = s1；2. 买入今天的股票，花了 price[i] 钱，s1 = s0 - price[i] 状态 s2: 卖出了股票。s2 的值有两个来源：1. 之前已经卖出了，所以维持卖出状态，不能再次卖了，s2 = s1；2. 卖出之前买入的股票，挣 price[i] 钱，s2 = s1 + price[i]  所以，我们可以得到如下状态转移关系：
 s0 = s0 s1 = s1 s1 = s0 - price[i] s2 = s2 s2 = s1 + price[i]  在这整个过程中，我们都要保证每一天的 s0、s1、s2 都是 max 状态，s2 是最终卖完后的收益，所以返回这个结果就行。</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅱ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/</guid>
      <description>Best Time to Buy and Sell Stock Ⅱ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅱ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你可以进行无限次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 这道题就一个想法，只要今天 price[i] 比昨天 price[i - 1] 的价格涨了，就可以算作是有效的利润，累加到最后的结果中。
答案 // 假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。 // 设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。 // 然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。 // // https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-ii/description public class BestTimetoBuyandSellStockII { public int maxProfit(int[] prices) { int max = 0; for (int i = 1; i &amp;lt; prices.length; i++) { int diff = prices[i] - prices[i - 1]; if (diff &amp;gt; 0) { max += diff; } } return max; } } 扫描下面二维码，在手机上阅读这篇文章：</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅲ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/</guid>
      <description>Best Time to Buy and Sell Stock Ⅲ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅲ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行两次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 参考 Best Time to Buy and Sell Stock 思路上状态机，状态机应用两次即可。
答案 // 最多两次交易 // 且不能同时持有，必须卖掉这个，然后持有另外一个 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ // public class BestTimetoBuyandSellStockIII { // Buy Sell Buy Sell  // s0 ----&amp;gt; s1 -----&amp;gt; s2 -----&amp;gt; s3 ------&amp;gt; s4 (end)  // ↑___| ↑__| ↑____| ↑___|  //  public int maxProfit(int[] prices) { if (prices == null || prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅳ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/</guid>
      <description>Best Time to Buy and Sell Stock Ⅳ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅳ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行K次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 参考 Best Time to Buy and Sell Stock 思路上状态机，状态机应用K次即可。
答案 // 最多交易 k 次 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ // public class BestTimetoBuyandSellStockIV { public int maxProfit(int k, int[] prices) { if (prices == null || prices.length &amp;lt;= 1 || k &amp;lt;= 0) { return 0; } if (k &amp;gt;= prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock With Cooldown</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Best Time to Buy and Sell Stock With Cooldown 题目 LeetCode 地址：Best Time to Buy and Sell Stock With Cooldown
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行任意次交易（某天买入一支股票，然后过几天卖掉），你卖出一只股票后，接下来的一天不能买，必须要到后天才能买。也就是说有冷静期1天。请问你能收获的最大利润是多少？
答案 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ // 交易任意多次，只不过 buy sell 之后的第二天必须 cooldown 隔天才能再次 buy // // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/240277/Java-solution-in-Chinese public class BestTimetoBuyandSellStockwithCooldown { public int maxProfit(int[] prices) { if (prices == null || prices.length &amp;lt;= 1) { return 0; } // 买入只能是从前天买入 buy[i] = sell[i - 2] - prices[i];  // 卖出可以昨天卖出 sell[i] = buy[i - 1] + prices[i];  int[] sell = new int[prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Best Time to Buy and Sell Stock with Transaction Fee  每次交易都需要交易费用
 // 可以交易任意多次 // 只不过每一次都有小费 // // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/160964/java-Using-State-Machine-like-stock-III public class BestTimetoBuyandSellStockwithTransactionFee { public int maxProfit(int[] prices, int fee) { if (prices == null || prices.length &amp;lt;= 1) { return 0; } int s0 = 0; int s1 = s0 - prices[0]; // 买入  for (int i = 1; i &amp;lt; prices.length; i++) { // 这两种状态都能转移到 s0 状态:  //  // s0 -&amp;gt; s0  // s1 卖出 -&amp;gt; s0  s0 = Math.</description>
    </item>
    
    <item>
      <title>Binary Search 二分搜索</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-search/</guid>
      <description>Binary Search // https://leetcode.com/problems/binary-search/ // public class BinarySearch { public int search(int[] nums, int target) { if (nums == null || nums.length == 0) { return -1; } int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] == target) { return m; } else if (nums[m] &amp;gt; target) { hi = m - 1; } else { lo = m + 1; } } return -1; } } </description>
    </item>
    
    <item>
      <title>Circular Array (循环数组)</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/circular-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/circular-array/</guid>
      <description>Circular Array 循环数组 来自一亩三分地，微软面试官问的问题。过去任意 1 秒内来自同一 IP 的请求是否超过 100 次，可以用循环数组可以做。
// // https://www.javaguides.net/2018/09/queue-implementation-using-circular-array-in-java.html // package com.zk.algorithm.array; /** * Queue Implementation using Circular Array * @author Ramesh Fadatare * */ public class CircularArray { // Array used to implement the queue.  private int[] queueRep; // 添加数据，存放在 (rear + 1) % size，size++  // 取出数据，(front + 1) % size，size--  private int size, front, rear; // Length of the array used to implement the queue.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/container-with-most-water/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/container-with-most-water/</guid>
      <description>Container With Most Water // 两个柱子中间包含最多的水 // 可以看一下这道题的这个图 // 这个是两个柱子之间的所能容纳的水的矩形面积 // // https://leetcode.com/problems/container-with-most-water/ // // [1,8,6,2,5,4,8,3,7] // ↑ ↑ // 7 * 7 = 49 // public class ContainerWithMostWater { public int maxArea(int[] height) { int maxArea = Integer.MIN_VALUE; int lo = 0; int hi = height.length - 1; // O(n)  while (lo &amp;lt; hi) { maxArea = Math.max(maxArea, Math.min(height[lo], height[hi]) * (hi - lo)); // =======================================  // 此处这个地方，必须是小的一边移动  // 因为大的移动的话，面积一定变小 (宽度变小，而且高度不会超过小的)  // 而小的移动有可能变大  //  // 另外一种解释：  // 我们选择一个高的，以便容纳更多的水  // https://leetcode.</description>
    </item>
    
    <item>
      <title>Count Of Smaller After Self</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/countofsmallerafterself/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/countofsmallerafterself/</guid>
      <description>Count Of Smaller After Self 题目 数组里面的每一个数字，排在这个数字后面的小于这个数字的有多少个数字
解法 import java.util.ArrayList; import java.util.List; // Input: [5,2,6,1] // Output: [2,1,1,0] // // 统计小于自己的有多少个数字 public class CountOfSmallerAfterSelf { public List&amp;lt;Integer&amp;gt; countSmaller(int[] nums) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int curr = nums[i]; int count = 0; for (int j = i + 1; j &amp;lt; nums.length; j++) { if (nums[j] &amp;lt; curr) { count++; } } result.</description>
    </item>
    
    <item>
      <title>设计循环队列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/designcircularqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/designcircularqueue/</guid>
      <description>Design Circular Queue 题目 设计循环队列
解法 public class DesignCircularQueue { static class MyCircularQueue { private int[] queue; private int frontIndex; private int rearIndex; private int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { this.size = k + 1; this.queue = new int[k + 1]; } /** Insert an element into the circular queue. Return true if the operation is successful.</description>
    </item>
    
    <item>
      <title>有序数组查找最小和最大元素的位置</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/</guid>
      <description>有序数组查找最小和最大元素的位置 public class FindFirstandLastPositionofElementinSortedArray { public int[] searchRange(int[] nums, int target) { int minIndex = searchMinIndex(nums, target); if (minIndex == -1) { return new int[]{ -1, -1 }; } int maxIndex = searchMaxIndex(nums, target); return new int[] { minIndex, maxIndex }; } private int searchMaxIndex(int[] nums, int target) { int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] &amp;gt; target) { hi = m - 1; } else if (nums[m] &amp;lt; target) { lo = m + 1; } else { if (m == nums.</description>
    </item>
    
    <item>
      <title>数据流寻找中位数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findmedianfromdatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findmedianfromdatastream/</guid>
      <description>数据流寻找中位数 import java.util.Comparator; import java.util.PriorityQueue; // https://leetcode.com/problems/find-median-from-data-stream/ // 剑指 Offer 41 题 // public class FindMedianfromDataStream { // 堆顶是最小的  // 最小堆的堆顶是最大值  //  private PriorityQueue&amp;lt;Integer&amp;gt; minQueue = new PriorityQueue&amp;lt;&amp;gt;(); // 堆顶是最大的  // 最大堆的堆顶是最小的值  private PriorityQueue&amp;lt;Integer&amp;gt; maxQueue = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Integer&amp;gt;() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); private boolean sameSize = true; public FindMedianfromDataStream() { } public void addNum(int num) { if (sameSize) { minQueue.</description>
    </item>
    
    <item>
      <title>旋转有序数组中寻找最小数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/</guid>
      <description>旋转有序数组中寻找最小数字 // 没有重复元素 // 1 2 3 4 5 6 7 // // 5 6 7 1 2 3 4 // lo hi // public class FindMinimuminRotatedSortedArray { public int findMin(int[] nums) { int lo = 0; // always point to 前半部分  int hi = nums.length - 1; // always point to 后半部分  if (nums[lo] &amp;gt; nums[hi]) { while (lo &amp;lt; hi) { if (hi - lo == 1) { return nums[hi]; } int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] &amp;lt; nums[0]) { // middle 位于后半部分  hi = m; } else if (nums[m] &amp;gt; nums[nums.</description>
    </item>
    
    <item>
      <title>寻找峰值元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findpeakelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findpeakelement/</guid>
      <description>寻找峰值元素 题目 你给出一个整数数组(size为n)，其具有以下特点：
 相邻位置的数字是不同的 A[0] &amp;lt; A[1] 并且 A[n - 2] &amp;gt; A[n - 1]  假定P是峰值的位置则满足A[P] &amp;gt; A[P-1]且A[P] &amp;gt; A[P+1]，返回数组中任意一个峰值的位置。
 数组保证至少存在一个峰 如果数组存在多个峰，返回其中任意一个就行 数组至少包含 3 个数   微软面试题
 解法 // https://www.lintcode.com/problem/find-peak-element/description // // Microsoft // A[P] &amp;gt; A[P-1] &amp;amp;&amp;amp; A[P] &amp;gt; A[P+1] public class FindPeakElement { // 返回的是索引  //  // 数组太大的话，会超时  public int findPeak(int[] A) { // [x,x,x,x,x]  int lo = 1; int hi = A.</description>
    </item>
    
    <item>
      <title>寻找重复数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findtheduplicatenumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findtheduplicatenumber/</guid>
      <description>寻找重复数字 // Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), // prove that at least one duplicate number must exist. // Assume that there is only one duplicate number, find the duplicate one. // // 1 到 n 的数字，某个数字重复，可能重复次数 &amp;gt; 1 // // Input: [3,1,3,4,2] // Output: 3 // // https://leetcode.com/problems/find-the-duplicate-number/ public class FindtheDuplicateNumber { // ==================================  // 数组不允许修改版本  //  // 剑指 Offer  // ==================================  public int findDuplicate(int[] nums) { int lo = 1; int hi = nums.</description>
    </item>
    
    <item>
      <title>第一个缺失的最小正数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/firstmissingpositive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/firstmissingpositive/</guid>
      <description>第一个缺失的最小正数 import java.util.ArrayList; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Set; // https://leetcode.com/problems/first-missing-positive/ // Given an unsorted integer array, find the smallest missing positive integer. // // Input: [3,4,-1,1] // Output: 2 // // Input: [7,8,9,11,12] // Output: 1 // public class FirstMissingPositive { // ===============================  // 不使用辅助空间  //  // 最核心的是，遇见哪些数字可以不用管:  // - 负数  // - 大于 nums.length 的数  // ===============================  public int firstMissingPositive(int[] nums) { int i = 0; while (i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>数据流的第一个唯一数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/firstuniquenumberindatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/firstuniquenumberindatastream/</guid>
      <description>数据流的第一个唯一数字 import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map; // https://www.lintcode.com/problem/first-unique-number-in-data-stream/description // // 给一个连续的数据流,写一个函数返回终止数字到达时的第一个唯一数字（包括终止数字）, // 如果在终止数字前无唯一数字或者找不到这个终止数字, 返回 -1. public class FirstUniqueNumberinDataStream { public int firstUniqueNumber(int[] nums, int number) { boolean hasStopNumber = false; HashMap&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int count= map.getOrDefault(nums[i], 0); map.put(nums[i], count + 1); if (nums[i] == number) { hasStopNumber = true; break; } } if (!hasStopNumber) { return -1; } for (Map.</description>
    </item>
    
    <item>
      <title>插入 Interval</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/insertinterval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/insertinterval/</guid>
      <description>插入 Interval import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; import com.zk.algorithm.beans.Interval; // Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] // Output: [[1,2],[3,10],[12,16]] // Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. public class InsertInterval { // 插入一个新的 interval  // 如果有交集，那么合并  public List&amp;lt;Interval&amp;gt; insert(List&amp;lt;Interval&amp;gt; intervals, Interval newInterval) { intervals.add(newInterval); Collections.sort(intervals, new Comparator&amp;lt;Interval&amp;gt;() { public int compare(Interval a, Interval b) { if (a.start &amp;lt; b.start) { return -1; } else if (a.</description>
    </item>
    
    <item>
      <title>数组交集</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/intersectionoftwoarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/intersectionoftwoarrays/</guid>
      <description>数组交集 方法一 // // Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] // Output: [9,4] // public class IntersectionofTwoArrays { public int[] intersection(int[] nums1, int[] nums2) { Set&amp;lt;Integer&amp;gt; set1 = toSet(nums1); Set&amp;lt;Integer&amp;gt; set2 = toSet(nums2); return findIntersection(set1, set2); } private int[] findIntersection(Set&amp;lt;Integer&amp;gt; set1, Set&amp;lt;Integer&amp;gt; set2) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int num: set2) { if (set1.contains(num)) { list.add(num); } } int[] res = new int[list.size()]; for (int i = 0; i &amp;lt; list.</description>
    </item>
    
  </channel>
</rss>