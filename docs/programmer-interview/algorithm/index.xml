<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/programmer-interview/algorithm/</link>
    <description>Recent content in 算法 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://kunzhao.org/docs/programmer-interview/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/</guid>
      <description>Best Time to Buy and Sell Stock 题目 LeetCode 地址：Best Time to Buy and Sell Stock
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行一次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 这道题有两个简单做法：状态机和动态规划。
使用状态机的做法的好处是，这种思路可以延续到其它几个买卖股票的问题上。关键是要想清楚，某一天有几种状态，在这道题是三种：
 状态 s0: 不买也不卖，无操作。s0 的值只能有一个来源，就是和昨天保持一致，不买也不卖 状态 s1: 买入了股票。s1 的值有两个来源：1. 与昨天一致，即已经买入了，且只能买一次，所以不能再买了，s1 = s1；2. 买入今天的股票，花了 price[i] 钱，s1 = s0 - price[i] 状态 s2: 卖出了股票。s2 的值有两个来源：1. 之前已经卖出了，所以维持卖出状态，不能再次卖了，s2 = s1；2. 卖出之前买入的股票，挣 price[i] 钱，s2 = s1 + price[i]  所以，我们可以得到如下状态转移关系：
 s0 = s0 s1 = s1 s1 = s0 - price[i] s2 = s2 s2 = s1 + price[i]  在这整个过程中，我们都要保证每一天的 s0、s1、s2 都是 max 状态，s2 是最终卖完后的收益，所以返回这个结果就行。</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅱ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/</guid>
      <description>Best Time to Buy and Sell Stock Ⅱ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅱ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你可以进行无限次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 这道题就一个想法，只要今天 price[i] 比昨天 price[i - 1] 的价格涨了，就可以算作是有效的利润，累加到最后的结果中。
答案 // 假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。 // 设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。 // 然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。 // // https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-ii/description public class BestTimetoBuyandSellStockII { public int maxProfit(int[] prices) { int max = 0; for (int i = 1; i &amp;lt; prices.length; i++) { int diff = prices[i] - prices[i - 1]; if (diff &amp;gt; 0) { max += diff; } } return max; } } 扫描下面二维码，在手机上阅读这篇文章：</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅲ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/</guid>
      <description>Best Time to Buy and Sell Stock Ⅲ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅲ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行两次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 参考 Best Time to Buy and Sell Stock 思路上状态机，状态机应用两次即可。
答案 // 最多两次交易 // 且不能同时持有，必须卖掉这个，然后持有另外一个 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ // public class BestTimetoBuyandSellStockIII { // Buy Sell Buy Sell  // s0 ----&amp;gt; s1 -----&amp;gt; s2 -----&amp;gt; s3 ------&amp;gt; s4 (end)  // ↑___| ↑__| ↑____| ↑___|  //  public int maxProfit(int[] prices) { if (prices == null || prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅳ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/</guid>
      <description>Best Time to Buy and Sell Stock Ⅳ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅳ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行K次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 参考 Best Time to Buy and Sell Stock 思路上状态机，状态机应用K次即可。
答案 // 最多交易 k 次 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ // public class BestTimetoBuyandSellStockIV { public int maxProfit(int k, int[] prices) { if (prices == null || prices.length &amp;lt;= 1 || k &amp;lt;= 0) { return 0; } if (k &amp;gt;= prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock With Cooldown</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Best Time to Buy and Sell Stock With Cooldown 题目 LeetCode 地址：Best Time to Buy and Sell Stock With Cooldown
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行任意次交易（某天买入一支股票，然后过几天卖掉），你卖出一只股票后，接下来的一天不能买，必须要到后天才能买。也就是说有冷静期1天。请问你能收获的最大利润是多少？
答案 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ // 交易任意多次，只不过 buy sell 之后的第二天必须 cooldown 隔天才能再次 buy // // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/240277/Java-solution-in-Chinese public class BestTimetoBuyandSellStockwithCooldown { public int maxProfit(int[] prices) { if (prices == null || prices.length &amp;lt;= 1) { return 0; } // 买入只能是从前天买入 buy[i] = sell[i - 2] - prices[i];  // 卖出可以昨天卖出 sell[i] = buy[i - 1] + prices[i];  int[] sell = new int[prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Best Time to Buy and Sell Stock with Transaction Fee  每次交易都需要交易费用
 // 可以交易任意多次 // 只不过每一次都有小费 // // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/160964/java-Using-State-Machine-like-stock-III public class BestTimetoBuyandSellStockwithTransactionFee { public int maxProfit(int[] prices, int fee) { if (prices == null || prices.length &amp;lt;= 1) { return 0; } int s0 = 0; int s1 = s0 - prices[0]; // 买入  for (int i = 1; i &amp;lt; prices.length; i++) { // 这两种状态都能转移到 s0 状态:  //  // s0 -&amp;gt; s0  // s1 卖出 -&amp;gt; s0  s0 = Math.</description>
    </item>
    
    <item>
      <title>Binary Search 二分搜索</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-search/</guid>
      <description>Binary Search // https://leetcode.com/problems/binary-search/ // public class BinarySearch { public int search(int[] nums, int target) { if (nums == null || nums.length == 0) { return -1; } int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] == target) { return m; } else if (nums[m] &amp;gt; target) { hi = m - 1; } else { lo = m + 1; } } return -1; } } </description>
    </item>
    
    <item>
      <title>Circular Array (循环数组)</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/circular-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/circular-array/</guid>
      <description>Circular Array 循环数组 来自一亩三分地，微软面试官问的问题。过去任意 1 秒内来自同一 IP 的请求是否超过 100 次，可以用循环数组可以做。
 微软
 // // https://www.javaguides.net/2018/09/queue-implementation-using-circular-array-in-java.html // package com.zk.algorithm.array; /** * Queue Implementation using Circular Array * @author Ramesh Fadatare * */ public class CircularArray { // Array used to implement the queue.  private int[] queueRep; // 添加数据，存放在 (rear + 1) % size，size++  // 取出数据，(front + 1) % size，size--  private int size, front, rear; // Length of the array used to implement the queue.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/container-with-most-water/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/container-with-most-water/</guid>
      <description>Container With Most Water // 两个柱子中间包含最多的水 // 可以看一下这道题的这个图 // 这个是两个柱子之间的所能容纳的水的矩形面积 // // https://leetcode.com/problems/container-with-most-water/ // // [1,8,6,2,5,4,8,3,7] // ↑ ↑ // 7 * 7 = 49 // public class ContainerWithMostWater { public int maxArea(int[] height) { int maxArea = Integer.MIN_VALUE; int lo = 0; int hi = height.length - 1; // O(n)  while (lo &amp;lt; hi) { maxArea = Math.max(maxArea, Math.min(height[lo], height[hi]) * (hi - lo)); // =======================================  // 此处这个地方，必须是小的一边移动  // 因为大的移动的话，面积一定变小 (宽度变小，而且高度不会超过小的)  // 而小的移动有可能变大  //  // 另外一种解释：  // 我们选择一个高的，以便容纳更多的水  // https://leetcode.</description>
    </item>
    
    <item>
      <title>Count Of Smaller After Self</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/countofsmallerafterself/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/countofsmallerafterself/</guid>
      <description>Count Of Smaller After Self 题目 数组里面的每一个数字，排在这个数字后面的小于这个数字的有多少个数字
解法 import java.util.ArrayList; import java.util.List; // Input: [5,2,6,1] // Output: [2,1,1,0] // // 统计小于自己的有多少个数字 public class CountOfSmallerAfterSelf { public List&amp;lt;Integer&amp;gt; countSmaller(int[] nums) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int curr = nums[i]; int count = 0; for (int j = i + 1; j &amp;lt; nums.length; j++) { if (nums[j] &amp;lt; curr) { count++; } } result.</description>
    </item>
    
    <item>
      <title>设计循环队列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/designcircularqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/designcircularqueue/</guid>
      <description>Design Circular Queue 题目 设计循环队列
解法 public class DesignCircularQueue { static class MyCircularQueue { private int[] queue; private int frontIndex; private int rearIndex; private int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { this.size = k + 1; this.queue = new int[k + 1]; } /** Insert an element into the circular queue. Return true if the operation is successful.</description>
    </item>
    
    <item>
      <title>有序数组查找最小和最大元素的位置</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/</guid>
      <description>有序数组查找最小和最大元素的位置 public class FindFirstandLastPositionofElementinSortedArray { public int[] searchRange(int[] nums, int target) { int minIndex = searchMinIndex(nums, target); if (minIndex == -1) { return new int[]{ -1, -1 }; } int maxIndex = searchMaxIndex(nums, target); return new int[] { minIndex, maxIndex }; } private int searchMaxIndex(int[] nums, int target) { int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] &amp;gt; target) { hi = m - 1; } else if (nums[m] &amp;lt; target) { lo = m + 1; } else { if (m == nums.</description>
    </item>
    
    <item>
      <title>数据流寻找中位数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findmedianfromdatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findmedianfromdatastream/</guid>
      <description>数据流寻找中位数 import java.util.Comparator; import java.util.PriorityQueue; // https://leetcode.com/problems/find-median-from-data-stream/ // 剑指 Offer 41 题 // public class FindMedianfromDataStream { // 堆顶是最小的  // 最小堆的堆顶是最大值  //  private PriorityQueue&amp;lt;Integer&amp;gt; minQueue = new PriorityQueue&amp;lt;&amp;gt;(); // 堆顶是最大的  // 最大堆的堆顶是最小的值  private PriorityQueue&amp;lt;Integer&amp;gt; maxQueue = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Integer&amp;gt;() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); private boolean sameSize = true; public FindMedianfromDataStream() { } public void addNum(int num) { if (sameSize) { minQueue.</description>
    </item>
    
    <item>
      <title>旋转有序数组中寻找最小数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/</guid>
      <description>旋转有序数组中寻找最小数字 // 没有重复元素 // 1 2 3 4 5 6 7 // // 5 6 7 1 2 3 4 // lo hi // public class FindMinimuminRotatedSortedArray { public int findMin(int[] nums) { int lo = 0; // always point to 前半部分  int hi = nums.length - 1; // always point to 后半部分  if (nums[lo] &amp;gt; nums[hi]) { while (lo &amp;lt; hi) { if (hi - lo == 1) { return nums[hi]; } int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] &amp;lt; nums[0]) { // middle 位于后半部分  hi = m; } else if (nums[m] &amp;gt; nums[nums.</description>
    </item>
    
    <item>
      <title>寻找峰值元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findpeakelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findpeakelement/</guid>
      <description>寻找峰值元素 题目 你给出一个整数数组(size为n)，其具有以下特点：
 相邻位置的数字是不同的 A[0] &amp;lt; A[1] 并且 A[n - 2] &amp;gt; A[n - 1]  假定P是峰值的位置则满足A[P] &amp;gt; A[P-1]且A[P] &amp;gt; A[P+1]，返回数组中任意一个峰值的位置。
 数组保证至少存在一个峰 如果数组存在多个峰，返回其中任意一个就行 数组至少包含 3 个数   微软面试题
 解法 // https://www.lintcode.com/problem/find-peak-element/description // // Microsoft // A[P] &amp;gt; A[P-1] &amp;amp;&amp;amp; A[P] &amp;gt; A[P+1] public class FindPeakElement { // 返回的是索引  //  // 数组太大的话，会超时  public int findPeak(int[] A) { // [x,x,x,x,x]  int lo = 1; int hi = A.</description>
    </item>
    
    <item>
      <title>寻找重复数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findtheduplicatenumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findtheduplicatenumber/</guid>
      <description>寻找重复数字 // Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), // prove that at least one duplicate number must exist. // Assume that there is only one duplicate number, find the duplicate one. // // 1 到 n 的数字，某个数字重复，可能重复次数 &amp;gt; 1 // // Input: [3,1,3,4,2] // Output: 3 // // https://leetcode.com/problems/find-the-duplicate-number/ public class FindtheDuplicateNumber { // ==================================  // 数组不允许修改版本  //  // 剑指 Offer  // ==================================  public int findDuplicate(int[] nums) { int lo = 1; int hi = nums.</description>
    </item>
    
    <item>
      <title>第一个缺失的最小正数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/firstmissingpositive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/firstmissingpositive/</guid>
      <description>第一个缺失的最小正数 import java.util.ArrayList; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Set; // https://leetcode.com/problems/first-missing-positive/ // Given an unsorted integer array, find the smallest missing positive integer. // // Input: [3,4,-1,1] // Output: 2 // // Input: [7,8,9,11,12] // Output: 1 // public class FirstMissingPositive { // ===============================  // 不使用辅助空间  //  // 最核心的是，遇见哪些数字可以不用管:  // - 负数  // - 大于 nums.length 的数  // ===============================  public int firstMissingPositive(int[] nums) { int i = 0; while (i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>数据流的第一个唯一数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/firstuniquenumberindatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/firstuniquenumberindatastream/</guid>
      <description>数据流的第一个唯一数字 import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map; // https://www.lintcode.com/problem/first-unique-number-in-data-stream/description // // 给一个连续的数据流,写一个函数返回终止数字到达时的第一个唯一数字（包括终止数字）, // 如果在终止数字前无唯一数字或者找不到这个终止数字, 返回 -1. public class FirstUniqueNumberinDataStream { public int firstUniqueNumber(int[] nums, int number) { boolean hasStopNumber = false; HashMap&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int count= map.getOrDefault(nums[i], 0); map.put(nums[i], count + 1); if (nums[i] == number) { hasStopNumber = true; break; } } if (!hasStopNumber) { return -1; } for (Map.</description>
    </item>
    
    <item>
      <title>插入区间</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/insertinterval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/insertinterval/</guid>
      <description>插入区间 import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; import com.zk.algorithm.beans.Interval; // Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] // Output: [[1,2],[3,10],[12,16]] // Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. public class InsertInterval { // 插入一个新的 interval  // 如果有交集，那么合并  public List&amp;lt;Interval&amp;gt; insert(List&amp;lt;Interval&amp;gt; intervals, Interval newInterval) { intervals.add(newInterval); Collections.sort(intervals, new Comparator&amp;lt;Interval&amp;gt;() { public int compare(Interval a, Interval b) { if (a.start &amp;lt; b.start) { return -1; } else if (a.</description>
    </item>
    
    <item>
      <title>数组交集</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/intersectionoftwoarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/intersectionoftwoarrays/</guid>
      <description>数组交集 方法一 // // Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] // Output: [9,4] // public class IntersectionofTwoArrays { public int[] intersection(int[] nums1, int[] nums2) { Set&amp;lt;Integer&amp;gt; set1 = toSet(nums1); Set&amp;lt;Integer&amp;gt; set2 = toSet(nums2); return findIntersection(set1, set2); } private int[] findIntersection(Set&amp;lt;Integer&amp;gt; set1, Set&amp;lt;Integer&amp;gt; set2) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int num: set2) { if (set1.contains(num)) { list.add(num); } } int[] res = new int[list.size()]; for (int i = 0; i &amp;lt; list.</description>
    </item>
    
    <item>
      <title>最小的K个数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/ksmallestnuminanarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/ksmallestnuminanarray/</guid>
      <description>最小的K个数 import java.util.ArrayList; // 牛客网 // https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf // 最小的 k 个数 // public class KSmallestNumInAnArray { public ArrayList&amp;lt;Integer&amp;gt; GetLeastNumbers_Solution(int[] input, int k) { int lo = 0; int hi = input.length - 1; while (lo &amp;lt;= hi) { int kth = partition(input, lo, hi); if (kth == k - 1) { ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; k; i++) { res.add(input[i]); } return res; } else if (kth &amp;lt; k - 1) { lo = kth + 1; } else { hi = kth - 1; } } return new ArrayList&amp;lt;Integer&amp;gt;(); } private int partition(int[] nums, int lo, int hi) { int left = lo - 1; int pivot = nums[hi]; for (int i = lo; i &amp;lt;= hi - 1; i++) { if (nums[i] &amp;lt;= pivot) { swap(nums, ++left, i); } } swap(nums, left + 1, hi); return left + 1; } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } </description>
    </item>
    
    <item>
      <title>绝对值差为K的数对数量</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kdiffpairsinanarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kdiffpairsinanarray/</guid>
      <description>绝对值差为K的数对数量 描述 给定一个整数数组和一个整数k，您需要找到数组中唯一k-diff对的数量。这里k-diff对被定义为整数对(i, j)，其中i和j都是数组中的数字，它们的绝对差是k。
 对(i,j)和(j,i)计为同一对。 数组的长度不超过10,000。 给定输入中的所有整数都属于以下范围：[ -1e7, 1e7]。  答案 import java.util.Arrays; // https://www.lintcode.com/problem/k-diff-pairs-in-an-array/description // Amazon // // 这个 pair 差的绝对值 == k public class KdiffPairsinanArray { // O(n^2)  public int findPairs(int[] nums, int k) { Arrays.sort(nums); int count = 0; for (int i = 0; i &amp;lt; nums.length - 1; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>第 K 个最大的数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kthlargestelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kthlargestelement/</guid>
      <description>第 K 个最大的数字 数组中的第 K 个最大数字 // 数组无序 public class KthLargestElementinanArray { public int findKthLargest(int[] nums, int k) { k = nums.length - k; // 1 2 3 4 5 6  // ↑(第 2 大)  // ↑(partition = 2 的时候，实际上指向的是这里)  int lo = 0; int hi = nums.length - 1; // ==========================  // while (lo &amp;lt; hi)  // nums = [1]，这种情况进入不了循环  //  // ==========================  while (lo &amp;lt;= hi) { int index = partition(nums, lo, hi); if (index == k) { return nums[index]; } else if (index &amp;lt; k) { lo = index + 1; } else { hi = index - 1; } } return -1; } private int partition(int[] nums, int lo, int high) { int i = lo - 1; int pivot = nums[high]; for (int j = lo; j &amp;lt;= high - 1; j++) { if (nums[j] &amp;lt;= pivot) { i++; swap(nums, i, j); } } swap(nums, i + 1, high); return i + 1; } private void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } } 数据流中的第 K 个最大数字  堆  import java.</description>
    </item>
    
    <item>
      <title>第 K 个最小的数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kthsmallestelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kthsmallestelement/</guid>
      <description>第 K 个最小的数字 9 * 9 乘法表中的第 K 个最小数字 // http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3819&amp;amp;konwledgeId=40 // https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/ // // 百度乘法表 // 9 * 9 乘法表 // public class KthSmallestNumberinMultiplicationTable { public int findKthNumber(int m, int n, int k) { int lo = 1; int hi = m * n; while (lo &amp;lt;= hi) { int middle = lo + ((hi - lo) &amp;gt;&amp;gt; 1); int count = countLessOrEqualK(m, n, middle); if (count &amp;lt; k) { lo = middle + 1; } else { hi = middle - 1; } } return lo; } private int countLessOrEqualK(int m, int n, int k) { int c = 0; for (int i = 1; i &amp;lt;= m; i++) { // 1 2 3 4  // 2 4 6 8  // 3 6 9 12  //  // k = 5  // - k &amp;gt;= 第 1 行的 (1 2 3 4) 最后的 4，所以 c += n 个  // - k &amp;lt; 第 2 行的 (2 4 6 8) 最后的 8，所以 c += k / i 个  //  if (k &amp;gt;= n * i) { c += n; } else { c += k / i; } } return c; } } 行或列均有序的矩阵中的第 K 个最小数字 // matrix = [ // [ 1, 5, 9], // [10, 11, 13], // [12, 13, 15] // ], // k = 8,  // return 13.</description>
    </item>
    
    <item>
      <title>数组元素所能拼成的最大数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/largestnumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/largestnumber/</guid>
      <description>数组元素所能拼成的最大数字 import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class LargestNumber { public String largestNumber(int[] nums) { List&amp;lt;String&amp;gt; numList = toList(nums); Collections.sort(numList, new Comparator&amp;lt;String&amp;gt;() { @Override public int compare(String a, String b) { return (b + a).compareTo(a + b); } }); final StringBuilder sb = new StringBuilder(); for (String str: numList) { sb.append(str); } String res = sb.toString(); if (allZero(res)) { return &amp;#34;0&amp;#34;; } return res; } private boolean allZero(String str) { for (char c: str.</description>
    </item>
    
    <item>
      <title>柱状图中最大的矩形</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/largestrectangleinhistogram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/largestrectangleinhistogram/</guid>
      <description>柱状图中最大的矩形 描述 题目来源
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。
题解 // https://leetcode.com/problems/largest-rectangle-in-histogram/ 直方图 // __ // __| | // | | | // | | | __ // __ | | |__| | // | |__| | | | | // |__|__|__|__|__|__| // public class LargestRectangleinHistogram { public int largestRectangleArea(int[] heights) { // =================================  // 左边最多延展到哪个索引  // =================================  // 左边比自己大的或相等的  //  // 单调栈找到第一个比自己大的或者小的数字  int[] left = new int[heights.</description>
    </item>
    
    <item>
      <title>最长序列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/longestsequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/longestsequence/</guid>
      <description>最长序列 最长连续递增相差为 1 的序列 import java.util.Arrays; // [100, 4, 200, 1, 3, 2] // // 必须是连续的 1 2 3 4 差值为 1 public class LongestConsecutiveSequence { public int longestConsecutive(int[] nums) { if (nums.length == 0) { return 0; } Arrays.sort(nums); int longestStreak = 1; int currentStreak = 1; for (int i = 1; i &amp;lt; nums.length; i++) { if (nums[i] != nums[i - 1]) { if (nums[i] == nums[i - 1] + 1) { currentStreak += 1; } else { longestStreak = Math.</description>
    </item>
    
    <item>
      <title>找出过半数的元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/majorityelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/majorityelement/</guid>
      <description>找出过半数的元素 // Given an array of size n, find the majority element. // The majority element is the element that appears more than ⌊ n/2 ⌋ times. // You may assume that the array is non-empty and the majority element always exist in the array. // public class MajorityElement { public int majorityElement(int[] nums) { int candidate = nums[0]; int count = 1; for (int i = 1; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>最大的岛屿</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maxareaofisland/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maxareaofisland/</guid>
      <description>最大的岛屿 // 时间复杂度 O(row * col)，因为每个小方格访问一次 // public class MaxAreaofIsland { public int maxAreaOfIsland(int[][] grid) { int row = grid.length; int col = grid[0].length; boolean[][] visited = new boolean[row][col]; int max = 0; for (int r = 0; r &amp;lt; row; r++) { for (int c = 0; c &amp;lt; col; c++) { max = Math.max(maxArea(grid, visited, r, c), max); } } return max; } private int maxArea(int[][] grid, boolean[][] visited, int r, int c) { if (r &amp;lt; 0 || r &amp;gt;= grid.</description>
    </item>
    
    <item>
      <title>直线上最多的点数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maxpointsonaline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maxpointsonaline/</guid>
      <description>直线上最多的点数 描述 题目 给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。
输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^|| o| o o| o| o o+-------------------&amp;gt;0 1 2 3 4 5 6题解 public class MaxPointsonaLine { public int maxPoints(Point[] points) { if (points.length &amp;lt;= 1) { return points.length; } int max = 0; for (int i = 0; i &amp;lt; points.length - 1; i++) { for (int j = i + 1; j &amp;lt; points.</description>
    </item>
    
    <item>
      <title>最大的矩形</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximalrectangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximalrectangle/</guid>
      <description>最大的矩形 描述 题目 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
输入:[[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;]]输出: 6答案 // Given a matrix: // [ // [1, 1, 0, 0, 1], // [0, 1, 0, 0, 1], // [0, 0, 1, 1, 1], // [0, 0, 1, 1, 1], // [0, 0, 0, 0, 1] // ] // return 6. public class MaximalRectangle { public int maximalRectangle(boolean[][] matrix) { if (matrix == null || matrix.</description>
    </item>
    
    <item>
      <title>子数组的最大平均值</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumaveragesubarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumaveragesubarray/</guid>
      <description>子数组的最大平均值 描述 原题 给定一个由 n 个整数组成的数组，找到给定长度 k 的连续子数组，该子数组具有最大平均值。你需要输出最大平均值。
答案  前缀和  // https://www.lintcode.com/problem/maximum-average-subarray/description // 给定一个由 n 个整数组成的数组，找到给定长度 k 的连续子数组，该子数组具有最大平均值。你需要输出最大平均值。 // 注意这个长度 k 是固定的 // public class MaximumAverageSubarray { public double findMaxAverage(int[] nums, int k) { int[] prefixSum = prefixSum(nums); int maxSum = 0; for (int i = k; i &amp;lt; prefixSum.length; i++) { maxSum = Math.max(maxSum, prefixSum[i] - prefixSum[i - k]); } return maxSum * 1.0 / k; } private int[] prefixSum(int[] nums) { int[] prefixSum = new int[nums.</description>
    </item>
    
    <item>
      <title>连续子数组最大乘积</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumproductsubarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumproductsubarray/</guid>
      <description>连续子数组最大乘积 // 连续子数组最大乘积 public class MaximumProductSubarray { public int maxProduct(int[] nums) { int min = nums[0]; int max = nums[0]; int ans = nums[0]; for (int i = 1; i &amp;lt; nums.length; i++) { // ==============================  // max 值基于更新后的 min 值进行了计算  // ==============================  int A = nums[i] * min; int B = nums[i] * max; min = min(A, B, nums[i]); max = max(A, B, nums[i]); if (max &amp;gt; ans) { ans = max; } } return ans; } private int min(int.</description>
    </item>
    
    <item>
      <title>最大子数组之和为 K</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumsizesubarraysumequalsk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumsizesubarraysumequalsk/</guid>
      <description>最大子数组之和为 K  微软
 描述 给一个数组nums和目标值k，找到数组中最长的子数组，使其中的元素和为k。如果没有，则返回0。
 数组之和保证在32位有符号整型数的范围内
 题解  前缀和 + Map  import java.util.HashMap; import java.util.Map; // https://www.lintcode.com/problem/maximum-size-subarray-sum-equals-k/description // Facebook // // 微软面试题 // longest consecutive sequence of numbers that sum to K // https://www.1point3acres.com/bbs/thread-541121-1-1.html // // 给一个数组nums和目标值k，找到数组中最长的子数组，使其中的元素和为k。如果没有，则返回0。 // // ↓ ↓ (k = 17) // 2 [ 3 5 6 3 ] 8 public class MaximumSizeSubarraySumEqualsk { public int maxSubArrayLen(int[] nums, int k) { int[] prefixSum = prefixSum(nums); // 感觉就是跟 two sum 似的  // 借助 map 直接让复杂度降低了  Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); // 左边的边界  map.</description>
    </item>
    
    <item>
      <title>最大子矩阵</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumsubmatrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumsubmatrix/</guid>
      <description>最大子矩阵 描述 原题 给出一个大小为 n x n 的矩阵，里面元素为 正整数 和 负整数 ，找到具有最大和的子矩阵。
输入:matrix = [[1,3,-1],[2,3,-2],[-1,-2,-3]]输出: 9解释:具有最大和的子矩阵是:[[1,3],[2,3]]题解  二维数组的前缀和  // https://www.lintcode.com/problem/maximum-submatrix/description // // Given an n x n matrix of positive and negative integers, // find the submatrix with the largest possible sum. // public class MaximumSubmatrix { public int maxSubmatrix(int[][] matrix) { if (matrix == null || matrix.</description>
    </item>
    
    <item>
      <title>最大的交换</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumswap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumswap/</guid>
      <description>最大的交换 描述 原题 给定一个非负整数, 你可以选择交换它的两个数位. 返回你能获得的最大的合法的数.
 给定的数字在 [0, 10^8] 范围内
 输入: 2736输出: 7236解释: 交换数字2和数字7.题解 // https://www.lintcode.com/problem/maximum-swap/description // // 给定一个非负整数, 你可以选择交换它的两个数位. 返回你能获得的最大的合法的数. // // 输入: 2736 // 输出: 7236 // 解释: 交换数字2和数字7. // // 给定的数字在 [0, 10^8] 范围内 public class MaximumSwap { public static void main(String...args) { MaximumSwap maximumSwap = new MaximumSwap(); System.out.println(maximumSwap.maximumSwap0(98368)); System.out.println(maximumSwap.maximumSwap0(1993)); } public int maximumSwap0(int num) { char[] arr = String.valueOf(num).toCharArray(); int[] max = new int[arr.</description>
    </item>
    
    <item>
      <title>两个有序数组合并后的中位数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/medianoftwosortedarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/medianoftwosortedarrays/</guid>
      <description>两个有序数组合并后的中位数  微软
 题解 public class MedianofTwoSortedArrays { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int n = nums1.length + nums2.length; if (n % 2 == 1) { return findKth(nums1, nums2, 0, nums1.length - 1, 0, nums2.length - 1, n / 2 + 1); } else { double a = findKth(nums1, nums2, 0, nums1.length - 1, 0, nums2.length - 1, n / 2); double b = findKth(nums1, nums2, 0, nums1.</description>
    </item>
    
    <item>
      <title>合并区间</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/mergeintervals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/mergeintervals/</guid>
      <description>合并区间 描述 原题 给出一个区间的集合，请合并所有重叠的区间。
输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].题解 // Input: [[1,3],[2,6],[8,10],[15,18]] // Output: [[1,6],[8,10],[15,18]] // Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. // // 56: https://leetcode.com/problems/merge-intervals/ public class MergeIntervals { public List&amp;lt;Interval&amp;gt; merge(List&amp;lt;Interval&amp;gt; intervals) { if (intervals == null || intervals.isEmpty()) { return Collections.emptyList(); } Collections.sort(intervals, new Comparator&amp;lt;Interval&amp;gt;() { @Override public int compare(Interval a, Interval b) { if (a.</description>
    </item>
    
    <item>
      <title>合并 K 个有序数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/mergeksortedarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/mergeksortedarrays/</guid>
      <description>合并 K 个有序数组 题解  优先级队列  import java.util.PriorityQueue; // https://www.lintcode.com/problem/merge-k-sorted-arrays/description // public class MergeKSortedArrays { public int[] mergekSortedArrays(int[][] arrays) { PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(); int n = 0; for (int i = 0; i &amp;lt; arrays.length; i++) { for (int j = 0; j &amp;lt; arrays[i].length; j++) { n++; queue.offer(arrays[i][j]); } } int[] sortedArr = new int[n]; int index = 0; while (!queue.isEmpty()) { sortedArr[index++] = queue.poll(); } return sortedArr; } } </description>
    </item>
    
    <item>
      <title>长度最小的子数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/minimumsizesubarraysum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/minimumsizesubarraysum/</guid>
      <description>长度最小的子数组 描述 题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
输入：s = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。题解 // Given an array of n positive integers and a positive integer s, // find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn&amp;#39;t one, return 0 instead. // // Input: s = 7, nums = [2,3,1,2,4,3] // Output: 2 // Explanation: the subarray [4,3] has the minimal length under the problem constraint.</description>
    </item>
    
    <item>
      <title>数据流滑动窗口平均值</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/movingaveragefromdatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/movingaveragefromdatastream/</guid>
      <description>数据流滑动窗口平均值 描述 原题 给出一串整数流和窗口大小，计算滑动窗口中所有整数的平均值。
题解 import java.util.LinkedList; import java.util.Queue; // https://www.lintcode.com/problem/moving-average-from-data-stream/description // 给出一串整数流和窗口大小，计算滑动窗口中所有整数的平均值。 // // MovingAverage m = new MovingAverage(3); // m.next(1) = 1 // 返回 1.00000 // m.next(10) = (1 + 10) / 2 // 返回 5.50000 // m.next(3) = (1 + 10 + 3) / 3 // 返回 4.66667 // m.next(5) = (10 + 3 + 5) / 3 // 返回 6.00000 // public class MovingAveragefromDataStream { private final int size; private final Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); private double sum; /* * @param size: An integer */ public MovingAveragefromDataStream(int size) { this.</description>
    </item>
    
    <item>
      <title>下一个更大元素 II</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/nextgreaterelementii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/nextgreaterelementii/</guid>
      <description>下一个更大元素 II 描述 原题 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。
输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。题解 // 循环数组 // Input: [1,2,1] // Output: [2,-1,2] public class NextGreaterElementII { // O(n^2)  public int[] nextGreaterElements(int[] nums) { int[] greater = new int[nums.length]; for (int i = 0; i &amp;lt; nums.length; i++) { greater[i] = findNextGreat(nums, i); } return greater; } private int findNextGreat(int[] nums, int i) { int great = nums[i]; int j = i + 1; while (j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>下一个排列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/nextpermutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/nextpermutation/</guid>
      <description>下一个排列  微软
 描述 原题 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1题解 public class NextPermutation { // 1 5 8 4 7 6 5 3 1  // ↑  // ↑(5 &amp;gt; 4 最后一个大于它的)  // 1 5 8 5 7 6 4 3 1 (交换)  // ↑(reverse)↑  // 1 5 8 5 1 3 4 6 7  //  // 找到第一个不符合从右到左升序对的数字 i = 4  // 找到第一个刚刚大于 nums[i] 的数字 j = 5  // swap(i, j)  // reverse(i + 1)  //  // ↓ (第一个不符合的数字 3，如果相等，比如多个 3 还要再往前找)  // 7 3 6 4 2  // ↑ (第一个刚刚大于 3 的数字 4)  //  // 7 4 6 3 2 (交换)  //  // 7 4 2 3 6 (4 后面的数字也交换)  public void nextPermutation(int[] nums) { int i = nums.</description>
    </item>
    
    <item>
      <title>数飞机</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/numberofairplanesinthesky/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/numberofairplanesinthesky/</guid>
      <description>数飞机 描述 原题 给出飞机的起飞和降落时间的列表，用序列 interval 表示. 请计算出天上同时最多有多少架飞机？
 如果多架飞机降落和起飞在同一时刻，我们认为降落有优先权。
 输入: [(1, 10), (2, 3), (5, 8), (4, 7)]输出: 3解释: 第一架飞机在1时刻起飞, 10时刻降落.第二架飞机在2时刻起飞, 3时刻降落.第三架飞机在5时刻起飞, 8时刻降落.第四架飞机在4时刻起飞, 7时刻降落.在5时刻到6时刻之间, 天空中有三架飞机.题解 import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; import com.zk.algorithm.beans.Interval; // https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/description // Amazon // // Input: [(1, 10), (2, 3), (5, 8), (4, 7)] // Output: 3 // Explanation: // The first airplane takes off at 1 and lands at 10.</description>
    </item>
    
    <item>
      <title>分割等和子集</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/partitionequalsubsetsum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/partitionequalsubsetsum/</guid>
      <description>分割等和子集 描述 原题 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
 每个数组中的元素不会超过 100 数组的大小不会超过 200  输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11].题解 import java.util.Arrays; // https://leetcode.com/problems/partition-equal-subset-sum/ // // 0 1 背包问题 // 从 nums.length 个数中找出若干个数，使其和 == sum /2 // // 416. Two subset public class PartitionEqualSubsetSum { public boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) { sum += num; } if ((sum &amp;amp; 1) == 1) { return false; } // ======================  // sum 变为一半  // ======================  sum /= 2; int n = nums.</description>
    </item>
    
    <item>
      <title>数组除了自身的乘积</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/productofarrayexceptself/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/productofarrayexceptself/</guid>
      <description>描述 原题 给定 n 个整数的数组 nums，其中 n &amp;gt; 1，返回一个数组输出，使得 output[i] 等于 nums 的所有除了nums[i] 的元素的乘积。
输入: [1,2,3,4]输出: [24,12,8,6]解释:2*3*4=241*3*4=121*2*4=81*2*3=6题解 // 给定n个整数的数组nums，其中n&amp;gt; 1，返回一个数组输出，使得output [i]等于nums的所有除了nums [i]的元素的乘积。 // 在没有除和O(n)时间内解决 // https://www.lintcode.com/problem/product-of-array-except-self/description // 输入: [1,2,3,4] // 输出: [24,12,8,6] // 解释: // 2*3*4=24 // 1*3*4=12 // 1*2*4=8 // 1*2*3=6 // // 输入: [2,3,8] // 输出: [24,16,6] // 解释: // 3*8=24 // 2*8=16 // 2*3=6 public class ProductofArrayExceptSelf { public int[] productExceptSelf(int[] nums) { //  // 2, 3, 8  //  // 2, 6, 1  // 1, 24, 8  //  // 24, 16, 6  int[] leftProduct = new int[nums.</description>
    </item>
    
    <item>
      <title>根据身高重建队列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/queuereconstructionbyheight/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/queuereconstructionbyheight/</guid>
      <description>根据身高重建队列 原题 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。
注意：
 总人数少于1100人。  示例
输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]题解 import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List; // https://leetcode.com/problems/queue-reconstruction-by-height/ public class QueueReconstructionbyHeight { // [[7,0], [7,1], [6,1], [5,2], [5,0], [4,4]]  //  // [[7,0]]  // [[7,0], [7,1]]  // [[7,0], [6,1], [7,1]]  // [[7,0], [6,1], [5,2], [7,1]]  // [[5,0], [7,0], [6,1], [5,2], [7,1]]  // [[5,0], [7,0], [6,1], [5,2], [4,4], [7,1]]  public int[][] reconstructQueue(int[][] people) { // 个高的排在最前面，个矮的排在后面  Arrays.</description>
    </item>
    
    <item>
      <title>限流器</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/ratelimiter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/ratelimiter/</guid>
      <description>限流器  基于 Token Bucket 的限流算法 基于 Redis 的限流算法  public class RateLimiter { public static long now() { return System.currentTimeMillis(); } // ==================  // - Token Bucket  // - Redis  // ==================  // =========================  // Token Bucket 算法  // 每过 RATE / PER 时间，就加  // =========================  public static class TokenBucketRateLimiter { private long lastCheck = now(); private static final int RATE = 5; // 5 requests  private static final int PER = 8; // 8 seconds  private int allowance = RATE; public boolean overhead(String key) { long current = now(); long timePassed = current - lastCheck; lastCheck = timePassed; // ======================  // 过去的这段时间内可以增加多少个 allowance  // ======================  allowance += timePassed * (RATE / PER); if (allowance &amp;gt; RATE) { allowance = RATE; } // ======================  // 是否能够减去 1.</description>
    </item>
    
    <item>
      <title>删除排序数组中的重复项</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/removeduplicatesfromsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/removeduplicatesfromsortedarray/</guid>
      <description>删除排序数组中的重复项 描述 原题 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
 示例 1:
给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。题解 // 排序数组 // 移除重复数字 public class RemoveDuplicatesfromSortedArray { public int removeDuplicates(int[] nums) { // [1,1,1,1,2,2,3,4,5,5]  //  int noDuplicated = 0; for (int i = 1; i &amp;lt; nums.length; i++) { if (nums[i] == nums[i - 1]) { continue; } else { nums[++noDuplicated] = nums[i]; } } return nums.</description>
    </item>
    
    <item>
      <title>移除元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/removeelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/removeelement/</guid>
      <description>移除元素 描述 原题 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:
给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。题解 public class RemoveElement { // [1,1,1,2,2]  public int removeElement(int[] nums, int val) { int valid = -1; for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] != val) { nums[++valid] = nums[i]; } } return nums.</description>
    </item>
    
    <item>
      <title>逆序对</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/reversepairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/reversepairs/</guid>
      <description>逆序对 描述 数组的逆序对个数
题解 // https://www.lintcode.com/problem/reverse-pairs/description // // Input: A = [2, 4, 1, 3, 5] // Output: 3 // Explanation: // (2, 1), (4, 1), (4, 3) are reverse pairs // // 逆序对个数 public class ReversePairs { public long reversePairs(int[] A) { return mergeSort(A, 0, A.length - 1); } private long mergeSort(int[] A, int lo, int hi) { int sum = 0; if (lo &amp;lt; hi) { int mid = lo + ((hi - lo) &amp;gt;&amp;gt; 1); // =====================  // 注意：这个地方是都加了一遍  // =====================  sum += mergeSort(A, lo, mid); sum += mergeSort(A, mid + 1, hi); sum += merge(A, lo, mid, hi); } return sum; } private int merge(int[] A, int lo, int mid, int hi) { int[] temp = new int[hi - lo + 1]; int tempIndex = 0; int loIndex = lo; int hiIndex = mid + 1; int count = 0; while (loIndex &amp;lt;= mid &amp;amp;&amp;amp; hiIndex &amp;lt;= hi) { // left | right  // 3 5 6 | 2  //  // 3 比 2 大的话，那么 3 5 6 都比 2 大  if (A[loIndex] &amp;gt; A[hiIndex]) { count += mid - loIndex + 1; temp[tempIndex++] = A[hiIndex++]; } else { temp[tempIndex++] = A[loIndex++]; } } while (loIndex &amp;lt;= mid) { temp[tempIndex++] = A[loIndex++]; } while (hiIndex &amp;lt;= hi) { temp[tempIndex++] = A[hiIndex++]; } tempIndex = 0; while (tempIndex &amp;lt; temp.</description>
    </item>
    
    <item>
      <title>旋转图像</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/rotateimage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/rotateimage/</guid>
      <description>旋转图像 描述 原题 给定一个 n × n 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。
说明：
你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
题解 // Given input matrix = // [ // [1,2,3], // [4,5,6], // [7,8,9] // ],  // rotate the input matrix in-place such that it becomes: // [ // [7,4,1], // [8,5,2], // [9,6,3] // ] public class RotateImage { public void rotate(int[][] matrix) { int n = matrix.length; for (int i = 0; i &amp;lt; n / 2; i++) { // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓  // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓  //  // 【j 走到哪里停】?</description>
    </item>
    
    <item>
      <title>二维数组中的查找</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/searcha2dmatrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/searcha2dmatrix/</guid>
      <description>二维数组中的查找 描述  剑指offer  在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
题解 // 这个算法适用于行有序、列有序的情况 public class Searcha2DMatrix { public boolean searchMatrix(int[][] matrix, int target) { if (matrix.length == 0) { return false; } int m = matrix.length; int n = matrix[0].length; // 第一行最后一个数字  //  int r = 0; int c = n - 1; while (r &amp;lt; m &amp;amp;&amp;amp; c &amp;gt;= 0) { int val = matrix[r][c]; if (target &amp;gt; val) { r++; } else if (target &amp;lt; val) { c--; } else { return true; } } return false; } } </description>
    </item>
    
    <item>
      <title>搜索区间</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/searchforarange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/searchforarange/</guid>
      <description>搜索区间 描述 原题 给定一个包含 n 个整数的排序数组，找出给定目标值 target 的起始和结束位置。
如果目标值不在数组中，则返回 [-1, -1]
题解 // LintCode // https://www.lintcode.com/problem/search-for-a-range/leaderboard // public class SearchforaRange { public int[] searchRange(int[] A, int target) { if (A == null || A.length == 0) { return new int[]{ -1, -1 }; } int start = searchStartIndex(A, target); int end = searchEndIndex(A, target); return new int[]{ start, end }; } // target 开始的地方  private int searchStartIndex(int[] A, int target) { int lo = 0; int hi = A.</description>
    </item>
    
    <item>
      <title>搜索旋转排序数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/searchinrotatedsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/searchinrotatedsortedarray/</guid>
      <description>搜索旋转排序数组 Search in Rotated Sorted Array 和 Search in Rotated Sorted Array II
数组无重复数字 // 么有重复数字 public class SearchinRotatedSortedArray { // https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14472/Java-AC-Solution-using-once-binary-search  // 使用一次二分搜索  //  // 核心思想: 确定 m 位于哪一边，然后确定 target 是不是位于有序的一边  //  public int search(int[] nums, int target) { int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] == target) { return m; } // 6 7 1 2 3 4 5  // ↑ ↑ ↑ ↑ ↑  //  // 1 2 3 4 5 6 7  // ↑ ↑ ↑ ↑ ↑ ↑ ↑  //  // 右侧有序  // target 是不是位于有序右侧空间  if (nums[m] &amp;lt;= nums[hi]) { if (target &amp;gt; nums[m] &amp;amp;&amp;amp; target &amp;lt;= nums[hi]) { lo = m + 1; } else { hi = m - 1; } } else { // 6 7 1 2 3 4 5  // ↑ ↑  //  // target 是否位于左侧有序空间内  if (target &amp;gt;= nums[lo] &amp;amp;&amp;amp; target &amp;lt; nums[m]) { hi = m - 1; } else { lo = m + 1; } } } return -1; } // ================================  // 下面这个方案先查找 min 值  // ================================  public int search0(int[] nums, int target) { // ================================  // 忘记这一步骤了  // ================================  if (nums.</description>
    </item>
    
    <item>
      <title>滑动窗口最大值</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/slidingwindowmaximum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/slidingwindowmaximum/</guid>
      <description>滑动窗口最大值 描述 原题 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 31 [3 -1 -3] 5 3 6 7 31 3 [-1 -3 5] 3 6 7 51 3 -1 [-3 5 3] 6 7 51 3 -1 -3 [5 3 6] 7 61 3 -1 -3 5 [3 6 7] 7题解 import java.</description>
    </item>
    
    <item>
      <title>滑动窗口中位数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/slidingwindowmedian/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/slidingwindowmedian/</guid>
      <description>滑动窗口中位数 描述 原题 中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。
例如：
 [2,3,4]，中位数是 3 [2,3]，中位数是 (2 + 3) / 2 = 2.5  给你一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。
示例：
给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。
窗口位置 中位数--------------- -----[1 3 -1] -3 5 3 6 7 11 [3 -1 -3] 5 3 6 7 -11 3 [-1 -3 5] 3 6 7 -11 3 -1 [-3 5 3] 6 7 31 3 -1 -3 [5 3 6] 7 51 3 -1 -3 5 [3 6 7] 6因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。</description>
    </item>
    
    <item>
      <title>颜色分类</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sortcolors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sortcolors/</guid>
      <description>颜色分类 描述 原题 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
题解 public class SortColors { // 0,0,1,1,2,2  //  // 2 0 1 0 1 1 2  public void sortColors(int[] nums) { // 000001111122222  // ↑ ↑  // l r  //  int left = 0; int right = nums.length - 1; int i = 0; while (i &amp;lt;= right) { if (nums[i] == 0) { // =========================  // 遇到 0 就换到左边  //  // 0 0 0 0 1 1 1 1 0 2  // ↑ ↑  // left i  //  // =========================  swap(nums, left++, i++); } else if (nums[i] == 1) { i++; } else { // =========================  // right 指向的是第一个非 2 的位置  //  // 遇到 2 就换到右边，但是换过来的不一定是 1 还是 0，所以 i 不能动  //  // 1 1 1 1 1 2 2 0  // ↑ ↑  // i right  //  // =========================  swap(nums, i, right--); } } } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } </description>
    </item>
    
    <item>
      <title>螺旋矩阵</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/spiralmatrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/spiralmatrix/</guid>
      <description>螺旋矩阵 Spiral Matrix 和 Spiral Matrix II
返回螺旋顺序 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
import java.util.ArrayList; import java.util.Collections; import java.util.List; public class SpiralMatrix { public List&amp;lt;Integer&amp;gt; spiralOrder(int[][] matrix) { if (matrix == null || matrix.length == 0) { return Collections.emptyList(); } List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int left = 0; int right = matrix[0].length - 1; int top = 0; int bottom = matrix.length - 1; while (true) { for (int c = left; c &amp;lt;= right; c++) { res.</description>
    </item>
    
    <item>
      <title>分割数组的最大值</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/splitarraylargestsum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/splitarraylargestsum/</guid>
      <description>分割数组的最大值 描述 原题 给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。
注意: 数组长度 n 满足以下条件:
 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)  输入:nums = [7,2,5,10,8]m = 2输出:18解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。题解 // 数组包含非负整数，以及一个 整数 m // 将数组分成 m 个连续的 subarray // 写一个算法，来使得所有的这些 subarrays 的最大和最小 // // [7,2,5,10,8] // // https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java public class SplitArrayLargestSum { // [.......]  //  // max: 所有数相加  // min: Math.</description>
    </item>
    
    <item>
      <title>X 的平方根</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sqrt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sqrt/</guid>
      <description>X 的平方根 描述 原题 实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
题解 public class Sqrt { public int mySqrt(int x) { // 注意边界条件  if (x == 0) { return 0; } int lo = 1; int hi = x / 2; int ans = lo; while (lo &amp;lt;= hi) { int mid = lo + ((hi - lo) &amp;gt;&amp;gt; 1); // 注意这里  // 防止溢出  if (mid &amp;gt; x / mid) { hi = mid - 1; } else if (mid &amp;lt;= x / mid) { ans = mid; lo = mid + 1; } } return ans; } } </description>
    </item>
    
    <item>
      <title>乘积小于K的子数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/subarrayproductlessthank/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/subarrayproductlessthank/</guid>
      <description>乘积小于K的子数组 描述 原题 给定一个正整数数组 nums。
找出该数组内乘积小于 k 的连续的子数组的个数。
示例 1:
输入: nums = [10,5,2,6], k = 100输出: 8解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。需要注意的是 [10,5,2] 并不是乘积小于100的子数组。题解 // Input: nums = [10, 5, 2, 6], k = 100 // Output: 8 // Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</description>
    </item>
    
    <item>
      <title>和为K的子数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/subarraysumequalsk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/subarraysumequalsk/</guid>
      <description>和为K的子数组 描述 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。题解 // Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. // // 和为 k 的连续子数组，有多少组 public class SubarraySumEqualsK { public int subarraySum(int[] nums, int k) { int[] preSum = calcPreSum(nums); int count = 0; for (int i = 0; i &amp;lt; preSum.</description>
    </item>
    
    <item>
      <title>K 个不同整数的子数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/subarrayswithkdifferentintegers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/subarrayswithkdifferentintegers/</guid>
      <description>K 个不同整数的子数组 描述 给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。
（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）
返回 A 中好子数组的数目。
示例 1：
输入：A = [1,2,1,2,3], K = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].题解 import java.util.HashMap; import java.util.Map; // Input: A = [1,2,1,2,3], K = 2 // Output: 7 // Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. // // 子数组里面有 k 个不同的数字 // // 解法参考了 // https://leetcode.</description>
    </item>
    
    <item>
      <title>2、3、4个数之和</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sum/</guid>
      <description>2、3、4个数之和 从 nums 数组中找到数字相加的结果符合要求的几个数字。
两数之和 import java.util.HashMap; import java.util.Map; // 返回索引 // // O(N) public class TwoSum { public int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { if (map.containsKey(target - nums[i])) { return new int[]{ map.get(target - nums[i]), i }; } map.put(nums[i], i); } return new int[]{}; } } 三个数之和 import java.util.List; import java.util.LinkedList; import java.util.ArrayList; import java.</description>
    </item>
    
    <item>
      <title>子数组的最小值之和</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sumofsubarrayminimums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sumofsubarrayminimums/</guid>
      <description>子数组的最小值之和 描述 原题 给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。
由于答案可能很大，因此返回答案模 10^9 + 7。
示例：
输入：[3,1,2,4]输出：17解释：子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。题解 import java.util.Stack; // // 连续子数组里面的最小值 min 相加的和 // [3,1,2,4]: // // [3][1][2][4][3,1][1,2][2,4][3,1,2][1,2,4][3,1,2,4] // public class SumofSubarrayMinimums { public int sumSubarrayMins(int[] A) { Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;(); // ==========================================  // 最左侧，第一个比 A[i] 小的值  // ==========================================  int[] leftMin = new int[A.length]; for (int i = 0; i &amp;lt; A.</description>
    </item>
    
    <item>
      <title>第三大的数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/thirdmaximumnumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/thirdmaximumnumber/</guid>
      <description>第三大的数 描述 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是 O(n)。
示例 1:
输入: [3, 2, 1]输出: 1解释: 第三大的数是 1.题解 // 返回第三大，如果不存在，返回最大的 // // Input: [3, 2, 1] // Output: 1 // Explanation: The third maximum is 1. // // Input: [2, 2, 3, 1] // Output: 1 // Explanation: Note that the third maximum here means the third maximum distinct number. // Both numbers with value 2 are both considered as second maximum. // // https://leetcode.</description>
    </item>
    
    <item>
      <title>前K大数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/topklargestnumbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/topklargestnumbers/</guid>
      <description>前K大数 描述 原题 在一个数组中找到前K大的数
题解 // https://www.lintcode.com/problem/top-k-largest-numbers/description // // Input: [3, 10, 1000, -99, 4, 100] and k = 3 // Output: [1000, 100, 10] import java.util.*; public class TopkLargestNumbers { public int[] topk(int[] nums, int k) { PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Integer&amp;gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); } }); for (int num: nums) { queue.offer(num); if (queue.size() &amp;gt; k) { queue.poll(); } } // addFirst();  // addLast();  // removeFirst();  // removeLast();  int[] res = new int[queue.</description>
    </item>
    
    <item>
      <title>有效的山脉数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/validmountainarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/validmountainarray/</guid>
      <description>有效的山脉数组 原题 给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。
让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：
 A.length &amp;gt;= 3 在 0 &amp;lt; i &amp;lt; A.length - 1 条件下，存在 i 使得：  A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]    题解 // https://leetcode.com/problems/valid-mountain-array/ // // (1) A.length &amp;gt;= 3 // (2) There exists some i with 0 &amp;lt; i &amp;lt; A.length - 1 such that: // A[0] &amp;lt; A[1] &amp;lt; .</description>
    </item>
    
    <item>
      <title>有效的数独</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/validsudoku/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/validsudoku/</guid>
      <description>有效的数独 描述 原题 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。  题解 import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; // https://leetcode.com/problems/valid-sudoku/ // // public class ValidSudoku { public boolean isValidSudoku(char[][] board) { int m = board.length; int n = board[0].length; Map&amp;lt;Integer, Set&amp;lt;Integer&amp;gt;&amp;gt; rowMap = new HashMap&amp;lt;&amp;gt;(); Map&amp;lt;Integer, Set&amp;lt;Integer&amp;gt;&amp;gt; colMap = new HashMap&amp;lt;&amp;gt;(); // 1 2 3  // 4 5 6  // 7 8 9  Map&amp;lt;Integer, Set&amp;lt;Integer&amp;gt;&amp;gt; smallBoxMap = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { char c = board[i][j]; if (c == &amp;#39;.</description>
    </item>
    
    <item>
      <title>有效三角形的个数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/validtrianglenumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/validtrianglenumber/</guid>
      <description>有效三角形的个数 描述 原题 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。
示例 1:
输入: [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3题解 import java.util.Arrays; // 给定一个包含非负整数的数组，你的任务是计算从数组中选出的可以制作三角形的三元组数目，如果我们把它们作为三角形的边长。 // 非负 // // https://www.lintcode.com/problem/valid-triangle-number/description // public class ValidTriangleNumber { // ERROR: O(n ^ 2)，错误解法  public int triangleNumber(int[] nums) { // a + b &amp;gt; c  // c &amp;lt; a + b  //  // 1 2 3 4  Arrays.sort(nums); int count = 0; // 2 2 3 4  // ↑  // 2, 2, 4  // 2, 3, 4  // 2, 3, 4  // 2, 2, 3  for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/combinationsum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/combinationsum/</guid>
      <description>组合总和 下属题目，所有数字均是正整数
Combination Sum 原题 一个数组，从这个数组中找出所有相加等于 target 的元素的组合，数组中的每一个数字可以被多次重复选取。
 数组无重复数字。
 import java.util.ArrayList; import java.util.List; // Input: candidates = [2,3,5], target = 8, // A solution set is: // [ // [2,2,2,2], // [2,3,3], // [3,5] // ] // // candidates 里面没有重复数字 // 每一个 candidate 可以重复使用多次 // // 时间复杂度可以转为，见这个帖子分析 // https://leetcode.com/problems/combination-sum/discuss/16634/if-asked-to-discuss-the-time-complexity-of-your-solution-what-would-you-say // // 每个元素有 ceil(target / element) 个 // 展开后的数组个数为 n&amp;#39; = ceil(target / element) * n // 最后时间复杂度为 O(k * 2 ^ n&amp;#39;) // public class CombinationSum { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); helper(candidates, res, new ArrayList&amp;lt;Integer&amp;gt;(), 0, 0, target); return res; } private void helper(int[] candidates, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res, List&amp;lt;Integer&amp;gt; cur, int curSum, int index, int target) { if (curSum &amp;gt; target) { return; } if (curSum == target) { res.</description>
    </item>
    
    <item>
      <title>组合</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/combinations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/combinations/</guid>
      <description>组合 描述 原题 给定两个整数 n 和 k，返回 1 &amp;hellip; n 中所有可能的 k 个数的组合。
示例:
输入: n = 4, k = 2输出:[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]题解 import java.util.ArrayList; import java.util.List; // Input: n = 4, k = 2 // Output: // [ // [2,4], // [3,4], // [2,3], // [1,2], // [1,3], // [1,4], // ] // // 时间复杂度看起来像是 C(n, k)，从 n 个数里面选择 k 个 // 所以总的时间复杂度为 C(n, k) * O(k) public class Combinations { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int[] array = buildArray(n); helper(res, new ArrayList&amp;lt;Integer&amp;gt;(), array, k, 0); return res; } private void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res, List&amp;lt;Integer&amp;gt; cur, int[] array, int k, int begin) { // Base Case  // 得到之后，需要花费 O(K) 来拷贝结果到 res 里面  //  if (cur.</description>
    </item>
    
    <item>
      <title>为运算表达式设计优先级</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/differentwaystoaddparentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/differentwaystoaddparentheses/</guid>
      <description>为运算表达式设计优先级 描述 原题 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。
输入: &amp;quot;2-1-1&amp;quot;输出: [0, 2]解释: ((2-1)-1) = 0 (2-(1-1)) = 2 头条面试题
 题解 import java.util.LinkedList; import java.util.List; // 头条面试题 // // https://leetcode.com/problems/different-ways-to-add-parentheses/ // Input: &amp;#34;2*3-4*5&amp;#34; // Output: [-34, -14, -10, -10, 10] // Explanation: // (2*(3-(4*5))) = -34 // ((2*3)-(4*5)) = -14 // ((2*(3-4))*5) = -10 // (2*((3-4)*5)) = -10 // (((2*3)-4)*5) = 10 // // 只有 +、- 和 * // // 有几种不同的结果 public class DifferentWaysToAddParentheses { public List&amp;lt;Integer&amp;gt; diffWaysToCompute(String input) { List&amp;lt;Integer&amp;gt; ret = new LinkedList&amp;lt;Integer&amp;gt;(); for (int i = 0; i &amp;lt; input.</description>
    </item>
    
    <item>
      <title>快算 24</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/game24/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/game24/</guid>
      <description>快算 24 描述 原题 你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。
题解 import java.util.ArrayList; // Input: [4, 1, 8, 7] // Output: True // Explanation: (8-4) * (7-1) = 24 // // https://leetcode.com/articles/24-game/ public class Game24 { public boolean judgePoint24(int[] nums) { ArrayList A = new ArrayList&amp;lt;Double&amp;gt;(); for (int v: nums) { A.add((double) v); } return solve(A); } private boolean solve(ArrayList&amp;lt;Double&amp;gt; nums) { if (nums.size() == 0) return false; if (nums.</description>
    </item>
    
    <item>
      <title>生成括号对</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/generateparentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/generateparentheses/</guid>
      <description>生成括号对 描述 原题 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
输入：n = 3输出：[&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;]题解 import java.util.LinkedList; import java.util.List; // 时间复杂度，总的括号对个数是 Catalan number 个 // O(C(2n, n) / (n + 1)) // public class GenerateParentheses { public List&amp;lt;String&amp;gt; generateParenthesis(int n) { List&amp;lt;String&amp;gt; res = new LinkedList&amp;lt;&amp;gt;(); helper(res, &amp;#34;&amp;#34;, 0, 0, n); return res; } private void helper(List&amp;lt;String&amp;gt; res, String cur, int open, int close, int n) { if (open == n &amp;amp;&amp;amp; close == n) { res.</description>
    </item>
    
    <item>
      <title>字母大小写全排列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/lettercasepermutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/lettercasepermutation/</guid>
      <description>字母大小写全排列 描述 给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。
题解 import java.util.ArrayList; import java.util.List; // Examples: // Input: S = &amp;#34;a1b2&amp;#34; // Output: [&amp;#34;a1b2&amp;#34;, &amp;#34;a1B2&amp;#34;, &amp;#34;A1b2&amp;#34;, &amp;#34;A1B2&amp;#34;]  // Input: S = &amp;#34;3z4&amp;#34; // Output: [&amp;#34;3z4&amp;#34;, &amp;#34;3Z4&amp;#34;]  // Input: S = &amp;#34;12345&amp;#34; // Output: [&amp;#34;12345&amp;#34;] // // 假设字符串中包含 k 个需要转的字符 // 那么总共有 2 ^ k 个状态，base case 需要拷贝，那么就是 O(n) // 所以复杂度为 O(n * 2^k) public class LetterCasePermutation { public List&amp;lt;String&amp;gt; letterCasePermutation(String S) { List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); helper(res, S.</description>
    </item>
    
    <item>
      <title>电话号码的字母组合</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/lettercombinationsofaphonenumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/lettercombinationsofaphonenumber/</guid>
      <description>电话号码的字母组合 描述 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
题解 import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; // 时间复杂度为 O(3 ^ N * 4 ^ M) 次方个 // // 每一个数有 3 种选法的有 N 个 // 每一个数有 4 种选法的有 M 个 // public class LetterCombinationsofaPhoneNumber { static Map&amp;lt;Character, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); static { map.put(&amp;#39;2&amp;#39;, &amp;#34;abc&amp;#34;); map.put(&amp;#39;3&amp;#39;, &amp;#34;def&amp;#34;); map.put(&amp;#39;4&amp;#39;, &amp;#34;ghi&amp;#34;); map.put(&amp;#39;5&amp;#39;, &amp;#34;jkl&amp;#34;); map.put(&amp;#39;6&amp;#39;, &amp;#34;mno&amp;#34;); map.put(&amp;#39;7&amp;#39;, &amp;#34;pqrs&amp;#34;); map.put(&amp;#39;8&amp;#39;, &amp;#34;tuv&amp;#34;); map.put(&amp;#39;9&amp;#39;, &amp;#34;wxyz&amp;#34;); } public List&amp;lt;String&amp;gt; letterCombinations(String digits) { List&amp;lt;String&amp;gt; res = new LinkedList&amp;lt;&amp;gt;(); if (digits == null || digits.</description>
    </item>
    
    <item>
      <title>N 皇后</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/nqueues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/nqueues/</guid>
      <description>N 皇后 描述 原题 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
题解 import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.List; public class NQueues { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueens(int n) { char[][] grid = new char[n][n]; for (int i = 0; i &amp;lt; n; i++) { Arrays.fill(grid[i], &amp;#39;.&amp;#39;); } List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(); helper(res, grid, 0, n); return res; } // 方法是对于固定的列 colIndex，依次试探第 0 1 2 ... n 行，然后看是否 OK，如果 OK，试探 colIndex + 1 列  // colIndex == n 的时候，就可以返回了  private void helper(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res, char[][] grid, int colIndex /** 对于固定的列 */, int n) { if (colIndex == n) { res.</description>
    </item>
    
    <item>
      <title>二叉搜索树中删除一个节点</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/delete-node-in-bst/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/delete-node-in-bst/</guid>
      <description>二叉搜索树中删除一个节点  微软
 // https://leetcode.com/problems/delete-node-in-a-bst/ // // 微软面试题 // // 这道题的删除节点，就是把这个节点所有的孩子都给删除了 public class DeleteNodeinaBST { public TreeNode deleteNode(TreeNode root, int key) { // ================  // search the node  // ================  TreeNode curr = root; TreeNode predecessor = null; // 我们是从 root 的 left 树进去的吗?  boolean left = false; while (curr != null) { if (curr.val == key) { break; } else if (curr.val &amp;gt; key) { predecessor = curr; curr = curr.</description>
    </item>
    
    <item>
      <title>二叉搜索树中新增一个节点</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/insert-into-bst/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/insert-into-bst/</guid>
      <description>二叉搜索树中新增一个节点  微软
 // https://leetcode.com/problems/insert-into-a-binary-search-tree/ // 保证二叉树原来没有值为 val 的节点 // // 微软面试题 public class InsertintoaBinarySearchTree { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode backupRoot = root; TreeNode predecessor = null; while (root != null) { predecessor = root; if (root.val &amp;gt; val) { root = root.left; } else if (root.val &amp;lt; val) { root = root.right; } } if (predecessor.</description>
    </item>
    
    <item>
      <title>二叉树的直径</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/diameter-of-binary-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/diameter-of-binary-tree/</guid>
      <description>二叉树的直径  微软
 // https://leetcode.com/problems/diameter-of-binary-tree/ // // 二叉树的直径 // // Given a binary tree // 1 // / \ // 2 3 // / \ // 4 5 // Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. public class DiameterofBinaryTree { public int diameterOfBinaryTree(TreeNode root) { if (root == null) { return 0; } int rootDiameter = depth(root.left) + depth(root.right); int leftDiameter = diameterOfBinaryTree(root.left); int rightDiameter = diameterOfBinaryTree(root.</description>
    </item>
    
    <item>
      <title>中序遍历的下一个节点</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/next-node-of-inorder-traverse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/next-node-of-inorder-traverse/</guid>
      <description>中序遍历的下一个节点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
// https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e // // 牛客网 // 二叉树中包含指向父节点的指针 next public class NextNodeOfBinaryTree { public TreeLinkNode GetNext(TreeLinkNode pNode) { if (pNode == null) { return null; } // 1  // 2 3  // 4 5 6 7  // 8 9  if (pNode.right != null) { // 2 的下一个节点:  //  // 如果 8 存在，那么最终是 8  // 如果 8 不存在，那么最终是 5  TreeLinkNode p = pNode.</description>
    </item>
    
    <item>
      <title>二叉树最大路径和</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-maximum-path-sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-maximum-path-sum/</guid>
      <description>二叉树最大路径和 解法一 // // 从树的任何一个节点开始，到任何一个节点结束，路径和最长 // 至少包含一个节点 // // Hard 级别 // public class BinaryTreeMaximumPathSum { int result = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { helper(root); return result; } private int helper(TreeNode root) { if (root == null) { return 0; } int left = helper(root.left); int right = helper(root.right); // - 只选择 root  // - 选择 root + left  // - 选择 root + right  // - 为什么没有 left ?</description>
    </item>
    
    <item>
      <title>二叉树非递归中序遍历</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-inorder-traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-inorder-traversal/</guid>
      <description>二叉树非递归中序遍历 public class BinaryTreeInorderTraversal { public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) { if (root == null) { return Collections.emptyList(); } List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); TreeNode curr = root; // 1  // / \  // 2 3  // / \  // 4 5  // / \  // 6 7  //  // 4 2 6 5 7 1 3  while (true) { // =========================  // 这个地方容易出错：  //  // stack.</description>
    </item>
    
    <item>
      <title>二叉树的公共祖先</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>二叉树的公共祖先 二叉树的公共祖先 // 所有 NODE 节点的值都是唯一的 // p 和 q 一定存在于二叉树里面 public class LowestCommonAncestorofaBinaryTree { // =========================  // 这个方法最优  // =========================  public TreeNode lowestCommonAncestor0(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;amp;&amp;amp; right != null) { return root; } return left !</description>
    </item>
    
    <item>
      <title>一颗二叉树是否是另外一颗的子树</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/is-subtree-another-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/is-subtree-another-tree/</guid>
      <description>一颗二叉树是否是另外一颗的子树 // O(N^2) public class SubtreeOfAnotherTree { public boolean isSubtree(TreeNode s /** root tree */, TreeNode t /** sub tree */) { return isSameTree(s, t) || (s != null ? (isSubtree(s.left, t) || isSubtree(s.right, t)) : false); } private boolean isSameTree(TreeNode a, TreeNode b) { if (a == null &amp;amp;&amp;amp; b == null) { return true; } if (a == null || b == null) { return false; } if (a.</description>
    </item>
    
    <item>
      <title>WordLadder</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/word-ladder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/word-ladder/</guid>
      <description>WordLadder  微软、阿里巴巴
 // 常见面试题 // 阿里巴巴、微软都问过 // https://leetcode.com/problems/word-ladder/ // public class WordLadder { // Runtime: 135 ms, faster than 39.64% of Java online submissions for Word Ladder.  public int ladderLength(String beginWord, String endWord, List&amp;lt;String&amp;gt; wordList) { Set&amp;lt;String&amp;gt; wordSet = new HashSet&amp;lt;&amp;gt;(wordList); if (!wordSet.contains(endWord)) { return 0; } Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.offer(beginWord); int level = 0; while (!queue.isEmpty()) { level++; int size = queue.size(); for (int i = 0; i &amp;lt; size; i++) { String curr = queue.</description>
    </item>
    
    <item>
      <title>二维数组寻找最长的单调递增序列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/longest-increasing-path-in-a-matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/longest-increasing-path-in-a-matrix/</guid>
      <description>二维数组寻找最长的单调递增序列  微软
 // Input: nums = // [ // [9,9,4], // [6,6,8], // [2,1,1] // ] // Output: 4 // Explanation: The longest increasing path is [1, 2, 6, 9]. // // 微软面试题: 二维数组寻找最长的单调递增序列 // // =========================== // 时间复杂度分析: // 每个单元格，尝试它的四个相邻单元格 // 每个单元格都当做起始单元格，使用一个 Cache 来存储结果 // O(M * N) // =========================== public class LongestIncreasingPathinaMatrix { public int longestIncreasingPath(int[][] matrix) { if (matrix.length == 0) { return 0; } int[][] cached = new int[matrix.</description>
    </item>
    
    <item>
      <title>PancakeSorting</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/pancake-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/pancake-sorting/</guid>
      <description>PancakeSorting 煎饼排序  微软
 // 微软面试题 // https://leetcode.com/problems/pancake-sorting/ // // https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;amp;tid=518795&amp;amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D327%26sortid%3D327 // 给出算法题，完成一个只能flip subarray的sort功能。 // 然后面试官提示看代码XX行，可以优化。 然后在她的提示下进行了两次优化。 // 然后要写flip的功能，时间来不及了，就匆匆用python的 reverse()完成了个简单的flip。 // 然后面试官说能不能不用reverse，我说可以，用forloop和stack就行了。她说可以用swap。 // 然后说时间到了，问我有没有想问的，我就问了能不能有更快的算法完成这个sort，她说没有了。 // // 看起来 flip 的意思是指只能从 0 ~ index 的位置整体翻转 // // Any valid answer that sorts the array within 10 * A.length flips will be judged as correct. // A[i] is a permutation of [1, 2, ..., A.length] public class PancakeSorting { public List&amp;lt;Integer&amp;gt; pancakeSort(int[] A) { List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int end = A.</description>
    </item>
    
    <item>
      <title>堆排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/heap-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/heap-sort/</guid>
      <description>堆排序 // - 建堆，不同节点运行 heapify 的时间与节点所处的高度相关 // https://www.cnblogs.com/LzyRapx/p/9565305.html // // 树高 h = lgn // // 第 0 层，只有根节点，它需要最多向下调整 h * 2^0 次 // 第 1 层，有 2 个节点，它需要向下调整 (h - 1) * 2^1 次 // 第 2 层，有 4 个节点，它需要向下调整 (h - 2) * 2^2 次 // // 第 h 层，有 2^h 个节点，它需要向下调整 (h - h) * 2^h 次 // // O(n) = h * 2^0 + (h - 1) * 2^1 + (h - 2) * 2^2 + .</description>
    </item>
    
    <item>
      <title>链表归并排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/linkedlist-mergesort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/linkedlist-mergesort/</guid>
      <description>链表归并排序 // ============================= // MergeSort // // 切分为三部分: // - small // - equal // - large // ============================= public class SortList { public ListNode sortList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode lessOrEqualThanPivot = new ListNode(-1); ListNode pivot = head; ListNode greatThanPivot = new ListNode(-1); ListNode equalPivot = new ListNode(-1); ListNode p = head; ListNode pLess = lessOrEqualThanPivot; ListNode pGreat = greatThanPivot; ListNode pEqual = equalPivot; while (p !</description>
    </item>
    
    <item>
      <title>快排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/quicksort/</guid>
      <description>快排序 // T(n) = T(n - 1) + T(0)，每次都分为 n - 1 个和 0 个元素 // T(n - 1) = T(n - 2) + T(0) // ... // 迭代想加 // T(n) = O(n^2) // // - 最坏情况: // T(n) = 2T(n / 2) + O(n) // T(n / 2) = 2T(n / 4) + O(n) // // 画出树，整颗树高 log2^n 然后每次都是 O(n) 所以 nlogn // // n.................O(n) // n/2 n/2.............O(n) // n/4 n/4 n/4 n/4.</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/mergesort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/mergesort/</guid>
      <description>归并排序 public class MergeSort { public void sort(int[] array) { sort(array, 0, array.length - 1); } private void sort(int[] array, int begin, int end) { if (end &amp;gt; begin) { int middle = begin + ((end - begin) &amp;gt;&amp;gt; 1); // ===========================  // begin ~ middle  // ===========================  sort(array, begin, middle); // ===========================  // middle + 1 ~ end  // ===========================  sort(array, middle + 1, end); merge(array, begin, middle, end); } } private void merge(int[] array, int begin, int middle, int end) { int[] temp = new int[end - begin + 1]; int i = begin; int j = middle + 1; int k = 0; while (i &amp;lt;= middle &amp;amp;&amp;amp; j &amp;lt;= end) { if (array[i] &amp;lt; array[j]) { temp[k++] = array[i++]; } else { temp[k++] = array[j++]; } } while (i &amp;lt;= middle) { temp[k++] = array[i++]; } while (j &amp;lt;= end) { temp[k++] = array[j++]; } k = 0; while (k &amp;lt; temp.</description>
    </item>
    
    <item>
      <title>栈排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sort-stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sort-stack/</guid>
      <description>栈排序 // 美团面试题: https://www.nowcoder.com/discuss/268612?type=2&amp;amp;order=0&amp;amp;pos=49&amp;amp;page=1 public class SortStack { public static void stackSorting(Stack&amp;lt;Integer&amp;gt; stack) { Stack&amp;lt;Integer&amp;gt; t = new Stack&amp;lt;&amp;gt;(); while(!stack.isEmpty()) { int item = stack.pop(); while(!t.isEmpty() &amp;amp;&amp;amp; t.peek() &amp;gt; item) stack.push(t.pop()); t.push(item); } while(!t.isEmpty()) stack.push(t.pop()); } } </description>
    </item>
    
    <item>
      <title>磁盘多路归并排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/disk-merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/disk-merge-sort/</guid>
      <description>磁盘多路归并排序 // 磁盘多路归并排序 // https://mp.weixin.qq.com/s?__biz=MzI0MzQyMTYzOQ==&amp;amp;mid=2247484900&amp;amp;idx=1&amp;amp;sn=a120748f4c1229dbb851732e4cd5f47c&amp;amp;pass_ticket=TEG93hpjf7gdkxzIPcHay9NH%2FprQkpCtcZYYI4NcTDeNiCpFQAsK%2Bh4x9M1mviQ8 // // 1 2 3 4 5 (文件 1 2 3 4 5) // ---------- // 2 5 5 7 12 // 3 6 5 8 13 // 4 6 6 9 13 // // 内存中维护的数组变化，方括号内代表这个数字属于哪个文件 // 2[1] 5[2] 5[3] 7[4] 12[5] // 3[1] 5[2] 5[3] 7[4] 12[5] // 4[1] 5[2] 5[3] 7[4] 12[5] // 5[2] 5[3] 6[2] 7[4] 12[5] // 5[3] 6[2] 6[2] 7[4] 12[5] // .</description>
    </item>
    
    <item>
      <title>求解逆波兰表达式</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/evaluate-reverse-polish-notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/evaluate-reverse-polish-notation/</guid>
      <description>求解逆波兰表达式 - 写一个计算器  微软
 // https://leetcode.com/problems/evaluate-reverse-polish-notation/submissions/ // // Input: [&amp;#34;2&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;+&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;*&amp;#34;] // Output: 9 // Explanation: ((2 + 1) * 3) = 9 // // Input: [&amp;#34;4&amp;#34;, &amp;#34;13&amp;#34;, &amp;#34;5&amp;#34;, &amp;#34;/&amp;#34;, &amp;#34;+&amp;#34;] // Output: 6 // Explanation: (4 + (13 / 5)) = 6 // // 微软面试题: 写一个计算器 // 这个原题，给你的已经是一个逆波兰表达式了 public class EvaluateReversePolishNotation { public int evalRPN(String[] tokens) { Stack&amp;lt;Integer&amp;gt; numStack = new Stack&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; tokens.</description>
    </item>
    
    <item>
      <title>MinStack</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/minstack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/minstack/</guid>
      <description>MinStack 使用两个栈 // 使用了两个栈 // 占用内存大 // // 使用一个栈的解法见 MinStack_Solution_1.java public class MinStack { private Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;(); private Stack&amp;lt;Integer&amp;gt; minStack = new Stack&amp;lt;Integer&amp;gt;(); /** initialize your data structure here. */ public MinStack() { } public void push(int x) { stack.push(x); if (minStack.isEmpty()) { minStack.push(x); } else { minStack.push(x &amp;lt; minStack.peek() ? x : minStack.peek()); } } public void pop() { stack.pop(); minStack.pop(); } public int top() { return stack.</description>
    </item>
    
    <item>
      <title>找出最多 K 个不同字符的最长子串</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/longest-substring-with-at-most-k-distinct-characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/longest-substring-with-at-most-k-distinct-characters/</guid>
      <description>找出最多 K 个不同字符的最长子串  微软、网易
 // https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/description // 网易 // 微软面试题 // // 给定字符串S，找到最多有k个不同字符的最长子串 T // // 输入: S = &amp;#34;eceba&amp;#34; 并且 k = 3 // 输出: 4 // 解释: T = &amp;#34;eceb&amp;#34; public class LongestSubstringwithAtMostKDistinctCharacters { public int lengthOfLongestSubstringKDistinct(String s, int k) { if (k == 0 || s.length() == 0) { return 0; } Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int longest = 0; int right = 0; int left = 0; while (right &amp;lt; s.</description>
    </item>
    
    <item>
      <title>两个字符串整数相加</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/add-strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/add-strings/</guid>
      <description>两个字符串整数相加  微软
 // https://leetcode.com/problems/add-strings/ // 没有 leading zeros // 微软面试题 public class AddStrings { // 1 2 3 4  // 7 8 9  public String addStrings(String num1, String num2) { if (num1 == null) { return num2; } if (num2 == null) { return num1; } final StringBuilder sb = new StringBuilder(Math.max(num1.length(), num2.length()) + 1); int index1 = num1.length() - 1; int index2 = num2.length() - 1; int remainder = 0; while (index1 &amp;gt;= 0 &amp;amp;&amp;amp; index2 &amp;gt;= 0) { char a = num1.</description>
    </item>
    
    <item>
      <title>二维矩阵数值和最小的路径</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/minimum-path-sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/minimum-path-sum/</guid>
      <description>二维矩阵数值和最小的路径  微软
 // 微软面试题: 二维矩阵，没有负值，找出从左上角到右下角，使得路径上的数值和最小的路径 // https://leetcode.com/problems/minimum-path-sum/ // public class MinimumPathSum { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] minSum = new int[m][n]; minSum[0][0] = grid[0][0]; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (i == 0 &amp;amp;&amp;amp; j == 0) { continue; } if (i - 1 &amp;lt; 0) { minSum[i][j] = minSum[i][j - 1] + grid[i][j]; } else if (j - 1 &amp;lt; 0) { minSum[i][j] = minSum[i - 1][j] + grid[i][j]; } else { // =======================  // 这一个公式就可以了  // =======================  minSum[i][j] = Math.</description>
    </item>
    
    <item>
      <title>最小火车票费用</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/minimum-cost-for-tickets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/minimum-cost-for-tickets/</guid>
      <description>最小火车票费用 // 亚马逊电面 // 最小火车票费用 // // 一年有 365 天，第一天编号为 1 // days = [1,4,6,7,8,20] 你的旅游时间必须覆盖到1、4、6、... // costs = [2,7,15] 旅游有 1 日游、7 日游、30 日游 // 问覆盖到所有天数的最小 cost // // https://leetcode.com/problems/minimum-cost-for-tickets/ public class MinimumCostForTickets { public int mincostTickets(int[] days, int[] costs) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; days.length; i++) { set.add(days[i]); } int[] dp = new int[366]; for (int i = 1; i &amp;lt; 366; i++) { if (!</description>
    </item>
    
    <item>
      <title>最长递增子序列 (LIS)</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/lis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/lis/</guid>
      <description>最长递增子序列 (LIS) 方法一 // 未排序 // [10,9,2,5,3,7,101,18] =&amp;gt; [2,3,7,101], length = 4 public class LongestIncreasingSubsequence { public int lengthOfLIS(int[] array) { if (array.length == 0) { return 0; } // [10,9,2,5,3,7,101,18]  // 1(10)  // 1(9)  // 1(2)  // 2(5)  // 2(3)  // 3(7)  // 4(101)  // 4(18)  //  // 每个长度 i + 1 的最小值  // 这是一个有序序列  int[] lisLength = new int[array.</description>
    </item>
    
    <item>
      <title>链表是否有环</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/linkedlist-has-cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/linkedlist-has-cycle/</guid>
      <description>链表是否有环  微软
 // https://leetcode.com/problems/linked-list-cycle/discuss/44669/Fully-Explained!-why-fast-and-slow-can-meet-in-the-cycle // https://www.cnblogs.com/wuyuegb2312/p/3183214.html // // 解释: 为什么快指针、慢指针能够相遇 // // 在任意时刻，p1 和 p2都在环上。由于 p1 每次向前 1 步，p2 每次向前两步， // 用相对运动的观点来看，把 p1 看作静止，那么 p2 每次相对 p1 向前 1 步， // 二者在顺时针方向上的距离每经过一个时刻就减少 1，直到变为 0，也即二者恰好相遇。 // 这样就证明了在离散情况下，对于有环链表，二者也是必然在某一时刻相遇在某个节点上的。 public class LinkedListCycle { public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode slower = head; ListNode faster = head.next; while (slower != null &amp;amp;&amp;amp; faster != null) { if (slower == faster) { return true; } slower = slower.</description>
    </item>
    
    <item>
      <title>找出链表环的入口节点</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/find-linkedlist-cycle-start-node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/find-linkedlist-cycle-start-node/</guid>
      <description>找出链表环的入口节点  微软
 // 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 // ↑_________| // // 假设链表长度为 L = 4 // 假设环长度为 C = 3 // 假设相遇时的点，距离环的入口 [逆时针顺序] 长度为 K // // 最终相遇: // - 快指针走了 L + m * C + K 步骤 // - 慢指针走了 L + n * C + K 步骤 // // L + m * C + K = 2 * (L + n * C + K) // // 化简得到 m * C = L + 2n * C + K // 化简得到 (m - 2n) * C = L + K // 化简得到 K = (m - 2n) * C - L = n&amp;#39; * C - L // // 即 K 是常数 // // 此时，相遇点 K 的位置是 n&amp;#39; * C - L，它再走 L 步就能到链表入口处 // 而此时慢指针从头开始走，也需要 L 步才能到链表入口处，所以这个是可以找到入口的 // // 还有就是如下这个代码，faster 从头开始移动 C 个，因为总长度是 L + C 个，所以全程还剩余 L 个 // 慢指针也需要走 L 步，所以还是会相遇 public class LinkedListCycle2 { public ListNode detectCycle(ListNode head) { // 是否有环  ListNode meetNode = hasCycle(head); if (meetNode == null) { return null; } // 求出环的个数  int cycleLen = lengthOfCycle(meetNode); // 先移动 cycleLen 个  ListNode faster = head; while (cycleLen &amp;gt; 0) { faster = faster.</description>
    </item>
    
    <item>
      <title>5 个线程读 1 个线程写</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/5-read-1-write/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/5-read-1-write/</guid>
      <description>5 个线程读 1 个线程写  微软
 /** * 微软三面面试题: * * - 一个线程写，如果 5 个读线程没有读完，那么等待 * - 5 个线程【同时】读，如果已经读过，那么等待 * * @author zk */ public class ReaderWriter { public static void main(String[] args) { final int READ_COUNT = 5; final ReaderWriter rw = new ReaderWriter(READ_COUNT); Thread writer = new Thread(new Runnable() { @Override public void run() { AtomicInteger atomicInteger = new AtomicInteger(); while (true) { rw.write(atomicInteger.getAndIncrement()); } } }); writer.</description>
    </item>
    
  </channel>
</rss>
