<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/docs/programmer-interview/algorithm/</link>
    <description>Recent content in 算法 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://kunzhao.org/docs/programmer-interview/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/</guid>
      <description>Best Time to Buy and Sell Stock 题目 LeetCode 地址：Best Time to Buy and Sell Stock
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行一次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 这道题有两个简单做法：状态机和动态规划。
使用状态机的做法的好处是，这种思路可以延续到其它几个买卖股票的问题上。关键是要想清楚，某一天有几种状态，在这道题是三种：
 状态 s0: 不买也不卖，无操作。s0 的值只能有一个来源，就是和昨天保持一致，不买也不卖 状态 s1: 买入了股票。s1 的值有两个来源：1. 与昨天一致，即已经买入了，且只能买一次，所以不能再买了，s1 = s1；2. 买入今天的股票，花了 price[i] 钱，s1 = s0 - price[i] 状态 s2: 卖出了股票。s2 的值有两个来源：1. 之前已经卖出了，所以维持卖出状态，不能再次卖了，s2 = s1；2. 卖出之前买入的股票，挣 price[i] 钱，s2 = s1 + price[i]  所以，我们可以得到如下状态转移关系：
 s0 = s0 s1 = s1 s1 = s0 - price[i] s2 = s2 s2 = s1 + price[i]  在这整个过程中，我们都要保证每一天的 s0、s1、s2 都是 max 状态，s2 是最终卖完后的收益，所以返回这个结果就行。</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅱ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/</guid>
      <description>Best Time to Buy and Sell Stock Ⅱ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅱ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你可以进行无限次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 这道题就一个想法，只要今天 price[i] 比昨天 price[i - 1] 的价格涨了，就可以算作是有效的利润，累加到最后的结果中。
答案 // 假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。 // 设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。 // 然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。 // // https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-ii/description public class BestTimetoBuyandSellStockII { public int maxProfit(int[] prices) { int max = 0; for (int i = 1; i &amp;lt; prices.length; i++) { int diff = prices[i] - prices[i - 1]; if (diff &amp;gt; 0) { max += diff; } } return max; } } 扫描下面二维码，在手机上阅读这篇文章：</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅲ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/</guid>
      <description>Best Time to Buy and Sell Stock Ⅲ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅲ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行两次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 参考 Best Time to Buy and Sell Stock 思路上状态机，状态机应用两次即可。
答案 // 最多两次交易 // 且不能同时持有，必须卖掉这个，然后持有另外一个 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ // public class BestTimetoBuyandSellStockIII { // Buy Sell Buy Sell  // s0 ----&amp;gt; s1 -----&amp;gt; s2 -----&amp;gt; s3 ------&amp;gt; s4 (end)  // ↑___| ↑__| ↑____| ↑___|  //  public int maxProfit(int[] prices) { if (prices == null || prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅳ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/</guid>
      <description>Best Time to Buy and Sell Stock Ⅳ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅳ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行K次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 参考 Best Time to Buy and Sell Stock 思路上状态机，状态机应用K次即可。
答案 // 最多交易 k 次 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ // public class BestTimetoBuyandSellStockIV { public int maxProfit(int k, int[] prices) { if (prices == null || prices.length &amp;lt;= 1 || k &amp;lt;= 0) { return 0; } if (k &amp;gt;= prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock With Cooldown</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Best Time to Buy and Sell Stock With Cooldown 题目 LeetCode 地址：Best Time to Buy and Sell Stock With Cooldown
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行任意次交易（某天买入一支股票，然后过几天卖掉），你卖出一只股票后，接下来的一天不能买，必须要到后天才能买。也就是说有冷静期1天。请问你能收获的最大利润是多少？
答案 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ // 交易任意多次，只不过 buy sell 之后的第二天必须 cooldown 隔天才能再次 buy // // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/240277/Java-solution-in-Chinese public class BestTimetoBuyandSellStockwithCooldown { public int maxProfit(int[] prices) { if (prices == null || prices.length &amp;lt;= 1) { return 0; } // 买入只能是从前天买入 buy[i] = sell[i - 2] - prices[i];  // 卖出可以昨天卖出 sell[i] = buy[i - 1] + prices[i];  int[] sell = new int[prices.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Best Time to Buy and Sell Stock with Transaction Fee  每次交易都需要交易费用
 // 可以交易任意多次 // 只不过每一次都有小费 // // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/160964/java-Using-State-Machine-like-stock-III public class BestTimetoBuyandSellStockwithTransactionFee { public int maxProfit(int[] prices, int fee) { if (prices == null || prices.length &amp;lt;= 1) { return 0; } int s0 = 0; int s1 = s0 - prices[0]; // 买入  for (int i = 1; i &amp;lt; prices.length; i++) { // 这两种状态都能转移到 s0 状态:  //  // s0 -&amp;gt; s0  // s1 卖出 -&amp;gt; s0  s0 = Math.</description>
    </item>
    
    <item>
      <title>Binary Search 二分搜索</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-search/</guid>
      <description>Binary Search // https://leetcode.com/problems/binary-search/ // public class BinarySearch { public int search(int[] nums, int target) { if (nums == null || nums.length == 0) { return -1; } int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] == target) { return m; } else if (nums[m] &amp;gt; target) { hi = m - 1; } else { lo = m + 1; } } return -1; } } </description>
    </item>
    
    <item>
      <title>Circular Array (循环数组)</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/circular-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/circular-array/</guid>
      <description>Circular Array 循环数组 来自一亩三分地，微软面试官问的问题。过去任意 1 秒内来自同一 IP 的请求是否超过 100 次，可以用循环数组可以做。
// // https://www.javaguides.net/2018/09/queue-implementation-using-circular-array-in-java.html // package com.zk.algorithm.array; /** * Queue Implementation using Circular Array * @author Ramesh Fadatare * */ public class CircularArray { // Array used to implement the queue.  private int[] queueRep; // 添加数据，存放在 (rear + 1) % size，size++  // 取出数据，(front + 1) % size，size--  private int size, front, rear; // Length of the array used to implement the queue.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/container-with-most-water/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/container-with-most-water/</guid>
      <description>Container With Most Water // 两个柱子中间包含最多的水 // 可以看一下这道题的这个图 // 这个是两个柱子之间的所能容纳的水的矩形面积 // // https://leetcode.com/problems/container-with-most-water/ // // [1,8,6,2,5,4,8,3,7] // ↑ ↑ // 7 * 7 = 49 // public class ContainerWithMostWater { public int maxArea(int[] height) { int maxArea = Integer.MIN_VALUE; int lo = 0; int hi = height.length - 1; // O(n)  while (lo &amp;lt; hi) { maxArea = Math.max(maxArea, Math.min(height[lo], height[hi]) * (hi - lo)); // =======================================  // 此处这个地方，必须是小的一边移动  // 因为大的移动的话，面积一定变小 (宽度变小，而且高度不会超过小的)  // 而小的移动有可能变大  //  // 另外一种解释：  // 我们选择一个高的，以便容纳更多的水  // https://leetcode.</description>
    </item>
    
    <item>
      <title>Count Of Smaller After Self</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/countofsmallerafterself/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/countofsmallerafterself/</guid>
      <description>Count Of Smaller After Self 题目 数组里面的每一个数字，排在这个数字后面的小于这个数字的有多少个数字
解法 import java.util.ArrayList; import java.util.List; // Input: [5,2,6,1] // Output: [2,1,1,0] // // 统计小于自己的有多少个数字 public class CountOfSmallerAfterSelf { public List&amp;lt;Integer&amp;gt; countSmaller(int[] nums) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int curr = nums[i]; int count = 0; for (int j = i + 1; j &amp;lt; nums.length; j++) { if (nums[j] &amp;lt; curr) { count++; } } result.</description>
    </item>
    
    <item>
      <title>设计循环队列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/designcircularqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/designcircularqueue/</guid>
      <description>Design Circular Queue 题目 设计循环队列
解法 public class DesignCircularQueue { static class MyCircularQueue { private int[] queue; private int frontIndex; private int rearIndex; private int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { this.size = k + 1; this.queue = new int[k + 1]; } /** Insert an element into the circular queue. Return true if the operation is successful.</description>
    </item>
    
    <item>
      <title>有序数组查找最小和最大元素的位置</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/</guid>
      <description>有序数组查找最小和最大元素的位置 public class FindFirstandLastPositionofElementinSortedArray { public int[] searchRange(int[] nums, int target) { int minIndex = searchMinIndex(nums, target); if (minIndex == -1) { return new int[]{ -1, -1 }; } int maxIndex = searchMaxIndex(nums, target); return new int[] { minIndex, maxIndex }; } private int searchMaxIndex(int[] nums, int target) { int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] &amp;gt; target) { hi = m - 1; } else if (nums[m] &amp;lt; target) { lo = m + 1; } else { if (m == nums.</description>
    </item>
    
    <item>
      <title>数据流寻找中位数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findmedianfromdatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findmedianfromdatastream/</guid>
      <description>数据流寻找中位数 import java.util.Comparator; import java.util.PriorityQueue; // https://leetcode.com/problems/find-median-from-data-stream/ // 剑指 Offer 41 题 // public class FindMedianfromDataStream { // 堆顶是最小的  // 最小堆的堆顶是最大值  //  private PriorityQueue&amp;lt;Integer&amp;gt; minQueue = new PriorityQueue&amp;lt;&amp;gt;(); // 堆顶是最大的  // 最大堆的堆顶是最小的值  private PriorityQueue&amp;lt;Integer&amp;gt; maxQueue = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Integer&amp;gt;() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); private boolean sameSize = true; public FindMedianfromDataStream() { } public void addNum(int num) { if (sameSize) { minQueue.</description>
    </item>
    
    <item>
      <title>旋转有序数组中寻找最小数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/</guid>
      <description>旋转有序数组中寻找最小数字 // 没有重复元素 // 1 2 3 4 5 6 7 // // 5 6 7 1 2 3 4 // lo hi // public class FindMinimuminRotatedSortedArray { public int findMin(int[] nums) { int lo = 0; // always point to 前半部分  int hi = nums.length - 1; // always point to 后半部分  if (nums[lo] &amp;gt; nums[hi]) { while (lo &amp;lt; hi) { if (hi - lo == 1) { return nums[hi]; } int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] &amp;lt; nums[0]) { // middle 位于后半部分  hi = m; } else if (nums[m] &amp;gt; nums[nums.</description>
    </item>
    
    <item>
      <title>寻找峰值元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findpeakelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findpeakelement/</guid>
      <description>寻找峰值元素 题目 你给出一个整数数组(size为n)，其具有以下特点：
 相邻位置的数字是不同的 A[0] &amp;lt; A[1] 并且 A[n - 2] &amp;gt; A[n - 1]  假定P是峰值的位置则满足A[P] &amp;gt; A[P-1]且A[P] &amp;gt; A[P+1]，返回数组中任意一个峰值的位置。
 数组保证至少存在一个峰 如果数组存在多个峰，返回其中任意一个就行 数组至少包含 3 个数   微软面试题
 解法 // https://www.lintcode.com/problem/find-peak-element/description // // Microsoft // A[P] &amp;gt; A[P-1] &amp;amp;&amp;amp; A[P] &amp;gt; A[P+1] public class FindPeakElement { // 返回的是索引  //  // 数组太大的话，会超时  public int findPeak(int[] A) { // [x,x,x,x,x]  int lo = 1; int hi = A.</description>
    </item>
    
    <item>
      <title>寻找重复数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findtheduplicatenumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findtheduplicatenumber/</guid>
      <description>寻找重复数字 // Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), // prove that at least one duplicate number must exist. // Assume that there is only one duplicate number, find the duplicate one. // // 1 到 n 的数字，某个数字重复，可能重复次数 &amp;gt; 1 // // Input: [3,1,3,4,2] // Output: 3 // // https://leetcode.com/problems/find-the-duplicate-number/ public class FindtheDuplicateNumber { // ==================================  // 数组不允许修改版本  //  // 剑指 Offer  // ==================================  public int findDuplicate(int[] nums) { int lo = 1; int hi = nums.</description>
    </item>
    
    <item>
      <title>第一个缺失的最小正数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/firstmissingpositive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/firstmissingpositive/</guid>
      <description>第一个缺失的最小正数 import java.util.ArrayList; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Set; // https://leetcode.com/problems/first-missing-positive/ // Given an unsorted integer array, find the smallest missing positive integer. // // Input: [3,4,-1,1] // Output: 2 // // Input: [7,8,9,11,12] // Output: 1 // public class FirstMissingPositive { // ===============================  // 不使用辅助空间  //  // 最核心的是，遇见哪些数字可以不用管:  // - 负数  // - 大于 nums.length 的数  // ===============================  public int firstMissingPositive(int[] nums) { int i = 0; while (i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>数据流的第一个唯一数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/firstuniquenumberindatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/firstuniquenumberindatastream/</guid>
      <description>数据流的第一个唯一数字 import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map; // https://www.lintcode.com/problem/first-unique-number-in-data-stream/description // // 给一个连续的数据流,写一个函数返回终止数字到达时的第一个唯一数字（包括终止数字）, // 如果在终止数字前无唯一数字或者找不到这个终止数字, 返回 -1. public class FirstUniqueNumberinDataStream { public int firstUniqueNumber(int[] nums, int number) { boolean hasStopNumber = false; HashMap&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int count= map.getOrDefault(nums[i], 0); map.put(nums[i], count + 1); if (nums[i] == number) { hasStopNumber = true; break; } } if (!hasStopNumber) { return -1; } for (Map.</description>
    </item>
    
    <item>
      <title>插入 Interval</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/insertinterval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/insertinterval/</guid>
      <description>插入 Interval import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; import com.zk.algorithm.beans.Interval; // Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] // Output: [[1,2],[3,10],[12,16]] // Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. public class InsertInterval { // 插入一个新的 interval  // 如果有交集，那么合并  public List&amp;lt;Interval&amp;gt; insert(List&amp;lt;Interval&amp;gt; intervals, Interval newInterval) { intervals.add(newInterval); Collections.sort(intervals, new Comparator&amp;lt;Interval&amp;gt;() { public int compare(Interval a, Interval b) { if (a.start &amp;lt; b.start) { return -1; } else if (a.</description>
    </item>
    
    <item>
      <title>数组交集</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/intersectionoftwoarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/intersectionoftwoarrays/</guid>
      <description>数组交集 方法一 // // Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] // Output: [9,4] // public class IntersectionofTwoArrays { public int[] intersection(int[] nums1, int[] nums2) { Set&amp;lt;Integer&amp;gt; set1 = toSet(nums1); Set&amp;lt;Integer&amp;gt; set2 = toSet(nums2); return findIntersection(set1, set2); } private int[] findIntersection(Set&amp;lt;Integer&amp;gt; set1, Set&amp;lt;Integer&amp;gt; set2) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int num: set2) { if (set1.contains(num)) { list.add(num); } } int[] res = new int[list.size()]; for (int i = 0; i &amp;lt; list.</description>
    </item>
    
    <item>
      <title>最小的K个数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/ksmallestnuminanarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/ksmallestnuminanarray/</guid>
      <description>最小的K个数 import java.util.ArrayList; // 牛客网 // https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf // 最小的 k 个数 // public class KSmallestNumInAnArray { public ArrayList&amp;lt;Integer&amp;gt; GetLeastNumbers_Solution(int[] input, int k) { int lo = 0; int hi = input.length - 1; while (lo &amp;lt;= hi) { int kth = partition(input, lo, hi); if (kth == k - 1) { ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; k; i++) { res.add(input[i]); } return res; } else if (kth &amp;lt; k - 1) { lo = kth + 1; } else { hi = kth - 1; } } return new ArrayList&amp;lt;Integer&amp;gt;(); } private int partition(int[] nums, int lo, int hi) { int left = lo - 1; int pivot = nums[hi]; for (int i = lo; i &amp;lt;= hi - 1; i++) { if (nums[i] &amp;lt;= pivot) { swap(nums, ++left, i); } } swap(nums, left + 1, hi); return left + 1; } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } </description>
    </item>
    
    <item>
      <title>绝对值差为K的数对数量</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kdiffpairsinanarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kdiffpairsinanarray/</guid>
      <description>绝对值差为K的数对数量 描述 给定一个整数数组和一个整数k，您需要找到数组中唯一k-diff对的数量。这里k-diff对被定义为整数对(i, j)，其中i和j都是数组中的数字，它们的绝对差是k。
 对(i,j)和(j,i)计为同一对。 数组的长度不超过10,000。 给定输入中的所有整数都属于以下范围：[ -1e7, 1e7]。  答案 import java.util.Arrays; // https://www.lintcode.com/problem/k-diff-pairs-in-an-array/description // Amazon // // 这个 pair 差的绝对值 == k public class KdiffPairsinanArray { // O(n^2)  public int findPairs(int[] nums, int k) { Arrays.sort(nums); int count = 0; for (int i = 0; i &amp;lt; nums.length - 1; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>第 K 个最大的数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kthlargestelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kthlargestelement/</guid>
      <description>第 K 个最大的数字 数组中的第 K 个最大数字 // 数组无序 public class KthLargestElementinanArray { public int findKthLargest(int[] nums, int k) { k = nums.length - k; // 1 2 3 4 5 6  // ↑(第 2 大)  // ↑(partition = 2 的时候，实际上指向的是这里)  int lo = 0; int hi = nums.length - 1; // ==========================  // while (lo &amp;lt; hi)  // nums = [1]，这种情况进入不了循环  //  // ==========================  while (lo &amp;lt;= hi) { int index = partition(nums, lo, hi); if (index == k) { return nums[index]; } else if (index &amp;lt; k) { lo = index + 1; } else { hi = index - 1; } } return -1; } private int partition(int[] nums, int lo, int high) { int i = lo - 1; int pivot = nums[high]; for (int j = lo; j &amp;lt;= high - 1; j++) { if (nums[j] &amp;lt;= pivot) { i++; swap(nums, i, j); } } swap(nums, i + 1, high); return i + 1; } private void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } } 数据流中的第 K 个最大数字  堆  import java.</description>
    </item>
    
    <item>
      <title>第 K 个最小的数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kthsmallestelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kthsmallestelement/</guid>
      <description>第 K 个最小的数字 9 * 9 乘法表中的第 K 个最小数字 // http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3819&amp;amp;konwledgeId=40 // https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/ // // 百度乘法表 // 9 * 9 乘法表 // public class KthSmallestNumberinMultiplicationTable { public int findKthNumber(int m, int n, int k) { int lo = 1; int hi = m * n; while (lo &amp;lt;= hi) { int middle = lo + ((hi - lo) &amp;gt;&amp;gt; 1); int count = countLessOrEqualK(m, n, middle); if (count &amp;lt; k) { lo = middle + 1; } else { hi = middle - 1; } } return lo; } private int countLessOrEqualK(int m, int n, int k) { int c = 0; for (int i = 1; i &amp;lt;= m; i++) { // 1 2 3 4  // 2 4 6 8  // 3 6 9 12  //  // k = 5  // - k &amp;gt;= 第 1 行的 (1 2 3 4) 最后的 4，所以 c += n 个  // - k &amp;lt; 第 2 行的 (2 4 6 8) 最后的 8，所以 c += k / i 个  //  if (k &amp;gt;= n * i) { c += n; } else { c += k / i; } } return c; } } 行或列均有序的矩阵中的第 K 个最小数字 // matrix = [ // [ 1, 5, 9], // [10, 11, 13], // [12, 13, 15] // ], // k = 8,  // return 13.</description>
    </item>
    
    <item>
      <title>数组元素所能拼成的最大数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/largestnumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/largestnumber/</guid>
      <description>数组元素所能拼成的最大数字 import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class LargestNumber { public String largestNumber(int[] nums) { List&amp;lt;String&amp;gt; numList = toList(nums); Collections.sort(numList, new Comparator&amp;lt;String&amp;gt;() { @Override public int compare(String a, String b) { return (b + a).compareTo(a + b); } }); final StringBuilder sb = new StringBuilder(); for (String str: numList) { sb.append(str); } String res = sb.toString(); if (allZero(res)) { return &amp;#34;0&amp;#34;; } return res; } private boolean allZero(String str) { for (char c: str.</description>
    </item>
    
    <item>
      <title>柱状图中最大的矩形</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/largestrectangleinhistogram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/largestrectangleinhistogram/</guid>
      <description>柱状图中最大的矩形 描述 题目来源
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。
题解 // https://leetcode.com/problems/largest-rectangle-in-histogram/ 直方图 // __ // __| | // | | | // | | | __ // __ | | |__| | // | |__| | | | | // |__|__|__|__|__|__| // public class LargestRectangleinHistogram { public int largestRectangleArea(int[] heights) { // =================================  // 左边最多延展到哪个索引  // =================================  // 左边比自己大的或相等的  //  // 单调栈找到第一个比自己大的或者小的数字  int[] left = new int[heights.</description>
    </item>
    
    <item>
      <title>最长序列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/longestsequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/longestsequence/</guid>
      <description>最长序列 最长连续递增相差为 1 的序列 import java.util.Arrays; // [100, 4, 200, 1, 3, 2] // // 必须是连续的 1 2 3 4 差值为 1 public class LongestConsecutiveSequence { public int longestConsecutive(int[] nums) { if (nums.length == 0) { return 0; } Arrays.sort(nums); int longestStreak = 1; int currentStreak = 1; for (int i = 1; i &amp;lt; nums.length; i++) { if (nums[i] != nums[i - 1]) { if (nums[i] == nums[i - 1] + 1) { currentStreak += 1; } else { longestStreak = Math.</description>
    </item>
    
    <item>
      <title>找出过半数的元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/majorityelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/majorityelement/</guid>
      <description>找出过半数的元素 // Given an array of size n, find the majority element. // The majority element is the element that appears more than ⌊ n/2 ⌋ times. // You may assume that the array is non-empty and the majority element always exist in the array. // public class MajorityElement { public int majorityElement(int[] nums) { int candidate = nums[0]; int count = 1; for (int i = 1; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>最大的岛屿</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maxareaofisland/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maxareaofisland/</guid>
      <description>最大的岛屿 // 时间复杂度 O(row * col)，因为每个小方格访问一次 // public class MaxAreaofIsland { public int maxAreaOfIsland(int[][] grid) { int row = grid.length; int col = grid[0].length; boolean[][] visited = new boolean[row][col]; int max = 0; for (int r = 0; r &amp;lt; row; r++) { for (int c = 0; c &amp;lt; col; c++) { max = Math.max(maxArea(grid, visited, r, c), max); } } return max; } private int maxArea(int[][] grid, boolean[][] visited, int r, int c) { if (r &amp;lt; 0 || r &amp;gt;= grid.</description>
    </item>
    
    <item>
      <title>直线上最多的点数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maxpointsonaline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maxpointsonaline/</guid>
      <description>直线上最多的点数 描述 题目 给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。
输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^|| o| o o| o| o o+-------------------&amp;gt;0 1 2 3 4 5 6题解 public class MaxPointsonaLine { public int maxPoints(Point[] points) { if (points.length &amp;lt;= 1) { return points.length; } int max = 0; for (int i = 0; i &amp;lt; points.length - 1; i++) { for (int j = i + 1; j &amp;lt; points.</description>
    </item>
    
  </channel>
</rss>