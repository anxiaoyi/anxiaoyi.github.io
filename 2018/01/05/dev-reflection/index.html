<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>开发反思</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="开发反思"><a href="#开发反思" class="headerlink" title="开发反思"></a>开发反思</h2><h3 id="不要吞掉-NULL-或者-Exception-信息"><a href="#不要吞掉-NULL-或者-Exception-信息" class="headerlink" title="不要吞掉 NULL 或者 Exception 信息"></a>不要吞掉 <code>NULL</code> 或者 <code>Exception</code> 信息</h3><p>如图，就是忘记添加 <code>else</code> 行了，导致没有日志输出，找不到代码运行到哪里停了。</p>
<p><img src="2018_01_05_23_17_40.png" alt="ELSE"></p>
<p>如下，就是原来没有书写 <code>Exception</code>，导致 <code>DB</code> 连接不上很久了，也<strong>没有从日志</strong>里面查询出任何一行 <code>Error</code> 信息:</p>
<p><img src="2018_01_06_14_00_44.png" alt="Exception"></p>
<h3 id="数据来源要支持多样化"><a href="#数据来源要支持多样化" class="headerlink" title="数据来源要支持多样化"></a>数据来源要支持多样化</h3><p>如下是内嵌在某个类里面的部分代码片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downloadProxyAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String response = URLDownloader.download(url);</span><br><span class="line">        ProxyAddressResult addressResult = JSONObject.parseObject(response);</span><br><span class="line">        List&lt;InetSocketAddress&gt; socketAddressPool = convert2SocketAddressList(addressResult);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写的时候，就会导致特别<strong>难写测试类</strong>。这段代码严重依赖<code>URLDownloader.download</code>这个方法，严重<strong>依赖网络</strong>，我们的目的就是为了获取 <code>List&lt;InetSocketAddress&gt;</code> ，在项目实际运行的时候，<code>socketAddressPool</code> 可能是依赖网络需要联网去下载数据并解析的，然而在<strong>开发</strong>过程中，编写<strong>测试</strong>的时候，不应该这么直接做。</p>
<p>要想到<strong>支持测试类的数据来源</strong>，要明白开发中的任何<strong>一项数据应该至少拥有两个来源</strong>，要意识到能够很<strong>方便</strong>的给某个类<strong>构建伪数据</strong>是一件很重要的事情，千万<strong>不要限定死</strong>数据的来源:</p>
<ul>
<li><strong>主线来源</strong>: 项目运行过程中实际的数据来源</li>
<li><strong>测试来源</strong>: 通过测试类来构造的伪数据来源</li>
</ul>
<p>这也正是<strong>接口</strong>的用武之地之一。</p>
<h3 id="让方法行为可确定"><a href="#让方法行为可确定" class="headerlink" title="让方法行为可确定"></a>让方法行为可确定</h3><p><img src="2018_01_06_14_06_26.png" alt="Charset.defaultCharset"></p>
<p>我们在本地跑的项目，请求页面没有任何编码问题，然而这段代码部署到服务器上，就开始出现<strong>页面乱码</strong>问题。原因就是：</p>
<ul>
<li>想当然了，想当然认为这个方法返回的就是<strong>默认编码</strong>，想当然认为 <code>Java</code> 的<strong>跨平台性</strong>为我们屏蔽了任何编码问题，想当然认为这段代码在任何 <strong><code>OS</code></strong>、用任何的 <code>Java</code> <strong>版本</strong>都能够保持初心返回一个唯一的确定的值。</li>
<li>没有好好阅读 <code>Java</code> 文档。事实上，这个方法的 <code>Documentation</code> 已经<strong>很明确地</strong>告知了开发者: The default charset is determined during virtual-machine startup and typically <strong>depends upon the locale and charset of the underlying operating system (依赖 <code>LOCALE</code> 和底层操作系统的编码)</strong>.</li>
<li>存在<strong>侥幸心理</strong>。侥幸认为我不用关心这段代码<strong>背后</strong>究竟是怎么运行的，<strong>背后</strong>究竟是怎么获取的默认编码，项目依旧可以好好的运行。</li>
<li>快点完成项目的心理。<strong>错误地</strong>认为自己不测试 <code>Charset.defaultCharse</code> 所<strong>省下来的时间</strong>就真的省下来了。</li>
</ul>
<h3 id="实践是检验真理的唯一标准"><a href="#实践是检验真理的唯一标准" class="headerlink" title="实践是检验真理的唯一标准"></a>实践是检验真理的唯一标准</h3><p>以下是读到一篇<a href="http://blog.csdn.net/eaphyy/article/details/71190441" target="_blank" rel="noopener">Mybatis 的常见面试题</a>时候所看到的:</p>
<p><img src="2018_01_06_14_20_20.png" alt="CSDN_Mybatis_interview"></p>
<p><strong>心理第一反映</strong>: <code>Mapper</code> 接口里面的方法是不能重载的，这个知识点还是我第一次遇见，<strong>下次面试官问我我也就直接回答上了</strong>，美滋滋。</p>
<p>然而，当<strong>想</strong>亲自验证一下的时候，我发现在 <code>Mapper</code> 里面，重载方法竟然是 <code>OK</code> 的，声明上第二个方法之后，能够正确调用 <code>Mapper</code> 中的 <code>selectRecentlyRecords</code> 方法，且<strong>一切运行正常</strong>:</p>
<p><img src="2018_01_06_14_25_43.png" alt="Mapper_Method_Override"></p>
<p>后经过一番验证，才发现确切的说应该是 <strong><code>Mapper.xml</code></strong> 中的 <code>&lt;select&gt;</code> <strong>节点的 <code>id</code> 要唯一</strong>！</p>
<p><strong>网络不可不信但网络也不可尽信之</strong>！搜索引擎虽然加速了知识传播的速度，加快了我们获取知识的速度，但是<strong>知识的来源参差不齐，可信度也随之下降，我们对知识的可辨度也要随之提升才行</strong>。所以一定要亲自<strong>验证</strong>。</p>






<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
