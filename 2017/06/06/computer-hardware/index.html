<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>System Hardware &amp; 计算机体系结构</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="System-Hardware-amp-计算机体系结构"><a href="#System-Hardware-amp-计算机体系结构" class="headerlink" title="System Hardware &amp; 计算机体系结构"></a>System Hardware &amp; 计算机体系结构</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>The CPU has several layers of cache between it and main memory (RAM), because even accessing main memory is too slow.</p>
<p><strong>The closer the cache is to the CPU, the faster it is and the smaller it is</strong>.  L1 cache is small and very fast, and right next to the core that uses it.  L2 is bigger and slower, and still only used by a single core.  L3 is more common with modern multi-core machines, and is bigger again, slower again, and shared across cores on a single socket.  Finally you have main memory, which is shared across all cores and all sockets.</p>
<table>
<thead>
<tr>
<th>Latency from CPU to…</th>
<th>Approx. number of CPU cycles</th>
<th>Approx. time in nanoseconds</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main memory</td>
<td></td>
<td>~60-80ns</td>
</tr>
<tr>
<td>QPI transit (between sockets, not drawn)</td>
<td></td>
<td>~20ns</td>
</tr>
<tr>
<td>L3 cache</td>
<td>~40-45 cycles,</td>
<td>~15ns</td>
</tr>
<tr>
<td>L2 cache</td>
<td>~10 cycles,</td>
<td>~3ns</td>
</tr>
<tr>
<td>L1 cache</td>
<td>~3-4 cycles,</td>
<td>~1ns</td>
</tr>
<tr>
<td>Register</td>
<td>1 cycle</td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="CacheHierarchy.jpg" alt=""><br><img src="CacheCoherency.jpg" alt=""><br><img src="cacheline.png" alt=""></p>
<p><strong>(1) Cache lines</strong></p>
<p>Now the interesting thing to note is that it’s not individual items that get stored in the cache - i.e. it’s not a single variable, a single pointer.  The cache is made up of cache lines, typically 64 bytes, and it effectively references a location in main memory.  A Java long is 8 bytes, so in a single cache line you could have 8 long variables.</p>
<p><img src="CacheLines.png" alt=""></p>
<p>参考 <a href="http://mechanitis.blogspot.jp/2011/07/dissecting-disruptor-why-its-so-fast_22.html" target="_blank" rel="noopener">Dissecting the Disruptor: Why it’s so fast (part two) - Magic cache line padding</a></p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>It is a basic Law of Computing that given <strong>a single CPU</strong> resource, <strong>executing A and B sequentially will always be faster than executing A and B “simultaneously” through time-slicing</strong>. Once the number of threads exceeds the number of CPU cores, you’re going slower by adding more threads, not faster.</p>
<p>Don’t be tricked into thinking, “SSDs are faster and therefore I can have more threads”. That is exactly 180 degrees backwards. Faster, no seeks, no rotational delays means less blocking and therefore fewer threads [closer to core count] will perform better than more threads. <strong>More threads only perform better when blocking creates opportunities for executing</strong>.</p>
<h4 id="False-Sharing"><a href="#False-Sharing" class="headerlink" title="False Sharing"></a>False Sharing</h4><p>多个线程修改共享一个 Cache Line 的独立变量的时候，会造成这个 Cache Line 中的其他变量缓存失效，这被称之为 False sharing</p>
<p><img src="cache-line.png" alt=""></p>
<p>在核心 1 上运行的线程想更新变量 X，同时核心2上的线程想要更新变量 Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果核心 1 获得了所有权，缓存子系统将会使核心 2 中对应的缓存行失效。当核心 2 获得了所有权然后执行更新操作，核心 1 就要使自己对应的缓存行失效。这会来来回回的经过 L3 缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽 (socket interconnect) 连接，问题可能更加严重。</p>
<p><img src="5-4-figure-1.gif" alt=""></p>
<p><strong>False sharing occurs when threads on different processors modify variables that reside on the same cache line. This invalidates the cache line and forces a memory update to maintain cache coherency</strong>.</p>
<p>(1) Java 6 通过填充缓存行 (padding the cache) 来避免:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferPad</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考 <a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/RingBuffer.java" target="_blank" rel="noopener">RingBuffer.java</a></p>
<p>(2) Java 7</p>
<p>It seems Java 7 <strong>got clever and eliminated or re-ordered the unused fields</strong>, thus re-introducing false sharing.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sumPaddingToPreventOptimisation</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    PaddedAtomicLong v = longs[index];</span><br><span class="line">    <span class="keyword">return</span> v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicLong</span> <span class="keyword">extends</span> <span class="title">AtomicLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6 = <span class="number">7L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考 <a href="https://mechanical-sympathy.blogspot.jp/2011/08/false-sharing-java-7.html" target="_blank" rel="noopener">False Sharing &amp;&amp; Java 7</a></p>
<p>(3) Java 8 通过声明 <code>sun.misc.Contended</code> 注解加启动参数 <code>-XX:-RestrictContended</code> 来搞定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">        CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考 <a href="http://budairenqin.iteye.com/blog/2048257" target="_blank" rel="noopener">Java8 中用 <code>sun.misc.Contended</code> 避免伪共享(false sharing)</a></p>
<h3 id="位数"><a href="#位数" class="headerlink" title="位数"></a>位数</h3><p>虽然 32 位使用较小的指针大小可以节约内存，但由于操作系统的<strong>寻址受限</strong>，它在缓冲区大小设置上存在固有的约束，理论上，每个进程在 32 为系统上的最大可用内存为 4GB，实际上在很多系统上这个数值很小。</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>关于磁盘，你需要关注<strong>磁盘读延迟</strong> (每次读访问需要多长时间) 和 <strong><code>fsync</code> 延迟</strong> (每个 <code>fsync</code> 耗时多少)，大多数存储引擎是针对硬盘读写优化的，所以不要指望固态硬盘能够出现什么性能上的奇迹。</p>
<hr>
<ul>
<li><code>Hd(0,0)</code> is the <strong>1st</strong> partition of the <strong>1st physical disk</strong>.</li>
<li><code>Hd(0,1)</code> is the <strong>2nd</strong> partition of the <strong>1st physical disk</strong>.</li>
</ul>
<p>I believe that</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sda = hd0, </span><br><span class="line">sdb = hd1,</span><br></pre></td></tr></table></figure>
<p>so on etc. etc. <code>sdc = hd2</code> When it says <code>sda1</code> that would be <code>(hd0, 0)</code> and <code>sda2 (hd0, 1)</code> and <code>sda3 (hd0, 2)</code> and <code>sdb1 (hd1, 0)</code> so on and so forth…</p>
<h3 id="Hello-World-的运行过程"><a href="#Hello-World-的运行过程" class="headerlink" title="Hello World 的运行过程"></a><code>Hello World</code> 的运行过程</h3><h3 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2x"</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span> *x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>%.2x</code></strong> 表示整数必须用至少两个数字的十六进制格式输出。</li>
</ul>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">0x87654321</span>;</span><br><span class="line">byte_pointer = (byte_pointer) &amp;val;</span><br><span class="line"></span><br><span class="line">show_bytes(valp, <span class="number">1</span>);</span><br><span class="line">show_bytes(valp, <span class="number">2</span>);</span><br><span class="line">show_bytes(valp, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>小端法: <code>21</code> 大端法: <code>87</code></li>
<li>小端法: <code>21 43</code> 大端法: <code>87 65</code></li>
<li>小端法: <code>21 43 65</code> 大端法: <code>87 65 43</code></li>
<li>小端法: <code>21 43 65 87</code> 大端法: <code>87 65 43 21</code></li>
</ul>
<hr>
<p>整数和浮点数的编码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_show_bytes</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = val;</span><br><span class="line">    <span class="keyword">float</span> fval = (<span class="keyword">float</span>) val;</span><br><span class="line">    <span class="keyword">int</span> *pval = &amp;ival;</span><br><span class="line"></span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_float(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test_show_bytes(<span class="number">12345</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>整数 <code>12345</code> 的编码: <code>39300000</code></li>
<li>浮点数 <code>12345.0</code> 的编码: <code>00e44046</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0011 1001 0011 0000 0000 0000 0000 0000</span><br><span class="line">0000 0000 1110 0100 0100 0000 0100 0110</span><br></pre></td></tr></table></figure>
<p>你会发现整数和浮点数有一部分是交叉重复的。</p>
<hr>
<p>位级运算一个常见用法就是实现<strong>掩码</strong>运算，表示从一个字中选出的位的集合。</p>
<ul>
<li><code>0xFF</code> 表示一个字的低位字节</li>
<li><code>x &amp; 0xFF</code> 生成一个由 <code>x</code> 的最低有效字节组成的值，而其他字节置位 <code>0</code></li>
<li><code>~0xFF</code> 表示 <code>8</code> 个最低位为 <code>0</code>，而其余的位都是 <code>1</code></li>
<li><code>~0</code> 生成一个全 <code>1</code> 的掩码，不管机器的字是多少。尽管对于一个 32 位的机器来说，同样的掩码可以写成 <code>0xFFFFFFFF</code>，但是这样的代码是不可移植的。</li>
</ul>
<p>实际中较为常用的几种模式：</p>
<ul>
<li><code>x</code> 的最低有效字节，其他位均置位 <code>0</code>: <code>x &amp;0xFF</code></li>
<li>除了 <code>x</code> 的最低有效字节外，其他的位都取补，最低有效字节保持不变: <code>x ^ ~0xFF</code></li>
<li><code>x</code> 的最低有效字节设置成全 <code>1</code>，其他字节保持变: <code>x | 0xFF</code></li>
</ul>
<hr>
<p>对于 <code>0x87 ([10000111])</code> 来说，不同的移位操作:</p>
<ul>
<li><code>x &lt;&lt; 3</code>: <code>[00111000]</code></li>
<li><code>x &gt;&gt; 2 (逻辑)</code>: <code>[00100001]</code></li>
<li><code>x &gt;&gt; 2 (算术)</code>: <code>[11100001]</code></li>
</ul>
<hr>
<p><strong>反汇编器</strong>是一种将可执行程序文件转换回可读性更好的 <code>ASCII</code> 码形式的程序。这些文件包含许多十六进制数字，<strong>都是用典型的补码形式来表示这些值</strong>。能够认识这些数字并理解它们的意义 (例如，它们是正数还是负数)，是<strong>一项重要的技能</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8048337: 81 ec b8 01 00 00    sub    $0x1b8,%esp    440</span><br></pre></td></tr></table></figure>
<p><code>81 ec b8 01 00 00</code> 是一条指令的字节级表示，取出后 4 个字节 <code>b8 01 00 00</code> 按照相反的顺序写出来，我们得到 <code>00 00 01 b8</code>，这就是等价的十进制 <code>440</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8048343: 8b 85 58 fe ff ff    mov    0xfffffe58(%ebp),%eax   -424</span><br></pre></td></tr></table></figure>
<p><code>58 fe ff ff</code> 相反顺序: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ff ff fe 58</span><br><span class="line">// 以二进制表示</span><br><span class="line">11111111 11111111 11111110 01011000</span><br><span class="line">// 取反 + 1，这个是正数 424，因此原值为 -424</span><br><span class="line">00000000 00000000 00000001 10101000</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在无符 word 上进行的，算是逻辑移位</span></span><br><span class="line"><span class="comment">// 从参数的低 8 位中提取一个值，得到范围 0 ~ 155 之间的一个整数</span></span><br><span class="line"><span class="comment">// 0x00000076 -&gt; 0x00000076</span></span><br><span class="line"><span class="comment">// 0x87654321 -&gt; 0x00000021</span></span><br><span class="line"><span class="comment">// 0x000000C9 -&gt; 0x000000C9</span></span><br><span class="line"><span class="comment">// 0xEDCBA987 -&gt; 0x00000087</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">unsigned</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ((word &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// word 强制转换为 int</span></span><br><span class="line"><span class="comment">// 进行算术移位</span></span><br><span class="line"><span class="comment">// 从这个参数的低 8 位中提取一个值，但是它还要执行符号扩展。结果将是介于 -128 ~ 127 之间的一个数</span></span><br><span class="line"><span class="comment">// 0x00000076 -&gt; 0x00000076</span></span><br><span class="line"><span class="comment">// 0x87654321 -&gt; 0x00000021</span></span><br><span class="line"><span class="comment">// 0x000000C9 -&gt; 0xFFFFFFC9</span></span><br><span class="line"><span class="comment">// 0xEDCBA987 -&gt; 0xFFFFFF87</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">unsigned</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span>) word &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参数 <code>length</code> 是无符的，计算 <code>0-1</code> 将进行<strong>无符号运算</strong>，这等价于模数加法。结果得到 <code>unsigned max</code>，任何数都是小于或者等于 <code>unsigned max</code> 的，所以这个比较总是真！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bug fix (1):</span></span><br><span class="line"><span class="comment">// float sum_elements(float a[], int length) &#123;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Bug fix (2):</span></span><br><span class="line"><span class="comment">// for (i=0; i&lt;length; i++) &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sum_elements</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">unsigned</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        result += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阅读下面这个小测试:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> ret = length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 4294967295</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 `s` 比 `t` 短的时候，该函数会不正确的返回 1</span></span><br><span class="line"><span class="comment">// strlen(s) - strlen(t) 会为负</span></span><br><span class="line"><span class="comment">// 变成了一个很大的无符号数，且大于 0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Bug Fix (1):</span></span><br><span class="line"><span class="comment">// return strlen(s) &gt; strlen(t);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlonger</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(t) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>size_t</code> 在 32 位机器上典型的被定义为 <code>unsigned int</code>，看下面这个示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> lenA = <span class="built_in">strlen</span>(<span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> lenB = <span class="built_in">strlen</span>(<span class="string">"abcdefg"</span>);</span><br><span class="line">    <span class="comment">// 18446744073709551610</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu"</span>, lenA - lenB);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>%lu</code> for unsigned long</li>
<li><code>%llu</code> for unsigned long long</li>
</ul>
<h3 id="虚拟内存-Virtual-Memory"><a href="#虚拟内存-Virtual-Memory" class="headerlink" title="虚拟内存 Virtual Memory"></a>虚拟内存 Virtual Memory</h3><p>In computing, virtual memory (also virtual storage) is a <strong>memory management technique (内存管理技巧)</strong> that provides an “idealized abstraction of the storage resources that are actually available on a given machine” which <strong>“creates the illusion to users of a very large (main) memory.” (给用户一种我有很大内存的感觉)</strong></p>
<p>Virtual memory combines active RAM and inactive memory on DASD to form a large range of contiguous addresses.</p>
<p><img src="500px-Virtual_memory.svg.png" alt="Virtual_Memory"></p>
<p><strong>Address translation hardware (地址转换硬件)</strong> in the CPU, often referred to as a memory management unit or <strong>MMU</strong>, automatically translates virtual addresses to physical addresses.</p>
<h3 id="Interrupt-中断"><a href="#Interrupt-中断" class="headerlink" title="Interrupt 中断"></a>Interrupt 中断</h3><p>In system programming, an interrupt is a <strong>signal (信号)</strong> to the <strong>processor (处理器)</strong> emitted by <strong>hardware or software (硬件或者软件发出的)</strong> indicating an event that needs <strong>immediate (立即处理)</strong> attention. The processor responds by <strong>suspending (挂起)</strong> its current activities, saving its state, and executing a function called an <strong>interrupt handler (中断回调)</strong> (or an interrupt service routine, ISR) to deal with the event. This interruption is temporary, and, after the interrupt handler finishes, the processor <strong>resumes (恢复)</strong> normal activities.</p>
<p><strong>Types of interrupts:</strong></p>
<p><strong>(1) Level-triggered (电平触发，也被称为条件触发):</strong> A level-triggered interrupt is an interrupt signaled by maintaining the interrupt line at a high or low logic level. 电平触发是在<strong>高或低电平保持的时间</strong>内触发。只要<strong>满足条件</strong>，就触发一个事件(<strong>只要有数据没有被获取，内核就不断通知你</strong>)</p>
<p><strong>(2) Edge-triggered (边沿触发):</strong> An edge-triggered interrupt is an interrupt signalled by a level transition on the interrupt line, either a falling edge (high to low) or a rising edge (low to high). 边沿触发是<strong>由高到低或由低到高这一瞬间触发</strong>。每<strong>当状态变化</strong>时，触发一个事件。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://fuzzyreflection.com/" target="_blank" rel="noopener">Knowing the hardware</a></li>
<li><a href="https://confluence.csiro.au/display/SC/Multi+CPU+Optimisation" target="_blank" rel="noopener">Multi CPU Optimisation</a></li>
<li><a href="https://item.jd.com/11741440.html" target="_blank" rel="noopener">《MySQL 排错指南》</a></li>
<li><a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing" target="_blank" rel="noopener">HikariCP - About Pool Sizing</a></li>
<li><a href="https://www.amazon.cn/gp/product/B01N03IQK4" target="_blank" rel="noopener">《深入理解计算机系统》</a></li>
<li><a href="https://www.cnblogs.com/Blub-xinye1/p/5513549.html" target="_blank" rel="noopener">边沿触发和电平触发的区别</a></li>
</ul>






<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
