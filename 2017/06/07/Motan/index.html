<html>
<head>
	
	<title>Motan</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/>
    

</head>

<body>

<h2 id="Motan-服务注册中心"><a href="#Motan-服务注册中心" class="headerlink" title="Motan - 服务注册中心"></a>Motan - 服务注册中心</h2><ul>
<li><strong><code>RegistryService</code> 接口</strong>: 注册、设置 URL 的可用</li>
<li><strong><code>DiscoveryService</code> 接口</strong>: 订阅 URL</li>
<li><strong><code>Registry</code> 接口</strong>: 一个 URL 就是一个 <code>Registry</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registry</span></span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">RegistryService</span>, <span class="title">DiscoveryService</span> </span>&#123;</div><div class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong><code>RegistryFactory</code> 接口</strong>: 根据 URL 创建 <code>Registry</code></li>
</ul>
<h2 id="Motan-代理"><a href="#Motan-代理" class="headerlink" title="Motan - 代理"></a>Motan - 代理</h2><ul>
<li><strong><code>ProxyFactory</code> 接口</strong>: 创建某个类的代理</li>
</ul>
<p>关注实现类 <code>RefererInvocationHandler</code> 的 <code>invoke</code> 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( 是本地方法( method ) ) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> async = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> ( method 以 <span class="string">'Async'</span> 结尾 ||</div><div class="line">         method 返回 ResponseFuture.class ) &#123;</div><div class="line">        async = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request 请求 = <span class="keyword">new</span> Request( 请求 Id );</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( 集群: 所有集群 ) &#123;</div><div class="line">        <span class="keyword">if</span> ( 集群关了 )</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Response r = 集群.call( 请求 );</div><div class="line">            <span class="keyword">if</span> ( async )</div><div class="line">                <span class="keyword">return</span> response;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> response.value;</div><div class="line">        &#125; <span class="keyword">catch</span>( RuntimeException e ) &#123;</div><div class="line">            <span class="keyword">if</span> ( 业务方逻辑抛出的异常 )</div><div class="line">                <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Motan-数据传输"><a href="#Motan-数据传输" class="headerlink" title="Motan - 数据传输"></a>Motan - 数据传输</h2><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>在源码编译阶段，让编译器创建一个类名为 <code>{interfaceName}Async</code> ，同时所有方法以 <code>Async</code> 结尾的生成类，并默认放在目录 <code>target/generated-sources/annotations/</code> 下面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations,</span></span></div><div class="line"><span class="function"><span class="params">                       RoundEnvironment roundEnv)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( Element c: 所有注解了 MotanAsync.class 的类) &#123;</div><div class="line">        <span class="keyword">if</span> ( c 是接口 ) &#123;</div><div class="line"></div><div class="line">            </div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><ul>
<li><strong><code>Transport</code> 接口</strong>: 将 <code>byte[]</code> 请求从这头发送到那一头，并返回 <code>byte[]</code></li>
<li><strong><code>Channel</code> 接口</strong>: 将 <code>Request</code> 请求从这头发送到另一头，并返回 <code>Response</code></li>
<li><strong><code>Endpoint</code> 接口</strong>: 继承 <code>Channel</code></li>
<li><strong><code>Clent</code> 接口</strong>: 继承 <code>Endpoint</code>，异步发送心跳包请求</li>
<li><strong><code>Server</code> 接口</strong>: 继承 <code>Endpoint</code>，可以得到所有的 <code>Channels</code></li>
<li><strong><code>MessageHandler</code> 接口</strong>: 处理一个 <code>Channel</code> 上的 <code>message</code>，并返回 <code>Object</code> 类型</li>
<li><strong><code>EndpointFactory</code> 接口</strong>: 可以创建 <code>Server</code> 和 <code>Client</code></li>
<li><strong><code>EndpointManager</code> 接口</strong>: 可以初始化/销毁，也可以添加/移除 <code>Endpoint</code></li>
<li><strong><code>HeartbeatFactory</code> 接口</strong>: 创建心跳包请求，对 <code>MessageHandler</code> 进行包装</li>
</ul>
<p>下面看 <code>AbstractClient</code> 的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClient</span></span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> InetSocketAddress localAddress;</div><div class="line">    <span class="keyword">protected</span> InetSocketAddress remoteAddress;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> ChannelState state = <span class="string">'未初始化状态'</span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AbstractServer</code> 的实现和 <code>AbstractClient</code> 的实现大同小异，不再赘述。</p>
<p><code>AbstractPoolClient</code> 的实现，实际上内部使用了 <code>org.apache.commons.pool.impl.GenericObjectPool</code> 作为默认对象池的实现，其可以支持如下机制:</p>
<ul>
<li>设置最小空闲对象个数</li>
<li>设置最大空闲对象个数</li>
<li>设置最大活跃对象个数</li>
<li>设置最大等待对象个数</li>
<li>设置以 LIFO 或 FIFO 机制来借对象<ul>
<li>LIFO: 借对象的时候会返回上次归还的 <code>idle</code> 对象</li>
<li>FIFO: 借对象的时候会返回很久未使用过的 <code>idle</code> 对象</li>
</ul>
</li>
<li>如果非延迟初始化，则会添加最小空闲个数量的对象</li>
<li>借对象</li>
<li>使对象失效</li>
<li>还对象</li>
</ul>
<p><code>DefaultRpcHeartbeatFactory</code> 的实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRpcHeartbeatFactory</span></span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">HeartbeatFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">createRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">        Request request = <span class="keyword">new</span> Request();</div><div class="line">        request.接口名(<span class="string">"com.weibo.api.motan.rpc.heartbeat"</span>);</div><div class="line">        request.方法名(<span class="string">"heartbeat"</span>);</div><div class="line">        request.参数(<span class="string">"void"</span>);</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MessageHandler <span class="title">wrapMessageHandler</span><span class="params">(MessageHandler handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeartMessageHandleWrapper(handler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartMessageHandleWrapper</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">MessageHandler</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Channel channel, Object message)</span> </span>&#123;</div><div class="line">            <span class="comment">// 根据接口名、方法名、参数来判断是否是心跳包请求</span></div><div class="line">            <span class="keyword">if</span> ( 是心跳包请求(message) ) &#123;</div><div class="line">                DefaultResponse response = <span class="keyword">new</span> DefaultResponse();</div><div class="line">                response.setValue(<span class="string">"heartbeat"</span>);</div><div class="line">                <span class="keyword">return</span> response;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> messageHandler.handle(channel, message);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>HeartbeatClientEndpointManager</code> 中有一个核心数据结构:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ConcurrentMap&lt;Client, HeartbeatFactory&gt; endpoints;</div></pre></td></tr></table></figure>
<p>然后在构造器中又开启了一个 <code>ScheduledExecutorService</code> 服务，每隔 500 ms 检查一下 <code>Client</code> 是否联通:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果节点是存活状态，那么没必要走心跳</span></div><div class="line"><span class="keyword">if</span> (endpoint.isAvailable()) &#123;</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HeartbeatFactory factory = entry.getValue();</div><div class="line">endpoint.heartbeat(factory.createRequest());</div></pre></td></tr></table></figure>
<h2 id="Motan-集群"><a href="#Motan-集群" class="headerlink" title="Motan - 集群"></a>Motan - 集群</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul>
<li><strong><code>LoadBalance&lt;T&gt;</code> 接口</strong>: 对请求选择 <code>Referer</code></li>
<li><strong><code>AbstractLoadBalance&lt;T&gt;</code> 抽象类</strong>: 实现了 <code>LoadBalance&lt;T&gt;</code> 接口，主要对可用的 <code>Referer&lt;T&gt;</code> 在数量上进行了一些检查，并交由子类来实现 <code>doSelect</code> 方法</li>
</ul>
<p>Motan 主要提供了如下几种负载均衡算法，所有算法均继承自 <code>AbstractLoadBalance&lt;T&gt;</code>:</p>
<h4 id="ActiveWeightLoadBalance-lt-T-gt-低并发优化负载均衡"><a href="#ActiveWeightLoadBalance-lt-T-gt-低并发优化负载均衡" class="headerlink" title="ActiveWeightLoadBalance&lt;T&gt;: 低并发优化负载均衡"></a><strong><code>ActiveWeightLoadBalance&lt;T&gt;</code></strong>: 低并发优化负载均衡</h4><ul>
<li>随机抽取 10 台服务器，筛选出 <code>activeRefererCount</code> 值最小的可用的 <code>Referer</code></li>
</ul>
<h4 id="ConsistentHashLoadBalance-lt-T-gt-一致性-Hash"><a href="#ConsistentHashLoadBalance-lt-T-gt-一致性-Hash" class="headerlink" title="ConsistentHashLoadBalance&lt;T&gt;: 一致性 Hash"></a><strong><code>ConsistentHashLoadBalance&lt;T&gt;</code></strong>: 一致性 Hash</h4><p>生成一致性 <code>Hash</code> 数组算法:</p>
<ul>
<li>把所有 <code>referers</code> 全部打乱</li>
<li>每打乱一次，就放进数组里面，</li>
<li>上述两步骤重复 1000 次</li>
<li>然后最终使 <code>consistentHashReferers</code> 指向这个数组</li>
</ul>
<p><code>Hash</code> 算法的生成:</p>
<ul>
<li>无参数，就基于 <code>Request</code> 对象本身生成 <code>hashCode</code></li>
<li>有参数，就使用 <code>Arrays.hashCode(request.getArguments())</code> 来生成 <code>hashCode</code></li>
<li>最后，使用 <code>0x7fffffff &amp; originValue</code> 来得到最终的 <code>hash</code> 值</li>
</ul>
<p>请求选择 <code>Referer</code>:</p>
<ul>
<li>遍历所有的 <code>referers</code></li>
<li>然后进行下面的取余操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ref = consistentHashReferers.get((hash + i) % consistentHashReferers.size());</div></pre></td></tr></table></figure>
<ul>
<li>如果这个 <code>ref</code> 可用，那么直接返回</li>
</ul>
<h4 id="LocalFirstLoadBalance-lt-T-gt-本地服务优先"><a href="#LocalFirstLoadBalance-lt-T-gt-本地服务优先" class="headerlink" title="LocalFirstLoadBalance&lt;T&gt;: 本地服务优先"></a><strong><code>LocalFirstLoadBalance&lt;T&gt;</code></strong>: 本地服务优先</h4><p>当 <code>referers</code> 里面包含本地暴露的服务时，并此服务为 <code>available</code> 的情况下，优先使用此服务。当不存在本地暴露的服务时，默认使用低并发 <code>ActiveWeight</code> 负载均衡策略。</p>
<p>对 <code>referers</code> 根据 <code>ip</code> 顺序查找本地服务，多存在多个本地服务，获取 <code>Active</code> 最小的本地服务进行服务。当不存在本地服务，但是存在远程 <code>RPC</code> 服务，则根据 <code>ActivWeight</code> 获取远程 <code>RPC</code> 服务，当两者都存在，所有本地服务都应优先于远程服务，本地 <code>RPC</code> 服务与远程 <code>RPC</code> 服务内部则根据 <code>ActiveWeight</code> 进行.</p>
<p><strong>获取本地 IP 算法</strong>: 检查缓存 -&gt; 检查 <code>Hostname</code> -&gt; 根据 <code>Socket</code> -&gt; 根据网口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">IP 得到本地IP() &#123;</div><div class="line">    <span class="keyword">if</span> (本地缓存了)</div><div class="line">        <span class="keyword">return</span> 缓存的;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (InetAddress.getLocalHost())</div><div class="line">        <span class="keyword">return</span> InetAddress.getLocalHost();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (创建 Socket 连接指定目标地址)</div><div class="line">        <span class="keyword">return</span> socket.getLocalAddress();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (NetworkInterface.getNetworkInterfaces())</div><div class="line">        <span class="keyword">return</span> 轮询到的 IP;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找到本地 IP 后，会将 <code>Referres</code> 里面所有等于这个 <code>IP</code> 的 <code>Referer</code> 筛选出来，然后从这几个 <code>Referer</code> 中找到 <code>Referer.activeRefererCount()</code> 数量最少的的 <code>Referer</code></p>
<h4 id="RandomLoadBalance-lt-T-gt-随机负载均衡"><a href="#RandomLoadBalance-lt-T-gt-随机负载均衡" class="headerlink" title="RandomLoadBalance&lt;T&gt;: 随机负载均衡"></a><strong><code>RandomLoadBalance&lt;T&gt;</code></strong>: 随机负载均衡</h4><p>随机从 <code>referers</code> 中挑选一个可用的 <code>Referer</code> 返回</p>
<h4 id="RoundRobinLoadBalance-lt-T-gt-轮询负载均衡"><a href="#RoundRobinLoadBalance-lt-T-gt-轮询负载均衡" class="headerlink" title="RoundRobinLoadBalance&lt;T&gt;: 轮询负载均衡"></a><code>RoundRobinLoadBalance&lt;T&gt;</code>: 轮询负载均衡</h4><p>在 <code>referers</code> 上轮询可用的 <code>Referer</code>，其中获取下一个索引的算法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextPositive</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> MathUtil.getPositive(idx.incrementAndGet());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ConfigurableWeightLoadBalance-lt-T-gt-权重可配置的负载均衡"><a href="#ConfigurableWeightLoadBalance-lt-T-gt-权重可配置的负载均衡" class="headerlink" title="ConfigurableWeightLoadBalance&lt;T&gt;: 权重可配置的负载均衡"></a><code>ConfigurableWeightLoadBalance&lt;T&gt;</code>: 权重可配置的负载均衡</h4><p><strong>TODO</strong></p>
<h3 id="HaStrategy-高可用策略"><a href="#HaStrategy-高可用策略" class="headerlink" title="HaStrategy: 高可用策略"></a>HaStrategy: 高可用策略</h3><p><strong><code>HaStrategy&lt;T&gt;</code></strong> 接口定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HaStrategy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(URL url)</span></span>;</div><div class="line">    <span class="function">Response <span class="title">call</span><span class="params">(Request request, LoadBalance&lt;T&gt; loadBalance)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>AbstractHaStrategy&lt;T&gt;</code></strong> 抽象类主要是定义了一个 <code>URL</code> 字段，目前主要提供两种策略:</p>
<ul>
<li><strong><code>FailfastHaStrategy&lt;T&gt;</code></strong>: 快速失败策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">call</span><span class="params">(Request request, LoadBalance&lt;T&gt; loadBalance)</span> </span>&#123;</div><div class="line">    Referer&lt;T&gt; refer = loadBalance.select(request);</div><div class="line">    <span class="keyword">return</span> refer.call(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong><code>FailoverHaStrategy&lt;T&gt;</code></strong>: 失败重试策略</li>
</ul>
<p>先使用负载均衡筛选出一批符合策略的 <code>referers</code>，然后轮询重试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tryCount; i++) &#123;</div><div class="line">    Referer&lt;T&gt; refer = referers.get(i % referers.size());</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        request.setRetries(i);</div><div class="line">        <span class="keyword">return</span> refer.call(request);</div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">        <span class="comment">// 对于业务异常，直接抛出</span></div><div class="line">        <span class="keyword">if</span> (ExceptionUtil.isBizException(e)) &#123;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= tryCount) &#123;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Motan-序列化"><a href="#Motan-序列化" class="headerlink" title="Motan - 序列化"></a>Motan - 序列化</h2><p>实现 <code>Object</code> 和 <code>byte[]</code> 之间的相互转化:</p>
<ul>
<li><code>FactJson</code> 序列化</li>
<li><code>Hessian2</code> 序列化</li>
</ul>
<h2 id="Motan-服务开关"><a href="#Motan-服务开关" class="headerlink" title="Motan - 服务开关"></a>Motan - 服务开关</h2><ul>
<li><strong><code>SwitchListener</code> 接口</strong>: 通知服务开/关了</li>
<li><strong>Switcher</strong>: 代表一个开关</li>
</ul>
<p>两个核心数据结构:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;String, Switcher&gt; switchers;</div><div class="line"><span class="keyword">private</span> Map&lt;String, List&lt;SwitcherListener&gt;&gt; listenerMap;</div></pre></td></tr></table></figure>
<p>每次 <code>setValue</code> 的时候，都会遍历这个开关上的所有 <code>SwitchListener</code> 来通知值变了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String switcherName, <span class="keyword">boolean</span> value)</span> </span>&#123;</div><div class="line">    putSwitcher(<span class="keyword">new</span> Switcher(switcherName, value));</div><div class="line"></div><div class="line">    List&lt;SwitcherListener&gt; listeners = listenerMap.get(switcherName);</div><div class="line">    <span class="keyword">if</span>(listeners != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (SwitcherListener listener : listeners) &#123;</div><div class="line">            listener.onValueChanged(switcherName, value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="SPI-扩展"><a href="#SPI-扩展" class="headerlink" title="SPI 扩展"></a>SPI 扩展</h2><ul>
<li><strong><code>DefaultThreadFactory</code></strong>: 默认线程工厂</li>
<li><strong><code>Spi</code> 注解</strong>: </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Spi &#123;</div><div class="line">    <span class="function">Scope <span class="title">scope</span><span class="params">()</span> <span class="keyword">default</span> Scope.PROTOTYPE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>作用域可以设置为:</p>
<ul>
<li><code>Scope.SINGLETON</code>: 单例模式</li>
<li><code>Scope.PROTOTYPE</code>: 多例模式</li>
</ul>
</li>
<li><p><strong><code>SpiMeta</code> 注解</strong>: Spi 元信息</p>
</li>
<li><strong><code>Activation</code> 注解</strong>: 用来对 Spi 的实现根据条件进行过滤、排序等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activation &#123;</div><div class="line"></div><div class="line">    <span class="comment">/** seq号越小，在返回的list&lt;Instance&gt;中的位置越靠前，尽量使用 0-100以内的数字 */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sequence</span><span class="params">()</span> <span class="keyword">default</span> 20</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** spi 的key，获取spi列表时，根据key进行匹配，当key中存在待过滤的search-key时，匹配成功 */</span></div><div class="line">    String[] key() <span class="keyword">default</span> <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 是否支持重试的时候也调用 */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retry</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong><code>ActivationComparator</code></strong>: 比较器</li>
<li><strong><code>ExtensionLoader&lt;T&gt;</code></strong>: 自己实现的 <code>ServiceProvider</code></li>
</ul>
<p>构造器，需要传入想要实例化的接口，如 <code>com.weibo.api.motan.cluster.HaStrategy.class</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.type = type;</div><div class="line">    <span class="keyword">this</span>.classLoader = Thread.currentThread().getContextClassLoader();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从资源文件夹加载 <code>URL</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String fullName = <span class="string">"META-INF/services/"</span> + type.getName();</div><div class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(fullName);</div></pre></td></tr></table></figure>
<p>然后解析文件中的所有声明的实现类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">    indexNumber++;</div><div class="line">    parseLine(type, url, line, indexNumber, classNames);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析完类之后，装载类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clz = (Class&lt;T&gt;) Class.forName(className, <span class="keyword">true</span>, classLoader);</div></pre></td></tr></table></figure>
<p>这里的 <code>true</code> 参数代表所有位于这个<strong>类中的所有静态块都被初始化</strong>。</p>
<p>接着检查刚装载的类是否符合实现要求:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// check is class public</span></div><div class="line"><span class="keyword">if</span> (!Modifier.isPublic(clz.getModifiers())) &#123;</div><div class="line">    failThrows(clz, <span class="string">"Error is not a public class"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// check is constructor public</span></div><div class="line">Constructor&lt;?&gt;[] constructors = clz.getConstructors();</div><div class="line"><span class="keyword">if</span> (constructors == <span class="keyword">null</span> || constructors.length == <span class="number">0</span>) &#123;</div><div class="line">    failThrows(clz, <span class="string">"Error has no public no-args constructor"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</div><div class="line">    <span class="keyword">if</span> (Modifier.isPublic(constructor.getModifiers()) &amp;&amp; constructor.getParameterTypes().length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// check inherit</span></div><div class="line"><span class="keyword">if</span> (!type.isAssignableFrom(clz)) &#123;</div><div class="line">    failThrows(clz, <span class="string">"Error is not instanceof "</span> + type.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取单例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Spi spi = type.getAnnotation(Spi.class);</div><div class="line"><span class="keyword">if</span> (spi.scope() == Scope.SINGLETON) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (singletonInstances) &#123;</div><div class="line">        obj = singletonInstances.get(name);</div><div class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> obj;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        obj = clz.newInstance();</div><div class="line">        singletonInstances.put(name, obj);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取 PROTOTYPE 类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;T&gt; clz = extensionClasses.get(name);</div><div class="line"><span class="keyword">return</span> clz.newInstance();</div></pre></td></tr></table></figure>
<p>获取所有扩展:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;(extensionClasses.size());</div><div class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Class&lt;T&gt;&gt; entry : extensionClasses.entrySet()) &#123;</div><div class="line">    Activation activation = entry.getValue().getAnnotation(Activation.class);</div><div class="line">    <span class="keyword">if</span> (StringUtils.isBlank(key)) &#123;</div><div class="line">        exts.add(getExtension(entry.getKey()));</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activation != <span class="keyword">null</span> &amp;&amp; activation.key() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (String k : activation.key()) &#123;</div><div class="line">            <span class="keyword">if</span> (key.equals(k)) &#123;</div><div class="line">                exts.add(getExtension(entry.getKey()));</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Collections.sort(exts, <span class="keyword">new</span> ActivationComparator&lt;T&gt;());</div><div class="line"><span class="keyword">return</span> exts;</div></pre></td></tr></table></figure>
<h2 id="Motan-Config-配置"><a href="#Motan-Config-配置" class="headerlink" title="Motan - Config 配置"></a>Motan - Config 配置</h2><ul>
<li><strong><code>AbstractConfig</code></strong>: </li>
</ul>
<p>从像下面的这样的方法中提取 <code>key</code> 以及执行方法获取 <code>value</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public boolean isXXX() &#123;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String getName() &#123;</div><div class="line">    return &quot;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong><code>ProtocolConfig</code></strong>:</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>服务协议</td>
</tr>
<tr>
<td>serialization</td>
<td>序列化方式</td>
</tr>
<tr>
<td>codec</td>
<td>协议编码</td>
</tr>
<tr>
<td>iothreads</td>
<td>IO 线程池大小</td>
</tr>
<tr>
<td>requestTimeout</td>
<td>请求超时</td>
</tr>
<tr>
<td>minClientConnection</td>
<td>最小连接数</td>
</tr>
<tr>
<td>maxClientConnection</td>
<td>最大连接数</td>
</tr>
<tr>
<td>minWorkerThread</td>
<td>最小工作池线程数</td>
</tr>
<tr>
<td>maxWorkerThread</td>
<td>最大工作池线程数</td>
</tr>
<tr>
<td>maxContentLength</td>
<td>请求响应包的最大长度限制</td>
</tr>
<tr>
<td>maxServerConnection</td>
<td>Server 支持的最大连接数</td>
</tr>
<tr>
<td>poolLifo</td>
<td>连接池管理方式，是否 LIFO</td>
</tr>
<tr>
<td>lazyInit</td>
<td>是否延迟</td>
</tr>
<tr>
<td>endpointFactory</td>
<td>endpointFactory</td>
</tr>
<tr>
<td>cluster</td>
<td>采用哪种 cluster 的实现</td>
</tr>
<tr>
<td>loadbalance</td>
<td>负载均衡方式</td>
</tr>
<tr>
<td>haStrategy</td>
<td>high available strategy</td>
</tr>
<tr>
<td>workerQueueSize</td>
<td>server worker queue size</td>
</tr>
<tr>
<td>server accept connections count</td>
<td>acceptConnections</td>
</tr>
<tr>
<td>proxy</td>
<td>proxy type, like jdk or javassist</td>
</tr>
<tr>
<td>filter</td>
<td>filter, 多个filter用”,”分割，blank string 表示采用默认的filter配置</td>
</tr>
<tr>
<td>retries</td>
<td>retry count if call failure</td>
</tr>
<tr>
<td>async</td>
<td>if the request is called async, a taskFuture result will be sent back</td>
</tr>
<tr>
<td>isDefault</td>
<td>是否缺省配置</td>
</tr>
<tr>
<td>Map<string, string=""> parameters</string,></td>
<td>扩展参数</td>
</tr>
</tbody>
</table>
<h2 id="Motan-Spring-扩展"><a href="#Motan-Spring-扩展" class="headerlink" title="Motan - Spring 扩展"></a>Motan - Spring 扩展</h2><p>先简单介绍一下几个扩展 <code>Spring</code> 的重要接口:</p>
<h3 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>Bean</code> 的所有属性均被设置完的时候，此方法会被调用</p>
<h3 id="DisposableBean"><a href="#DisposableBean" class="headerlink" title="DisposableBean"></a>DisposableBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>Spring</code> 容器释放这个 <code>Bean</code> 的时候，次方法会被调用</p>
<h3 id="BeanFactoryAware"><a href="#BeanFactoryAware" class="headerlink" title="BeanFactoryAware"></a>BeanFactoryAware</h3><p>Interface to be implemented by beans <strong>that wish to be aware of their owning <code>BeanFactory</code></strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory var1)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aware</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>The <code>BeanPostProcessor</code> interface defines <strong>callback methods</strong> that you can implement to <strong>provide your own (or override the container’s default) instantiation logic, dependency-resolution logic</strong>, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more BeanPostProcessor implementations.</p>
<h2 id="Motan-log"><a href="#Motan-log" class="headerlink" title="Motan - log"></a>Motan - log</h2><ul>
<li><strong><code>LogService</code></strong>: 常见的 Log 方法</li>
</ul>
<p>默认实现 <code>DefaultLogService</code> 采用的是: <code>org.slf4j.Logger</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://weibo.com/ttarticle/p/show?id=2309404032432130125498" target="_blank" rel="external">Motan：支撑微博千亿调用的轻量级RPC框架</a></li>
<li><a href="http://weibo.com/ttarticle/p/show?id=2309403951077522312320" target="_blank" rel="external">支撑微博千亿调用的轻量级RPC框架：Motan</a></li>
<li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="external">ANNOTATION PROCESSING 101</a></li>
<li><a href="https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom" target="_blank" rel="external">Random over ThreadLocalRandom</a></li>
</ul>






</body>
</html>
