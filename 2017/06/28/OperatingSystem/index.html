<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>Operating System</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><h3 id="What-is-wrong-with-the-code-x-x-a-in-context-of-a-concurrent-system"><a href="#What-is-wrong-with-the-code-x-x-a-in-context-of-a-concurrent-system" class="headerlink" title="What is wrong with the code : x = x + a , in context of a concurrent system?"></a>What is wrong with the code : <code>x = x + a</code> , in context of a concurrent system?</h3><p>At machine level, <code>x = x + a</code> is implemented in multiple instructions :</p>
<ul>
<li>Load the value of <code>x</code> into register.</li>
<li>Add <code>a</code> to the register value.</li>
<li>Store the value from register.</li>
</ul>
<p>For concurrent systems, race condition can come and result in multiple processes/threads reading the old value simultaneously and updating independently. This will result in overwriting results from each other. To implement the code safely, we need to acquire write-lock (mutually exclusive lock) before writing our value. This will result in updating of value sequentially which will avoid the race condition:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(x, a)</span> </span>&#123;</span><br><span class="line">    lockW(x);</span><br><span class="line">    x = x + a;</span><br><span class="line">    unlockW(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="What-is-inode-in-file-system"><a href="#What-is-inode-in-file-system" class="headerlink" title="What is inode in file system?"></a>What is <code>inode</code> in file system?</h3><p><code>inode</code> is a type of <strong>data-structure</strong> in a UNIX-style file system, and is used to <strong>store a file’s metadata</strong> such as block location, owner, time of last change, etc.</p>
<p>In Linux Operaing System, <strong>Two files can have same inode number</strong>: In linux kernel Inode numbers are <strong>filesystem-specific</strong> and are created to index files locally. There is no mechanism for filesystems to coordinate across partitions and devices and future-connected devices to decide unique inode numbers. A file is identified by first identifying the device and an inode within the device. therefore two files on different devices or partitions can have same inode number. <strong>Hardlink is a good example.</strong></p>
<h3 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h3><p>The scheduler is an operating system module that <strong>selects the next jobs</strong> to be admitted into the system and the next process to run. </p>
<ul>
<li><strong>Long-term scheduling</strong>: decides which jobs or processes are to be admitted (from the secondary memory) to the ready queue (in main memory).</li>
<li><strong>Medium-term scheduling</strong>: The medium-term scheduler temporarily removes processes from main memory and places them in secondary memory.</li>
<li><strong>Short-term scheduling</strong>: decides which of the ready, in-memory processes is to be executed (allocated a CPU) after a clock interrupt, an I/O interrupt, an operating system call or another form of signal.</li>
</ul>
<h3 id="Example-of-fork-system-call"><a href="#Example-of-fork-system-call" class="headerlink" title="Example of fork() system call"></a>Example of <code>fork()</code> system call</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From Advanced Programming in the Unix Environment Figure 8.1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> glob = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> var; </span><br><span class="line">    <span class="keyword">pid_t</span> pid; </span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before fork\n"</span>); </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        glob++; </span><br><span class="line">        var++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">2</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid = %d, glob = %d, var = %d\n"</span>, getpid(), glob, var);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>fork()</code> system call is <strong>called once and returns twice</strong>. In child process, when we modify the local and global variables which are located in stack and heap respectively of the child process, only the child process will be affected with output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before fork</span><br><span class="line">pid = 9894, glob = 7, var = 89 // child output</span><br><span class="line">pid = 9893, glob = 6, var = 88 // parent output after 2 seconds</span><br></pre></td></tr></table></figure>
<p><img src="3_10_C_fork.jpg" alt=""></p>
<p><img src="3_10_ProcessCreation.jpg" alt=""></p>
<h3 id="Zombie-Processes-amp-Prevention"><a href="#Zombie-Processes-amp-Prevention" class="headerlink" title="Zombie Processes &amp; Prevention"></a>Zombie Processes &amp; Prevention</h3><p>When a process is created in UNIX using <code>fork()</code> system call, the address space of the Parent process is replicated. If the parent process calls <code>wait()</code> system call, then the execution of parent is suspended until the child is terminated. <strong>At the termination of the child, a ‘SIGCHLD’ signal is generated which is delivered to the parent by the kernel</strong>. Parent, on receipt of ‘SIGCHLD’ reaps the status of the child from the process table. Even though, the child is terminated, there is an entry in the process table corresponding to the child where the status is stored. When parent collects the status, this entry is deleted. Thus, all the traces of the child process are removed from the system. If the parent decides not to wait for the child’s termination and it executes its subsequent task, then at the termination of the child, the exit status is not read. Hence, there remains an entry in the process table even after the termination of the child. This state of the child process is known as the Zombie state.</p>
<p>Different ways in which creation of Zombie can be prevented:-</p>
<ul>
<li><strong>Using <code>wait()</code> system call</strong> : When the parent process calls wait(), after the creation of child, it indicates that, it will wait for the child to complete and it will reap the exit status of the child. The parent process is suspended(waits in a waiting queue) until the child is terminated. It must be understood that during this period, the parent process does nothing just waits.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A C program to demonstrate working of</span></span><br><span class="line"><span class="comment">// fork()/wait() and Zombie processes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I am Child\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am Parent\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>By ignoring the <code>SIGCHLD</code> signal</strong> : When a child is terminated, a corresponding SIGCHLD signal is delivered to the parent, if we call the ‘signal(SIGCHLD,SIG_IGN)’, then the SIGCHLD signal is ignored by the system, and the child process entry is deleted from the process table. Thus, no zombie is created. However, in this case, the parent cannot know about the exit status of the child.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A C program to demonstrate ignoring </span></span><br><span class="line"><span class="comment">// SIGCHLD signal to prevent Zombie processes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I am Child\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(SIGCHLD, SIG_IGN);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am Parent\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>By using a signal handler</strong> : The parent process installs a signal handler for the <code>SIGCHLD</code> signal. The signal handler calls <code>wait()</code> system call within it. In this senario, when the child terminated, the SIGCHLD is delivered to the parent.On receipt of SIGCHLD, the corresponding handler is activated, which in turn calls the <code>wait()</code> system call. Hence, the parent collects the exit status almost immediately and the child entry in the process table is cleared. Thus no zombie is created.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A C program to demonstrate handling of</span></span><br><span class="line"><span class="comment">// SIGCHLD signal to prevent Zombie processes.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I am Child\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(SIGCHLD, func);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am Parent\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Elaborate-what-happens-under-the-hood-after-typing-ls"><a href="#Elaborate-what-happens-under-the-hood-after-typing-ls" class="headerlink" title="Elaborate what happens under the hood after typing ls?"></a>Elaborate what happens under the hood after typing <code>ls</code>?</h3><p>First of all, whenever we press a key on keyboard, the keyboard controller will <strong>emit an interrupt signal to processor(CPU)</strong> indicating there is an event that needs immediate attention. As <strong>interrupts usually have high priority</strong>, the processor will suspending its current execution, save its state, and call an interrupt handler(should be the one that handles keyboard interrupt). Suppose <strong>we type ‘l’ then this character will be written the file that fd stdout points to</strong>, while shell’s stdout usually points to screen (a device, in *nix familiy, everything “looks” like a file), then “l” will be shown on the screen. After the interrupt handler finishes its job, the process will resume its original work.</p>
<p>We type ‘ls’ and hit enter, then shell will first <strong>check out $PATH environment variable</strong> to see if there is a program ‘ls’ under each given path. Suppose we find <code>/usr/bin/ls</code>. Shell will <strong>call <code>fork()</code></strong>, followed by <code>execve(&quot;/usr/bin/ls&quot;)</code>. <code>fork()</code> will create an identical child process and return twice. In parent(shell), it will typically call <code>wait()</code> to wait child process to complete. In child, it will execute <code>execve()</code> and a successful <code>execve()</code> will replace original data(including text, data, heap and stack, etc) in the child process’s address space with new data in order to run the new executable. Note that file descriptors opened by parent will be kept(that is why output from ls will be displayed on screen like shell).</p>
<p>Then the child process will be one that runs <code>/usr/bin/ls</code> code, it will make system calls(<code>open(2), printf(3c)</code> etc.) to list directory entries in the current working directory. After the child process finishes its job, it will call <code>exit()</code>(usually called implicitly by ‘return’ in <code>main()</code>). Then all of the fds, streams will be closed. The parent process(in this case the shell) will be notified of child’s termination, so <code>wait()</code> will be return and <strong>child exit code could be read from <code>wait()</code></strong>. Then parent process(the shell) can proceed, waiting for next command to run.</p>
<p>What will happen if another interrupt is received while the processor is running interrupt handler code?</p>
<p>A: Different OS may have different ways to deal with this situation. For linux, task of an interrupt handler is split into two halves, top half and bottom half. Top half runs with interrupts disabled and respond to the interrupt as fast as possible, then bottom half runs with interrupts enabled for as long as it needs and could be preempted.</p>
<p>How does shell implement I/O redirection if we want to redirect output of <code>ls</code> to another command as its input? like <code>ls | sort</code>:</p>
<p>A: Briefly speaking, shell will call a <code>pipe()</code> before <code>fork()</code> to <strong>get two fds</strong>, <code>rfd</code> for read end and <code>wfd</code> for write end, then call <strong>dup2(wfd, 1)</strong> in <code>ls</code> and <strong>dup2(rfd, 0)</strong> in <code>sort</code>.</p>
<p>There are <strong>two types of interrupts</strong>: <strong>hardware interrupt</strong>(which caused by external device, like keyboard, mouse, disk, etc) and <strong>software interrupt</strong>(which caused by program, like system call, divide-by-zero)</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>If a 进程 wishes to access another process’ resources, inter-process communications have to be used. These include <strong>管道, 文件, socks, and other forms</strong>.</p>
<h3 id="上下文切换-如何测量时间？-Cracking-The-Coding-Interview"><a href="#上下文切换-如何测量时间？-Cracking-The-Coding-Interview" class="headerlink" title="上下文切换: 如何测量时间？ - Cracking The Coding Interview"></a>上下文切换: 如何测量时间？ - Cracking The Coding Interview</h3><p>A context switch is the time spent switching between two processes. This happens in multitasking. The operating system must bring the state information of waiting processes into memory and save the state information of the currently running process.</p>
<p><strong>怎么知道发生了上下文切换</strong>: 我们不知道。</p>
<p>Another issue is that swapping is governed by the scheduling algorithm of the operating system and there may be many kernel level threads which are also doing context switches</p>
<p>In order to overcome these obstacles, <strong>构建环境</strong> such that after P1 executes, <strong>任务调度器立马选择 P2 去运行</strong>. This may be accomplished by constructing a data channel, such as <strong>管道</strong>, between P1 and P2 and having the two processes play a game of ping-pong with a data token.</p>
<p>That is, let’s allow P1 to be the initial sender and P2 to be the receiver. Initially, P2 is blocked (sleeping) as it awaits the data token. When P1 executes, it delivers the token over the data channel to P2 and immediately attempts to read a response token. However, since P2 has not yet had a chance to run, no such token is available for P1 and the process is blocked.This relinquishes the CPU.</p>
<p>A context switch results and the task scheduler must select another process to run. Since P2 is now in a ready-to-run state, it is a desirable candidate to be selected by the task scheduler for execution. When P2 runs, the roles of P1 and P2 are swapped. P2 is now acting as the sender and P1 as the blocked receiver. The game ends when P2 returns the token to P1.</p>
<ul>
<li>进程2 正在等待来自进程1 的数据</li>
<li>进程1 记录开始时间</li>
<li>进程1 发送 Token 给进程2</li>
<li>进程1 尝试从 进程2 读取响应，这会触发一个<strong>上下文切换</strong></li>
<li>进程2 被调度然后收到 Token</li>
<li>进程2 发送一个 Token 响应给进程1</li>
<li>进程2 尝试读取来自 进程1 的 Token 响应，这会触发一个<strong>上下文切换</strong></li>
<li>进程1 被调度然后收到了 Token</li>
<li>进程1 记录结束时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T = 2 * (Time of deliver + Time of context switch + Time of receive)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P1 ---token---&gt; CPU Context Switch ---token---&gt; P2</span><br><span class="line">P2 ---response---&gt; CPU Context Switch ---response ---&gt; P1</span><br></pre></td></tr></table></figure>
<p>P1 will be able to easily compute <code>T</code>, since this is just the time between events 3 and 8. So, to solve for Tc’ we must first determine the value of Td + Tr·</p>
<p>How can we do this? We can do this by measuring the length of time it takes P1 to send and receive a token to itself. This will not induce a context switch <strong>因为 P1 发送的时候已经运行在 CPU 上了，并不会阻塞它</strong>.</p>
<p>The game is played a number of iterations to average out any variability in the elapsed time between steps 2 and 9 that may result from unexpected kernel interrupts and additional kernel threads contendingfor the CPU. We select the smallest observed context switch time as our final answer.</p>
<p>However, all we can ultimately say that this is an approximation which depends on the underlying system. For example, <strong>我们假设一旦数据准备好，P2立马被调度运行</strong>. However, this is dependent on the implementation of the task scheduler and we cannot make any guarantees.</p>
<p>That’s okay; it’s important in an interview to recognize when your solution might not be perfect</p>
<h3 id="哲学家进餐问题，如何防止死锁-Cracking-The-Coding-Interview"><a href="#哲学家进餐问题，如何防止死锁-Cracking-The-Coding-Interview" class="headerlink" title="哲学家进餐问题，如何防止死锁 - Cracking The Coding Interview"></a>哲学家进餐问题，如何防止死锁 - Cracking The Coding Interview</h3><p><strong>(1) 要么成要么不成</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* same as before */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pickUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pickUp()) &#123;</span><br><span class="line">            chew();</span><br><span class="line">            putDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pickUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!left.pickUp()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!right.pickUp()) &#123;</span><br><span class="line">            left.putDown();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 优先级筷子</strong>:</p>
<p>为每一根筷子赋予一个数字 <code>0 ~ N-1</code>，每一位哲学家都得<strong>优先获取数字较小的那根筷子</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Chopstick lower, higher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.getNumber() &lt; right.getNumber()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lower = left;</span><br><span class="line">            <span class="keyword">this</span>.higher = right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lower = right;</span><br><span class="line">            <span class="keyword">this</span>.higher = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pickup();</span><br><span class="line">        chew();</span><br><span class="line">        putDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pickUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lower.pickup();</span><br><span class="line">        higher.pickup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        higher.putDown();</span><br><span class="line">        lower.putDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="保证不会出现死锁的时候才提供的锁-Cracking-The-Coding-Interview"><a href="#保证不会出现死锁的时候才提供的锁-Cracking-The-Coding-Interview" class="headerlink" title="保证不会出现死锁的时候才提供的锁 - Cracking The Coding Interview"></a>保证不会出现死锁的时候才提供的锁 - Cracking The Coding Interview</h3><p>There are several common ways to prevent deadlocks. One of the popular ways is to require a process to declare upfront what locks it will need. We can then verify if a deadlock would be created by issuing these locks, and we can fail if so.</p>
<h3 id="保证三个线程顺序执行-Cracking-The-Coding-Interview"><a href="#保证三个线程顺序执行-Cracking-The-Coding-Interview" class="headerlink" title="保证三个线程顺序执行 - Cracking The Coding Interview"></a>保证三个线程顺序执行 - Cracking The Coding Interview</h3><p>A lock in Java is owned by <strong>相同的线程</strong> which locked it.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Semaphore seml, sem2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sem1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">            sem2 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            sem1.acquire();</span><br><span class="line">            sem2.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (...) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            sem1.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (...) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sem1.acquire();</span><br><span class="line">            sem1.release();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            sem2.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (...) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sem2.acquire();</span><br><span class="line">            sem2.release();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (...) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件系统格式"><a href="#文件系统格式" class="headerlink" title="文件系统格式"></a>文件系统格式</h3><ul>
<li><code>FAT32</code> 支持的最大文件大小: <code>FAT32</code> was implemented on 32-bit hardware for a 32-bit operating system with a 32-bit compiler, so it’s an obvious choice and anything beyond 32 bits would have cost precious processor cycles, disk space and programming time. (In those days, we thought <strong>4GB</strong> was pretty large for an HD, let alone for a single file.) </li>
</ul>
<p><a href="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/" target="_blank" rel="noopener">特别好的操作系统课程</a></p>
<h3 id="进程被分为几部分"><a href="#进程被分为几部分" class="headerlink" title="进程被分为几部分"></a>进程被分为几部分</h3><ul>
<li>Process memory is divided into <strong>四部分</strong> as shown in Figure 3.1 below:<ul>
<li>The <strong>text section</strong> comprises the compiled program code <strong>编译后的程序</strong>, read in from non-volatile storage when the program is launched.</li>
<li>The <strong>data section</strong> stores global and static variables <strong>全局、静态变量</strong>, allocated and initialized prior to executing main.</li>
<li>The heap is used for <strong>dynamic memory allocation 动态内存分配</strong>, and is managed via calls to new, delete, malloc, free, etc.</li>
<li>The stack is used for <strong>local variables</strong>. Space on the stack is reserved for local variables when they are declared ( at function entrance or elsewhere, depending on the language ), and the space is freed up when the variables go out of scope. Note that the stack is also used for function return values, and the exact mechanisms of stack management may be language specific.</li>
<li>Note that the stack and the heap start at opposite ends of the process’s free space and grow towards each other. If they should ever meet, then either a stack overflow error will occur, or else a call to new or malloc will fail due to insufficient memory available.</li>
</ul>
</li>
</ul>
<p><img src="3_01_Process_Memory.jpg" alt=""></p>
<h3 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h3><p>child code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> exitCode;</span><br><span class="line"><span class="built_in">exit</span>( exitCode );  <span class="comment">// return exitCode; has the same effect when executed from main( )</span></span><br></pre></td></tr></table></figure>
<p>parent code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> status</span><br><span class="line">pid = wait( &amp;status ); </span><br><span class="line"><span class="comment">// pid indicates which child exited. exitCode in low-order bits of status</span></span><br><span class="line"><span class="comment">// macros can test the high-order bits of status for why it stopped</span></span><br></pre></td></tr></table></figure>
<p>Processes may also be terminated by the system for a variety of reasons, including:</p>
<ul>
<li>The inability of the system to deliver necessary system resources.</li>
<li>In response to a <code>KILL</code> command, or other un handled process interrupt.</li>
<li>A parent may kill its children if the task assigned to them is no longer needed.</li>
<li>If the parent exits, the system may or may not allow the child to continue <strong>没有父进程</strong>. ( On UNIX systems, orphaned processes are generally inherited by init, which then proceeds to kill them. The UNIX <strong><code>nohup</code></strong> command allows a child to <strong>继续执行</strong> after <strong>父进程已经退出</strong>. )</li>
</ul>
<h3 id="进程协调"><a href="#进程协调" class="headerlink" title="进程协调"></a>进程协调</h3><p>Communications models: </p>
<ul>
<li><strong>Message passing</strong></li>
<li><strong>Shared memory</strong></li>
</ul>
<p><img src="3_12_CommunicationsModels.jpg" alt=""></p>
<ul>
<li>Shared Memory is faster once it is set up, because no system calls are required and access occurs at normal memory speeds. However it is more complicated to set up, and doesn’t work as well across multiple computers. Shared memory is generally preferable when large amounts of information must be shared quickly on the same computer.</li>
<li>Message Passing requires system calls for every message transfer, and is therefore slower, but it is simpler to set up and works well across multiple computers. Message passing is generally preferable when the amount and/or frequency of data transfers is small, or when multiple computers are involved.</li>
</ul>
<h4 id="Shared-Memory-消费者-生产者"><a href="#Shared-Memory-消费者-生产者" class="headerlink" title="Shared Memory 消费者-生产者"></a>Shared Memory 消费者-生产者</h4><h3 id="以下哪种方式，在读取磁盘上多个顺序数据块时的效率最高？"><a href="#以下哪种方式，在读取磁盘上多个顺序数据块时的效率最高？" class="headerlink" title="以下哪种方式，在读取磁盘上多个顺序数据块时的效率最高？"></a>以下哪种方式，在读取磁盘上多个顺序数据块时的效率最高？</h3><ul>
<li>程序直接访问方式跟循环检测IO方式，应该是一个意思吧，是最古老的方式。CPU和IO串行，<strong>每读一个字节（或字）</strong>，CPU都需要不断检测状态寄存器的busy标志，当busy=1时，表示IO还没完成；当 <code>busy=0</code> 时，表示IO完成。此时读取一个字的过程才结束，接着读取下一个字。</li>
<li>中断控制方式：循环检测先进些，IO设备和CPU可以并行工作，<strong>只有在开始IO和结束IO时，才需要CPU。但每次只能读取一个字</strong>。</li>
<li>DMA方式：Direct Memory Access，直接存储器访问，比中断先进的地方是每次可以<strong>读取一个块</strong>，而不是一个字。</li>
<li><font color="red"><strong>通道方式</strong></font>：比DMA先进的地方是，每次<strong>可以处理多个块</strong>，而不只是一个块。</li>
</ul>
<h3 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h3><p><img src="Big-Endian.svg.png" alt=""><br><img src="280px-Little-Endian.svg.png" alt=""></p>






<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
