<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>Redis</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-Jedis-的用法"><a href="#1-Jedis-的用法" class="headerlink" title="(1) Jedis 的用法"></a>(1) <a href="https://github.com/xetorthio/jedis/wiki/Getting-started" target="_blank" rel="noopener"><code>Jedis</code></a> 的用法</h3><h4 id="1-1-多线程环境"><a href="#1-1-多线程环境" class="headerlink" title="(1.1) 多线程环境"></a>(1.1) 多线程环境</h4><p><strong>单个 <code>Jedis</code> 实例不是线程安全</strong>的，于是我看见了这样的代码，这样的问题在于不停地在创建 <code>Jedis</code> 实例，而<strong>每一个 <code>Jedis</code> 就意味着一条连接</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( tasknum.get() &gt; <span class="number">49</span> )&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    jedis = <span class="keyword">new</span> Jedis(redisip, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，推荐<strong>使用 <code>JedisPool</code> 来获得更好的性能</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jedis = pool.getResource();</span><br><span class="line">    <span class="comment">/// ... do stuff here ... for example</span></span><br><span class="line">    jedis.set(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">    String foobar = jedis.get(<span class="string">"foo"</span>);</span><br><span class="line">    jedis.zadd(<span class="string">"sose"</span>, <span class="number">0</span>, <span class="string">"car"</span>); jedis.zadd(<span class="string">"sose"</span>, <span class="number">0</span>, <span class="string">"bike"</span>); </span><br><span class="line">    Set&lt;String&gt; sose = jedis.zrange(<span class="string">"sose"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// ... when closing your application:</span></span><br><span class="line">pool.destroy();</span><br></pre></td></tr></table></figure>
<h3 id="2-查看日志"><a href="#2-查看日志" class="headerlink" title="(2) 查看日志"></a>(2) 查看日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/redis</span><br></pre></td></tr></table></figure>
<h3 id="3-Redis-简介"><a href="#3-Redis-简介" class="headerlink" title="(3) Redis 简介"></a>(3) Redis 简介</h3><p><code>Redis</code> 的全称是:</p>
<p><img src="17-08-13-11_12_27_709_221.png" alt=""></p>
<p><code>Redis</code> 可以做:</p>
<ul>
<li>缓存</li>
<li>排行榜系统</li>
<li>计数器应用</li>
<li>社交网络</li>
<li>消息队列系统</li>
</ul>
<p><code>Redis</code> 不可以做:</p>
<ul>
<li>存放大规模数据</li>
<li>存放冷数据</li>
</ul>
<p><strong>豌豆荚</strong>开源了基于 <code>Proxy</code> 的 <code>Redis</code> 分布式实现 <strong><code>Codis</code></strong></p>
<hr>
<p>查看<strong>版本</strong>，<code>Redis</code> 借鉴了 <code>Linux</code> 操作系统对于<strong>版本号的命名规则</strong>: 版本号第二位如果是奇数，则为非稳定版本，如果是偶数，则为稳定版本:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$redis</span>-cli -v</span><br><span class="line">redis-cli 3.0.6</span><br></pre></td></tr></table></figure>
<hr>
<p>安装完 <code>redis</code> 之后，多了<strong>几个 <code>redis</code> 工具</strong>:</p>
<p><img src="17-08-13-11_24_14_791_153.png" alt=""></p>
<hr>
<p>启动:</p>
<ul>
<li>使用 <strong><code>redis-sever</code> 启动</strong>:</li>
</ul>
<p><img src="17-08-13-11_29_01_1300_567.png" alt=""></p>
<p>这种方式<strong>无法自定义配置</strong>，生成环境中根本不会使用</p>
<ul>
<li>使用 <strong><code>redis-server --port 6380</code></strong> 启动:</li>
</ul>
<p>如果需要修改的配置较多或者希望将配置保存到文件中，不建议使用这种方式</p>
<ul>
<li>使用 <strong><code>redis-sever xxx.conf</code></strong> 配置文件来启动:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server ~/Documents/github/redis/redis.conf</span><br></pre></td></tr></table></figure>
<p><img src="17-08-13-11_53_23_892_77.png" alt=""></p>
<hr>
<p><strong><code>redis</code></strong> 默认的几个比较<strong>重要的配置</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># By default Redis does not run as a daemon. Use &apos;yes&apos; if you need it.</span><br><span class="line"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line">daemonize no</span><br><span class="line"># Accept connections on the specified port, default is 6379.</span><br><span class="line"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port 6379</span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &apos;dbfilename&apos; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br><span class="line"># Specify the log file name. Also the empty string can be used to force</span><br><span class="line"># Redis to log on the standard output. Note that if you use standard</span><br><span class="line"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="line">logfile &quot;&quot;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><code>redis-cli</code> 连接</strong>到 <code>redis-server</code> 的<strong>两种方式</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互方式</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line"><span class="comment"># 命令方式</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 get hello</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>停止 <code>redis</code></strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/redis-server restart</span><br><span class="line">/etc/init.d/redis-server stop</span><br><span class="line">/etc/init.d/redis-server start</span><br></pre></td></tr></table></figure>
<p><strong>Mac OS (未测试)</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure>
<p>除了可以通过 <code>shutdown</code> 命令关闭 <code>redis</code> 服务之外，还可以通过 <code>kill pid</code> 的方式关闭 <code>redis</code>，但是<strong>不要粗暴地使用 <code>kill -9</code> 强制杀死 <code>redis</code> 服务</strong>，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况会造成 AOF 和复制丢失数据的情况。</p>
<h3 id="4-Redis-命令"><a href="#4-Redis-命令" class="headerlink" title="(4) Redis 命令"></a>(4) Redis 命令</h3><p><strong>全局命令</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出所有键</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键的总数</span></span><br><span class="line">dbsize</span><br></pre></td></tr></table></figure>
<p><code>dbsize</code> 命令在计算键总数时不会遍历所有键，而是直接获取 <code>Redis</code> 内置的键总数变量，所以 <code>dbsize</code> 命令的时间复杂度是 <code>O(1)</code>。而 <strong><code>keys</code> 命令会遍历所有键</strong>，所以它的时间复杂度是 <code>O(n)</code>，当 <code>Redis</code> 保存了大量键时，<strong>线上环境禁止使用</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查键是否存在</span></span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除键</span></span><br><span class="line">del key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键过期，超过指定时间后，会自动删除键</span></span><br><span class="line">expire key seconds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回键的剩余过期时间: -1: 键没有过期时间; -2: 键不存在</span></span><br><span class="line">ttl key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键的数据结构类型，注意是键的，不是值的</span></span><br><span class="line"><span class="built_in">type</span> key</span><br></pre></td></tr></table></figure>
<p><code>string, hash, list, set, zset</code> 只是 <code>Redis</code> 对外的数据结构，实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样 <code>Redis</code> 会在合适的场景选择合适的内部编码，可以通过 <code>object encoding</code> 命令查询内部编码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; object encoding mlist</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>
<p><img src="1025557994-59433aafdce44_articlex.png" alt=""></p>
<h3 id="5-Redis-的单线程架构"><a href="#5-Redis-的单线程架构" class="headerlink" title="(5) Redis 的单线程架构"></a>(5) Redis 的单线程架构</h3><p>Redis 是使用了 <code>单线程架构</code> 和 <code>I/O多路复用模型</code> 来实现高性能的内存数据库服务。Redis 是<strong>单线程来处理命令</strong>的，所以命令到达 Redis 后并不会立即执行，而是<strong>进入队列之后逐个执行</strong>。对于差不多同时到达的命令执行的顺序是无法确定的。</p>
<p><img src="226737223.jpg" alt=""></p>
<p><strong>为什么单线程还能如此快？</strong></p>
<ul>
<li><strong>1. 纯内存访问</strong></li>
<li><strong>2. 非阻塞 I/O，使用 <code>epoll</code> 作为 I/O 多路复用技术的实现</strong>:</li>
</ul>
<p><img src="1228862924.jpg" alt=""></p>
<ul>
<li><strong>3. 单线程避免了线程切换和竞态产生的消耗</strong></li>
</ul>
<p>但是单线程会有一个问题，<strong>对于每个命令的执行时间是有要求的</strong>。如果某个命令执行过长，<strong>会造成其他命令的阻塞</strong>，对于 <code>Redis</code> 这种高性能的服务来说是致命的。</p>
<h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="(6) 字符串"></a>(6) 字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置秒级、毫秒级过期时间</span></span><br><span class="line"><span class="comment"># nx: 键必须不存在，才可以设置成功，用于添加</span></span><br><span class="line"><span class="comment"># xx: 与 nx 想法，键必须存在，才可以设置成功，用于更新</span></span><br><span class="line"><span class="built_in">set</span> key value [ex seconds] [px milliseconds] [nx|xx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 ex 作用一样</span></span><br><span class="line">setex key seconds value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 nx 作用一样</span></span><br><span class="line">setnx key value</span><br></pre></td></tr></table></figure>
<p><code>setnx</code> 与 <code>setxx</code> 在实际使用中有什么应用场景吗？以 <code>setnx</code> 为例子，由于 <code>Redis</code> 的单线程命令处理机制，如果有多个客户端同时执行 <code>setnx key value</code>，根据 <code>setnx</code> 的特性，只有一个客户端才能设置成功，<strong><code>setnx</code> 可以作为分布式锁</strong>的一种实现方案。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量设置键值对</span></span><br><span class="line">mset key value [key value ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量获取值</span></span><br><span class="line">mget key [key ...]</span><br></pre></td></tr></table></figure>
<hr>
<p>设计<strong>合理的键名</strong>，有利于放置键冲突和项目的可维护性，比较推荐的方式是使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">业务名:对象名:id:[属性]</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>共享 <code>Session</code></strong> :</p>
<p><img src="720738266.jpg" alt=""></p>
<h3 id="7-哈希"><a href="#7-哈希" class="headerlink" title="(7) 哈希"></a>(7) 哈希</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置值 &#123;name=Tom&#125;</span></span><br><span class="line">hset user:1 name Tom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line">hget user:1 name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除值</span></span><br><span class="line">hdel user:1 name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到字段的个数</span></span><br><span class="line">hlen user:1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量设置</span></span><br><span class="line">hmset user:1 name Tom age 23</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量获取</span></span><br><span class="line">hmget user:1 name age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的字段</span></span><br><span class="line">hkeys user:1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的值</span></span><br><span class="line">hvals user:1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的 &#123;key=value&#125;</span></span><br><span class="line">hgetall user:1</span><br></pre></td></tr></table></figure>
<p>在使用 <strong><code>hgetall</code></strong> 的时候，如果哈希元素个数比较多，会存在<strong>阻塞 <code>Redis</code> 的可能</strong>。如果开发人员只需要获取部分字段，可以使用 <code>hmget</code>，如果一定要获取全部 <code>field-value</code>，可以使用 <strong><code>hscan</code></strong> 命令，该命令会<strong>渐进式遍历哈希类型</strong>。</p>
<p><strong>两种情况会触发哈希类型的内部编码发生变化</strong>:</p>
<p><img src="17-08-13-14_46_05_693_312.png" alt=""></p>
<h3 id="8-列表"><a href="#8-列表" class="headerlink" title="(8) 列表"></a>(8) 列表</h3><p>列表<strong>两端插入和弹出</strong>操作:</p>
<p><img src="1584601931.jpg" alt=""></p>
<p>列表<strong>获取、删除</strong>等操作:</p>
<p><img src="985890936.jpg" alt=""></p>
<p>列表中的元素是<strong>有序</strong>、<strong>可重复</strong>的。</p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从右边插入元素</span></span><br><span class="line">rpush user:1:message a b c d e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左边插入元素</span></span><br><span class="line">lpush user:1:message e d c b a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左到右获取列表的所有元素</span></span><br><span class="line">lrange user:1:message 0 -1</span><br><span class="line">lrange user:1:message 0 4</span><br><span class="line">lrange user:1:message -5 -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向某个元素前或者后插入元素，从列表中找到等于 d 的元素，然后在前面插入 item</span></span><br><span class="line"><span class="comment"># a b c item d e</span></span><br><span class="line">linsert user:1:message before d item</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取索引为 3 的元素</span></span><br><span class="line">lindex user:1:message 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列表长度</span></span><br><span class="line">llen user:1:message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表左侧弹出元素</span></span><br><span class="line">lpop user:1:message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表右侧弹出元素</span></span><br><span class="line">rpop user:1:message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有值为 a 元素</span></span><br><span class="line">lrem user:1:message 0 a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左到右，删除最多 3 个值为 a 的元素</span></span><br><span class="line">lrem user:1:message 3 a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右到做，删除最多 |-3| 个值为 a 的元素</span></span><br><span class="line">lrem user:1:message -3 a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留第 2 到第 4 个元素</span></span><br><span class="line">ltrim user:1:message 1 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改下标为 2 处的元素值为 newValue</span></span><br><span class="line">lset user:1:message 2 newValue</span><br></pre></td></tr></table></figure>
<p><code>lrange</code> 的操作会获取列表指定索引范围所有的元素。索引下标有两个特点: </p>
<ul>
<li>索引下标从做导游分别是 0 到 N-1，但是从右到左分别是 -1 到 -N</li>
<li><code>lrange</code> 中的 <code>end</code> 选项包含了自身，这个和很多编程语言不包含 <code>end</code> 不太相同</li>
</ul>
<hr>
<p><strong>阻塞操作</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key...] timeout</span><br><span class="line">brpop key [key...] timeout</span><br></pre></td></tr></table></figure>
<p>如果 <code>timeout</code> 设置为 <strong>0</strong>，那么如果<strong>列表为空</strong>，客户端会<strong>一直阻塞</strong>下去。</p>
<p>以 <code>brpop</code> 为例，在使用 <code>brpop</code> 时，有两点需要注意:</p>
<ul>
<li>如果是多个键，那么 <code>brpop</code> 会<strong>从左至右</strong>遍历键，<strong>一旦有一个键能弹出元素</strong>，客户端会立即返回。</li>
<li>如果多个客户端对同一个键执行 <code>brpop</code>，那么<strong>最先执行 <code>brpop</code> 命令的客户端可以获取到弹出的值</strong>，另外两个客户端继续阻塞。</li>
</ul>
<p>TODO 此处应该有 1091 页图</p>
<h3 id="9-集合"><a href="#9-集合" class="headerlink" title="(9) 集合"></a>(9) 集合</h3><p>集合<strong>不允许有重复元素</strong>，并且集合中的元素是<strong>无序</strong>的，<code>Redis</code> 除了支持集合内的增删改查，同时还支持<strong>多个集合取交集、并集、差集</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">sadd user:1:follow it music sports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多个元素</span></span><br><span class="line">srem user:1:follow it music</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算元素个数</span></span><br><span class="line">scard user:1:follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否在集合中</span></span><br><span class="line">sismember user:1:follow it</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机从集合中返回指定个数的元素</span></span><br><span class="line">srandmember user:1:follow 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合中随机弹出一个元素</span></span><br><span class="line">spop user:1:follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有元素</span></span><br><span class="line">smembers user:1:follow</span><br></pre></td></tr></table></figure>
<p><strong><code>smembers</code> 和 <code>lrange</code>、<code>hgetall</code></strong> 都属于<strong>比较重</strong>的命令，如果元素过多存在阻塞 <code>Redis</code> 的可能性，这时候可以使用 <code>sscan</code> 来完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求多个集合的交集</span></span><br><span class="line">sinter user:1:follow user:2:follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求多个集合的并集</span></span><br><span class="line">sunion user:1:follow user:2:follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求多个集合的差集</span></span><br><span class="line"><span class="comment"># user:1 中有，user:2 中没有的</span></span><br><span class="line">sdiff user:1:follow user:2:follow</span><br><span class="line"><span class="comment"># user:2 中有，user:1 中没有的</span></span><br><span class="line">sdiff user:2:follow user:1:follow</span><br></pre></td></tr></table></figure>
<hr>
<p>典型使用场景: <strong>标签</strong>:</p>
<p><strong>给用户添加标签</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag3</span><br><span class="line">sadd user:2:tags tag2 tag4 tag5</span><br></pre></td></tr></table></figure>
<p><strong>给标签添加用户</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sadd tag1:users user:1 user:3</span><br><span class="line">sadd tag2:users user:1 user:2 user:3</span><br></pre></td></tr></table></figure>
<p><strong>删除用户下的标签</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem user:1:tags tag1 tag3</span><br></pre></td></tr></table></figure>
<p><strong>删除标签下的用户</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem tag1:users user:1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用户和标签的关系维护应该在<strong>一个事务</strong>内执行，防止部分命令失败造成的数据不一致。</p>
</blockquote>
<h3 id="10-有序集合"><a href="#10-有序集合" class="headerlink" title="(10) 有序集合"></a>(10) 有序集合</h3><p>为每个元素设置一个 <code>score</code> 作为排序的依据，有序集合中的元素不能重复，但是 <code>score</code> 可以重复，就像<strong>一个班里学生学号不能重复，但是考试成绩可以相同</strong>一个道理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加成员</span></span><br><span class="line">zadd user:ranking 251 Tom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算成员个数</span></span><br><span class="line">zcard user:ranking</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算某个成员的分数</span></span><br><span class="line">zscore user:ranking Tom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分数从低到高排序</span></span><br><span class="line">zrank user:ranking member</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除成员</span></span><br><span class="line">zrem user:ranking Tom [member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 Tom 增加 19 分</span></span><br><span class="line">zincrby user:ranking 19 Tom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定排名范围 (后三名) 的成员 (包含分数), zrange 是从低到高排名的</span></span><br><span class="line">zrange user:ranking 0 2 withscores</span><br><span class="line"><span class="comment"># 返回前三名</span></span><br><span class="line">zrevrange user:ranking 0 2 withscores</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 200 &gt; 221 之间的成员</span></span><br><span class="line">zrangebyscore user:ranking 200 221 withscores</span><br><span class="line"><span class="comment"># 返回 221 -&gt; 200 之间的成员</span></span><br><span class="line">zrevrangebyscore user:ranking 221 200 withscores</span><br><span class="line"><span class="comment"># 返回 &gt;= 200 的成员</span></span><br><span class="line">zrangebyscore user:ranking 200 +inf withscores</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 200 -&gt; 221 之间的成员个数</span></span><br><span class="line">zcount user:ranking 200 221</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除成绩最低的三名成员</span></span><br><span class="line">zremrangebyrank user:ranking 0 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定分数范围内的成员</span></span><br><span class="line">zremrangebyscore user:ranking 250 +inf</span><br></pre></td></tr></table></figure>
<p>有序集合比集合提供了排序字段，但是也产生了代价，<code>zadd</code> 的时间复杂度为 <code>O(log(n))</code>，<strong>有序集合一般用在排行榜系统中</strong></p>
<h3 id="11-键管理"><a href="#11-键管理" class="headerlink" title="(11) 键管理"></a>(11) 键管理</h3><ul>
<li><strong>对于字符串类型，执行 <code>set</code> 命令会去掉过期时间</strong>，这个问题很容易在开发中被忽视。</li>
<li><code>setex</code> 命令作为 <code>set + expire</code> 的组合，不但是<strong>原子执行</strong>，同时<strong>减少了一次网络通讯的时间</strong>。</li>
</ul>
<p><strong>迁移键</strong>:</p>
<p>(1) <code>move</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis 内部多个数据库之间互相迁移，不建议使用</span></span><br><span class="line">move key db</span><br></pre></td></tr></table></figure>
<p><img src="1967137130.jpg" alt=""></p>
<p>(2) <code>dump + restore</code></p>
<p><img src="320215817.jpg" alt=""></p>
<p>在源 <code>Redis</code> 上执行 <code>dump</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; dump hello</span><br><span class="line"><span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span><br></pre></td></tr></table></figure>
<p>在目标 <code>Redis</code> 上执行 <code>restore</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; restore hello 0 <span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line"><span class="string">"world"</span></span><br></pre></td></tr></table></figure>
<p>(3) <code>migrate</code></p>
<p><code>migrate</code> 命令就是将 <code>dump</code>, <code>restore</code>, <code>del</code> 这三个命令进行组合，从而简化了操作流程。<code>migrate</code> 命令具有原子性，而且从 <code>Redis 3.0.6</code> 以后已经支持迁移多个键的功能。</p>
<p><img src="904612627.jpg" alt=""></p>
<h3 id="12-输入输出缓冲"><a href="#12-输入输出缓冲" class="headerlink" title="(12) 输入输出缓冲"></a>(12) 输入输出缓冲</h3><p><code>Redis</code> 为每个客户端分配了输入缓冲区，它的作用是将客户端发送的命令临时保存，同时 <code>Redis</code> 会从输入缓冲区拉取命令并执行，输入缓冲区为客户端发送命令到 <code>Redis</code> 执行命令提供了缓冲功能:</p>
<p><img src="1266411753.jpg" alt=""></p>
<p>输入缓冲区使用不当会产生两个问题:</p>
<ul>
<li>每个客户端的输入缓冲区的大小都不能超过 1G，超过后客户端将会被关闭</li>
<li><strong>输入缓冲区不受 <code>maxmemory</code> 控制</strong></li>
</ul>
<p><img src="17-08-15-11_23_56_1051_198.png" alt=""></p>
<p>同样，<code>Redis</code> 为每个客户端分配了输出缓冲区，它的作用是保存命令执行的结果返回给客户端，为 <code>Redis</code> 和客户端交互返回结果提供缓冲:</p>
<p><img src="1502022510.jpg" alt=""></p>
<p>输出缓冲区做的很细致，按照客户端的不同分为三种: <strong>普通客户端、发布订阅客户端、<code>slave</code> 客户端</strong>:</p>
<p><img src="54388826.jpg" alt=""></p>
<p>对应的配置规则为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;class&gt;</code>: 客户端类型: <code>normal</code>, <code>slave</code>, <code>pubsub</code></li>
<li><code>&lt;hard limit&gt;</code>: 如果客户端使用的输出缓冲区大于 <code>&lt;hard limit&gt;</code>，那么<strong>客户端会立即关闭</strong>。</li>
<li><code>&lt;sort limit&gt;, &lt;soft seconds&gt;</code>: 如果客户端使用的输出缓冲区超过了 <code>&lt;soft limit&gt;</code> 并且<strong>持续了</strong> <code>&lt;sort seconds&gt;</code> 秒，客户端会被立即关闭。</li>
</ul>
<p>实际上输出缓冲区由两部分组成: 固定缓冲区 (16KB) 和动态缓冲区，其中固定缓冲区返回比较小的执行结果，而动态缓冲区返回比较大的结果。固定缓冲区使用的是字节数组，动态缓冲区使用的是列表。当固定缓冲区存满后会将 <code>Redis</code> 新的返回结果存放在动态缓冲区的队列中:</p>
<p><img src="17-08-15-11_15_08_1050_232.png" alt=""></p>
<p><strong>输出缓冲区同样也不会收到 <code>maxmemory</code> 的限制</strong>，如果使用不当同样会造成 <code>maxmemory</code> 用满产生的数据丢失、键值淘汰、OOM 等情况。</p>
<h3 id="13-如何识别-Redis-是否有内存交换"><a href="#13-如何识别-Redis-是否有内存交换" class="headerlink" title="(13) 如何识别 Redis 是否有内存交换"></a>(13) 如何识别 Redis 是否有内存交换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询进程号</span></span><br><span class="line">redis-cli -p 6379 info server | grep process_id</span><br><span class="line"><span class="comment"># 查询内存交换信息</span></span><br><span class="line">sudo cat /proc/1166/smaps | grep Swap</span><br></pre></td></tr></table></figure>
<p>如果<strong>交换量都是 0KB 或者个别的是 4KB</strong>，则是正常现象，说明 <code>Redis</code> 进程内存没有被交换。预防内存交换主要就是：</p>
<ul>
<li><strong>增加内存</strong></li>
<li><strong>确保所有 <code>Redis</code> 实例设置了 <code>maxmemory</code></strong></li>
</ul>
<h3 id="14-Redis-可视化"><a href="#14-Redis-可视化" class="headerlink" title="(14) Redis 可视化"></a>(14) Redis 可视化</h3><ul>
<li><a href="https://github.com/nkrode/RedisLive" target="_blank" rel="noopener"><strong>RedisLive</strong></a></li>
</ul>
<h3 id="15-内存占用"><a href="#15-内存占用" class="headerlink" title="(15) 内存占用"></a>(15) 内存占用</h3><p><img src="747077755.jpg" alt=""></p>
<p><strong><code>maxmemory</code> 限制的是 <code>Redis</code> 实际使用的内存量，也就是 <code>used_memory</code> 统计项对应的内存</strong>。由于内存碎片率的存在，实际消耗的内存可能会比 <code>maxmemory</code> 设置的更大，实际使用时要小心这部分内存溢出。</p>
<p><img src="527266900.jpg" alt=""></p>
<p><code>Redis</code> 存储的<strong>所有值对象</strong>在内部定义为 <code>redisObject</code> 结构体:</p>
<p><img src="1793122074.jpg" alt=""></p>
<p>降低 <code>Redis</code> 内存使用最直接的方式就是缩减键 (key) 和值 (value) 的长度。</p>
<ul>
<li><code>key</code>: <code>user:{uid}:friends:notiry:{fid}</code> 可简化为 <code>u:{uid}:fs:nt:{fid}</code></li>
<li><code>value</code>: 业务对象序列化成二进制对象放入 <code>Redis</code>。首先应该在业务上<strong>精简业务对象</strong>，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择<strong>更高效的序列化工具</strong>来降低字节数组大小。</li>
</ul>
<p><img src="504991348.jpg" alt=""></p>
<p><code>Redis</code> 内部维护 [0 - 9999] 的整数对象池，用于节约内存。因此开发中在满足需求的前提下，<strong>尽量使用整数对象以节省内存</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> foo 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object refcount foo</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bar 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object refcount bar</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
<p><img src="191229736.jpg" alt=""></p>
<p>需要注意的是对象池并不是只要存储 [0 - 9999] 就可以工作。当设置 <code>maxmemory</code> 并启用 LRU 相关淘汰策略如: <code>volatile-lru</code>, <code>allkeys-lru</code> 时，<code>Redis</code> 禁止使用共享对象池。</p>
<p>为什么开启 <code>maxmemory</code> 和 <code>LRU</code> 淘汰策略后对象池无效? LRU 算法需要获取对象最后被访问时间，而每个对象最后访问时间存储在 <code>redisObject</code> 对象的 <code>lru</code> 字段中。对象存储意味着多个引用共享同一个 <code>redisObject</code>，这时<strong> <code>lru</code> 字段也会被共享</strong>，导致无法获取每个对象的最后访问时间。因此两者冲突，使用时需要注意。</p>
<h3 id="16-遍历键"><a href="#16-遍历键" class="headerlink" title="(16) 遍历键"></a>(16) 遍历键</h3><ul>
<li><strong>1. 全量遍历</strong>:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配任意字符</span></span><br><span class="line">keys *</span><br><span class="line"><span class="comment"># . 代表匹配一个字符</span></span><br><span class="line">keys a.c</span><br><span class="line"><span class="comment"># 匹配 jedis, redis</span></span><br><span class="line">keys [j,r]edis</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>2. 渐进式遍历</strong>:</li>
</ul>
<p>Redis 存储键值对实际使用的是 <code>hashtable</code> 的数据结构，其简化模型如下:</p>
<p><img src="318175513.jpg" alt=""></p>
<p>每次执行 <code>scan</code>，可以想象成<strong>只扫描一个字典中的一部分键</strong>，直到将字典中的所有键遍历完毕，<code>scan</code> 用法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次 scan 完，返回当前游标的值，直到重新变为 0</span></span><br><span class="line"><span class="comment"># count number: 每次要遍历的键的个数，默认为 10</span></span><br><span class="line">scan cursor [match pattern] [count number]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> a 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> b 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> c 3</span><br><span class="line">...</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> x 24</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> y 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> z 26</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>第一次扫描:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) <span class="string">"17"</span></span><br><span class="line">2)  1) <span class="string">"a"</span></span><br><span class="line">    2) <span class="string">"e"</span></span><br><span class="line">    3) <span class="string">"o"</span></span><br><span class="line">    4) <span class="string">"f"</span></span><br><span class="line">    5) <span class="string">"k"</span></span><br><span class="line">    6) <span class="string">"q"</span></span><br><span class="line">    7) <span class="string">"g"</span></span><br><span class="line">    8) <span class="string">"s"</span></span><br><span class="line">    9) <span class="string">"l"</span></span><br><span class="line">   10) <span class="string">"y"</span></span><br></pre></td></tr></table></figure>
<p>第二次扫描:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 17</span><br><span class="line">1) <span class="string">"19"</span></span><br><span class="line">2)  1) <span class="string">"z"</span></span><br><span class="line">    2) <span class="string">"i"</span></span><br><span class="line">    3) <span class="string">"d"</span></span><br><span class="line">    4) <span class="string">"u"</span></span><br><span class="line">    5) <span class="string">"r"</span></span><br><span class="line">    6) <span class="string">"w"</span></span><br><span class="line">    7) <span class="string">"p"</span></span><br><span class="line">    8) <span class="string">"x"</span></span><br><span class="line">    9) <span class="string">"h"</span></span><br><span class="line">   10) <span class="string">"b"</span></span><br></pre></td></tr></table></figure>
<p>第三次扫描:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 19</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2) 1) <span class="string">"m"</span></span><br><span class="line">   2) <span class="string">"v"</span></span><br><span class="line">   3) <span class="string">"j"</span></span><br><span class="line">   4) <span class="string">"n"</span></span><br><span class="line">   5) <span class="string">"t"</span></span><br><span class="line">   6) <span class="string">"c"</span></span><br></pre></td></tr></table></figure>
<p><code>cursor</code> 返回 0，说明所有键已经被遍历过了。</p>
<p>除了 <code>scan</code> 以外，Redis 提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决诸如 <code>hgetall</code>、<code>smembers</code>、<code>zrange</code> 可能产生的阻塞问题，对应的命令分别是 <code>hscan</code>、<code>sscan</code>、<code>zscan</code>，它们的用法和 <code>scan</code> 基本类似。</p>
<h3 id="17-redis-benchmark"><a href="#17-redis-benchmark" class="headerlink" title="(17) redis-benchmark"></a>(17) redis-benchmark</h3><ul>
<li><strong>-c</strong>: 代表客户端的并发数量，默认 50</li>
<li><strong>-n</strong>: 客户端请求总量，默认 100000</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 个客户端同时请求 Redis，一共执行 20000 次</span></span><br><span class="line">redis-benchmark -c 100 -n 20000</span><br></pre></td></tr></table></figure>
<p><img src="17-08-16-15_38_06_781_228.png" alt=""></p>
<p>在一个空的 Redis 上执行了 <code>redis-benchmark</code> 后会发现只有 3 个键:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"key:__rand_int__"</span></span><br><span class="line">2) <span class="string">"mylist"</span></span><br><span class="line">3) <span class="string">"counter:__rand_int__"</span></span><br></pre></td></tr></table></figure>
<p>如果想向 Redis 插入更多的键，可以执行使用 <code>-r (random)</code> 选项，向 Redis 插入更多随机键。</p>
<h3 id="18-Pipeline"><a href="#18-Pipeline" class="headerlink" title="(18) Pipeline"></a>(18) Pipeline</h3><p>可以使用 <code>Pipeline</code> 模拟出批量操作的效果，但是在使用时要注意它与原生批量命令的区别:</p>
<ul>
<li>原生批量命令是原子的，<strong><code>Pipeline</code> 是非原子的</strong>。</li>
<li>原生批量命令是一个命令对应多个 <code>key</code>，<code>Pipeline</code> 支持多个命令。</li>
<li>原生批量命令是 Redis 服务端支持实现的，而 <code>Pipeline</code> 需要服务端和客户端的共同实现。</li>
</ul>
<p><code>Pipeline</code> 虽然好用，但是每次 <code>Pipeline</code> 组装的命令个数不能没有节制，否则一次组装 <code>Pipeline</code> 数据量过大，一方面会增加客户端的等待时间，另一方面会造成一定的网络阻塞，可以将一次包含大量命令的 <code>Pipeline</code> 拆分成多次较小的 <code>Pipeline</code> 来完成。</p>
<hr>
<p>为了<strong>保证多条命令组合的原子性</strong>，Redis 提供了<strong>简单的事务功能以及集成 <code>Lua</code> 脚本</strong>来解决这个问题。Redis 提供了简单的事务，之所以说它简单，主要是因为<strong>它不支持事务中的回滚特性，同时无法实现命令之间的逻辑关系计算</strong>，当然也体现了 Redis 的 “keep  it  simple” 的特性。</p>
<h3 id="19-RDB-持久化"><a href="#19-RDB-持久化" class="headerlink" title="(19) RDB 持久化"></a>(19) RDB 持久化</h3><p>RDB 持久化是<strong>把当前进程数据生成快照保存到硬盘</strong>的过程，触发 RDB 持久化过程分为<strong>手动触发和自动触发</strong>。</p>
<ul>
<li><strong><code>bgsave</code> 手动触发</strong>: Redis 进程执行 <code>fork</code> 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 <code>fork</code> 阶段，一般时间很短。运行 <code>bgsave</code> 命令对应的 Redis 日志如下:</li>
</ul>
<p><img src="17-08-16-16_04_49_945_125.png" alt=""></p>
<p>查看最近一次 <code>fork</code> 操作的耗时 (723 微秒):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zk@zk-pc:~$ redis-cli info stats | grep latest_fork_usec</span><br><span class="line">latest_fork_usec:723</span><br></pre></td></tr></table></figure>
<p>子进程创建 <code>RDB</code> 文件，根据父进程内存生成临时快照文件，完成后<strong>对原有文件进行原子替换</strong>，执行 <code>lastsave</code> 命令可以获取最后一次生成 <code>RDB</code> 的时间:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lastsave</span><br><span class="line">(<span class="built_in">integer</span>) 1502870682</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>自动触发</strong>:<ul>
<li>使用 <code>save</code> 相关配置，如 <strong><code>save m n</code></strong>。表示 m 秒内数据集存在 n 次修改时，自动触发 <code>bgsave</code>。</li>
<li>如果<strong>从节点执行全量复制操作</strong>，主节点自动执行 <code>bgsave</code> 生成 <code>RDB</code> 文件并发送给从节点。</li>
<li>执行 <code>debug reload</code> 命令重新加载 Redis 时，也会自动触发 <code>save</code> 操作。</li>
<li>默认情况下执行 <code>shutdown</code> 命令时，如果没有开启 AOF 持久化功能则自动执行 <code>bgsave</code>。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>1) RDB 的优点</strong>:</p>
<ul>
<li>RDB 是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。<strong>非常适用于备份，全量复制等场景</strong>。比如每 6 小时执行 <code>bgsave</code> 备份，并把 RDB 文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</li>
<li>Redis 加载 RDB 恢复数据远远快于 AOF 的方式。 </li>
</ul>
<p><strong>2) RDB 的缺点</strong>:</p>
<ul>
<li><strong>RDB方式数据没办法做到实时持久化/秒级持久化</strong>。因为 <code>bgsave</code> 每次运行都要执行 <code>fork</code> 操作创建子进程，属于重量级操作，频繁执行成本过高。</li>
<li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在<strong>老版本Redis服务无法兼容新版RDB格式的问题</strong>。</li>
</ul>
<hr>
<p>Redis 的 RDB 文件保存的位置，如果使用 Redis 默认自带的配置文件 <a href="https://github.com/antirez/redis/blob/unstable/redis.conf" target="_blank" rel="noopener"><code>redis.conf</code></a> 来启动 <code>redis-server</code> 的话，那么其工作目录如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir ./</span><br></pre></td></tr></table></figure>
<p>其代表的含义是，在哪个目录运行的 <code>redis-server</code> 启动的 <code>redis</code> 服务器，那么 <code>dir</code> 目录就会指向哪个文件，相应的 <code>dump.rdb</code> 文件也就会保存在这个目录下:</p>
<p><img src="17-08-16-16_38_56_1301_114.png" alt=""></p>
<p><code>dump.rdb</code> 文件也在这个目录下:</p>
<p><img src="17-08-16-16_39_47_1129_50.png" alt=""></p>
<p>另外使用命令 <strong><code>redis-cli config get dir</code></strong> 也能得到工作目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/home/zk/Documents/bupt_518/appsec_search_redis/search-redis&quot;</span><br></pre></td></tr></table></figure>
<h3 id="20-AOF-持久化"><a href="#20-AOF-持久化" class="headerlink" title="(20) AOF 持久化"></a>(20) AOF 持久化</h3><h3 id="21-客户端管理"><a href="#21-客户端管理" class="headerlink" title="(21) 客户端管理"></a>(21) 客户端管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出能与 Redis 服务端相连的所有客户端连接信息</span></span><br><span class="line">client list</span><br></pre></td></tr></table></figure>
<p><code>age</code> 和 <code>idle</code> 字段分别代表<strong>当前客户端已经连接的时间和最近一次的空闲时间</strong>:</p>
<p><img src="17-08-16-22_42_36_1297_180.png" alt=""></p>
<p>某些情况下，可能存在大量 <code>idle</code> 连接，无论是从网络连接的成本还是超过 <code>maxclients</code> 的后果来说都不是什么好事，因此 Redis 提供了 <code>timeout</code> (单位为秒) 参数来限制连接的最大空闲时间，<strong>一旦客户端连接的 <code>idle</code> 时间超过了 <code>timeout</code>，连接将会被关闭</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> timeout 300</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>实际开发中，应该在<strong>客户端使用上添加空闲检测和验证</strong>等措施，例如 <code>JedisPool</code> 使用 <code>common-pool</code> 提供的三个属性:</p>
<ul>
<li><code>minEvictableIdleTimeMillis</code></li>
<li><code>testWhileIdle</code></li>
<li><code>timeBetweenEvictionRunsMills</code></li>
</ul>
<hr>
<p><code>client list</code> 中的 <code>flags</code> 用于标识当前客户端的类型:</p>
<p><img src="1365398089.jpg" alt=""></p>
<hr>
<p><strong>杀掉</strong>指定 IP 地址和端口的客户端:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client <span class="built_in">kill</span> ip:port</span><br></pre></td></tr></table></figure>
<h3 id="22-卸载-Redis"><a href="#22-卸载-Redis" class="headerlink" title="(22) 卸载 Redis"></a>(22) 卸载 <code>Redis</code></h3><ul>
<li><a href="http://grainier.net/how-to-uninstall-redis-server-from-ubuntu/" target="_blank" rel="noopener">How to uninstall Redis server from Ubuntu</a></li>
</ul>
<h3 id="23-阿里云-Redis"><a href="#23-阿里云-Redis" class="headerlink" title="(23) 阿里云 Redis"></a>(23) 阿里云 <code>Redis</code></h3><ul>
<li><a href="https://yq.aliyun.com/topic/104?utm_campaign=redis&amp;utm_medium=images&amp;utm_source=renyimen&amp;utm_content=m_26891" target="_blank" rel="noopener">阿里云 <code>Redis</code> 视频</a></li>
</ul>
<h3 id="理解内存"><a href="#理解内存" class="headerlink" title="理解内存"></a>理解内存</h3><hr>
<p><strong>3) 内存回收策略 - 删除过期键对象</strong>:</p>
<p><code>Redis</code> 采用 <strong>惰性删除</strong>和<strong>定时任务</strong>删除机制实现过期键的内存回收。</p>
<ul>
<li>惰性删除：惰性删除用于当客户端<strong>读取</strong>带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空，这种策略是出于节省CPU 成本考虑，不需要单独维护TTL 链表来处理过期键的删除。但是单独用这种方式存在<strong>内存泄露</strong>的问题，当过期键<strong>一直没有访问</strong>将无法得到及时删除，从而导致内存不能及时释放。正因为如此，Redis 还提供另一种定时任务删除机制作为惰性删除的补充。</li>
<li>定时任务删除：Redis 内部维护一个定时任务，默认每秒运行 10 次（通过配置hz 控制）。定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例、使用快慢两种速率模式回收键。</li>
</ul>
<p><img src="2051100408.jpg" alt=""></p>
<p>快慢两种模式内部删除逻辑相同，只是执行的<strong>超时时间不同</strong>。</p>
<p><strong>3) 内存回收策略 - 内存溢出控制策略</strong>:</p>
<p>当 Redis 所用内存达到 <code>maxmemory</code> 上限时会触发相应的溢出控制策略。 具体策略受 <code>maxmemory-policy</code> 参数控制， Redis 支持 <strong>6 种策略</strong>，如下所示： </p>
<ul>
<li><code>noeviction</code>：<strong>默认策略</strong>，不会删除任何数据，<strong>拒绝所有写入操作</strong>并返回客户端错误信息 <code>（error）OOM command not allowed when used memory</code>，此时Redis 只响应读操作。</li>
<li><code>volatile-lru</code>：根据 <code>LRU</code> 算法<strong>删除设置了超时属性（<code>expire</code>）的键</strong>，直到腾出足够空间为止。如果没有可删除的键对象，回退到 <code>noeviction</code> 策略。</li>
<li><code>allkeys-lru</code>：根据 <code>LRU</code> 算法删除键，<strong>不管数据有没有设置超时属性</strong>，直到腾出足够空间为止。</li>
<li><code>allkeys-random</code>： <strong>随机删除所有键</strong>，直到腾出足够空间为止。</li>
<li><code>volatile-random</code>： <strong>随机删除过期键</strong>，直到腾出足够空间为止。</li>
<li><code>volatile-ttl</code>：根据键值对象的 <code>ttl</code> 属性，<strong>删除最近将要过期数据</strong>。如果没有，回退到 <code>noeviction</code> 策略。</li>
</ul>
<p>内存溢出控制策略可以采用 <code>config set maxmemory-policy {policy}</code> 动态配置。 Redis 支持丰富的内存溢出应对策略，可以根据实际需求灵活定制，比如当设置 <code>volatile-lru</code> 策略时，保证具有过期属性的键可以根据 LRU 剔除，而未设置超时的键可以永久保留。还可以采用 <code>allkeys-lru</code> 策略把 Redis 变为纯缓存服务器使用。当Redis 因为内存溢出删除键时，可以通过执行 <code>info stats</code> 命令查看 <code>evicted_keys</code> 指标找出当前 Redis 服务器已剔除的键数量。每次Redis 执行命令时如果设置了 <code>maxmemory</code> 参数，都会尝试执行回收内存操作。当 Redis 一直工作在内存溢出 <code>（used_ memory&gt; maxmemory）</code> 的状态下且设置非 <code>noeviction</code> 策略时，会频繁地触发回收内存的操作，影响Redis 服务器的性能。</p>






<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
