<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>cpp</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>virtual function calls 一般而言是通过一个表格 （内含 virtual functions 地址) 的索引而决议得知。</p>
<p><img src="2017_10_01_15_36_38.png" alt=""></p>
<h3 id="类-Point-在机器中如何被表示"><a href="#类-Point-在机器中如何被表示" class="headerlink" title="类 Point 在机器中如何被表示"></a>类 <code>Point</code> 在机器中如何被表示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    Point(<span class="keyword">float</span> xval);</div><div class="line">    <span class="keyword">virtual</span> ~Point();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">float</span> _x;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _point_count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="2017_10_01_15_45_24.png" alt=""></p>
<h3 id="什么时候使用-struct-什么时候用-class"><a href="#什么时候使用-struct-什么时候用-class" class="headerlink" title="什么时候使用 struct 什么时候用 class"></a>什么时候使用 <code>struct</code> 什么时候用 <code>class</code></h3><p><img src="2017_10_01_15_54_50.png" alt=""></p>
<h3 id="哪些操作支持多态"><a href="#哪些操作支持多态" class="headerlink" title="哪些操作支持多态"></a>哪些操作支持多态</h3><ul>
<li>隐含的转化:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shape *ps = <span class="keyword">new</span> circle();</div></pre></td></tr></table></figure>
<ul>
<li><strong><code>virtual function</code></strong> 机制:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps-&gt;rotate();</div></pre></td></tr></table></figure>
<ul>
<li>经过 <code>dynamic_cast</code> 和 <code>typeid</code> 运算符:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (circle *pc = <span class="keyword">dynamic_cast</span>&lt;circle *&gt;(ps)) &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="一个-class-object-需要多少内存"><a href="#一个-class-object-需要多少内存" class="headerlink" title="一个 class object 需要多少内存"></a>一个 <code>class object</code> 需要多少内存</h3><ul>
<li><code>nonstatic data members</code> 的总和大小</li>
<li>加上任何由于 <code>alignment</code> 的需求而填补 (padding) 上去的空间</li>
<li>加上为了支持 <code>virtual</code> 而由内部产生的任何额外负担 (overhead)</li>
</ul>
<h3 id="什么时候才会合成一个-default-constructor"><a href="#什么时候才会合成一个-default-constructor" class="headerlink" title="什么时候才会合成一个 default constructor"></a>什么时候才会合成一个 <code>default constructor</code></h3><p><img src="2017_10_01_16_14_59.png" alt=""><br><img src="2017_10_01_16_17_49.png" alt=""></p>
<p>编译器只会在以下 4 种情况，并且 <code>class</code> 自身没有定义 <code>default constructor</code> 的情况下，帮忙合成 <code>default constructor</code>：</p>
<ul>
<li>带有 <strong><code>default constructor</code></strong> 的 <code>member class object</code>: 也就是说，虽然 <code>class A</code> 没有显示定义 <code>default constructor</code>, 但是 <code>A class</code> 内的成员变量 <code>B</code>, <code>B</code> 本身是提供<strong>显示</strong>的 <code>default constructor</code> 的，这种情况下会为 <code>A</code> 构造一个 <code>default constructor</code>。在该构造函数里会调用 <code>B</code> 的构造函数，当然只有在被调用的时候才会被合成出来。</li>
<li>带有 <code>default constructor</code> 的 <code>base class</code>: 也就是说，虽然 <code>class A</code> 没有显示定义 <code>default constructor</code>,但是 <code>A class</code> 继承自 <code>B class</code>, <code>B</code> 本身是提供<strong>显示</strong>的 <code>default constructor</code> 的，这种情况下会为 <code>A</code> 构造一个 <code>default constructor</code>.</li>
<li>带有一个 <code>virtual function</code> 的 <code>class</code>: 也就是说，虽然 <code>class A</code> 没有显示定义 <code>default constructor</code>,但是 <code>A class</code> 内<strong>有虚函数</strong>，既然有虚函数，那么在初始化对象的时候，需要初始化其中的指针 <code>vptr</code> 指向 <code>vtable</code>，所以这种情况下会为 <code>A</code> 构造一个 <code>default constructor</code>.</li>
<li>带有一个 <code>virtual base class</code> 的 <code>class</code></li>
</ul>
<p>同时需要注意，只有再必要的时候编译器才会合成出来，如程序中都没建该 <code>class</code> 的对象，故编译器肯定也不用合成出来。</p>
<p><img src="2017_10_01_16_28_09.png" alt=""><br><img src="2017_10_01_16_26_58.png" alt=""></p>
<h3 id="合成-copy-constructor"><a href="#合成-copy-constructor" class="headerlink" title="合成 copy constructor"></a>合成 <code>copy constructor</code></h3><ul>
<li>对一个 <code>object</code> 做明确的初始化操作:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</div><div class="line">X x;</div><div class="line"></div><div class="line"><span class="comment">// 以 x 的内容作为 xx 的初值</span></div><div class="line">X xx = x;</div></pre></td></tr></table></figure>
<ul>
<li>传递参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</div><div class="line">    X xx;</div><div class="line">    <span class="comment">// 作为参数传递</span></div><div class="line">    foo(xx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>返回一个 <code>class object</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">X <span class="title">foo_bar</span><span class="params">()</span> </span>&#123;</div><div class="line">    X xx;</div><div class="line">    <span class="comment">// 传回一个 class object</span></div><div class="line">    <span class="keyword">return</span> xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设 <code>class</code> 设计者明确定义了一个 <code>copy constructor</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">X::X(<span class="keyword">const</span> X&amp; x);</div><div class="line">X::X(<span class="keyword">const</span> Y&amp; y, <span class="keyword">int</span> = <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>那么在大部分情况下，当一个 <code>class object</code> 以另一个同类实体作为初值时，上述的 <code>constructor</code> 会被调用。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">noun</span><span class="params">(<span class="string">"book"</span>)</span></span>;</div><div class="line">String verb = noun;</div></pre></td></tr></table></figure>
<p>其默认的 <code>copy constructor</code> 完成的操作如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">verb.str = noun.str;</div><div class="line">verb.len = noun.len;</div></pre></td></tr></table></figure>
<h3 id="静态链接库和动态链接库"><a href="#静态链接库和动态链接库" class="headerlink" title="静态链接库和动态链接库"></a>静态链接库和动态链接库</h3><ul>
<li>静态链接库的优点<br>(1) <strong>代码装载速度快</strong>，执行速度略比动态链接库快；<br>(2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 </li>
<li>动态链接库的优点<br>(1) <strong>更加节省内存并减少页面交换；</strong><br>(2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；<br>(3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；<br>(4) 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</li>
<li>不足之处<br>(1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；<br>(2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。</li>
</ul>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a><code>sizeof</code></h3><p><img src="2017_10_12_22_57_23.png" alt=""></p>
<p><strong>Size of union = size of the largest data type used</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">char</span> all[<span class="number">13</span>]; <span class="comment">// 13</span></div><div class="line">        <span class="keyword">int</span> foo; <span class="comment">// 4</span></div><div class="line">    &#125; record; <span class="comment">// 16</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">char</span> all[<span class="number">13</span>]; <span class="comment">// 13</span></div><div class="line">        <span class="keyword">int</span> foo; <span class="comment">// 4</span></div><div class="line">    &#125; record; <span class="comment">// 13</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Suppose you have this structure:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span>	&#123;</span></div><div class="line">    <span class="keyword">char</span> a[<span class="number">3</span>];</div><div class="line">    <span class="keyword">short</span> <span class="keyword">int</span> b;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">int</span> c;</div><div class="line">    <span class="keyword">char</span> d[<span class="number">3</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Now, you might think that it ought to be possible to pack this structure into memory like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+-------+-------+-------+-------+</div><div class="line">|           a           |   b   |</div><div class="line">+-------+-------+-------+-------+</div><div class="line">|   b   |           c           |</div><div class="line">+-------+-------+-------+-------+</div><div class="line">|   c   |           d           |</div><div class="line">+-------+-------+-------+-------+</div></pre></td></tr></table></figure>
<p>But it’s much, much easier on the processor if the compiler arranges it like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+-------+-------+-------+</div><div class="line">|           a           |</div><div class="line">+-------+-------+-------+</div><div class="line">|       b       |</div><div class="line">+-------+-------+-------+-------+</div><div class="line">|               c               |</div><div class="line">+-------+-------+-------+-------+</div><div class="line">|           d           |</div><div class="line">+-------+-------+-------+</div></pre></td></tr></table></figure>
<p>In the <code>packed&#39;&#39; version, notice how it&#39;s at least a little bit hard for you and me to see how the b and c fields wrap around? In a nutshell, it&#39;s hard for the processor, too. Therefore, most compilers will</code>pad’’ the structure (as if with extra, invisible fields) like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+-------+-------+-------+-------+</div><div class="line">|           a           | pad1  |</div><div class="line">+-------+-------+-------+-------+</div><div class="line">|       b       |     pad2      |</div><div class="line">+-------+-------+-------+-------+</div><div class="line">|               c               |</div><div class="line">+-------+-------+-------+-------+</div><div class="line">|           d           | pad3  |</div><div class="line">+-------+-------+-------+-------+</div></pre></td></tr></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* pint = <span class="number">0</span>; <span class="comment">// pint指针指向0地址处</span></div><div class="line">pint += <span class="number">6</span>; <span class="comment">// 每次加 1 相当于移动四个字节，值为 24</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; pint &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0x18 == 24</span></div></pre></td></tr></table></figure><!-- hexo-inject:begin --><!-- hexo-inject:end -->






</body>
</html>
