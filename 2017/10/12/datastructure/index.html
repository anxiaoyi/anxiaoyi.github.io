<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>datastructure</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h2><h3 id="n个数值选出最大m个数（3-lt-m-lt-n）的最小算法复杂度是"><a href="#n个数值选出最大m个数（3-lt-m-lt-n）的最小算法复杂度是" class="headerlink" title="n个数值选出最大m个数（3&lt;m&lt;n）的最小算法复杂度是"></a>n个数值选出最大m个数（3&lt;m&lt;n）的最小算法复杂度是</h3><ol>
<li>最简单的方法：将 <code>n</code> 个数排序，排序后的前k个数就是最大的k个数，这种算法的复杂度是O（nlogn）</li>
<li><code>O（n）</code> 的方法：利用快排的 <code>patition</code> 思想，基于数组的第k个数来调整，将比第k个数小的都位于数组的左边，比第k个数大的都调整到数组的右边，这样调整后，位于数组右边的k个数最大的k个数(这k个数不一定是排好序的）</li>
<li><code>O(nlogk）</code> 的方法：先创建一个大小为k的最小堆，接下来我们每次从输入的n个整数中读入一个数，如果这个数比最小堆的堆顶元素还要大，那么替换这个最小堆的堆顶并调整。</li>
</ol>
<h3 id="由权值分别为1、12、13、4、8的叶子节点生成一颗哈夫曼树，它的带权路径长度为"><a href="#由权值分别为1、12、13、4、8的叶子节点生成一颗哈夫曼树，它的带权路径长度为" class="headerlink" title="由权值分别为1、12、13、4、8的叶子节点生成一颗哈夫曼树，它的带权路径长度为()"></a>由权值分别为1、12、13、4、8的叶子节点生成一颗哈夫曼树，它的带权路径长度为()</h3><p><img src="428302_1464865710267_072774B6B658B3603E1AA7198722775C.png" alt=""></p>
<h3 id="二叉树先序、后序遍历"><a href="#二叉树先序、后序遍历" class="headerlink" title="二叉树先序、后序遍历"></a>二叉树先序、后序遍历</h3><p><img src="BinExamp.png" alt=""></p>
<ul>
<li>先序遍历</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          右</div><div class="line">根         ↓</div><div class="line">↓     -----------</div><div class="line">A B D C E G F H I</div><div class="line">  ---</div><div class="line">   ↑</div><div class="line">  左</div></pre></td></tr></table></figure>
<ul>
<li>中序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    根</div><div class="line">    ↓</div><div class="line">B D A G E C H F I</div><div class="line">---   -----------</div><div class="line"> ↑        ↑</div><div class="line"> 左       右</div></pre></td></tr></table></figure>
<ul>
<li>后序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">         右</div><div class="line">         ↓</div><div class="line">    -----------</div><div class="line">D B G E H I F C A</div><div class="line">---             ↑</div><div class="line"> ↑             根</div><div class="line"> 左</div></pre></td></tr></table></figure>
<h3 id="Binary-Heap-调整"><a href="#Binary-Heap-调整" class="headerlink" title="Binary Heap 调整"></a>Binary Heap 调整</h3><p><img src="2017_10_13_10_11_00.png" alt=""></p>
<h3 id="Quick-Sort-调整"><a href="#Quick-Sort-调整" class="headerlink" title="Quick Sort 调整"></a>Quick Sort 调整</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">12,15,1,18,2,35,30,11</div></pre></td></tr></table></figure>
<p>以 <code>12</code> 为基准记录的一趟快速排序结束后的结果为:</p>
<p>快速排序里的挖坑填补法：以 <code>12</code> 为标准值，<strong>从右</strong>开始找比12<strong>小</strong>的值，首先是 11，把 11 放在 12 的那个位置，把12放在11的位置，再<strong>从左</strong>找比12<strong>大</strong>的值15，把 15 放在 12 的新位置（原11的位置）之后变成 <code>11，12，1，18，2，35，30，15</code>. 在新的一轮开始，从右开始找12 小的数是2，把2放在12的位置，12放在2的位置，在从左找比12大的数18，把18放在12的新位置上（原2的位置）变成11，2，1，12，18，35，30，15.</p>
<h3 id="多项式-P-X-a-bx-cx-2-dx-3-，对于任意-x-，计算-P-X-中最少需要用到乘法操作的次数是多少？"><a href="#多项式-P-X-a-bx-cx-2-dx-3-，对于任意-x-，计算-P-X-中最少需要用到乘法操作的次数是多少？" class="headerlink" title="多项式 P(X)=a+bx+cx^2+dx^3 ，对于任意 x ，计算 P(X) 中最少需要用到乘法操作的次数是多少？"></a>多项式 <code>P(X)=a+bx+cx^2+dx^3</code> ，对于任意 <code>x</code> ，计算 P(X) 中最少需要用到乘法操作的次数是多少？</h3><p>一般地， 一元 <code>n</code> 次多项式 的求值需要经过 <code>2n-1</code> 次乘法和 <code>n</code> 次加法，而 <strong>秦九韶算法</strong> 只需要 <code>n</code> 次乘法和 <code>n</code> 次加法 。<br>题目中P(X)是3次多项式，所以3次乘法。</p>






<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
