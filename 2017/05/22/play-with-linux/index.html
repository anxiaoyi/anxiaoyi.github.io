<html>
<head>
	
	<title>Play With Linux</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/>
    

</head>

<body>

<h2 id="Play-With-Linux"><a href="#Play-With-Linux" class="headerlink" title="Play With Linux"></a>Play With Linux</h2><h3 id="1-Terminal"><a href="#1-Terminal" class="headerlink" title="1 Terminal"></a>1 Terminal</h3><h4 id="1-1-Ubuntu-Could-not-get-lock"><a href="#1-1-Ubuntu-Could-not-get-lock" class="headerlink" title="1.1 Ubuntu Could not get lock"></a>1.1 Ubuntu Could not get lock</h4><p><img src="17-05-22-14_52_30_1224_154.png" alt=""></p>
<p>解决方案:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo rm /var/lib/apt/lists/lock</div><div class="line">sudo rm /var/cache/apt/archives/lock</div><div class="line">sudo rm /var/lib/dpkg/lock</div><div class="line">sudo apt clean</div><div class="line">sudo apt update</div></pre></td></tr></table></figure>
<p>(2) 另外一种常见的问题是在执行 <code>sudo apt update</code> 的时候遇见的 <strong>Hash Sum mismatch</strong> 问题:</p>
<p><img src="17-07-17-09_11_43_1299_195.png" alt=""></p>
<p>其大多数情况都是因为添加了其他 PPA 源导致的:</p>
<p><img src="17-07-17-09_16_59_903_443.png" alt=""></p>
<p>通用做法一般是<strong>去除掉这个 PPA 源</strong>，另外一种是<strong>手动从源代码编译来安装</strong>。</p>
<h4 id="GPG-error"><a href="#GPG-error" class="headerlink" title="GPG error"></a>GPG error</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">E: GPG error:h ttp://cn.archive.ubuntu.com trusty InRelease: Clearsigned file isn&apos;t valid, got &apos;NODATA&apos; (does the network require authentication?)</div></pre></td></tr></table></figure>
<h4 id="软件更新源"><a href="#软件更新源" class="headerlink" title="软件更新源"></a>软件更新源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/apt/sources.list</div></pre></td></tr></table></figure>
<hr>
<p>在为 <code>deepin</code> 系统安装 <code>mysql-server</code> 的时候，执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install mysql-server</div></pre></td></tr></table></figure>
<p>卡在了 <code>connecting...</code> 界面，于是把 <code>Ubuntu</code> 的源覆盖了 <code>deepin</code> 的默认源，开始工作了，但是最后报 <code>broken package</code> 错误… 其原因就在于正确的解决方法应该是<strong>寻找适合 <code>deepin</code> 系统的源 (比如 清华大学, 163 等源), 而不是直接拷贝 <code>Ubuntu</code> 的源</strong>。</p>
<hr>
<p>在安装 <code>Python</code> 一些依赖的时候，遇见了一些典型问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cannot compile &apos;Python.h&apos; ...</div></pre></td></tr></table></figure>
<p>尝试安装按照网络上教程安装 <code>python-dev</code> 依赖的时候又提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The following packages have unmet dependencies:</div><div class="line"> python-dev : Depends: python2.7-dev (&gt;= 2.7.3) but it is not going to be installed</div><div class="line">E: Unable to correct problems, you have held broken packages.</div></pre></td></tr></table></figure>
<p>接着一顿乱试:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get clean</div><div class="line">sudo apt-get autoclean</div><div class="line">sudo apt-get -f install</div><div class="line">...</div></pre></td></tr></table></figure>
<p>最终<strong>换了一个<a href="http://www.cnblogs.com/littlemonsters/p/5783690.html" target="_blank" rel="external">阿里源</a></strong>搞定了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div></pre></td></tr></table></figure>
<blockquote>
<p>注: 上述问题发生在 <code>Ubuntu 14.04</code> 系统上</p>
</blockquote>
<p>换源，虽然能够修复一部分问题，但是也有可能出现如下情况，软件包不一致的问题:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql-server : </div><div class="line">    Depends: mysql-server-5.5 but it is not going to be installed</div></pre></td></tr></table></figure>
<p>再重新切换回原来的源就又好了</p>
<h4 id="1-2-解压缩"><a href="#1-2-解压缩" class="headerlink" title="1.2 解压缩"></a>1.2 解压缩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unrar e 文件.rar 解压之后保存的路径</div></pre></td></tr></table></figure>
<h4 id="1-3-登录文件"><a href="#1-3-登录文件" class="headerlink" title="1.3 登录文件"></a>1.3 登录文件</h4><p>每次启动 <code>terminal</code> 都会执行一遍文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/.bashrc</div></pre></td></tr></table></figure>
<h3 id="2-Shell"><a href="#2-Shell" class="headerlink" title="2. Shell"></a>2. Shell</h3><h4 id="2-1-Flow-Control"><a href="#2-1-Flow-Control" class="headerlink" title="2.1 Flow Control"></a>2.1 Flow Control</h4><p>(1) If 语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ -r /bin/netstat ]; <span class="keyword">then</span></div><div class="line">/bin/netstat -an &gt; <span class="variable">$DATE_DIR</span>/netstat.dump 2&gt;&amp;1</div><div class="line"><span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>if … else … 句式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"restart"</span> ]; <span class="keyword">then</span></div><div class="line">	./restart.sh</div><div class="line"><span class="keyword">else</span></div><div class="line">	<span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"dump"</span> ]; <span class="keyword">then</span></div><div class="line">		./dump.sh</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">echo</span> <span class="string">"ERROR: Please input argument: start or stop or debug or restart or dump"</span></div><div class="line">		<span class="built_in">exit</span> 1</div><div class="line">	<span class="keyword">fi</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>(2) For 语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -e <span class="string">"Dumping the <span class="variable">$SERVER_NAME</span> ...\c"</span></div><div class="line"><span class="keyword">for</span> PID <span class="keyword">in</span> <span class="variable">$PIDS</span> ; <span class="keyword">do</span></div><div class="line">	jstack <span class="variable">$PID</span> &gt; <span class="variable">$DATE_DIR</span>/jstack-<span class="variable">$PID</span>.dump 2&gt;&amp;1</div><div class="line">	<span class="built_in">echo</span> -e <span class="string">".\c"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>(3) Switch 语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></div><div class="line">	    <span class="string">'scp'</span>)</div><div class="line">		    scp_to_server</div><div class="line">		    ;;</div><div class="line">	    <span class="string">'ssh'</span>)</div><div class="line">		    ssh_to_server</div><div class="line">		    ;;</div><div class="line">	    *)</div><div class="line">		    <span class="built_in">echo</span> <span class="string">'Usage: ./deploy [scp | ssh]'</span></div><div class="line">		    ;;</div><div class="line">    <span class="keyword">esac</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">main <span class="variable">$1</span></div></pre></td></tr></table></figure>
<h4 id="2-2-String"><a href="#2-2-String" class="headerlink" title="2.2 String"></a>2.2 String</h4><table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[[ $str1 == $str2 ]]</code></td>
<td>判断两个字符串是否相同</td>
</tr>
<tr>
<td><code>[[ $str1 != $str2 ]]</code></td>
<td>判断两个字符串是否不同</td>
</tr>
<tr>
<td><code>[[ -z $str1 ]]</code></td>
<td>判断 <code>$str1</code> 是否是一个空字符串</td>
</tr>
<tr>
<td><code>[[ -n $str1 ]]</code></td>
<td>判断 <code>$str1</code> 是否是一个非空字符串</td>
</tr>
</tbody>
</table>
<h4 id="2-3-Sed-a-stream-editor"><a href="#2-3-Sed-a-stream-editor" class="headerlink" title="2.3 Sed - a stream editor"></a>2.3 Sed - a stream editor</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/pattern/action</div></pre></td></tr></table></figure>
<ul>
<li><strong>pattern</strong>: 正则表达式</li>
<li><strong>action</strong>: <code>p</code>, <code>d</code>, <code>s/pattern1/pattern2/</code></li>
</ul>
<p>(1) 行的地址与范围:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>4,10d</code></td>
<td>删除第 4 到第 10 行</td>
</tr>
<tr>
<td><code>4,+2d</code></td>
<td>删除 4,5,6 行</td>
</tr>
<tr>
<td><code>2,5!d</code></td>
<td>删除除了第 2 到第 5 行外的所有的行</td>
</tr>
<tr>
<td><code>1~3d</code></td>
<td>删除第 1,4,7,10 行</td>
</tr>
<tr>
<td><code>4,10p</code></td>
<td>打印第 4 到第 10 行</td>
</tr>
<tr>
<td><code>4,d</code></td>
<td>语法错误</td>
</tr>
<tr>
<td><code>,10d</code></td>
<td>语法错误</td>
</tr>
</tbody>
</table>
<p>(1) 查找并替换:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i -e <span class="string">'s/few/asd/g'</span> hello.txt</div></pre></td></tr></table></figure>
<p>使用一个不同的分隔符:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i -e <span class="string">'s:few:asd:g'</span> hello.txt</div></pre></td></tr></table></figure>
<p>使用空字符串替换:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/passed | sed <span class="string">'s/root//g'</span></div></pre></td></tr></table></figure>
<p>只替换某一行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd | sed <span class="string">'10s/sh/quiet/g'</span></div></pre></td></tr></table></figure>
<p>替换 1 到 5 行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd | sed <span class="string">'1,5s/sh/quiet/g'</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>-i[SUFFIX]</strong>: 对文件 <code>hello.txt</code> edit <strong>i</strong>n place</li>
<li><strong>–in-place[=SUFFIX]</strong>: 同上</li>
<li><strong>-e script</strong>: 指明 <strong>e</strong>xpression/command to run</li>
<li><strong>–expression=script</strong>: 同上</li>
<li><strong>-E</strong>:</li>
<li><strong>-r</strong>:</li>
<li><strong>–regexp-extended</strong>: 使用扩展正则表达式</li>
<li><strong>s/</strong>: 表示替换</li>
<li><strong>/g</strong>: 替换整行</li>
</ul>
<p>(2) 打印指定行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="string">'45p'</span> file.txt</div></pre></td></tr></table></figure>
<ul>
<li><strong>-n</strong>: 抑制输出，默认情况下 Sed 会打印所有的输入文件的内容</li>
<li><strong>p</strong>: 打印指定的行</li>
</ul>
<p>(3) 删除指定范围的行:</p>
<p>删除指定范围的行，然后把未删除的内容写入到 <code>output.txt</code> 文件中去:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'30,35d'</span> input.txt &gt; output.txt</div></pre></td></tr></table></figure>
<h4 id="2-4-文件系统"><a href="#2-4-文件系统" class="headerlink" title="2.4 文件系统"></a>2.4 文件系统</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[ -f $file_var ]</code></td>
<td>测试这个变量是否是一个正则表达式文件路径或文件名</td>
</tr>
<tr>
<td><code>[ -e $var ]</code></td>
<td>测试是否是一个可执行的文件路径</td>
</tr>
<tr>
<td><code>[ -d $var ]</code></td>
<td>测试是否是一个目录路径 (<strong>可以用来测试文件夹是否存在</strong>)</td>
</tr>
<tr>
<td><code>[ -e $var ]</code></td>
<td>文件是否存在</td>
</tr>
<tr>
<td><code>[ -c $var ]</code></td>
<td>文件是否是一个 character device 文件</td>
</tr>
<tr>
<td><code>[ -b $var ]</code></td>
<td>文件是否是一个 block device 文件</td>
</tr>
<tr>
<td><code>[ -w $var ]</code></td>
<td>文件路径是否可写</td>
</tr>
<tr>
<td><code>[ -r $var ]</code></td>
<td>文件路径是否可读</td>
</tr>
<tr>
<td><code>[ -L $var ]</code></td>
<td>文件是否是一个 symlink 路径</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DUMP_DATE=`date +%Y%m%d%H%M%S`</div><div class="line">DATE_DIR=<span class="variable">$DUMP_DIR</span>/<span class="variable">$DUMP_DATE</span></div><div class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$DATE_DIR</span> ]; <span class="keyword">then</span></div><div class="line">	mkdir <span class="variable">$DATE_DIR</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h4 id="2-5-date"><a href="#2-5-date" class="headerlink" title="2.5 date"></a>2.5 date</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ date +%Y%m%d%H%M%S</div><div class="line">20170701165459</div></pre></td></tr></table></figure>
<h4 id="2-6-echo"><a href="#2-6-echo" class="headerlink" title="2.6 echo"></a>2.6 echo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -e <span class="string">"Dumping the <span class="variable">$SERVER_NAME</span> ...\c"</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>-e</strong>: Enable echo’s interpretation of additional instances of the newline character as well as the interpretation of other special characters, such as a horizontal tab, which is represented by <code>\t</code></li>
</ul>
<h4 id="2-7-tr-translate-or-delete-characters"><a href="#2-7-tr-translate-or-delete-characters" class="headerlink" title="2.7 tr - translate or delete characters"></a>2.7 tr - translate or delete characters</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tr [OPTION]... SET1 [SET2]</div></pre></td></tr></table></figure>
<ul>
<li><strong>-d</strong>:</li>
<li><strong>–delete</strong>: 删除在 SET1 中的字符</li>
<li><strong>-s</strong>:</li>
<li><strong>–squeeze-repeats</strong>: 挤压字符</li>
</ul>
<p>(1) 删除字符 <code>t</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"the geek stuff"</span> | tr -d <span class="string">'t'</span></div></pre></td></tr></table></figure>
<p>Text files created on DOS/Windows machines have different line endings than files created on Unix/Linux. <strong>DOS uses carriage return and line feed (“\r\n”) as a line ending, which Unix uses just line feed (“\n”)</strong>. 删除 <code>\r</code> 字符:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tr -d <span class="string">'\r'</span></div></pre></td></tr></table></figure>
<p><strong>删除空格, Tab 键产生的空格等</strong>用这个 <code>tr</code> 命令就行了，AWK 正则匹配很不靠谱:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tr -d <span class="string">' \t'</span></div></pre></td></tr></table></figure>
<p>(2) 小写转成大写，必须手动输入需要转换的字符，然后回车才会显示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tr [:lower:] [:upper:]</div><div class="line">thegeekstuff</div><div class="line">THEGEEKSTUFF</div></pre></td></tr></table></figure>
<p>(3) 保留一个空格，删除其他空格</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"This  is  for testing"</span> | tr -s [:space:] <span class="string">' '</span></div></pre></td></tr></table></figure>
<h4 id="2-8-文件描述符和重定向"><a href="#2-8-文件描述符和重定向" class="headerlink" title="2.8 文件描述符和重定向"></a>2.8 文件描述符和重定向</h4><p>将标准错误转为标准输出:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> <span class="variable">$PID</span> &gt; /dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<h4 id="2-9-文件参数"><a href="#2-9-文件参数" class="headerlink" title="2.9 文件参数"></a>2.9 文件参数</h4><ul>
<li><strong>$0</strong>: 文件名</li>
<li><strong>$1</strong>: 参数1</li>
<li><strong>$2</strong>: 参数2</li>
<li><strong>$@</strong>: 文件名 参数1 参数2 …</li>
<li><strong>$*</strong>: 文件名 “参数1 参数2 …”</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># alibaba druid 项目的脚本文件 druidStat.sh</span></div><div class="line"><span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> -Dfile.encoding=<span class="string">"UTF-8"</span> -cp <span class="string">"./druid-0.2.6.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar"</span> com.alibaba.druid.support.console.DruidStat <span class="variable">$@</span></div></pre></td></tr></table></figure>
<hr>
<p>传递参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./deploy.sh <span class="built_in">test</span> -y 2017 -m 6</div></pre></td></tr></table></figure>
<p>现在我想在 <code>deploy.sh</code> 脚本中获取到 <code>-y 2017 -m 6</code> 这个参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shift</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$@</span></div></pre></td></tr></table></figure>
<p>输出的就是 <code>-y 2017 -m 6</code> 这个参数</p>
<h3 id="xxd-make-a-hexdump-or-do-the-reverse"><a href="#xxd-make-a-hexdump-or-do-the-reverse" class="headerlink" title="xxd - make a hexdump or do the reverse"></a>xxd - make a hexdump or do the reverse</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 二进制</div><div class="line">xxd -b file</div><div class="line">// 十六进制</div><div class="line">xxd file</div></pre></td></tr></table></figure>
<h3 id="od-dump-files-in-octal-and-other-formats"><a href="#od-dump-files-in-octal-and-other-formats" class="headerlink" title="od - dump files in octal and other formats"></a>od - dump files in octal and other formats</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// ASCII 编码方式打印</div><div class="line">od -c file</div><div class="line">// 十六进制</div><div class="line">od -cx file</div></pre></td></tr></table></figure>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><ul>
<li><strong>-v</strong>: </li>
<li><strong>–invert-match</strong>: 反匹配</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Redis 查询输出缓冲区不为 0 的客户端连接</span></div><div class="line"><span class="built_in">echo</span> <span class="string">'CLIENT LIST'</span> | redis-cli | grep -v <span class="string">'omem=0'</span></div><div class="line"><span class="comment"># 只在指定类型的文件中进行搜索</span></div><div class="line">grep <span class="string">'void'</span> -Rn . --include \*.java --include \*.c</div></pre></td></tr></table></figure>
<hr>
<p><strong>Basic vs Extended Regular Expressions</strong>:</p>
<p>In <strong>basic regular</strong> expressions the meta-characters ‘?’, ‘+’, ‘{’, ‘|’, ‘(’, and ‘)’ <strong>失去</strong> their special meaning; instead use the <strong>反斜线版本</strong> ‘\?’, ‘+’, ‘{’, ‘|’, ‘(’, and ‘)’.</p>
<p>Traditional egrep did not support the ‘{’ meta-character, and some egrep implementations support ‘{’ instead, so portable scripts should avoid ‘{’ in ‘grep -E’ patterns and should use ‘[{]’ to match a literal ‘{’.</p>
<hr>
<p><strong>默认情况下 <code>.</code> 是匹配单个字符</strong>的，<b><code>*</code> 是匹配多个字符</b>的，这两个是默认生效的。所以下面这行命令对 <code>abcdef</code> 和 <code>ab.def</code> 都能匹配上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">'ab.def'</span> -Rn .</div></pre></td></tr></table></figure>
<p>如果就想要匹配一个点，那么需要转义:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">'ab\.def'</span> -Rn .</div></pre></td></tr></table></figure>
<hr>
<p><strong>默认情况下，<code>grep</code> 是区分大小写的</strong>，可以使用 <code>-i</code> 来不区分大小写:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">"ab.def"</span> -Rni .</div></pre></td></tr></table></figure>
<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><blockquote>
<p><code>curl</code> 命令执行之前一定要 <code>unset http_proxy</code>，尤其是 <code>curl http://localhost:8080</code></p>
</blockquote>
<h4 id="1-curl-加上头"><a href="#1-curl-加上头" class="headerlink" title="(1) curl - 加上头"></a>(1) curl - 加上头</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -H <span class="string">'Accept:application/json'</span> http://localhost:8080</div></pre></td></tr></table></figure>
<h4 id="2-curl-只获取服务器返回的头"><a href="#2-curl-只获取服务器返回的头" class="headerlink" title="(2) curl - 只获取服务器返回的头"></a>(2) curl - 只获取服务器返回的头</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -I http://localhost:8080</div></pre></td></tr></table></figure>
<h4 id="3-curl-进行-POST-请求"><a href="#3-curl-进行-POST-请求" class="headerlink" title="(3) curl - 进行 POST 请求"></a>(3) curl - 进行 POST 请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X POST -d <span class="string">'&#123;"username":"xyz","password":"123"&#125;'</span> http://localhost/8080/api/login</div></pre></td></tr></table></figure>
<ul>
<li><strong>-d</strong>: 暗含了执行 <code>POST</code> 请求，所以 <code>-X</code> 可以不加</li>
</ul>
<h4 id="4-curl-进行-https-请求"><a href="#4-curl-进行-https-请求" class="headerlink" title="(4) curl - 进行 https 请求"></a>(4) curl - 进行 <code>https</code> 请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl: (35) error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol</div></pre></td></tr></table></figure>
<p>暂时不知道如何解决</p>
<h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 统计总行数 (A 文件行 +　Ｂ 文件行 + ...)</div><div class="line"># 而且,子目录也会被搜索</div><div class="line">find . -name &apos;*.java&apos; | xargs wc -l</div><div class="line"># 排除子目录</div><div class="line">find . -name &apos;*.java&apos; -maxdepth 1</div><div class="line"># 统计文件数</div><div class="line">find . -name &apos;*.java&apos; | awk &apos;&#123; print &#125; END &#123; print NR &#125;&apos;</div></pre></td></tr></table></figure>
<h3 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h3><p><img src="17-07-28-22_31_30_1033_401.png" alt=""></p>
<p><img src="17-07-28-23_07_28_1027_381.png" alt=""></p>
<p><img src="17-07-28-23_08_45_1024_573.png" alt=""></p>
<p><img src="17-07-28-22_36_14_1044_239.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync all.sql zk@10.108.113.85:~/Desktop/</div></pre></td></tr></table></figure>
<h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a><code>apt-get</code></h3><p>删除文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dpkg -l | grep sogoupinyin</div><div class="line">sudo apt remove --purge sogoupinyin</div></pre></td></tr></table></figure>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><code>netstat</code></h3><p>There’s a few parameters to <code>netstat</code> that are useful for how to check the opened/closed port on my computer:</p>
<ul>
<li><code>-l</code> or <code>--listening</code> shows only the sockets currently listening for incoming connection.</li>
<li><code>-a</code> or <code>--all</code> shows all sockets currently in use.</li>
<li><code>-t</code> or <code>--tcp</code> shows the tcp sockets.</li>
<li><code>-u</code> or <code>--udp</code> shows the udp sockets.</li>
<li><code>-n</code> or <code>--numeric</code> shows the hosts and ports as numbers, instead of resolving in dns and looking in /etc/services.</li>
<li><code>-p</code> or <code>--program</code> Show the PID and name of the program to which each socket belongs.</li>
<li><code>-e</code>, <code>--extend</code> Display additional information.  Use this option twice for maximum detail.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo netstat -peanut | grep 3306</div></pre></td></tr></table></figure>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="1-查看磁盘剩余空间"><a href="#1-查看磁盘剩余空间" class="headerlink" title="(1) 查看磁盘剩余空间"></a>(1) 查看磁盘剩余空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df -h</div></pre></td></tr></table></figure>
<h4 id="2-查看目录或文件占用多大空间"><a href="#2-查看目录或文件占用多大空间" class="headerlink" title="(2) 查看目录或文件占用多大空间"></a>(2) 查看目录或文件占用多大空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">du -h target/</div></pre></td></tr></table></figure>
<h3 id="SSH-免密登录"><a href="#SSH-免密登录" class="headerlink" title="SSH 免密登录"></a>SSH 免密登录</h3><p><strong>服务器端</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> .ssh</div><div class="line">ssh-keygen -t rsa  (hit <span class="built_in">return</span> through prompts)</div><div class="line">cat id_rsa.pub &gt;&gt; authorized_keys</div><div class="line">chmod 600 authorized_keys</div><div class="line">rm id_rsa.pub</div></pre></td></tr></table></figure>
<p><strong>客户端</strong>:</p>
<p>把自己的 <strong><code>./ssh/id_rsa.pub</code></strong> 文件里面的<strong>所有内容</strong> 都拷贝到服务器端的 <code>authorized_keys</code> 文件中去。</p>
<h3 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'$2 ~ /^org.*/ &#123;print $2&#125;'</span> .java_process</div></pre></td></tr></table></figure>
<hr>
<p>对如下 <code>combined_log</code> 日志文件进行分析:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">66.249.64.13 - - [18/Sep/2004:11:07:48 +1000] &quot;GET /robots.txt HTTP/1.0&quot; 200 468 &quot;-&quot; &quot;Googlebot/2.1&quot;</div><div class="line">66.249.64.13 - - [18/Sep/2004:11:07:48 +1000] &quot;GET / HTTP/1.0&quot; 200 6433 &quot;-&quot; &quot;Googlebot/2.1&quot;</div></pre></td></tr></table></figure>
<p><strong>打印所有 IP</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;print $1&#125;'</span> combined_log</div></pre></td></tr></table></figure>
<hr>
<p><strong>AWK 默认以空格为分隔符，现在我们修改为 <code>&quot;</code></strong>，打印所有请求行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk -F\<span class="string">" '&#123;print <span class="variable">$2</span>&#125;' combined_log</span></div></pre></td></tr></table></figure>
<hr>
<p>按照 <code>User Agent</code> 出现的次数<strong>降序</strong>排序:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk -F\<span class="string">" '&#123;print <span class="variable">$6</span>&#125;' combined_log | sort | uniq -c | sort -fr</span></div></pre></td></tr></table></figure>
<ul>
<li><strong><code>sort -r</code></strong>: reverse 的意思，<strong>降序排序</strong></li>
<li><strong><code>sort -f</code></strong>: <code>--ignore-case</code> 的意思，<strong>忽略大小写</strong></li>
<li><strong><code>uniq -c</code></strong>: <code>--count</code>，在每行之前显示这行<strong>出现的次数</strong></li>
</ul>
<p>参考: <a href="http://www.the-art-of-web.com/system/logs/" target="_blank" rel="external">System: Analyzing Apache Log Files</a></p>
<h3 id="Bash-字符串"><a href="#Bash-字符串" class="headerlink" title="Bash 字符串"></a>Bash 字符串</h3><h4 id="1-字符串连接"><a href="#1-字符串连接" class="headerlink" title="(1) 字符串连接"></a>(1) 字符串连接</h4><p>注意字符串连接的时候，几个<strong>字符串之间没有空格</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AWK_PROGRAM=<span class="string">'$2 ~ /^'</span><span class="variable">$PROCESS_NAME</span><span class="string">'.*/ &#123; print $1 &#125;'</span></div><div class="line"><span class="built_in">echo</span> `awk <span class="string">"<span class="variable">$AWK_PROGRAM</span>"</span> .java_process`</div></pre></td></tr></table></figure>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><strong><code>cp</code></strong> 的时候一定要<strong>注意目标地址的文件夹是否存在</strong>的问题:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># auto_creat_folder 一开始不存在，auto_creat_folder 将会自动被创建，目录结构变为: auto_creat_folder/**</span></div><div class="line">cp -r ../resources/ auto_creat_folder/</div><div class="line"><span class="comment"># exist_folder 已经存在了, 这个时候，目录结构会变为 exist_folder/resources/**</span></div><div class="line">cp -r ../resources exist_folder/</div></pre></td></tr></table></figure>
<h3 id="脚本启动的问题"><a href="#脚本启动的问题" class="headerlink" title="脚本启动的问题"></a>脚本启动的问题</h3><p>这样写是不行的，下一个命令会等待上一个命令执行结束:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ./start.sh</span></div><div class="line"></div><div class="line">java -jar a.jar</div><div class="line">java -jar b.jar</div><div class="line">java -jar c.jar</div></pre></td></tr></table></figure>
<p>所以应该都添加 <code>&amp;</code> 来确保其一块启动起来:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ./start.sh</span></div><div class="line"></div><div class="line">java -jar a.jar &amp;</div><div class="line">java -jar b.jar &amp;</div><div class="line">java -jar c.jar &amp;</div></pre></td></tr></table></figure>
<h3 id="kill-vs-kill-9"><a href="#kill-vs-kill-9" class="headerlink" title="kill vs kill -9"></a><code>kill</code> vs <code>kill -9</code></h3><p><code>kill -9</code> Meaning: The process will be killed by the kernel; this signal cannot be ignored. 9 means KILL signal <strong>that is not catchable or ignorable</strong></p>
<p>Uses: <code>SIGKILL</code> singal</p>
<p><code>Kill</code> Meaning: The kill command without any signal passes the signal 15, which terminates the process the normal way.</p>
<p>Uses: <code>SIGTERM</code> signal, <strong>which can be handled by programmers</strong></p>
<h3 id="etc-init-vs-etc-init-d"><a href="#etc-init-vs-etc-init-d" class="headerlink" title="/etc/init/ vs /etc/init.d/"></a><code>/etc/init/</code> vs <code>/etc/init.d/</code></h3><p><code>/etc/init.d</code> contains <strong>脚本</strong> used by the <strong>System V</strong> init tools (SysVinit). This is the traditional service management package for Linux, containing the <strong>初始化</strong> program (the first process that is run when the kernel has finished initializing¹) as well as some infrastructure to start and stop services and configure them. Specifically, files in <code>/etc/init.d</code> are shell scripts that respond to <code>start</code>, <code>stop</code>, <code>restart</code>, and (when supported) <code>reload</code> commands to manage a particular service. These scripts can be invoked directly or (most commonly) via some other trigger (typically the presence of a symbolic link in <code>/etc/rc?.d/</code>).</p>
<p><code>/etc/init</code> contains configuration files used by <strong>Upstart</strong>. Upstart is a young service management package championed by <strong>Ubuntu</strong>. Files in <code>/etc/init</code> are configuration files telling Upstart how and when to start, stop, reload the configuration, or query the status of a service. As of lucid, Ubuntu is transitioning from SysVinit to Upstart, which explains why many services come with SysVinit scripts even though Upstart configuration files are preferred. In fact, the SysVinit scripts are processed by a compatibility layer in Upstart.</p>
<p><code>.d</code> in directory names typically indicates a <strong>目录</strong> containing many configuration files or scripts for a particular situation (e.g. <code>/etc/apt/sources.list.d</code> contains files that are concatenated to make a virtual sources.list; <code>/etc/network/if-up.d</code> contains scripts that are executed when a network interface is activated). This structure is usually used when each entry in the directory is provided by a different source, so that each package can deposit its own plug-in without having to parse a single configuration file to reference itself. In this case, it just happens that “init” is a logical name for the directory, <code>SysVinit</code> <strong>来的比较早</strong> and used <code>init.d</code>, and <code>Upstart</code> used plain init for a directory with <strong>相同的目的</strong> (it would have been more “mainstream”, and perhaps less arrogant, if they’d used <code>/etc/upstart.d</code> instead).</p>
<p>参考: <a href="https://askubuntu.com/questions/5039/what-is-the-difference-between-etc-init-and-etc-init-d" target="_blank" rel="external">What is the difference between /etc/init/ and /etc/init.d/?</a></p>
<h3 id="查看所有用户"><a href="#查看所有用户" class="headerlink" title="查看所有用户"></a>查看所有用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd</div><div class="line"><span class="comment"># 或者</span></div><div class="line">awk -F<span class="string">':'</span> <span class="string">'&#123; print $1&#125;'</span> /etc/passwd</div></pre></td></tr></table></figure>
<h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p><code>nohup</code> is a POSIX command to ignore the <strong>HUP (hangup) signal</strong>. The HUP signal is, by convention, the way a terminal warns dependent processes of logout.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ nohup abcd &amp;</div><div class="line">$ <span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>Note that nohupping backgrounded jobs is typically used to avoid terminating them when logging off from a remote SSH session. A different issue that often arises in this situation is that <code>ssh</code> is <strong>拒绝退出 (“hangs”)</strong>, since it refuses to lose any data from/to the background job(s). This problem can also be overcome by <strong>重定向</strong> all three I/O streams:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nohup ./myprogram &gt; foo.out <span class="number">2</span>&gt; foo.err &lt; /dev/<span class="keyword">null</span> &amp;</div></pre></td></tr></table></figure>
<h3 id="Cron"><a href="#Cron" class="headerlink" title="Cron"></a>Cron</h3><p>The software utility <a href="https://en.wikipedia.org/wiki/Cron" target="_blank" rel="external"><code>Cron</code></a> is a time-based job scheduler in Unix-like computer operating systems. People who set up and maintain software environments use cron to <strong>调度任务(命令或者脚本)</strong> to run periodically at fixed times, dates, or intervals.</p>
<p><code>Cron</code> is driven by a <code>crontab</code> (cron table) file, a configuration file that specifies shell commands to run periodically on a given schedule. The crontab files are stored where the lists of jobs and other instructions to the cron daemon are kept. Users can have their own individual crontab files and often there is a system-wide crontab file (usually in <code>/etc</code> or a subdirectory of <code>/etc</code>) that only system administrators can edit.</p>
<p>Each line of a crontab file represents a job, and looks like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">┌───────────── minute (0 - 59)</div><div class="line">│ ┌───────────── hour (0 - 23)</div><div class="line">│ │ ┌───────────── day of month (1 - 31)</div><div class="line">│ │ │ ┌───────────── month (1 - 12)</div><div class="line">│ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday;</div><div class="line">│ │ │ │ │                                       7 is also Sunday on some systems)</div><div class="line">│ │ │ │ │</div><div class="line">│ │ │ │ │</div><div class="line">* * * * *  command to execute</div></pre></td></tr></table></figure>
<p>一些示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 每天 00:01 分清空一下这个日志文件的内容</span></div><div class="line">1 0 * * * <span class="built_in">printf</span> &gt; /var/<span class="built_in">log</span>/apache/error_log</div><div class="line"></div><div class="line"><span class="comment"># 每周六 23:45 分调用一下 dump.sh 这个脚本</span></div><div class="line">45 23 * * 6 /home/oracle/scripts/export_dump.sh</div><div class="line"></div><div class="line"><span class="comment"># 每小时的第一分钟开始执行</span></div><div class="line">@hourly /scripts/script.sh</div><div class="line"></div><div class="line"><span class="comment"># 每天的第一分钟开始执行</span></div><div class="line">@daily /scripts/script.sh</div><div class="line"></div><div class="line"><span class="comment"># 每周的第一分钟开始执行</span></div><div class="line">@weekly /bin/script.sh</div><div class="line"></div><div class="line"><span class="comment"># 没月的第一分钟开始执行</span></div><div class="line">@monthly /scripts/script.sh</div><div class="line"></div><div class="line"><span class="comment"># 每年的第一分钟开始执行</span></div><div class="line">@yearly /scripts/script.sh</div><div class="line"></div><div class="line"><span class="comment"># 重启执行</span></div><div class="line">@reboot /scripts/script.sh</div></pre></td></tr></table></figure>
<hr>
<p>编辑文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 打开 crontab 文件用当前用户进行编辑/添加</span></div><div class="line">crontab -e</div><div class="line"></div><div class="line"><span class="comment"># 列举任务</span></div><div class="line">crontab -l</div></pre></td></tr></table></figure>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p><img src="17-08-16-16_46_41_784_270.png" alt=""></p>
<h3 id="ps-ef-和-ps-aux"><a href="#ps-ef-和-ps-aux" class="headerlink" title="ps -ef 和 ps -aux"></a><code>ps -ef</code> 和 <code>ps -aux</code></h3><ul>
<li><code>ps -ef</code>:</li>
</ul>
<p><img src="17-08-16-17_12_47_853_203.png" alt=""></p>
<ul>
<li><code>ps -aux</code>:</li>
</ul>
<p><img src="17-08-16-17_03_22_1080_253.png" alt=""></p>
<h3 id="add-apt-repository"><a href="#add-apt-repository" class="headerlink" title="add-apt-repository"></a>add-apt-repository</h3><p>平常如果需要安装东西的时候，比如 <code>jdk8</code>，那么可能需要使用 <code>add-apt-repository</code> 这个命令，敲击回车后，如果提示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spider@hadoop-master:~$ sudo add-apt-repository ppa:webupd8team/java</div><div class="line">sudo: add-apt-repository: <span class="built_in">command</span> not found</div></pre></td></tr></table></figure>
<p>那么请执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spider@hadoop-master:~$ sudo apt-get install software-properties-common python-software-properties</div></pre></td></tr></table></figure>
<p>如果发现<strong>需要配置代理</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> http_proxy=http://&lt;proxy&gt;:&lt;port&gt;</div><div class="line"><span class="built_in">export</span> https_proxy=http://&lt;proxy&gt;:&lt;port&gt;</div><div class="line">sudo -E add-apt-repository ppa:linaro-maintainers/toolchain</div></pre></td></tr></table></figure>
<ul>
<li><strong>-E</strong>: 保留环境变量</li>
</ul>
<h3 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/default/grub</div></pre></td></tr></table></figure>
<p>然后把 <code>GRUB_DEFAULT=0</code> 后面的数字修改为任何想要的数字:</p>
<p><img src="1mMje.jpg" alt=""></p>
<p>最后不要忘记执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-grub</div></pre></td></tr></table></figure>
<h3 id="如何查看-Linux-内核版本"><a href="#如何查看-Linux-内核版本" class="headerlink" title="如何查看 Linux 内核版本"></a>如何查看 Linux 内核版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uname -r</div></pre></td></tr></table></figure>
<h3 id="Linux-命令中考没考虑过管道大小，管道满了怎么办"><a href="#Linux-命令中考没考虑过管道大小，管道满了怎么办" class="headerlink" title="Linux 命令中考没考虑过管道大小，管道满了怎么办"></a>Linux 命令中考没考虑过管道大小，管道满了怎么办</h3><p><strong>Pipe 容量</strong>:</p>
<p>A pipe has a limited capacity.  If the pipe is full, then a <strong><code>write(2)</code></strong> will block or fail <strong>阻塞或者失败</strong>, depending on whether the <code>O_NONBLOCK</code> flag is set (see below).  Different implementations have different limits for the pipe capacity.  Applications should not rely on a particular capacity: an application should be designed so that a reading process consumes data as soon as it is available, so that a writing process does not remain blocked.</p>
<p>In Linux versions before 2.6.11, the capacity of a pipe was the same as the <strong>system page size</strong> (e.g., 4096 bytes on i386).  Since Linux 2.6.11, the pipe capacity is <strong>16 pages</strong> (i.e., 65,536 bytes in a system with a page size of 4096 bytes).  Since Linux 2.6.35, the default pipe capacity is 16 pages, but the capacity can be queried and set using the fcntl(2) <code>F_GETPIPE_SZ</code> and <code>F_SETPIPE_SZ</code> operations.  See fcntl(2) for more information. The following ioctl(2) operation, which can be applied to a file descriptor that refers to either end of a pipe, places a count of the number of unread bytes in the pipe in the int buffer pointed to by the final argument of the call:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ioctl(fd, FIONREAD, &amp;nbytes);</div></pre></td></tr></table></figure>
<p>The FIONREAD operation is not specified in any standard, but is provided on many implementations.</p>
<hr>
<p>参考: </p>
<ul>
<li><a href="http://man7.org/linux/man-pages/man7/pipe.7.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man7/pipe.7.html</a></li>
</ul>
<h3 id="Linux-零拷贝"><a href="#Linux-零拷贝" class="headerlink" title="Linux 零拷贝"></a>Linux 零拷贝</h3><p><strong>“Zero-copy”</strong> describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to <strong>save CPU cycles and memory bandwidth</strong> when transmitting a file over a network. Also, zero-copy operations reduce the number of time-consuming mode switches between user space and kernel space. <strong>减少用户空间和内核空间的切换</strong></p>
<hr>
<p><strong>不用 Zero Copy 的问题所在</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read(file, tmp_buf, len);</div><div class="line">write(socket, tmp_buf, len);</div></pre></td></tr></table></figure>
<p>Looks simple enough; you would think there is not much overhead with only those two system calls. In reality, this couldn’t be further from the truth. Behind those two calls, the data has been copied at least four times <strong>数据至少拷贝 4 次</strong>, and almost as many user/kernel context switches have been performed. (Actually this process is much more complicated, but I wanted to keep it simple). To get a better idea of the process involved, take a look at Figure 1. The top side shows context switches, and the bottom side shows copy operations.</p>
<p><img src="6345f1.jpg" alt=""></p>
<p><strong>1) 第一步</strong>: the <code>read</code> system call causes a context switch <strong>上下文切换</strong> from user mode to kernel mode. The first copy is performed by the DMA engine, which reads file contents from the disk and stores them into a kernel address space buffer <strong>DMA 从磁盘拷贝到内核缓冲区</strong>.</p>
<p><strong>2) 第二步</strong>: data is copied from the kernel buffer into the user buffer <strong>数据从内核缓冲区拷贝到用户缓冲区</strong>, and the <code>read</code> system call returns. The return from the call caused a context switch from kernel back to user mode. Now the data is stored in the user address space buffer, and it can begin its way down again.</p>
<p><strong>3) 第三步</strong>: the <code>write</code> system call causes a context switch <strong>上下文切换</strong> from user mode to kernel mode. A third copy is performed to put the data into a kernel address space buffer again. This time, though, the data is put into a different buffer, a buffer that is associated with sockets specifically.</p>
<p><strong>4) 第四步</strong>: the <code>write</code> system call returns, creating our fourth context switch. Independently and asynchronously, a fourth copy happens as the DMA engine <strong>DMA 引擎</strong> passes the data from the kernel buffer to the protocol engine. You are probably asking yourself, “What do you mean independently and asynchronously? Wasn’t the data transmitted before the call returned?” Call return, in fact, doesn’t guarantee transmission; it doesn’t even guarantee the start of the transmission. It simply means the Ethernet driver had free descriptors in its queue and has accepted our data for transmission. There could be numerous packets queued before ours. Unless the driver/hardware implements priority rings or queues, data is transmitted on a first-in-first-out basis. (The forked DMA copy in Figure 1 illustrates the fact that the last copy can be delayed).</p>
<p>As you can see, a lot of data duplication is not really necessary <strong>不是特别有必要</strong> to hold things up. Some of the duplication could be eliminated to decrease overhead and increase performance. As a driver developer, I work with hardware that has some pretty advanced features. Some hardware can bypass the main memory altogether and transmit data directly to another device. This feature eliminates a copy in the system memory and is a nice thing to have, but not all hardware supports it. There is also the issue of the data from the disk having to be repackaged for the network, which introduces some complications. To eliminate overhead, we could start by eliminating some of the copying between the kernel and user buffers <strong>取消一些内核和用户空间的拷贝</strong>.</p>
<hr>
<p>One way to eliminate a copy is to <strong>跳过</strong> calling <code>read</code> and instead call <code>mmap</code>. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tmp_buf = mmap(file, len);</div><div class="line">write(socket, tmp_buf, len);</div></pre></td></tr></table></figure>
<p>To get a better idea of the process involved, take a look at Figure 2. Context switches remain the same.</p>
<p><img src="6345f2.jpg" alt=""></p>
<p><strong>1) 第一步</strong>: the <code>mmap</code> system call causes the file contents to be copied into a kernel buffer by the DMA engine. The buffer is shared then with the user process <strong>缓冲区同时被内核和用户区共享</strong>, without any copy being performed between the kernel and user memory spaces.</p>
<p><strong>2) 第二步</strong>: the <code>write</code> system call causes the kernel to copy the data from the original kernel buffers into the kernel buffers associated with sockets.</p>
<p><strong>3) 第三步</strong>: the third copy happens as the DMA engine passes the data from the kernel socket buffers to the protocol engine.</p>
<p>By using <code>mmap</code> instead of <code>read</code>, we’ve cut in half the amount of data the kernel has to copy. This yields reasonably good results when a lot of data is being transmitted. However, this improvement doesn’t come without a price; there are hidden pitfalls <strong>缺点</strong> when using the <code>mmap+write</code> method. You will fall into one of them when you memory map a file and then call write while another process <strong>其他进程截断</strong> truncates the same file. Your <code>write</code> system call will be interrupted by the bus error <strong>BUS 错误</strong> signal <code>SIGBUS</code>, because you performed a bad memory access <strong>坏内存访问</strong>. The default behavior for that signal is to kill the process and dump core—not the most desirable operation for a network server. There are two ways to get around this problem.</p>
<p>The first way is to install a signal handler for the <code>SIGBUS</code> signal, and then simply call return in the handler. By doing this the <code>write</code> system call returns with the number of bytes it wrote <strong>已经写的字节数</strong> before it got interrupted and the errno set to success. Let me point out that this would be a bad solution, one that treats the symptoms and not the cause of the problem. Because <code>SIGBUS</code> signals that something has gone seriously wrong with the process, I would discourage using this as a solution.</p>
<p>The second solution involves file leasing <strong>文件租赁</strong> (which is called “opportunistic locking” in Microsoft Windows) from the kernel. This is the correct way to fix this problem. By using leasing on the file descriptor, you take a lease <strong>租约</strong> with the kernel on a particular file. You then can request a <code>read/write</code> lease from the kernel. When another process tries to truncate the file you are transmitting, the kernel sends you a real-time signal, the <code>RT_SIGNAL_LEASE</code> signal. It tells you the kernel is breaking <strong>毁约</strong> your <code>write</code> or <code>read</code> lease on that file. Your <code>write</code> call is interrupted <strong><code>write</code> 提前被打断</strong> before your program accesses an invalid address and gets killed by the <code>SIGBUS</code> signal. The return value of the <code>write</code> call is the number of bytes written before the interruption, and the errno will be set to success. Here is some sample code that shows how to get a lease from the kernel:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(fcntl(fd, F_SETSIG, RT_SIGNAL_LEASE) == <span class="number">-1</span>) &#123;</div><div class="line">    perror(<span class="string">"kernel lease set signal"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* l_type can be F_RDLCK F_WRLCK */</span></div><div class="line"><span class="keyword">if</span>(fcntl(fd, F_SETLEASE, l_type))&#123;</div><div class="line">    perror(<span class="string">"kernel lease set type"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>You should get your lease before mmaping the file, and break your lease after you are done. This is achieved by calling <code>fcntl F_SETLEASE</code> with the lease type of <code>F_UNLCK</code>.</p>
<hr>
<p>In kernel version 2.1, the <code>sendfile</code> system call was introduced to simplify the transmission of data <strong>简化数据传输</strong> over the network and between two local files. Introduction of <code>sendfile</code> not only reduces data copying, it also reduces context switches. Use it like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendfile(socket, file, len);</div></pre></td></tr></table></figure>
<p>To get a better idea of the process involved, take a look at Figure 3.</p>
<p><img src="6345f3.jpg" alt=""></p>
<p><strong>1) 第一步</strong>: the <code>sendfile</code> system call causes the file contents to be copied into a kernel buffer by the DMA engine. Then the data is copied by the kernel into the kernel buffer associated with sockets.</p>
<p><strong>2) 第二步</strong>: the third copy happens as the DMA engine passes the data from the kernel socket buffers to the protocol engine.</p>
<p>You are probably wondering what happens if another process truncates the file we are transmitting with the <code>sendfile</code> system call. If we don’t register any signal handlers, the sendfile call simply returns with the number of bytes it transferred before it got interrupted, and the errno will be set to success.</p>
<p>If we get a lease from the kernel on the file before we call <code>sendfile</code>, however, the behavior and the return status are exactly the same. We also get the <code>RT_SIGNAL_LEASE</code> signal before the <code>sendfile</code> call returns.</p>
<p>So far, we have been able to avoid having the kernel make several copies, but we are still left with one copy. Can that be avoided too? Absolutely, with a little help from the hardware. To eliminate all the data duplication done by the kernel, we need a network interface that supports gather operations <strong>网卡支持 <code>gather</code> 操作</strong>. This simply means that data awaiting transmission doesn’t need to be in consecutive memory <strong>数据不用放在连续内存中</strong>; it can be scattered <strong>可以被聚合</strong> through various memory locations. In kernel version 2.4, the socket buffer descriptor was modified to accommodate those requirements—what is known as zero copy <strong>零拷贝</strong> under Linux. This approach not only reduces multiple context switches, it also eliminates data duplication done by the processor. For user-level applications nothing has changed, so the code still looks like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendfile(socket, file, len);</div></pre></td></tr></table></figure>
<p>To get a better idea of the process involved, take a look at Figure 4.</p>
<p><img src="6345f4.jpg" alt=""></p>
<p><strong>1) 第一步</strong>: the <code>sendfile</code> system call causes the file contents to be copied into a kernel buffer by the DMA engine.</p>
<p><strong>2) 第二步</strong>: no data is copied into the socket buffer. Instead, only descriptors with information about the whereabouts and length of the data are appended to the socket buffer. The DMA engine passes data directly from the kernel buffer to the protocol engine <strong>DMA 直接将数据从内核区传参给协议引擎</strong>, thus eliminating the remaining final copy.</p>
<p>Because data still is actually copied from the disk to the memory and from the memory to the wire, some might argue this is not a true zero copy. This is zero copy from the operating system standpoint, though, because the data is not duplicated between kernel buffers. When using zero copy, other performance benefits can be had besides copy avoidance, such as fewer context switches <strong>更少的上下文切换</strong>, less CPU data cache pollution <strong>更少的 CPU 缓存污染</strong> and no CPU checksum calculations <strong>CPU 不用计算校验</strong>.</p>
<p>Now that we know what zero copy is, let’s put theory into practice and write some code. You can download the full source code from <a href="www.xalien.org/articles/source/sfl-src.tgz">www.xalien.org/articles/source/sfl-src.tgz</a>. To unpack the source code, type <code>tar -zxvf sfl-src.tgz</code> at the prompt. To compile the code and create the random data file <code>data.bin</code>, run <code>make</code>.</p>
<p>Looking at the code starting with header files:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* sfl.c sendfile example program</span></div><div class="line"><span class="comment">Dragan Stancevic &lt;</span></div><div class="line"><span class="comment">header name                 function / variable</span></div><div class="line"><span class="comment">-------------------------------------------------*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;          /* printf, perror */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;          /* open */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;         /* close */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;          /* errno */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;         /* memset */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;     /* socket */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;     /* sockaddr_in */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;   /* sendfile */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;      /* inet_addr */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE (10*1024) <span class="comment">/* size of the tmp</span></span></div><div class="line"><span class="meta"><span class="comment">                               buffer */</span></span></div></pre></td></tr></table></figure>
<p>Besides the regular <code>&lt;sys/socket.h&gt;</code> and <code>&lt;netinet/in.h&gt;</code> required for basic socket operation, we need a prototype definition of the <code>sendfile</code> system call. This can be found in the <code>&lt;sys/sendfile.h&gt;</code> server flag:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* are we sending or receiving */</span></div><div class="line"><span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'s'</span>) is_server++;</div><div class="line"><span class="comment">/* open descriptors */</span></div><div class="line">sd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span>(is_server) fd = open(<span class="string">"data.bin"</span>, O_RDONLY);</div></pre></td></tr></table></figure>
<p>The same program can act as either a server/sender or a client/receiver. We have to check one of the command-prompt parameters, and then set the flag <code>is_server</code> to run in sender mode. We also open a stream socket of the INET protocol family. As part of running in server mode we need some type of data to transmit to a client, so we open our data file. We are using the system call <code>sendfile</code> to transmit data, so <strong>we don’t have to read the actual contents of the file and store it in our program memory buffer</strong>. Here’s the server address:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* clear the memory */</span></div><div class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</div><div class="line"><span class="comment">/* initialize structure */</span></div><div class="line">sa.sin_family = PF_INET;</div><div class="line">sa.sin_port = htons(<span class="number">1033</span>);</div><div class="line">sa.sin_addr.s_addr = inet_addr(argv[<span class="number">2</span>]);</div></pre></td></tr></table></figure>
<p>We clear the server address structure and assign the protocol family, port and IP address of the server. The address of the server is passed as a command-line parameter. The port number is hard coded to unassigned port 1033. This port number was chosen because it is above the port range requiring root access to the system.</p>
<p>Here is the server execution branch:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(is_server)&#123;</div><div class="line">    <span class="keyword">int</span> client; <span class="comment">/* new client socket */</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Server binding to [%s]\n"</span>, argv[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">if</span>(bind(sd, (struct sockaddr *)&amp;sa,</div><div class="line">                      <span class="keyword">sizeof</span>(sa)) &lt; <span class="number">0</span>)&#123;</div><div class="line">        perror(<span class="string">"bind"</span>);</div><div class="line">        <span class="built_in">exit</span>(errno);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>As a server, we need to assign an address to our socket descriptor. This is achieved by the system call <code>bind</code>, which assigns the socket descriptor (sd) a server address (sa):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(listen(sd,<span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</div><div class="line">    perror(<span class="string">"listen"</span>);</div><div class="line">    <span class="built_in">exit</span>(errno);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Because we are using a stream socket, we have to advertise our willingness to accept incoming connections and set the connection queue size. I’ve set the backlog queue to 1, but it is common to set the backlog a bit higher for established connections waiting to be accepted. In older versions of the kernel, the backlog queue <strong>backlog 队列</strong> was used to prevent syn flood attacks <strong>防止 SYN 洪泛攻击</strong>. Because the system call listen changed to set parameters for only established connections, the backlog queue feature has been deprecated for this call. The kernel parameter <code>tcp_max_syn_backlog</code> has taken over the role of protecting the system from syn flood attacks:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>((client = accept(sd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)&#123;</div><div class="line">    perror(<span class="string">"accept"</span>);</div><div class="line">    <span class="built_in">exit</span>(errno);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The system call accept creates a new connected socket from the first connection request on the pending connections queue. The return value from the call is a descriptor for a newly created connection; the socket is now ready for read, write or <code>poll/select</code> system calls:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>((cnt = sendfile(client,fd,&amp;off,</div><div class="line">                          BUFF_SIZE)) &lt; <span class="number">0</span>)&#123;</div><div class="line">    perror(<span class="string">"sendfile"</span>);</div><div class="line">    <span class="built_in">exit</span>(errno);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Server sent %d bytes.\n"</span>, cnt);</div><div class="line">close(client);</div></pre></td></tr></table></figure>
<p>A connection is established on the client socket descriptor, so we can start transmitting data to the remote system. We do this by calling the <code>sendfile</code> system call, which is prototyped under Linux in the following manner:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">ssize_t</span></div><div class="line">sendfile (<span class="keyword">int</span> __out_fd, <span class="keyword">int</span> __in_fd, <span class="keyword">off_t</span> *offset,</div><div class="line">          <span class="keyword">size_t</span> __count) __THROW;</div></pre></td></tr></table></figure>
<p>The first two parameters are file descriptors. The third parameter points to an offset from which sendfile should start sending data. The fourth parameter is the number of bytes we want to transmit. In order for the sendfile transmit to use zero-copy functionality, you need memory gather operation support from your networking card. You also need checksum capabilities for protocols that implement checksums, such as TCP or UDP. If your NIC is outdated and doesn’t support <strong>如果不支持</strong> those features, you still can use sendfile to transmit files. The difference is the kernel will merge the buffers <strong>内核在传送之前合并缓冲区</strong> before transmitting them.</p>
<hr>
<p>Portability Issues <strong>移植问题</strong>:</p>
<p>One of the problems with the <code>sendfile</code> system call, in general, is the lack of a standard implementation, as there is for the open system call. <code>Sendfile</code> implementations in Linux, Solaris or HP-UX are quite different. This poses a problem for developers who wish to use zero copy in their network data transmission code.</p>
<p>One of the implementation differences is Linux provides a <code>sendfile</code> that defines an interface for transmitting data between two file descriptors (<strong>file-to-file</strong>) and (<strong>file-to-socket</strong>). HP-UX and Solaris, on the other hand, can be used only for file-to-socket submissions.</p>
<p>The second difference is Linux doesn’t implement vectored transfers. Solaris sendfile and HP-UX sendfile have extra parameters that eliminate overhead associated with prepending headers to the data being transmitted.</p>
<hr>
<p>Looking Ahead</p>
<p>The implementation of zero copy under Linux is far from finished and is likely to change in the near future. More functionality should be added. For example, the <code>sendfile</code> call doesn’t support vectored transfers <strong>不支持矢量传输</strong>, and servers such as Samba and Apache have to use multiple sendfile calls with the <code>TCP_CORK</code> flag set. This flag tells the system more data is coming through in the next sendfile calls. <code>TCP_CORK</code> also is incompatible with <code>TCP_NODELAY</code> and is used when we want to prepend or append headers to the data. This is a perfect example of where a vectored call would eliminate the need for multiple <code>sendfile</code> calls <strong>需要多个 <code>sendfile</code> 调用</strong> and delays mandated by the current implementation.</p>
<p>One rather unpleasant limitation in the current <code>sendfile</code> is it cannot be used when transferring files greater than 2GB <strong>不能超过 2GB</strong>. Files of such size are not all that uncommon today, and it’s rather disappointing having to duplicate all that data on its way out. Because both <code>sendfile</code> and <code>mmap</code> methods are unusable in this case, a <code>sendfile64</code> would be really handy in a future kernel version.</p>
<hr>
<p><strong>编程访问</strong>:</p>
<p>The Linux kernel supports zero-copy through various system calls, such as <code>sys/socket.h</code>‘s <code>sendfile</code>, <code>sendfile64</code>, and <code>splice</code>. Some of them are specified in POSIX and thus also present in the BSD kernels or IBM AIX, some are unique to the Linux kernel API.</p>
<p>Java input streams can support zero-copy through the <code>java.nio.channels.FileChannel</code>‘s <strong><code>transferTo()</code></strong> method if the underlying operating system also supports zero copy.</p>
<hr>
<p>参考:</p>
<ul>
<li><a href="http://www.linuxjournal.com/article/6345" target="_blank" rel="external">Zero Copy I: User-Mode Perspective</a></li>
</ul>
<h3 id="Linux-的内核同步"><a href="#Linux-的内核同步" class="headerlink" title="Linux 的内核同步"></a>Linux 的内核同步</h3><hr>
<p>参考:</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/library/l-linux-synchronization/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/library/l-linux-synchronization/index.html</a></li>
</ul>
<h3 id="写复制"><a href="#写复制" class="headerlink" title="写复制"></a>写复制</h3><p><strong>Copy-on-write in 虚拟内存管理</strong>:</p>
<p>Copy-on-write finds its main use in <strong>共享虚拟内存</strong> of operating system processes, in the implementation of the <strong><code>fork</code> 系统调用</strong>. Typically, the process does not modify any memory and immediately executes a new process, replacing the address space entirely. Thus, it would be wasteful to copy all of the process’s memory <strong>拷贝所有内存是机器浪费的</strong> during a fork, and instead the copy-on-write technique is used. It can be implemented efficiently using the page table <strong>页表</strong> by marking certain pages of memory as read-only and keeping a count of the number of references to the page. When data is written to these pages, the kernel intercepts the write attempt and allocates a new physical page <strong>拦截写操作，并分配新的物理页</strong>, initialized with the copy-on-write data, although the allocation can be skipped if there is only one reference. The kernel then updates the page table with the new (writable) page, decrements the number of references, and performs the write. The new allocation ensures that a change in the memory of one process is not visible in another’s. The copy-on-write technique can be extended to support efficient memory allocation by having a page of physical memory filled with zeros. When the memory is allocated, all the pages returned refer to the page of zeros and are all marked copy-on-write. This way, physical memory is not allocated for the process until data is written, allowing processes to reserve more virtual memory than physical memory and use memory sparsely, at the risk of running out of virtual address space. The combined algorithm is similar to demand paging.</p>
<p>Copy-on-write pages are also used in the Linux kernel’s kernel same-page merging feature.</p>
<p><img src="slide_29.jpg" alt=""></p>
<h3 id="poll-vs-epoll-vs-select-区别和各自使用场景-epoll-和-select-底层使用的数据结构"><a href="#poll-vs-epoll-vs-select-区别和各自使用场景-epoll-和-select-底层使用的数据结构" class="headerlink" title="poll vs epoll vs select 区别和各自使用场景, epoll 和 select 底层使用的数据结构"></a><code>poll</code> vs <code>epoll</code> vs <code>select</code> 区别和各自使用场景, <code>epoll</code> 和 <code>select</code> 底层使用的数据结构</h3><p>When designing a high performance networking application with <strong>非阻塞</strong> socket I/O, the architect needs to decide which polling method to use to monitor the events generated by those sockets. There are several such methods, and the use cases for each of them are different. Choosing the correct method may be critical to satisfy the application needs.</p>
<h4 id="1-Polling-with-select"><a href="#1-Polling-with-select" class="headerlink" title="(1) Polling with select()"></a>(1) Polling with <code>select()</code></h4><p>Old, trusted workforce from the times the sockets were still called Berkeley sockets. It didn’t make it into the first specification though since there were <strong>还没有非阻塞 I/O 的概念</strong> of non-blocking I/O at that moment, but it did make it around <strong>八十年代</strong>, and nothing changed since that in its interface.</p>
<p>To use select, the developer needs to initialize and fill up several <code>fd_set</code> structures with the descriptors and the events to monitor, and then call <code>select()</code>. A typical workflow looks like that:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">fd_set fd_in, fd_out;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></div><div class="line"> </div><div class="line"><span class="comment">// Reset the sets</span></div><div class="line">FD_ZERO( &amp;fd_in );</div><div class="line">FD_ZERO( &amp;fd_out );</div><div class="line"> </div><div class="line"><span class="comment">// Monitor sock1 for input events</span></div><div class="line">FD_SET( sock1, &amp;fd_in );</div><div class="line"> </div><div class="line"><span class="comment">// Monitor sock2 for output events</span></div><div class="line">FD_SET( sock2, &amp;fd_out );</div><div class="line"> </div><div class="line"><span class="comment">// Find out which socket has the largest numeric value as select requires it</span></div><div class="line"><span class="keyword">int</span> largest_sock = sock1 &gt; sock2 ? sock1 : sock2;</div><div class="line"> </div><div class="line"><span class="comment">// Wait up to 10 seconds</span></div><div class="line">tv.tv_sec = <span class="number">10</span>;</div><div class="line">tv.tv_usec = <span class="number">0</span>;</div><div class="line"> </div><div class="line"><span class="comment">// Call the select</span></div><div class="line"><span class="keyword">int</span> ret = select( largest_sock + <span class="number">1</span>, &amp;fd_in, &amp;fd_out, <span class="literal">NULL</span>, &amp;tv );</div><div class="line"> </div><div class="line"><span class="comment">// Check if select actually succeed</span></div><div class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</div><div class="line">    <span class="comment">// report error and abort</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</div><div class="line">    <span class="comment">// timeout; no event detected</span></div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( FD_ISSET( sock1, &amp;fd_in ) )</div><div class="line">        <span class="comment">// input event on sock1</span></div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( FD_ISSET( sock2, &amp;fd_out ) )</div><div class="line">        <span class="comment">// output event on sock2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>When the select interface was designed and developed, nobody probably expected there would be multi-threaded applications serving many thousands connections. Hence select carries quite a few <strong>设计缺陷</strong> which make it undesirable as a polling mechanism in the modern networking application. The major disadvantages include:</p>
<ul>
<li>select modifies the passed <code>fd_sets</code> so <strong>无法重用</strong>. Even if you don’t need to change anything – such as if one of descriptors received data and needs to receive more data – a whole set <strong>整个 set</strong> has to be either recreated again (argh!) or restored from a backup copy via <code>FD_COPY</code>. And this has to be done each time the select is called.</li>
<li>To find out which descriptors raised the events you have to manually iterate <strong>遍历</strong> through all the descriptors in the set and call <code>FD_ISSET</code> on each one of them. When you have 2,000 of those descriptors and only one of them is active – and, likely, the last one – you’re wasting CPU cycles each time you wait.</li>
<li>Did I just mention 2,000 descriptors? Well, select cannot support that much <strong>文件描述符受限</strong>. At least on Linux. The maximum number of the supported descriptors is defined by the <code>FD_SETSIZE</code> constant, which Linux happily defines as 1024. And while some operating systems allow you to hack this restriction by redefining the <code>FD_SETSIZE</code> before including the <code>sys/select.h</code>, this is not portable. Indeed, Linux would just ignore this hack and the limit will stay the same.</li>
<li>You cannot modify the descriptor set <strong>无法修改描述符集</strong> from a different thread <strong>从不同线程中</strong> while waiting. Suppose a thread is executing the code above. Now suppose you have a housekeeping thread which decided that sock1 has been waiting too long for the input data, and it is time to cut the cord. Since this socket could be reused to serve another paying working client, the housekeeping thread wants to close the socket. However the socket is in the <code>fd_set</code> which select is waiting for. Now what happens when this socket is closed? man select has the answer, and you won’t like it. The answer is, “If a file descriptor being monitored by <code>select()</code> is closed in another thread, the result is unspecified”.</li>
<li>Same problem arises if another thread suddenly decides to send something via sock1. It is not possible to start monitoring the socket for the output event until select returns.</li>
<li>The choice of the events to wait for is limited; <strong>能检测的事件类型有限</strong> for example, to detect whether the remote socket is closed you have to a) monitor it for input and b) actually attempt to read the data from socket to detect the closure (read will return 0). Which is fine if you want to read from this socket, but what if you’re sending a file and do not care about any input right now?</li>
<li>select puts extra burden on you when filling up the descriptor list to calculate the largest descriptor number and provide it as a function parameter.</li>
</ul>
<p>Of course the operating system developers recognized those drawbacks and addressed most of them when designing the <code>poll</code> method. Therefore you may ask, is there is any reason to use select at all? <strong>还有没有使用 <code>select</code> 的理由？</strong> Why don’t just store it in the shelf of the Computer Science Museum? Then you may be pleased to know that yes, there are two reasons <strong>两个理由</strong>, which may be either very important to you or not important at all.</p>
<p>The first reason is portability <strong>移植性</strong>. select has been around for ages, and you can be sure that every single platform around which has network support and nonblocking sockets will have a working select implementation while it might not have poll at all. And unfortunately I’m not talking about the tubes and ENIAC here; <strong><code>poll</code></strong> is only available on <strong>Windows Vista</strong> and above which includes Windows XP – still used by the whooping 34% of users as of Sep 2013 despite the Microsoft pressure. Another option would be to still use <code>poll</code> on those platforms and emulate it with select on those which do not have it; it is up to you whether you consider it reasonable investment.</p>
<p>The second reason is more exotic, and is related to the fact that select can – theoretically – handle the timeouts <strong>超时</strong> withing the one nanosecond <strong>纳秒精度</strong> precision, while both <code>poll</code> and <code>epoll</code> can only handle the one millisecond precision. This is not likely to be a concern on a desktop or server system, which clocks doesn’t even run with such precision, but it may be necessary on a realtime embedded platform <strong>嵌入式平台</strong> while interacting with some hardware components. Such as lowering control rods to shut down a nuclear reactor – in this case, please, use select to make sure we’re all stay safe!</p>
<p>The case above would probably be the only case where you would have to use select and could not use anything else. However if you are writing an application which would never have to handle more than a handful of sockets (like, 200), the difference between using poll and select would not be based on performance, but more on personal preference or other factors.</p>
<h4 id="2-Polling-with-poll"><a href="#2-Polling-with-poll" class="headerlink" title="(2) Polling with poll()"></a>(2) Polling with poll()</h4><p><code>poll</code> is a newer polling method which probably was created immediately after someone actually tried to write the high performance networking server. It is much better designed and doesn’t suffer from most of the problems which select has. In the vast majority of cases you would be choosing between <code>poll</code> and <code>epoll/libevent</code>.</p>
<p>To use <code>poll</code>, the developer needs to initialize the members of <code>struct pollfd</code> structure with the descriptors and events to monitor, and call the <code>poll()</code>. A typical workflow looks like that:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The structure for two events</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></div><div class="line"> </div><div class="line"><span class="comment">// Monitor sock1 for input</span></div><div class="line">fds[<span class="number">0</span>].fd = sock1;</div><div class="line">fds[<span class="number">0</span>].events = POLLIN;</div><div class="line"> </div><div class="line"><span class="comment">// Monitor sock2 for output</span></div><div class="line">fds[<span class="number">1</span>].fd = sock2;</div><div class="line">fds[<span class="number">1</span>].events = POLLOUT;</div><div class="line"> </div><div class="line"><span class="comment">// Wait 10 seconds</span></div><div class="line"><span class="keyword">int</span> ret = poll( &amp;fds, <span class="number">2</span>, <span class="number">10000</span> );</div><div class="line"><span class="comment">// Check if poll actually succeed</span></div><div class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</div><div class="line">    <span class="comment">// report error and abort</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</div><div class="line">    <span class="comment">// timeout; no event detected</span></div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// If we detect the event, zero it out so we can reuse the structure</span></div><div class="line">    <span class="keyword">if</span> ( pfd[<span class="number">0</span>].revents &amp; POLLIN )</div><div class="line">        pfd[<span class="number">0</span>].revents = <span class="number">0</span>;</div><div class="line">        <span class="comment">// input event on sock1</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( pfd[<span class="number">1</span>].revents &amp; POLLOUT )</div><div class="line">        pfd[<span class="number">1</span>].revents = <span class="number">0</span>;</div><div class="line">        <span class="comment">// output event on sock2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>poll</code> was mainly created to fix <strong>修复</strong> the pending problems <code>select</code> had, so it has the following advantages over it:</p>
<ul>
<li>There is no hard limit on the number of descriptors poll can monitor, so the limit of 1024 does not apply here.</li>
<li>It does not modify <strong>不修改</strong> the data passed in the struct pollfd data. Therefore it could be reused between the <code>poll()</code> calls as long as set to zero the revents member for those descriptors which generated the events. The IEEE specification states that “In each pollfd structure, <code>poll()</code> shall clear the revents member, except that where the application requested a report on a condition by setting one of the bits of events listed above, <code>poll()</code> shall set the corresponding bit in revents if the requested condition is true“. However in my experience at least one platform did not follow this recommendation, and <code>man 2 poll</code> on Linux does not make such guarantee either (<code>man 3p poll</code> does though).</li>
<li>It allows more fine-grained control of events comparing to select. For example, it can detect remote peer shutdown <strong>检测远程关闭</strong> without monitoring for read events.</li>
</ul>
<p>There are a few disadvantages as well, which were mentioned above at the end of the select section. Notably, <code>poll</code> is not present on <strong>Microsoft Windows older than Vista</strong>; on Vista and above it is called <code>WSAPoll</code> although the prototype is the same, and it could be defined as simply as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (WIN32)</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">( struct pollfd *pfd, <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span> </span>&#123; <span class="keyword">return</span> WSAPoll ( pfd, nfds, timeout ); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>And, as mentioned above, poll timeout has the 1ms precision <strong>毫秒精度</strong>, which again is very unlikely to be a concern in most scenarios. Nevertheless poll still has a few issues <strong>仍然有一些问题</strong> which need to be kept in mind:</p>
<ul>
<li>Like select, it is still not possible to find out which descriptors have the events triggered without iterating through the whole list and checking the revents <strong>仍然需要遍历</strong>. Worse, the same happens in the kernel space as well, as the kernel has to iterate through the list of file descriptors to find out which sockets are monitored, and iterate through the whole list again to set up the events.</li>
<li>Like select, it is not possible to dynamically modify the set <strong>无法动态修改集合</strong> or close the socket which is being polled <strong>无法关闭正在 <code>polled</code> 的 <code>socket</code></strong> (see above).</li>
</ul>
<p>Please keep in mind, however, that those issues might be considered unimportant for most client networking applications – the only exception would be client software such as <strong>P2P</strong> which may require handling of thousands of open connections. Those issues might not be important even for some server applications. Therefore poll should be your default choice over select unless you have specific reasons mentioned above. More, poll should be your preferred method even over <code>epoll</code> if the following is true:</p>
<ul>
<li>You need to support more than just Linux <strong>支持更多操作系统</strong>, and do not want to use epoll wrappers such as libevent (epoll is Linux only);</li>
<li>Your application needs to monitor less than 1000 sockets <strong>一次监控小于 1000 个 <code>sockets</code></strong> at a time (you are not likely to see any benefits from using epoll);</li>
<li>Your application needs to monitor more than 1000 sockets at a time, but the connections are very short-lived <strong>都是短连接</strong> (this is a close case, but most likely in this scenario you are not likely to see any benefits from using epoll because the speedup in event waiting would be wasted on adding those new descriptors into the set – see below)</li>
<li>Your application is not designed the way that it changes the events while another thread is waiting for them (i.e. you’re not porting an app using <code>kqueue</code> or IO Completion Ports).</li>
</ul>
<h4 id="3-Polling-with-epoll"><a href="#3-Polling-with-epoll" class="headerlink" title="(3) Polling with epoll()"></a>(3) Polling with epoll()</h4><p><code>epoll</code> is the latest, greatest, newest polling method in Linux (and only Linux <strong>只有 <code>Linux</code></strong>). Well, it was actually added to kernel in 2002, so it is not so new. It differs both from <code>poll</code> and <code>select</code> in such a way that it keeps the information about the currently monitored descriptors and associated events inside the kernel, and exports the API to <code>add/remove/modify</code> those.</p>
<p>To use <code>epoll</code>, much more preparation is needed. A developer needs to:</p>
<ul>
<li><strong>创建</strong> the epoll descriptor by calling <code>epoll_create</code>;</li>
<li><strong>初始化</strong> the <code>struct epoll</code> structure with the wanted events <strong>事件</strong> and the context data pointer <strong>上下文数据指针</strong>. Context could be anything, epoll passes this value directly to the returned events structure. We store there a pointer to our Connection class.</li>
<li>Call <code>epoll_ctl( … EPOLL_CTL_ADD )</code> to <strong>添加</strong> the descriptor into the monitoring set</li>
<li>Call <code>epoll_wait()</code> to wait for 20 events for which we reserve the storage space. Unlike previous methods, this call receives an empty structure, and fills it up only with the triggered events. For example, if there are 200 descriptors and 5 of them have events pending, the <code>epoll_wait</code> will return 5, and only the first five members of the pevents structure will be initialized. If 50 descriptors have events pending, the first 20 would be copied and 30 would be left in queue, they won’t get lost.</li>
<li><strong>遍历</strong> through the returned items. This will be a short iteration since the only events returned are those which are triggered.</li>
</ul>
<p>A typical workflow looks like that:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span></div><div class="line"><span class="comment">// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span></div><div class="line"><span class="keyword">int</span> pollingfd = epoll_create( <span class="number">0xCAFE</span> ); </div><div class="line"></div><div class="line"><span class="keyword">if</span> ( pollingfd &lt; <span class="number">0</span> )</div><div class="line"> <span class="comment">// report error</span></div><div class="line"></div><div class="line"><span class="comment">// Initialize the epoll structure in case more members are added in future</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> = &#123;</span> <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Associate the connection class instance with the event. You can associate anything</span></div><div class="line"><span class="comment">// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span></div><div class="line">ev.data.ptr = pConnection1;</div><div class="line"></div><div class="line"><span class="comment">// Monitor for input, and do not automatically rearm the descriptor after the event</span></div><div class="line">ev.events = EPOLLIN | EPOLLONESHOT;</div><div class="line"><span class="comment">// Add the descriptor into the monitoring list. We can do it even if another thread is </span></div><div class="line"><span class="comment">// waiting in epoll_wait - the descriptor will be properly added</span></div><div class="line"><span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != <span class="number">0</span> )</div><div class="line">    <span class="comment">// report error</span></div><div class="line"></div><div class="line"><span class="comment">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">pevents</span>[ 20 ];</span></div><div class="line"></div><div class="line"><span class="comment">// Wait for 10 seconds</span></div><div class="line"><span class="keyword">int</span> ready = epoll_wait( pollingfd, pevents, <span class="number">20</span>, <span class="number">10000</span> );</div><div class="line"><span class="comment">// Check if epoll actually succeed</span></div><div class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</div><div class="line">    <span class="comment">// report error and abort</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</div><div class="line">    <span class="comment">// timeout; no event detected</span></div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Check if any events detected</span></div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++ )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ( pevents[i].events &amp; EPOLLIN )</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// Get back our connection pointer</span></div><div class="line">            Connection * c = (Connection*) pevents[i].data.ptr;</div><div class="line">            c-&gt;handleReadEvent();</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Just looking at the implementation alone should give you the hint of what are the disadvantages of <code>epoll</code>, which we will mention firs. It is more complex to use <strong>更加复杂</strong>, and requires you to write more code <strong>更多代码</strong>, and it requires more library calls comparing to other polling methods.</p>
<p>However <code>epoll</code> has some significant advantages <strong>更大优势</strong> over <code>select/poll</code> both in terms of performance and functionality:</p>
<ul>
<li><code>epoll</code> returns only the list of descriptors which triggered the events <strong>只返回触发事件的描述符</strong>. No need to iterate through 10,000 descriptors anymore to find that one which triggered the event!</li>
<li>You can attach meaningful context <strong>附加有意义的上下文</strong> to the monitored event instead of socket file descriptors. In our example we attached the class pointers which could be called directly, saving you another lookup.</li>
<li>You can add sockets or remove them from monitoring anytime <strong>任意添加/删除</strong>, even if another thread is in the <code>epoll_wait</code> function. You can even modify the descriptor events. Everything will work properly, and this behavior is supported and documented. This gives you much more flexibility in implementation.</li>
<li>Since the kernel knows all the monitoring descriptors, it can register the events happening on them even when nobody is calling <code>epoll_wait</code>. This allows implementing interesting features such as edge triggering, which will be described in a separate article.</li>
<li>It is possible to have the multiple threads waiting <strong>多线程等待</strong> on the same <code>epoll</code> queue with <code>epoll_wait()</code>, something you cannot do with <code>select/poll</code>. In fact it is not only possible with <code>epoll</code>, but the recommended method in the edge triggering mode.</li>
</ul>
<p>However you need to keep in mind that <strong>epoll is not a “better poll”</strong>, and it also has <strong>缺点</strong> when comparing to poll:</p>
<ul>
<li>Changing the event flags (i.e. from READ to WRITE) requires the <code>epoll_ctl</code> syscall, while when using poll this is a simple <strong>bitmask operation</strong> done entirely in <strong>userspace</strong>. Switching 5,000 sockets from reading to writing with epoll would require 5,000 syscalls and hence context switches <strong>上下文切换</strong> (as of 2014 calls to <code>epoll_ctl</code> still  could not be batched, and each descriptor must be changed separately), while in poll it would require a single loop over the <code>pollfd</code> structure.</li>
<li>Each <code>accept()</code>ed socket needs to be added to the set, and same as above, with <code>epoll</code> it has to be done by calling <code>epoll_ctl</code> – which means there are two required syscalls <strong>每个连接需要两个系统调用</strong> per new connection socket instead of one for <code>poll</code>. If your server has many short-lived connections which send or receive little traffic, <code>epoll</code> will likely take longer than poll to serve them.</li>
<li><code>epoll</code> is exclusively Linux domain, and while other platforms have similar mechanisms, they are not exactly the same – edge triggering, for example, is pretty unique (FreeBSD’s kqueue supports it too though).</li>
<li>High performance processing logic is more complex and hence more difficult to debug <strong>难以调试</strong>, especially for edge triggering which is prone to deadlocks if you miss extra read/write.</li>
</ul>
<p>Therefore you should only use epoll if all following is true:</p>
<ul>
<li>Your application runs a thread poll which handles many network connections by a handful of threads <strong>多线程</strong>. You would lose most of epoll benefits in a single-threaded application, and most likely it won’t outperform poll.</li>
<li>You expect to have a reasonably large number of sockets <strong>大量的</strong> to monitor (at least 1,000); with a smaller number epoll is not likely to have any performance benefits over poll and may actually worse the performance;</li>
<li>Your connections are relatively long-lived <strong>生命周期长</strong>; as stated above <code>epoll</code> will be slower than poll in a situation when a new connection sends a few bytes of data and immediately disconnects because of extra system call required to add the descriptor into epoll set;</li>
<li>Your app depends on other Linux-specific features (so in case portability question would suddenly pop up, epoll wouldn’t be the only roadblock), or you can provide wrappers for other supported systems. In the last case you should strongly consider libevent.</li>
</ul>
<p>If all the items above aren’t true, you should be better served by using poll instead.</p>
<h4 id="4-Polling-with-libevent"><a href="#4-Polling-with-libevent" class="headerlink" title="(4) Polling with libevent"></a>(4) Polling with libevent</h4><p><a href="http://libevent.org/" target="_blank" rel="external">libebent</a> is a library which wraps the polling methods listed in this article (and some others) in an uniform API.Its main advantage is that it allows you to write the code once and compile and run it on many operating systems without the need to change the code <strong>各个操作系统兼容性</strong>. It is important to understand that libevent it is just a wrapper built on top of the existing polling methods, and therefore it inherits the issues those polling methods have. It will not make select supporting more than 1024 sockets on Linux or allow epoll to modify the polling events without a syscall/context switch. Therefore it is still important to understand each method’s pros and cons.</p>
<p>Having to provide access to the functionality from the dramatically different methods, libevent has a rather complex API which is much more difficult to use than poll or even epoll. It is however easier to use libevent than to write two separate backends if you need to support FreeBSD (epoll and kqueue). Hence it is a viable alternative which should be considered if:</p>
<ul>
<li>Your application requirements indicate that you must use <code>epoll</code>, and using just <code>poll</code> would not be enough (if poll would satisfy your needs, it is extremely unlikely libevent would offer you any benefits)</li>
<li>You need to support other OS than Linux, or may expect such need to arise in future. Again, this depends on other features of your application – if it is tied up to many other Linux-specific things you’re not going to achieve anything by using libevent instead of <code>epoll</code>.</li>
</ul>
<hr>
<p>参考</p>
<ul>
<li><a href="https://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/" target="_blank" rel="external">select / poll / epoll: practical difference for system architects</a></li>
</ul>
<h3 id="libevent-实现，IO-定时-信号事件如何集成统一"><a href="#libevent-实现，IO-定时-信号事件如何集成统一" class="headerlink" title="libevent 实现，IO + 定时 + 信号事件如何集成统一"></a><code>libevent</code> 实现，IO + 定时 + 信号事件如何集成统一</h3><h3 id="PPA"><a href="#PPA" class="headerlink" title="PPA"></a>PPA</h3><p>A <strong>Personal Package Archive (PPA)</strong> is a software repository for uploading source packages to be built and published as an <strong>Advanced Packaging Tool (APT)</strong> repository by Launchpad.</p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xvf filename.tar.xz</div></pre></td></tr></table></figure>
<h3 id="目录结构问题"><a href="#目录结构问题" class="headerlink" title="目录结构问题"></a>目录结构问题</h3><p><code>/usr/lib/x86_64-linux-gnu</code> is <code>/usr/lib64</code>, This changed when Ubuntu 12.04 came out.</p>
<h3 id="包搜索问题"><a href="#包搜索问题" class="headerlink" title="包搜索问题"></a>包搜索问题</h3><p>使用 <code>apt search</code> 来搜索包，有的时候示例文档提示的需要的依赖，可能并不精确:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt search libaio</div></pre></td></tr></table></figure>
<h3 id="man-问题"><a href="#man-问题" class="headerlink" title="man 问题"></a><code>man</code> 问题</h3><p>查看第 8 节:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man 8 apt-get</div></pre></td></tr></table></figure>
<p>通过这个可以了解到，平常 <code>apt-get</code> 后面跟的 <code>-y</code> 选项代表的是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-y, --yes, --assume-yes</div><div class="line">           Automatic yes to prompts; assume &quot;yes&quot; as answer to all prompts and run</div><div class="line">           non-interactively. If an undesirable situation, such as changing a held package,</div><div class="line">           trying to install a unauthenticated package or removing an essential package occurs</div><div class="line">           then apt-get will abort.</div></pre></td></tr></table></figure>
<h3 id="如何只在文件夹不存在的情况下才创建文件夹"><a href="#如何只在文件夹不存在的情况下才创建文件夹" class="headerlink" title="如何只在文件夹不存在的情况下才创建文件夹"></a>如何只在文件夹不存在的情况下才创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p crawler/<span class="built_in">log</span></div></pre></td></tr></table></figure>
<h3 id="telnet-的正确使用方法"><a href="#telnet-的正确使用方法" class="headerlink" title="telnet 的正确使用方法"></a><code>telnet</code> 的正确使用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet 10.108.112.218 1099</div></pre></td></tr></table></figure>
<p><code>telnet</code> 可以连接到任何 <strong>TCP</strong> 服务器，包括 <strong>HTTP</strong> 服务器:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">zk@zk-pc:~/Documents$ telnet www.kunzhao.org 80</div><div class="line">Trying 59.110.168.119...</div><div class="line">Connected to www.kunzhao.org.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">GET / HTTP/1.1 &lt;- 输入这行</div><div class="line">&lt;- 输入回车行</div><div class="line">HTTP/1.1 200 OK &lt;- 服务器开始返回内容</div><div class="line">X-Powered-By: Hexo</div><div class="line">Content-Type: text/html</div><div class="line">Date: Mon, 11 Sep 2017 01:37:21 GMT</div><div class="line">Connection: keep-alive</div><div class="line">Transfer-Encoding: chunked</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="切换为-root-用户的正确操作"><a href="#切换为-root-用户的正确操作" class="headerlink" title="切换为 root 用户的正确操作"></a>切换为 <code>root</code> 用户的正确操作</h3><p>The root account is <strong>disabled by default</strong> in Ubuntu, so there is <strong>no root password</strong>, that’s why <code>su</code> fails with an authentication error.</p>
<p>Use <code>sudo -i</code> to become root:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">zk@zk-pc:~/Documents$ su root</div><div class="line">Password: </div><div class="line">su: Authentication failure</div><div class="line">zk@zk-pc:~/Documents$ sudo -i</div><div class="line">root@zk-pc:~<span class="comment">#</span></div></pre></td></tr></table></figure>
<h3 id="Ubuntu-设置启动项菜单引导"><a href="#Ubuntu-设置启动项菜单引导" class="headerlink" title="Ubuntu 设置启动项菜单引导"></a><code>Ubuntu</code> 设置启动项菜单引导</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:danielrichter2007/grub-customizer</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install grub-customizer</div></pre></td></tr></table></figure>
<h3 id="Ubuntu-卸载其它系统"><a href="#Ubuntu-卸载其它系统" class="headerlink" title="Ubuntu 卸载其它系统"></a><code>Ubuntu</code> 卸载其它系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</div><div class="line">sudo apt-get update; sudo apt-get install -y os-uninstaller &amp;&amp; os-uninstaller</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://help.ubuntu.com/community/OS-Uninstaller" target="_blank" rel="external">OS-Uninstaller</a></li>
</ul>
<h3 id="get-full-path-of-original-file-of-a-soft-symbolic-link"><a href="#get-full-path-of-original-file-of-a-soft-symbolic-link" class="headerlink" title="get full path of original file of a soft symbolic link"></a>get full path of original file of a soft symbolic link</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">readlink -f `<span class="built_in">which</span> emacs`</div></pre></td></tr></table></figure>
<h3 id="make-a-soft-symbolic-link"><a href="#make-a-soft-symbolic-link" class="headerlink" title="make a soft symbolic link"></a>make a soft symbolic link</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</div><div class="line">sudo ln -s /usr/lib/intellij_idea/idea-IC-172.3968.16/bin/idea.sh idea</div></pre></td></tr></table></figure>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a><code>mount</code></h3><p><strong>1) Determine what device a directory is located on</strong>:</p>
<p>Use <code>df -h</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zk@zk-pc:/dev$ df -h /media/zk/Documents/</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/sda3       209G   17G  192G   9% /media/zk/Documents</div></pre></td></tr></table></figure>
<p><strong>2) Unmount</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount Documents/</div></pre></td></tr></table></figure>
<p>必须等待不忙的时候再 <code>umount</code>，否则会出现如下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">zk@zk-pc:/media/zk$ umount Documents/</div><div class="line">Error unmounting block device 8:3: GDBus.Error:org.freedesktop.UDisks2.Error.DeviceBusy: Error unmounting /dev/sda3: Command-line `umount  &quot;/media/zk/Documents&quot;&apos; exited with non-zero exit status 32: umount: /media/zk/Documents: target is busy</div><div class="line">        (In some cases useful info about processes that</div><div class="line">         use the device is found by lsof(8) or fuser(1).)</div></pre></td></tr></table></figure>
<p><strong>3) Mount</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /media/zk</div><div class="line">sudo mkdir Documents/ <span class="comment"># 必须先创建文件夹</span></div><div class="line">sudo mount /dev/sda3 Documents</div></pre></td></tr></table></figure>
<h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 分区软件</span></div><div class="line">sudo apt install gparted</div><div class="line"></div><div class="line"><span class="comment"># 截屏软件</span></div><div class="line">sudo add-apt-repository ppa:shutter/ppa</div><div class="line">sudo apt-get update &amp;&amp; sudo apt-get install shutter</div><div class="line"></div><div class="line"><span class="comment"># 办公软件 http://community.wps.cn/download/</span></div><div class="line"></div><div class="line"><span class="comment"># PDF 阅读软件 https://www.foxitsoftware.cn/downloads/</span></div></pre></td></tr></table></figure>
<p><strong>1) Shutter 配置</strong>:</p>
<p>禁止掉原来的截屏快捷键:</p>
<p><img src="2017_08_30_13_30_14.png" alt=""></p>
<p>添加 <code>Shutter</code> 截屏快捷键:</p>
<p><img src="2017_08_30_13_32_32.png" alt=""></p>
<p>配置 <code>Shutter</code> 截屏后的文件名，自动拷贝路径等:</p>
<p><img src="2017_08_30_13_34_18.png" alt=""></p>
<h3 id="获得文件信息"><a href="#获得文件信息" class="headerlink" title="获得文件信息"></a>获得文件信息</h3><p><strong>1) 显示文件路径</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dirname <span class="variable">$file</span></div></pre></td></tr></table></figure>
<p><strong>2) 显示文件名</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">basename <span class="variable">$file</span></div></pre></td></tr></table></figure>
<h3 id="隐藏活动记录"><a href="#隐藏活动记录" class="headerlink" title="隐藏活动记录"></a>隐藏活动记录</h3><ul>
<li><a href="https://askubuntu.com/questions/29559/how-can-i-keep-recent-files-from-appearing-in-unity" target="_blank" rel="external">How can I keep recent files from appearing in Unity?</a></li>
</ul>
<h3 id="安装-QQ"><a href="#安装-QQ" class="headerlink" title="安装 QQ"></a>安装 <code>QQ</code></h3><ul>
<li><a href="http://blog.csdn.net/ysy950803/article/details/52958538" target="_blank" rel="external">教你如何在Ubuntu上安装最新版QQ</a></li>
</ul>
<h3 id="Windows-硬盘安装-Ubuntu"><a href="#Windows-硬盘安装-Ubuntu" class="headerlink" title="Windows 硬盘安装 Ubuntu"></a>Windows 硬盘安装 Ubuntu</h3><ul>
<li>下载安装 <code>EasyBCD</code>:</li>
</ul>
<p><img src="easybcd.png" alt=""></p>
<ul>
<li>进行配置，内容如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># NeoSmart NeoGrub Bootloader Configuration File</div><div class="line">#</div><div class="line"># This is the NeoGrub configuration file, and should be located at C:\NST\menu.lst</div><div class="line"># Please see the EasyBCD Documentation for information on how to create/modify entries:</div><div class="line"># http://neosmart.net/wiki/display/EBCD/</div><div class="line"></div><div class="line">title Install Ubuntu</div><div class="line">root (hd0,0)</div><div class="line">kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.3-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8</div><div class="line">initrd (hd0,0)/initrd.lz</div><div class="line">title reboot</div><div class="line">reboot</div><div class="line">title halt</div><div class="line">halt</div></pre></td></tr></table></figure>
<ul>
<li>解压 <code>ubuntu.iso</code> 提取两个文件:</li>
</ul>
<p><img src="uncompress_ubuntu_iso.png" alt=""></p>
<ul>
<li>将三个重要文件放到 <code>C</code> 盘目录:</li>
</ul>
<p><img src="c_files.png" alt=""></p>
<ul>
<li>重新启动，进入 <code>Ubuntu 引导启动加载</code>，进行安装</li>
</ul>
<hr>
<p>参考:</p>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_4618a6280102vhwy.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4618a6280102vhwy.html</a></li>
<li><a href="https://zhidao.baidu.com/question/512380327.html" target="_blank" rel="external">https://zhidao.baidu.com/question/512380327.html</a></li>
</ul>
<h3 id="openssh-server"><a href="#openssh-server" class="headerlink" title="openssh-server"></a>openssh-server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install openssh-server</div><div class="line">sudo ufw allow 22</div><div class="line">sudo iptables -L</div><div class="line">sudo iptables -A INPUT -p tcp --dport ssh -j ACCEPT</div></pre></td></tr></table></figure>
<h3 id="Windows-行结尾符转为-UNIX-结尾符"><a href="#Windows-行结尾符转为-UNIX-结尾符" class="headerlink" title="Windows 行结尾符转为 UNIX 结尾符"></a>Windows 行结尾符转为 UNIX 结尾符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt install dos2unix</div><div class="line"><span class="comment"># Replace all CR from all lines, in place operation.</span></div><div class="line">dos2unix file.txt</div><div class="line"><span class="comment"># To save the output in a different file</span></div><div class="line">dos2unix -n file.txt output.txt</div></pre></td></tr></table></figure>
<h3 id="Ubuntu-引导项重新扫描"><a href="#Ubuntu-引导项重新扫描" class="headerlink" title="Ubuntu 引导项重新扫描"></a>Ubuntu 引导项重新扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-grub</div></pre></td></tr></table></figure>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>不要 <code>.git</code> 文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zip -r bitvolution.zip bitvolution -x \*.git\*</div></pre></td></tr></table></figure>
<h3 id="添加新的用户"><a href="#添加新的用户" class="headerlink" title="添加新的用户"></a>添加新的用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建用户</span></div><div class="line">sudo useradd -d /home/tom -m tom -s /bin/bash</div><div class="line"></div><div class="line"><span class="comment"># 设置密码</span></div><div class="line">sudo passwd tom</div><div class="line"></div><div class="line"><span class="comment"># 添加 sudo 权限</span></div><div class="line">sudo adduser tom sudo</div></pre></td></tr></table></figure>
<h3 id="Linux-上安装虚拟机"><a href="#Linux-上安装虚拟机" class="headerlink" title="Linux 上安装虚拟机"></a>Linux 上安装虚拟机</h3><p>应该搜索的是 <code>virtualbox</code> 而不是 <code>vmware</code>，另外也需要 <a href="https://www.askvg.com/download-free-windows-xp-vista-and-windows-7-vhd-image-files-for-microsoft-virtual-pc/" target="_blank" rel="external"><code>Windows 32bit vhd</code></a> 文件才行</p>
<h3 id="Linux-修改组"><a href="#Linux-修改组" class="headerlink" title="Linux 修改组"></a>Linux 修改组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 添加一个组 zk</span></div><div class="line">sudo groupadd zk</div><div class="line"><span class="comment"># 组下面添加一个用户</span></div><div class="line">sudo usermod -a -G zk zk</div><div class="line"><span class="comment"># 改变文件组</span></div><div class="line">chgrp zk sample_file.txt </div><div class="line">chgrp -R zk sample_folder/</div><div class="line"><span class="comment"># 查看一个用户属于哪些组</span></div><div class="line">groups zk</div><div class="line"><span class="comment"># 查看 primary group</span></div><div class="line">id -g zk</div><div class="line"><span class="comment"># 改变用户分组</span></div><div class="line">usermod -g primaryGroupName zk</div></pre></td></tr></table></figure>
<p><img src="Selection_001.png" alt=""></p>
<h3 id="循环所有文件"><a href="#循环所有文件" class="headerlink" title="循环所有文件"></a>循环所有文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> `basename <span class="variable">$file</span>`<span class="string">"\t"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h3 id="合并所有文件"><a href="#合并所有文件" class="headerlink" title="合并所有文件"></a>合并所有文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat * &gt; merged-file</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.tutorialspoint.com/unix/unix-regular-expressions.htm" target="_blank" rel="external">Unix - Regular Expressions with SED</a></li>
<li><a href="http://www.linfo.org/echo.html" target="_blank" rel="external">The echo Command</a></li>
<li><a href="http://www.cs.toronto.edu/~krueger/csc209h/tut/line-endings.html" target="_blank" rel="external">DOS vs. Unix Line Endings</a></li>
</ul>






</body>
</html>
