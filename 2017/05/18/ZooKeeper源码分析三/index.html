<html>
<head>
	
	<title>ZooKeeper源码分析(三) - 会话管理</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/>
    

</head>

<body>

<h2 id="ZooKeeper源码分析-三-会话管理"><a href="#ZooKeeper源码分析-三-会话管理" class="headerlink" title="ZooKeeper源码分析(三) - 会话管理"></a>ZooKeeper源码分析(三) - 会话管理</h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><p>当有新的连接请求时，<code>NIOServerCnxn</code> 会检查 <code>ConnectRequest</code> 携带的 <code>sessionId</code>。如果为 0，那么 <code>ZooKeeper</code> 会为这个连接创建一个新的 <code>Session</code>，而在 <code>Session</code> 确定为有效之前，这个时候不会尝试从客户端读取任何数据:</p>
<p><img src="17-05-18-14:45:33_931_278.png" alt=""></p>
<p><code>ZooKeeper</code> 中的会话机制由 <code>SessionTrackerImpl</code> 来实现和管理。<code>SessionTrackerImpl</code> 继承了 <code>Thread</code> 线程，在其构造函数内部，默认调用了 <code>start</code> 方法。当 <code>ZooKeeperServer</code> 实例化 <code>SessionTrackerImpl</code> 就会作为一个单独的线程运行起来:</p>
<p><img src="17-05-18-14:56:52_955_361.png" alt=""></p>
<p>我们看一下 <code>Session</code> 是如何被创建的:</p>
<p><img src="17-05-18-15:00:11_751_192.png" alt=""></p>
<p><code>ZooKeeper</code> 选用系统当前时间，然后右移 24 位作为会话的起始 Id，之后，每多一个连接，这个起始会话 Id，就会加 1，以此分配给不同的连接。创建完成的 <code>Session</code> 会以 <code>sessionId</code> 作为键，<code>session</code> 最为值存放到 <code>sessionsById</code> 这个字典中。</p>
<p><img src="17-05-18-15:06:52_825_299.png" alt=""></p>
<h3 id="重新打开会话"><a href="#重新打开会话" class="headerlink" title="重新打开会话"></a>重新打开会话</h3><p>什么情况下客户端发送过来的 <code>sessionId</code> 不是为 0 呢，答案就是之前客户端连接过某服务器 (假设为 A)，从 A 服务器成功分配过 <code>sessionId</code>，但是 A 服务器之后由于某种原因退出了，这个时候客户端会重新选择新的服务器进行连接，然后拿着这个从 A 服务器分配的 <code>sessionId</code> 继续连接 B 服务器，这个时候 B 服务器会检测到 <code>sessionId</code> 不为 0，<code>ZooKeeperServer</code> 会尝试重新打开会话:</p>
<p><img src="17-05-18-15:17:09_926_277.png" alt=""></p>
<p>这个时候，<code>ZooKeeperServer</code> 会对来访者的这个会话标识进行认证，让它证明自己是合法连接，怎么证明呢，就是使用 <code>ConnectRequest</code> 传入的 16 字节的 passwd 来认证:</p>
<p><img src="17-05-18-15:24:16_740_275.png" alt=""></p>
<p>如果之前创建调用 <code>createSession</code> 成功过的话，那么 <code>passwd</code> 会随着 <code>ConnectResponse</code> 回传到客户端，客户端然后再更新自己本地的 <code>sessionPasswd</code>。其中 <code>passwd</code> 与 <code>sessionId</code> 息息相关，具体生成规则如下:</p>
<p><img src="17-05-18-15:46:17_657_216.png" alt=""></p>
<p>现在 <code>ZooKeeperServer</code> 要对这个客户端携带的 <code>passwd</code> 进行有效性检测:</p>
<p><img src="17-05-18-15:48:31_772_126.png" alt=""></p>
<p>如果检测失败，那么直接调用 <code>finishSessionInit(false)</code> 通知客户端认证失败；如果成功，那么会调用 <code>revalidateSession</code> 来刷新 <code>session</code>:</p>
<p><img src="17-05-18-15:56:37_878_191.png" alt=""></p>
<h3 id="会话超时"><a href="#会话超时" class="headerlink" title="会话超时"></a>会话超时</h3><p>在创建会话的时候，我们注意到其通过 <code>new Session(id, 0)</code> 来创建的会话，参数 <code>0</code> 代表的是这个新建会话的 <code>tickTime</code> 为 0。<code>tickTime</code> 代表的是一个会话能够维持多长时间，如果其超过指定的过期时间 <code>expireTime</code>，那么就要删除掉这个会话。比如设定的会话的持续时间为 10 分钟，随着时间的增加，<code>expireTime</code> 也在一直增加，逐渐逼近 10 分钟，当超过以后，就要删除这个会话，认为这个会话过期了，失效了。</p>
<p><img src="17-05-26-20:45:52_917_255.png" alt=""></p>
<p>在 <code>SessionTrackerImpl</code> 的内部，<code>ZooKeeper</code> 按照会话的 <code>tickTime</code> 的不同，来将不同的会话放入相同的 <code>SessionSet</code> 中。如图所示，左侧维持的都是能够持续 5 分钟的会话，中间维持的都是能够持续 10 分钟的…… 当超时之后，从相应的 <code>SessionSet</code> 中移除这个会话，并设置新的 <code>tickTime</code> 来放入新的 <code>SessionSet</code> 中。注意，不存在 <code>tickTime</code> 为 0 的 <code>SessionSet</code>，如果为 0 则代表新创建成功。</p>
<p><img src="17-05-26-21:21:04_710_241.png" alt=""></p>
<p>上述源码如下:</p>
<p><img src="17-05-26-21:44:36_873_468.png" alt=""></p>
<p>当然在源码的实现中，<code>tickTime</code> 存储的并不是像 5 分钟，10 分钟这样的时间间隔，而是一个时间点，即它能维持的会话有效的时间点。时间在不停地向前行走，那么旧的 <code>SessionSet</code> 被逐渐销毁，新的 <code>SessionSet</code> 被创建出来:</p>
<p><img src="17-05-26-22:25:19_702_287.png" alt=""></p>
<p>销毁 <code>SessionSet</code> 的过程是在 <code>run</code> 方法中做的:</p>
<p><img src="17-05-26-22:28:50_704_508.png" alt=""></p>
<p>我们注意到，当在销毁 <code>SessionSet</code> 的时候，其会对位于 <code>SessionSet</code> 中的所有会话做两件事:</p>
<ol>
<li>从 <code>sessionsById</code> 中移除这个会话</li>
<li>使用 <code>expirer</code> 通知这个会话过期</li>
</ol>
<p><code>expire</code> 方法的实现在是写在 <code>ZooKeeperServer</code> 中的，<code>ZooKeeperServer</code> 实现了 <code>SessionExpirer</code> 接口，并在创建 <code>SessionTracker</code> 实现的时候，将 <code>ZooKeeperServer</code> 本身作为构造器参数传入了进来，因此我们查看位于 <code>ZooKeeperServer</code> 内部的 <code>expire</code> 方法即可:</p>
<p><img src="17-05-26-22:52:26_867_301.png" alt=""></p>
<p>哦… 原来当移除 <code>SessionSet</code> 的时候，还对每一个会话都提交了一个 <code>OpCode.closeSession</code> 请求啊。另外这个地方，还应该注意的是 <code>submitRequest</code> 方法传递的 <code>cnxn</code> 参数为 <code>null</code>，下面会用到这个的。</p>
<p>当提交请求后，<code>OpCode.closeSession</code> 请求沿着调用链:</p>
<ol>
<li><code>PreRequestProcessor</code></li>
<li><code>SyncRequestProcessor</code></li>
<li><code>FinalRequestProcessor</code></li>
</ol>
<p>向前行进，在 <code>PreRequestProcessor</code> 中创建了一个 <code>TxnHeader</code> 对象对参数等进行一些封装。再交由 <code>FinalRequestProcessor</code> 进行处理 ( <code>SyncRequestProcessor</code> 对其执行逻辑无干扰，我们这里先跳过这个处理器 ):</p>
<p><img src="17-05-27-11:11:33_834_360.png" alt=""></p>
<p><code>FinalRequestProcessor</code> 当检测到其类型为 <code>OpCode.closeSession</code> 的时候，会调用 <code>removeSession</code> 来将这个会话从 <code>ZooKeeperServer</code> 中删除。<code>removeSession</code> 方法的具体实现如下:</p>
<p><img src="17-05-27-11:14:45_703_278.png" alt=""></p>
<p>回到刚才，我们知道提交请求的时候，传递的参数 <code>cnxn</code> 为 <code>null</code>，那么上面你可以看到 <code>FinalRequestProcessor</code> 在检测到 <code>cnxn</code> 为 <code>null</code> 的时候，会直接 <code>return</code>。也就是说 <code>OpCode.closeSession</code> 的响应并不会发送给客户端。一般而言，当行走到 <code>closeSesison</code> 的时候，这也就意味着客户端出现了问题，再下一节我们会看到客户端和服务器会不停的依靠心跳检测来不停地激活这个会话，当服务器检测到某个会话超时之后，即没有即使地从旧的 <code>SessionSet</code> 中迁移到新的 <code>SessionSet</code> 中去，那么说明服务器已经没有收到客户端发来的心跳包了，因此会删除这个会话。</p>
<h3 id="会话激活"><a href="#会话激活" class="headerlink" title="会话激活"></a>会话激活</h3><p>时间的车轮滚滚向前，永不停止。在上一小节我们提到，<code>SessionTrackerImpl</code> 内部维持了一个 <code>while (running)</code> 循环，通过每隔一段时间向前行走一个指定的间隔 <code>expirationInterval</code>, 进而一个一个把旧的 <code>SessionSet</code> 给删除掉。我们也提到 <code>ZooKeeperServer</code> 通过 <code>touchSession</code> 方法进行会话迁移，及时地把一些存活的会话不停地转移到一个新的 <code>SessionSet</code> 中去，进而维持会话的有效性。那么是谁在调用 <code>touchSession</code> 内？谁在不停的迁移整个会话呢？答案就在心跳检测不停的 <code>ping, ping, ping</code> 中…</p>
<p>回到 <code>NIOServerCnxn</code> 类，当其读到一个请求的时候，其会立即将这个请求 <code>submit</code> 出去 (除了 <code>OpCode.auth</code> 请求)，如下代码所示:</p>
<p><img src="17-05-27-16:26:22_811_256.png" alt=""></p>
<p>我们再往下看 <code>submitRequest</code> 方法:</p>
<p><img src="17-05-27-16:28:55_908_490.png" alt=""></p>
<p>我们会发现在每次 <code>submitRequest</code> 的时候，都会去调用 <code>touchSession</code> 方法，看这个会话是否需要迁移，客户端发来的每一种不同的操作类型 (除 <code>OpCode.auth</code> 类型) ，例如 <code>ping, setData, getData</code> 等都会调用 <code>touchSession</code> 方法。我们将 <code>touchSession</code> 称之为会话激活，也即会话迁移。这里最重要的就是 <code>ping</code> 请求的提交。我们在上一章中提到过，客户端会不停的往服务器发送心跳包，于此同时，客户端会间隔性的激活这个会话。只要收到心跳包不止，服务器就始终认为这个会话存在，始终认为其仍然有效。那些没有及时发送、或者因为网络原因断掉的客户端只能因为没有进行会话迁移而被服务器移除会话请单，可见维持好网络的畅通无阻，尽量保证延时时间的间隔要小是一件非常重要的事情。</p>






</body>
</html>
