<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>IO</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="IO-Input-和-Output"><a href="#IO-Input-和-Output" class="headerlink" title="IO - Input 和 Output"></a>IO - Input 和 Output</h2><h3 id="5-种-I-O-模型"><a href="#5-种-I-O-模型" class="headerlink" title="5 种 I/O 模型"></a>5 种 I/O 模型</h3><ul>
<li>阻塞式 I/O</li>
</ul>
<p><img src="17-05-06-23_04_13_785_388.png" alt=""></p>
<p>可能阻塞的套接字调用可分为如下几类:</p>
<p>输入操作: <code>read、readv、recv、recvfrom、recvmsg</code> 5 个函数<br>输出操作: <code>write、writev、send、sendto、sendmsg</code> 5 个函数<br>接受外来连接: <code>accept</code> 函数<br>发出外来连接: <code>connect</code> 函数</p>
<p>标准访问文的方式: 当应用程序调用 <code>read()</code> 接口时，操作系统检查在内核的告诉缓存中有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回。写入的时候，从用户地址空间复制到内核地址空间的缓存中，什么时候写到磁盘由操作系统决定。</p>
<p><img src="17-05-17-20_39_07_411_271.png" alt=""></p>
<p>直接 I/O 的方式: 应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，减少一次从内核缓冲区到用户数据缓存的数据复制。这种访问文件的方式通常是在对数据的缓存管理由应用程序的数据库管理系统中。</p>
<p><img src="17-05-17-20_43_00_447_290.png" alt=""></p>
<ul>
<li>非阻塞式 I/O</li>
</ul>
<p><img src="17-05-08-21_05_13_734_355.png" alt=""></p>
<p>设置非阻塞 I/O:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = fcntl(STDOUT_FILENO, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(STDOUT_FILENO, F_SETFL, val | O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<ul>
<li>I/O 复用 (<code>select</code> 和 <code>poll</code>)</li>
</ul>
<p><img src="17-05-08-21_21_11_717_340.png" alt=""></p>
<ul>
<li>信号驱动式 I/O (<code>SIGIO</code>)</li>
</ul>
<p><img src="17-05-08-21_23_49_760_365.png" alt=""></p>
<ul>
<li>异步 I/O (POSIX 的 <code>aio_</code> 系列函数)</li>
</ul>
<p>信号驱动式 I/O 是由内核通知我们<strong>何时可以启动</strong>一个 I/O 操作，而异步 I/O 模型是由内核通知我们<strong>何时完成</strong>。</p>
<p><img src="17-05-08-21_26_37_741_386.png" alt=""></p>
<p>5 种 I/O 模型比较:</p>
<p><img src="17-05-08-21_29_37_796_397.png" alt=""></p>
<p><code>select</code> 指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它，函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timespec *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们可以在下列情况收到内核通知:</p>
<ul>
<li>集合 {1, 4, 5} 中的任何描述符准备好读</li>
<li>集合 {2, 7} 中的任何描述符准备好写</li>
<li>集合 {1, 4} 中的任何描述符有异常条件待处理</li>
<li>已经历了 10.2 秒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fd_set rset; <span class="comment">// 比特位</span></span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_SET(<span class="number">1</span>, &amp;rset);</span><br><span class="line">FD_SET(<span class="number">5</span>, &amp;rset);</span><br><span class="line"></span><br><span class="line">select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">    <span class="comment">// socket is readable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>select</code> 最大缺陷就是单个进程所打开的文件描述符是有一定限制的，它由 <strong>FD_SETSIZE</strong> 设置，默认值是 1024。可以选择修改这个宏然后重新编译内核，不过这会带来网络效率的下降。</p>
<p><code>pselect</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pselect</code> 是能够处理信号阻塞并提供更高事件分辨率的 <code>select</code> 的增强版本。</p>
<p><code>poll</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>epoll</code> 函数:</p>
<ul>
<li>一个进程打开的 <code>socket</code> 描述符不受限制 (仅受限于操作系统的最大文件句柄数 <code>cat /proc/sys/fs/file-max</code> )</li>
<li>I/O 效率不会随着文件描述符数目的增加而线性下降，<code>select/poll</code> 每次都会线性扫描全部的集合</li>
<li>把内核和用户空间 <code>mmap</code> 到同一块内存来加速这两者之间的消息传递</li>
</ul>
<h3 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h3><p>在 UNIX 系统上大多数 I/O 只需要通过这五个函数完成: <code>open, read, write, lseek, and close</code>。相对于标准 I/O，我们这里讨论的都是 <strong>unbuffered I/O (每一次 <code>read</code> 和 <code>write</code> 都会产生一个系统调用)</strong>。</p>
<p>通常，UNIX 系统 shell 把文件描述符 0 与进程的标准输入关联，文件描述符 1 与标准输出关联，文件描述符 2 与标准错误关联。</p>
<p>文件描述符的最大限制:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max <span class="comment"># 599216</span></span><br></pre></td></tr></table></figure>
<p>文件描述符的当前数量:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-nr</span><br></pre></td></tr></table></figure>
<p>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>; <span class="comment">// 改变已经打开文件的属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 成功: 返回 0</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence); <span class="comment">// 成功: 返回新的文件偏移量</span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); <span class="comment">// 成功: 读到的字节数; 文件末尾: 返回 0</span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); <span class="comment">// 成功: 已写的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 复制一个现有的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 将所有修改的块缓冲区排入写队列，然后返回，并不等待磁盘操作结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 等待磁盘写操作结束</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>; <span class="comment">// I/O 操作的杂物箱，一般用于中断 I/O</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>dup(fd)</code> 等效于 <code>fcntl(fd, F_DUPFD, 0)</code>; <code>fcntl</code> 函数可以:</p>
<ul>
<li>复制一个已有的文件描述符</li>
<li>获取/设置文件描述符标志</li>
<li>获取/设置文件状态标志</li>
<li>获取/设置异步 I/O 所有权</li>
<li>获取/设置记录锁</li>
</ul>
<h3 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h3><blockquote>
<p>文件 I/O 围绕文件描述符，标准 I/O 围绕流</p>
</blockquote>
<h4 id="Binary-I-O"><a href="#Binary-I-O" class="headerlink" title="Binary I/O"></a>Binary I/O</h4><p>一次读或写一个 <strong>structure</strong>，下述两个函数提供了二进制 I/O:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj,</span><br><span class="line">             FILE *<span class="keyword">restrict</span> fp);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj,</span><br><span class="line">              FILE *<span class="keyword">restrict</span> fp);</span><br></pre></td></tr></table></figure>
<p>我们可以这样操作一个结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> count;</span><br><span class="line">    <span class="keyword">long</span> total;</span><br><span class="line">    <span class="keyword">char</span> name[NAMESIZE];</span><br><span class="line">&#125; item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;item, <span class="keyword">sizeof</span>(item), <span class="number">1</span>, fp) != <span class="number">1</span>)</span><br><span class="line">    err_sys(<span class="string">"fwrite error"</span>);</span><br></pre></td></tr></table></figure>
<p>基于字节的 Java I/O 操作接口:</p>
<p><img src="file_io.jpg" alt=""></p>
<p>基于字符的 Java I/O 操作接口:</p>
<p><img src="reader_and_writer_class_in_java.jpg" alt=""></p>
<p>字节与字符的转化接口: <code>InputStreamReader</code> 派生出 <code>FileReader</code></p>
<h3 id="高级-I-O"><a href="#高级-I-O" class="headerlink" title="高级 I/O"></a>高级 I/O</h3><p>涵盖了一些 <strong>非阻塞 I/O、记录锁、I/O 多路复用 (<code>select</code> 和 <code>poll</code>)、异步 I/O、<code>readv</code> 和 <code>writev</code>、内存映射 I/O (mmap)</strong></p>
<h4 id="readv-和-writev"><a href="#readv-和-writev" class="headerlink" title="readv 和 writev"></a><code>readv</code> 和 <code>writev</code></h4><p>这两个函数可以让我们从多个缓冲区里面读和写，这些操作称之为 <strong>scatter read</strong> 和 <strong>gather write</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *iov_base; <span class="comment">/* starting address of buffer */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/* size of buffer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Memory-Mapped-I-O-内存映射-I-O"><a href="#Memory-Mapped-I-O-内存映射-I-O" class="headerlink" title="Memory-Mapped I/O 内存映射 I/O"></a>Memory-Mapped I/O 内存映射 I/O</h4><p>Memory-Mapped I/O 让我们可以将位于磁盘上的一个文件映射到内存上的一个缓冲区中，当我们从缓冲区中读，我们就是从文件中读；当我们向缓冲区写，对象的文件也被写入了。Memory-Mapped I/O 已经被用于 virtual memory systems 很多年了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off )</span></span>;</span><br></pre></td></tr></table></figure>
<p>内存映射文件:</p>
<p><img src="17-05-08-22_09_32_629_472.png" alt=""></p>
<h3 id="Client-Server-IO"><a href="#Client-Server-IO" class="headerlink" title="Client/Server IO"></a>Client/Server IO</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p><img src="17-05-08-22_45_10_757_283.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        socket = server.accept();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Request(socket)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">        server.close();</span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="伪异步-IO"><a href="#伪异步-IO" class="headerlink" title="伪异步 IO"></a>伪异步 IO</h4><p><img src="17-05-08-22_44_31_784_278.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TimeServerHandlerExcutePool singleExecutor = <span class="keyword">new</span> TimeServerHandlerExecutePool(<span class="number">50</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    socket = server.accept();</span><br><span class="line">    singleExecutor.execute(<span class="keyword">new</span> TimeServerHandler(socket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当对 <code>Socket</code> 的输入流进行读取的操作的时候，它会一直阻塞下去，直到发生三种事件:</p>
<ul>
<li>有数据可读</li>
<li>可用数据已经读取完毕</li>
<li>发生空指针或 I/O 异常</li>
</ul>
<p>这意味着当对方发送请求或者应答消息比较缓慢，或者网络传输缓慢时，读取输入流的一方的通信线程将被长时间阻塞，如果对方要 60s 才能够将数据发送完成，读取一方的 I/O 线程也将会被同步阻塞 60s，在此期间，其他接入消息只能在消息队列中排队。当调用 <code>OutputStream</code> 的 <code>write</code> 方法时，也面临同样的问题。当消息的接收方处理缓慢的时候，将不能及时地从 TCP 缓冲区中读取数据，这将会导致发送方的 TCP window size 不断减小，直到为 0，双方处于 Keep-Alive 状态，消息发送方将不能再向 TCP 缓冲区写入消息，这时如果采用的是同步阻塞 I/O，<code>write</code> 操作将会被无期限阻塞，直到 TCP window size 大于 0 或者发生 I/O 异常。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MultiplexerTimeServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        servChannel = ServerSocketChannel.open();</span><br><span class="line">        servChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        servChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">1024</span>);</span><br><span class="line">        servChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector.select(<span class="number">1000</span>);</span><br><span class="line">            Set&lt;SelectonKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码未完待续 ...</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>SocketChannel</code> 是异步非阻塞的，它并不保证一次能够把需要发送的字节数组发送完，此时会出现 “写半包” 问题。我们需要注册写操作，不断轮询 <code>Selector</code> 将没有发送完的 <code>ByteBuffer</code> 发送完毕，然后可以通过 <code>ByteBuffer</code> 的 <code>hasRemain()</code> 方法判断消息是否发送完成。</p>
<p>相比于 BIO，NIO 的一个明显的好处是不需要为每一个 <code>Socket</code> 分配一个线程，而可以在一个线程中处理多个 <code>Socket</code> 套接字相关的工作。</p>
<p><img src="reactordiagram.png" alt=""></p>
<p>通过 <code>Channel</code> 对象获取的 I/O 数据首先要经过操作系统的 Socket 缓冲区，再将数据复制到 <code>Buffer</code> 中，这个操作系统缓冲区就是底层的 TCP 所关联的 RecvQ 或者 SendQ 队列，从操作系统缓冲区到用户缓冲区复制数据比较消耗性能，<code>Buffer</code> 还提供了另外一种直接操作系统缓冲区的方式，即 <code>ByteBuffer.allocateDirector(size)</code>，这个方法返回的 <code>DirectByteBuffer</code> 就是与底层存储空间关联的缓冲区，它通过 Native 代码操作非 JVM 堆的内存空间。每次创建或者释放的时候都会调用一次 <code>System.gc()</code>。一般在数据量比较大、生命周期比较长的情况下比较合适。</p>
<p><code>FileChannel.transferXXX</code> 与传统的访问文件方式相比可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动:</p>
<p><img src="17-05-17-20_54_48_510_282.png" alt=""></p>
<p><code>FileChannel.map</code> 将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时，将直接操作这个文件数据，这种方式省去了数据从内核空间向用户空间复制的损耗。这种方式适合对大文件的只读性操作，如大文件的 MD5 校验。</p>
<h4 id="AIO-编程"><a href="#AIO-编程" class="headerlink" title="AIO 编程"></a>AIO 编程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTimeServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    CountDownLatch latch;</span><br><span class="line">    AsynchronousServerSocketChannel asynchronousServerSocketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTimeServerHandler</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">            asynchronousServerSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        latch = <span class="keyword">new</span> CountDownLatch();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        asynchronousServerSocketChannel.accept(<span class="keyword">this</span>, <span class="keyword">new</span> AcceptCompletionHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousServerSocketChannel result, AcceptCompletionHandler attachment)</span> </span>&#123;</span><br><span class="line">        attachment.asynchronousServerSocketChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码未完继续 ...</span></span><br></pre></td></tr></table></figure>
<h4 id="I-O-调优"><a href="#I-O-调优" class="headerlink" title="I/O 调优"></a>I/O 调优</h4><p>性能检测: 通过压力测试，看系统 I/O wait 指标是否异常。例如，测试机器有 4 个 CPU，那么理想的 I/O wait 参数不应该超过 25%，如果超过，则 I/O 很可能成为应用程序的性能瓶颈。在 Linux 下通过 <code>iostat</code> 命令查看。通常我们还会查看另外一个参数，就是 IOPS，即要查看应用程序需要的最低的 IOPS 是多少，磁盘的 IOPS 能不能达到要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(磁盘数 * 每块磁盘的 IOPS) / (磁盘块的吞吐量 + RAID 因子 * 磁盘写的吞吐量) = IOPS</span><br></pre></td></tr></table></figure>
<p>TCP 连接查看主机可以使用的端口范围:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_local_port_range</span><br></pre></td></tr></table></figure>
<p><img src="17-05-17-21_11_26_708_54.png" alt=""></p>
<p>可用端口数量: 60999 - 32768 = 28231，如果这个值偏小，则遇到大量并发请求时就会成为性能瓶颈。</p>
<table>
<thead>
<tr>
<th>网络调优参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>echo &quot;1024 65535&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range</code></td>
<td>设置端口可用范围</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</code></td>
<td>设置 time_wait 连接重用</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</code></td>
<td>设置快速回收 time_wait 连接</td>
</tr>
<tr>
<td><code>echo 180000 &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets</code></td>
<td>设置最大 time_wait 连接长度</td>
</tr>
<tr>
<td><code>echo 0 &gt; /proc/sys/net/ipv4/tcp_timestamps</code></td>
<td>表示是否启用以一种比超时重发更精确的方法来启用对 RTT 的计算</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_window_scaling</code></td>
<td>设置 TCP/IP 会话的滑动窗口大小是否可变</td>
</tr>
<tr>
<td><code>echo 20000 &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog</code></td>
<td>设置最大等待处于客户端还没有应答回来的连接数</td>
</tr>
<tr>
<td><code>echo 10000 &gt; /proc/sys/net/core/somaxconn</code></td>
<td>设置每一个处于监听状态的端口的监听队列的长度</td>
</tr>
<tr>
<td><code>echo 10000 &gt; /proc/sys/net/core/netdev_max_backlog</code></td>
<td>设置最大等待 CPU 处理的包的数目</td>
</tr>
<tr>
<td><code>echo 2000000 &gt; /proc/sys/fs/file-max</code></td>
<td>设置最大打开的文件数</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>以上设置都是临时性的，系统重新启动后就会丢失。</p>
<h3 id="Buffered-I-O"><a href="#Buffered-I-O" class="headerlink" title="Buffered I/O"></a>Buffered I/O</h3><p><code>BufferedOutputStream</code> 经常被用在<strong>避免频繁操作磁盘和网络</strong>的地方(<a href="https://stackoverflow.com/questions/6821887/bufferedoutputstream-vs-bytearrayoutputstream" target="_blank" rel="noopener">参考</a>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(zip);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">oos.writeObject(prices);</span><br></pre></td></tr></table></figure>
<p><code>ByteArrayOutputStream</code> <strong>只是在内存里面</strong>做一层缓冲:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">GZIPOutputStream zip = <span class="keyword">new</span> GZIPOutputStream(baos);</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/" target="_blank" rel="noopener">《Advanced Programming in the UNIX》</a></li>
<li><a href="https://www.amazon.com/Unix-Network-Programming-Sockets-Networking/dp/0131411551" target="_blank" rel="noopener">《Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)》</a></li>
<li><a href="https://item.jd.com/11681556.html" target="_blank" rel="noopener">《Netty 权威指南》</a></li>
<li><a href="https://item.jd.com/11449803.html" target="_blank" rel="noopener">《大型网站系统与 Java 中间件实践》</a></li>
<li><a href="https://unix.stackexchange.com/questions/36841/why-is-number-of-open-files-limited-in-linux" target="_blank" rel="noopener">Why is number of open files limited in Linux?</a></li>
<li><a href="https://item.jd.com/11520670.html" target="_blank" rel="noopener">《深入分析 Java Web 内幕》</a></li>
<li><a href="https://item.jd.com/11896988.html" target="_blank" rel="noopener">《Java Performance: The Definitive Guide》</a></li>
</ul>






<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
