<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IO | 代码人生</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IO - Input 和 Output5 种 I/O 模型 阻塞式 I/O   可能阻塞的套接字调用可分为如下几类:  输入操作: read、readv、recv、recvfrom、recvmsg 5 个函数 输出操作: write、writev、send、sendto、sendmsg 5 个函数 接受外来连接: accept 函数 发出外来连接: connect 函数  标准访问文的方式: 当应">
<meta property="og:type" content="article">
<meta property="og:title" content="IO">
<meta property="og:url" content="http://blog.kunzhao.org/2017/05/06/IO/index.html">
<meta property="og:site_name" content="代码人生">
<meta property="og:description" content="IO - Input 和 Output5 种 I/O 模型 阻塞式 I/O   可能阻塞的套接字调用可分为如下几类:  输入操作: read、readv、recv、recvfrom、recvmsg 5 个函数 输出操作: write、writev、send、sendto、sendmsg 5 个函数 接受外来连接: accept 函数 发出外来连接: connect 函数  标准访问文的方式: 当应">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-06-23_04_13_785_388.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-17-20_39_07_411_271.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-17-20_43_00_447_290.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-08-21_05_13_734_355.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-08-21_21_11_717_340.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-08-21_23_49_760_365.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-08-21_26_37_741_386.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-08-21_29_37_796_397.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/file_io.jpg">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/reader_and_writer_class_in_java.jpg">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-08-22_09_32_629_472.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-08-22_45_10_757_283.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-08-22_44_31_784_278.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/reactordiagram.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-17-20_54_48_510_282.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-17-21_11_26_708_54.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/2017_12_04_22_40_07.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/2017_12_05_15_05_04.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/2017_12_05_15_05_35.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/2017_12_05_15_05_54.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/2017_12_05_17_54_09.png">
<meta property="og:image" content="http://blog.kunzhao.org/2017/05/06/IO/2017_12_05_21_40_53.png">
<meta property="og:updated_time" content="2017-12-30T09:11:08.669Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IO">
<meta name="twitter:description" content="IO - Input 和 Output5 种 I/O 模型 阻塞式 I/O   可能阻塞的套接字调用可分为如下几类:  输入操作: read、readv、recv、recvfrom、recvmsg 5 个函数 输出操作: write、writev、send、sendto、sendmsg 5 个函数 接受外来连接: accept 函数 发出外来连接: connect 函数  标准访问文的方式: 当应">
<meta name="twitter:image" content="http://blog.kunzhao.org/2017/05/06/IO/17-05-06-23_04_13_785_388.png">
  
    <link rel="alternate" href="/atom.xml" title="代码人生" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.kunzhao.org"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">首页</a>
        
          <a class="main-nav-link" href="/blog/archives">归档</a>
        
          <a class="main-nav-link" href="/blog/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">代码人生</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-IO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/06/IO/" class="article-date">
  <time datetime="2017-05-06T14:14:05.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      IO
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="IO-Input-和-Output"><a href="#IO-Input-和-Output" class="headerlink" title="IO - Input 和 Output"></a>IO - Input 和 Output</h2><h3 id="5-种-I-O-模型"><a href="#5-种-I-O-模型" class="headerlink" title="5 种 I/O 模型"></a>5 种 I/O 模型</h3><ul>
<li>阻塞式 I/O</li>
</ul>
<p><img src="17-05-06-23_04_13_785_388.png" alt=""></p>
<p>可能阻塞的套接字调用可分为如下几类:</p>
<ul>
<li>输入操作: <code>read、readv、recv、recvfrom、recvmsg</code> 5 个函数</li>
<li>输出操作: <code>write、writev、send、sendto、sendmsg</code> 5 个函数</li>
<li>接受外来连接: <code>accept</code> 函数</li>
<li>发出外来连接: <code>connect</code> 函数</li>
</ul>
<p>标准访问文的方式: 当应用程序调用 <code>read()</code> 接口时，操作系统检查在内核的告诉缓存中有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回。写入的时候，从用户地址空间复制到内核地址空间的缓存中，什么时候写到磁盘由操作系统决定。</p>
<p><img src="17-05-17-20_39_07_411_271.png" alt=""></p>
<p>直接 I/O 的方式: 应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，减少一次从内核缓冲区到用户数据缓存的数据复制。这种访问文件的方式通常是在对数据的缓存管理由应用程序的数据库管理系统中。</p>
<p><img src="17-05-17-20_43_00_447_290.png" alt=""></p>
<ul>
<li>非阻塞式 I/O</li>
</ul>
<p><img src="17-05-08-21_05_13_734_355.png" alt=""></p>
<p>设置非阻塞 I/O:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> val = fcntl(STDOUT_FILENO, F_GETFL, <span class="number">0</span>);</div><div class="line">fcntl(STDOUT_FILENO, F_SETFL, val | O_NONBLOCK);</div></pre></td></tr></table></figure>
<ul>
<li>I/O 复用 (<code>select</code> 和 <code>poll</code>)</li>
</ul>
<p><img src="17-05-08-21_21_11_717_340.png" alt=""></p>
<ul>
<li>信号驱动式 I/O (<code>SIGIO</code>)</li>
</ul>
<p><img src="17-05-08-21_23_49_760_365.png" alt=""></p>
<ul>
<li>异步 I/O (POSIX 的 <code>aio_</code> 系列函数)</li>
</ul>
<p>信号驱动式 I/O 是由内核通知我们<strong>何时可以启动</strong>一个 I/O 操作，而异步 I/O 模型是由内核通知我们<strong>何时完成</strong>。</p>
<p><img src="17-05-08-21_26_37_741_386.png" alt=""></p>
<p>5 种 I/O 模型比较:</p>
<p><img src="17-05-08-21_29_37_796_397.png" alt=""></p>
<p><code>select</code> 指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它，函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timespec *timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>我们可以在下列情况收到内核通知:</p>
<ul>
<li>集合 {1, 4, 5} 中的任何描述符准备好读</li>
<li>集合 {2, 7} 中的任何描述符准备好写</li>
<li>集合 {1, 4} 中的任何描述符有异常条件待处理</li>
<li>已经历了 10.2 秒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fd_set rset; <span class="comment">// 比特位</span></div><div class="line">FD_ZERO(&amp;rset);</div><div class="line">FD_SET(<span class="number">1</span>, &amp;rset);</div><div class="line">FD_SET(<span class="number">5</span>, &amp;rset);</div><div class="line"></div><div class="line">select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</div><div class="line">    <span class="comment">// socket is readable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>select</code> 最大缺陷就是单个进程所打开的文件描述符是有一定限制的，它由 <strong>FD_SETSIZE</strong> 设置，默认值是 1024。可以选择修改这个宏然后重新编译内核，不过这会带来网络效率的下降。</p>
<p><code>pselect</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</div></pre></td></tr></table></figure>
<p><code>pselect</code> 是能够处理信号阻塞并提供更高事件分辨率的 <code>select</code> 的增强版本。</p>
<p><code>poll</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<p><code>epoll</code> 函数:</p>
<ul>
<li>一个进程打开的 <code>socket</code> 描述符不受限制 (仅受限于操作系统的最大文件句柄数 <code>cat /proc/sys/fs/file-max</code> )</li>
<li>I/O 效率不会随着文件描述符数目的增加而线性下降，<code>select/poll</code> 每次都会线性扫描全部的集合</li>
<li>把内核和用户空间 <code>mmap</code> 到同一块内存来加速这两者之间的消息传递</li>
</ul>
<h3 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h3><p>在 UNIX 系统上大多数 I/O 只需要通过这五个函数完成: <code>open, read, write, lseek, and close</code>。相对于标准 I/O，我们这里讨论的都是 <strong>unbuffered I/O (每一次 <code>read</code> 和 <code>write</code> 都会产生一个系统调用)</strong>。</p>
<p>通常，UNIX 系统 shell 把文件描述符 0 与进程的标准输入关联，文件描述符 1 与标准输出关联，文件描述符 2 与标准错误关联。</p>
<p>文件描述符的最大限制:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/fs/file-max <span class="comment"># 599216</span></div></pre></td></tr></table></figure>
<p>文件描述符的当前数量:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/fs/file-nr</div></pre></td></tr></table></figure>
<p>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span> )</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>; <span class="comment">// 改变已经打开文件的属性</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 成功: 返回 0</span></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence); <span class="comment">// 成功: 返回新的文件偏移量</span></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); <span class="comment">// 成功: 读到的字节数; 文件末尾: 返回 0</span></div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); <span class="comment">// 成功: 已写的字节数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 复制一个现有的文件描述符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 将所有修改的块缓冲区排入写队列，然后返回，并不等待磁盘操作结束</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 等待磁盘写操作结束</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>; <span class="comment">// I/O 操作的杂物箱，一般用于中断 I/O</span></div></pre></td></tr></table></figure>
<p>调用 <code>dup(fd)</code> 等效于 <code>fcntl(fd, F_DUPFD, 0)</code>; <code>fcntl</code> 函数可以:</p>
<ul>
<li>复制一个已有的文件描述符</li>
<li>获取/设置文件描述符标志</li>
<li>获取/设置文件状态标志</li>
<li>获取/设置异步 I/O 所有权</li>
<li>获取/设置记录锁</li>
</ul>
<h3 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h3><blockquote>
<p>文件 I/O 围绕文件描述符，标准 I/O 围绕流</p>
</blockquote>
<h4 id="Binary-I-O"><a href="#Binary-I-O" class="headerlink" title="Binary I/O"></a>Binary I/O</h4><p>一次读或写一个 <strong>structure</strong>，下述两个函数提供了二进制 I/O:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj,</div><div class="line">             FILE *<span class="keyword">restrict</span> fp);</div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj,</div><div class="line">              FILE *<span class="keyword">restrict</span> fp);</div></pre></td></tr></table></figure>
<p>我们可以这样操作一个结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">short</span> count;</div><div class="line">    <span class="keyword">long</span> total;</div><div class="line">    <span class="keyword">char</span> name[NAMESIZE];</div><div class="line">&#125; item;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (fwrite(&amp;item, <span class="keyword">sizeof</span>(item), <span class="number">1</span>, fp) != <span class="number">1</span>)</div><div class="line">    err_sys(<span class="string">"fwrite error"</span>);</div></pre></td></tr></table></figure>
<p>基于字节的 Java I/O 操作接口:</p>
<p><img src="file_io.jpg" alt=""></p>
<p>基于字符的 Java I/O 操作接口:</p>
<p><img src="reader_and_writer_class_in_java.jpg" alt=""></p>
<p>字节与字符的转化接口: <code>InputStreamReader</code> 派生出 <code>FileReader</code></p>
<h3 id="高级-I-O"><a href="#高级-I-O" class="headerlink" title="高级 I/O"></a>高级 I/O</h3><p>涵盖了一些 <strong>非阻塞 I/O、记录锁、I/O 多路复用 (<code>select</code> 和 <code>poll</code>)、异步 I/O、<code>readv</code> 和 <code>writev</code>、内存映射 I/O (mmap)</strong></p>
<h4 id="readv-和-writev"><a href="#readv-和-writev" class="headerlink" title="readv 和 writev"></a><code>readv</code> 和 <code>writev</code></h4><p>这两个函数可以让我们从多个缓冲区里面读和写，这些操作称之为 <strong>scatter read</strong> 和 <strong>gather write</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *iov_base; <span class="comment">/* starting address of buffer */</span></div><div class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/* size of buffer */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Memory-Mapped-I-O-内存映射-I-O"><a href="#Memory-Mapped-I-O-内存映射-I-O" class="headerlink" title="Memory-Mapped I/O 内存映射 I/O"></a>Memory-Mapped I/O 内存映射 I/O</h4><p>Memory-Mapped I/O 让我们可以将位于磁盘上的一个文件映射到内存上的一个缓冲区中，当我们从缓冲区中读，我们就是从文件中读；当我们向缓冲区写，对象的文件也被写入了。Memory-Mapped I/O 已经被用于 virtual memory systems 很多年了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off )</span></span>;</div></pre></td></tr></table></figure>
<p>内存映射文件:</p>
<p><img src="17-05-08-22_09_32_629_472.png" alt=""></p>
<h3 id="Client-Server-IO"><a href="#Client-Server-IO" class="headerlink" title="Client/Server IO"></a>Client/Server IO</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p><img src="17-05-08-22_45_10_757_283.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ServerSocket server = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    server = <span class="keyword">new</span> ServerSocket(port);</div><div class="line">    Socket socket = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        socket = server.accept();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Request(socket)).start();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</div><div class="line">        server.close();</div><div class="line">        server = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="伪异步-IO"><a href="#伪异步-IO" class="headerlink" title="伪异步 IO"></a>伪异步 IO</h4><p><img src="17-05-08-22_44_31_784_278.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TimeServerHandlerExcutePool singleExecutor = <span class="keyword">new</span> TimeServerHandlerExecutePool(<span class="number">50</span>, <span class="number">10000</span>);</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    socket = server.accept();</div><div class="line">    singleExecutor.execute(<span class="keyword">new</span> TimeServerHandler(socket));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当对 <code>Socket</code> 的输入流进行读取的操作的时候，它会一直阻塞下去，直到发生三种事件:</p>
<ul>
<li>有数据可读</li>
<li>可用数据已经读取完毕</li>
<li>发生空指针或 I/O 异常</li>
</ul>
<p>这意味着当对方发送请求或者应答消息比较缓慢，或者网络传输缓慢时，读取输入流的一方的通信线程将被长时间阻塞，如果对方要 60s 才能够将数据发送完成，读取一方的 I/O 线程也将会被同步阻塞 60s，在此期间，其他接入消息只能在消息队列中排队。当调用 <code>OutputStream</code> 的 <code>write</code> 方法时，也面临同样的问题。当消息的接收方处理缓慢的时候，将不能及时地从 TCP 缓冲区中读取数据，这将会导致发送方的 TCP window size 不断减小，直到为 0，双方处于 Keep-Alive 状态，消息发送方将不能再向 TCP 缓冲区写入消息，这时如果采用的是同步阻塞 I/O，<code>write</code> 操作将会被无期限阻塞，直到 TCP window size 大于 0 或者发生 I/O 异常。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MultiplexerTimeServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        selector = Selector.open();</div><div class="line">        servChannel = ServerSocketChannel.open();</div><div class="line">        servChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        servChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">1024</span>);</div><div class="line">        servChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!stop) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            selector.select(<span class="number">1000</span>);</div><div class="line">            Set&lt;SelectonKey&gt; selectedKeys = selector.selectedKeys();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 代码未完待续 ...</span></div></pre></td></tr></table></figure>
<p>由于 <code>SocketChannel</code> 是异步非阻塞的，它并不保证一次能够把需要发送的字节数组发送完，此时会出现 “写半包” 问题。我们需要注册写操作，不断轮询 <code>Selector</code> 将没有发送完的 <code>ByteBuffer</code> 发送完毕，然后可以通过 <code>ByteBuffer</code> 的 <code>hasRemain()</code> 方法判断消息是否发送完成。</p>
<p>相比于 BIO，NIO 的一个明显的好处是不需要为每一个 <code>Socket</code> 分配一个线程，而可以在一个线程中处理多个 <code>Socket</code> 套接字相关的工作。</p>
<p><img src="reactordiagram.png" alt=""></p>
<p>通过 <code>Channel</code> 对象获取的 I/O 数据首先要经过操作系统的 Socket 缓冲区，再将数据复制到 <code>Buffer</code> 中，这个操作系统缓冲区就是底层的 TCP 所关联的 RecvQ 或者 SendQ 队列，从操作系统缓冲区到用户缓冲区复制数据比较消耗性能，<code>Buffer</code> 还提供了另外一种直接操作系统缓冲区的方式，即 <code>ByteBuffer.allocateDirector(size)</code>，这个方法返回的 <code>DirectByteBuffer</code> 就是与底层存储空间关联的缓冲区，它通过 Native 代码操作非 JVM 堆的内存空间。每次创建或者释放的时候都会调用一次 <code>System.gc()</code>。一般在数据量比较大、生命周期比较长的情况下比较合适。</p>
<p><code>FileChannel.transferXXX</code> 与传统的访问文件方式相比可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动:</p>
<p><img src="17-05-17-20_54_48_510_282.png" alt=""></p>
<p><code>FileChannel.map</code> 将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时，将直接操作这个文件数据，这种方式省去了数据从内核空间向用户空间复制的损耗。这种方式适合对大文件的只读性操作，如大文件的 MD5 校验。</p>
<h4 id="AIO-编程"><a href="#AIO-编程" class="headerlink" title="AIO 编程"></a>AIO 编程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTimeServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    </div><div class="line">    CountDownLatch latch;</div><div class="line">    AsynchronousServerSocketChannel asynchronousServerSocketChannel;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTimeServerHandler</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();</div><div class="line">            asynchronousServerSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        latch = <span class="keyword">new</span> CountDownLatch();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            latch.await();    </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        asynchronousServerSocketChannel.accept(<span class="keyword">this</span>, <span class="keyword">new</span> AcceptCompletionHandler());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousServerSocketChannel result, AcceptCompletionHandler attachment)</span> </span>&#123;</div><div class="line">        attachment.asynchronousServerSocketChannel.accept(attachment, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="comment">// 代码未完继续 ...</span></div></pre></td></tr></table></figure>
<h4 id="I-O-调优"><a href="#I-O-调优" class="headerlink" title="I/O 调优"></a>I/O 调优</h4><p>性能检测: 通过压力测试，看系统 I/O wait 指标是否异常。例如，测试机器有 4 个 CPU，那么理想的 I/O wait 参数不应该超过 25%，如果超过，则 I/O 很可能成为应用程序的性能瓶颈。在 Linux 下通过 <code>iostat</code> 命令查看。通常我们还会查看另外一个参数，就是 IOPS，即要查看应用程序需要的最低的 IOPS 是多少，磁盘的 IOPS 能不能达到要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(磁盘数 * 每块磁盘的 IOPS) / (磁盘块的吞吐量 + RAID 因子 * 磁盘写的吞吐量) = IOPS</div></pre></td></tr></table></figure>
<p>TCP 连接查看主机可以使用的端口范围:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/net/ipv4/ip_local_port_range</div></pre></td></tr></table></figure>
<p><img src="17-05-17-21_11_26_708_54.png" alt=""></p>
<p>可用端口数量: 60999 - 32768 = 28231，如果这个值偏小，则遇到大量并发请求时就会成为性能瓶颈。</p>
<table>
<thead>
<tr>
<th>网络调优参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>echo &quot;1024 65535&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range</code></td>
<td>设置端口可用范围</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</code></td>
<td>设置 time_wait 连接重用</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</code></td>
<td>设置快速回收 time_wait 连接</td>
</tr>
<tr>
<td><code>echo 180000 &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets</code></td>
<td>设置最大 time_wait 连接长度</td>
</tr>
<tr>
<td><code>echo 0 &gt; /proc/sys/net/ipv4/tcp_timestamps</code></td>
<td>表示是否启用以一种比超时重发更精确的方法来启用对 RTT 的计算</td>
</tr>
<tr>
<td><code>echo 1 &gt; /proc/sys/net/ipv4/tcp_window_scaling</code></td>
<td>设置 TCP/IP 会话的滑动窗口大小是否可变</td>
</tr>
<tr>
<td><code>echo 20000 &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog</code></td>
<td>设置最大等待处于客户端还没有应答回来的连接数</td>
</tr>
<tr>
<td><code>echo 10000 &gt; /proc/sys/net/core/somaxconn</code></td>
<td>设置每一个处于监听状态的端口的监听队列的长度</td>
</tr>
<tr>
<td><code>echo 10000 &gt; /proc/sys/net/core/netdev_max_backlog</code></td>
<td>设置最大等待 CPU 处理的包的数目</td>
</tr>
<tr>
<td><code>echo 2000000 &gt; /proc/sys/fs/file-max</code></td>
<td>设置最大打开的文件数</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>以上设置都是临时性的，系统重新启动后就会丢失。</p>
<h3 id="Buffered-I-O"><a href="#Buffered-I-O" class="headerlink" title="Buffered I/O"></a>Buffered I/O</h3><p><code>BufferedOutputStream</code> 经常被用在<strong>避免频繁操作磁盘和网络</strong>的地方(<a href="https://stackoverflow.com/questions/6821887/bufferedoutputstream-vs-bytearrayoutputstream" target="_blank" rel="external">参考</a>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(zip);</div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</div><div class="line">oos.writeObject(prices);</div></pre></td></tr></table></figure>
<p><code>ByteArrayOutputStream</code> <strong>只是在内存里面</strong>做一层缓冲:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">GZIPOutputStream zip = <span class="keyword">new</span> GZIPOutputStream(baos);</div></pre></td></tr></table></figure>
<h3 id="文件-I-O-CSAPP"><a href="#文件-I-O-CSAPP" class="headerlink" title="文件 I/O - CSAPP"></a>文件 I/O - CSAPP</h3><p><strong>文件描述符</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd1, fd2;</div><div class="line">    fd1 = open(<span class="string">"data/foo.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    close(fd1);</div><div class="line">    fd2 = open(<span class="string">"data/baz.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    <span class="comment">// fd2 = 3</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"fd2 = %d\n"</span>, fd2);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Unix <strong>进程生命周期</strong>开始时，打开的描述符赋给了 <code>stdin (0)</code>，<code>stdout (1)</code> 和 <code>stderr (2)</code>。 <code>open</code> 函数总是返回最低的未打开的描述符，所以第一次调用 <code>open</code> 会返回描述符 <code>3</code>，<strong>调用 <code>close</code> 函数会释放描述符 <code>3</code></strong>。最后依然会返回 <code>3</code>。</p>
<hr>
<p><strong>一次一个字节从标准输入拷贝到标准输出</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (read(STDIN_FILENO, &amp;c, <span class="number">1</span>) != <span class="number">0</span>) &#123;</div><div class="line">        write(STDOUT_FILENO, &amp;c, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="2017_12_04_22_40_07.png" alt=""></p>
<hr>
<p><strong>读取文件元数据</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></div><div class="line">    <span class="keyword">char</span> *type, *readok;</div><div class="line"></div><div class="line">    stat(argv[<span class="number">1</span>], &amp;stat_buf);</div><div class="line">    <span class="keyword">if</span> (S_ISREG(stat_buf.st_mode)) &#123;</div><div class="line">        type = <span class="string">"regular"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat_buf.st_mode)) &#123;</div><div class="line">        type = <span class="string">"directory"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        type = <span class="string">"other"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((stat_buf.st_mode &amp; S_IRUSR)) &#123;</div><div class="line">        readok = <span class="string">"yes"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        readok = <span class="string">"no"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"type: %s, read: %s\n"</span>, type, readok);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>共享文件</strong>:</p>
<p><img src="2017_12_05_15_05_04.png" alt=""></p>
<p>以同一个 <code>filename</code> 调用 <code>open</code> 函数两次，这个时候，<strong>每个描述符都有它自己的文件位置</strong>，所以对不同描述符的读操作可以从文件的不同位置获取数据:</p>
<p><img src="2017_12_05_15_05_35.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd1, fd2;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line"></div><div class="line">    <span class="comment">// foobar</span></div><div class="line">    fd1 = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    fd2 = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    read(fd1, &amp;c, <span class="number">1</span>);</div><div class="line">    read(fd2, &amp;c, <span class="number">1</span>);</div><div class="line">    <span class="comment">// c = f</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"c = %c\n"</span>, c);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fork</code> 之后，<strong>子进程有一个父进程的描述符表的副本</strong>:</p>
<p><img src="2017_12_05_15_05_54.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    </div><div class="line">    fd = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</div><div class="line">        read(fd, &amp;c, <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    wait(<span class="literal">NULL</span>);</div><div class="line">    read(fd, &amp;c, <span class="number">1</span>);</div><div class="line">    <span class="comment">// c = o</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"c = %c\n"</span>, c);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>I/O 重定向</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拷贝描述符表项 oldfd 到描述符表表项 newfd，覆盖描述符表表项 newfd 以前的内容</span></div><div class="line"><span class="comment">// 如果 newfd 已经打开，则会在拷贝 oldfd 之前关闭 newfd</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</div></pre></td></tr></table></figure>
<p>以命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls &gt; foo.txt</div></pre></td></tr></table></figure>
<p>为例，描述符 <code>1 (标准输出)</code> 原来对应于文件 <code>A (一个终端)</code>，描述符 <code>4</code> 原来对应于 <code>B (foo.txt)</code>，经过 <code>dup2(4, 1)</code> 之后:</p>
<p><img src="2017_12_05_17_54_09.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd1, fd2;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line"></div><div class="line">    fd1 = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    fd2 = open(<span class="string">"data/foobar.txt"</span>, O_RDONLY, <span class="number">0</span>);</div><div class="line">    read(fd2, &amp;c, <span class="number">1</span>);</div><div class="line">    <span class="comment">// int dup2(int oldfd, int newfd);</span></div><div class="line">    dup2(fd2, fd1);</div><div class="line">    read(fd1, &amp;c, <span class="number">1</span>);</div><div class="line">    <span class="comment">// c = o</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"c = %c\n"</span>, c);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><img src="2017_12_05_21_40_53.png" alt=""></p>
<p>当我们试图对网络输入使用标准 <code>I/O</code> 时，它会带来一些令人讨厌的问题:</p>
<ul>
<li><strong>标准 <code>I/O</code> 是全双工</strong>的，程序能够在同一个流上执行输入和输出。</li>
<li>跟在输出函数之后的输入函数。如果中间没有插入 <code>fflush</code>、<code>fseek</code>、<code>fsetpos</code> 或者 <code>rewind</code> 的调用，一个输入函数不能跟随在一个输出函数之后。<code>fflush</code> 清空与流相关的缓冲区。后三个函数调用使用 <code>Unix IO</code> 的 <code>lseek</code> 函数来重置当前的文件位置。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">write();</div><div class="line">fflush();</div><div class="line">read();</div></pre></td></tr></table></figure>
<ul>
<li>跟在输入函数之后的输出函数。如果中间没有插入 <code>fseek</code>、<code>fsetpos</code> 或者 <code>rewind</code> 的调用,一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个 <code>EOF</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一种可能解决方案</span></div><div class="line"><span class="comment">// 更正确的解决方案: 建议使用 RIO 函数</span></div><div class="line">FILE *fpin, *fpout;</div><div class="line"></div><div class="line">fpin = fdopen(sockfd, <span class="string">"r"</span>);</div><div class="line">fpout = fdopen(sockfd, <span class="string">"w"</span>);</div><div class="line"></div><div class="line">fclose(fpin);</div><div class="line"><span class="comment">// 第二个 close 操作可能会失败</span></div><div class="line">fclose(fpout);</div></pre></td></tr></table></figure>
<p>对套接字执行 <code>lseek</code> 函数是非法的。</p>
<h3 id="InputStream-available"><a href="#InputStream-available" class="headerlink" title="InputStream#available()"></a><code>InputStream#available()</code></h3><p>将 <code>InputStream</code> 变成 <code>byte[]</code> 的正确操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] inputStream2ByteArray(InputStream inputStream) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line"></div><div class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line">    <span class="keyword">while</span> ((c = inputStream.read(buf)) &gt;= <span class="number">0</span>) &#123;</div><div class="line">        byteArrayOutputStream.write(buf, <span class="number">0</span>, c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InputStream is;</div><div class="line"><span class="keyword">byte</span>[] bytes = IOUtils.toByteArray(is);</div></pre></td></tr></table></figure>
<p>千万不要像下面这样写 (<strong>尤其是网络流</strong>):</p>
<p>每次返回的 <code>available</code> 的值都不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] inputStream2ByteArray(InputStream inputStream) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">byte</span>[] buf = inputStream.available();</div><div class="line">    inputStream.read(buf);</div><div class="line">    <span class="keyword">return</span> buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The <code>available()</code> method tells you <strong>能够读取多少字节直到 the <code>read()</code></strong> call will block the execution flow of your program. On most of the input streams, all call to <code>read()</code> are blocking, that’s why available returns 0 by default.</p>
<p>However, on some streams (such as <code>BufferedInputStream</code>, that have an <strong>内部缓冲区</strong>), some bytes are read and kept in <strong>内存</strong>, so you can read them without blocking the program flow. In this case, the <code>available()</code> method tells you how many bytes are kept in the buffer.</p>
<h3 id="从文件末尾读取最多-30000-个字节的内容"><a href="#从文件末尾读取最多-30000-个字节的内容" class="headerlink" title="从文件末尾读取最多 30000 个字节的内容"></a>从文件末尾读取最多 30000 个字节的内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> SHOW_LOG_LENGTH = <span class="number">30000</span>;</div><div class="line"></div><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">FileChannel channel = fis.getChannel();</div><div class="line">size = channel.size();</div><div class="line"></div><div class="line">ByteBuffer bb;</div><div class="line"><span class="keyword">if</span> (size &lt;= SHOW_LOG_LENGTH) &#123;</div><div class="line">    bb = ByteBuffer.allocate((<span class="keyword">int</span>) size);</div><div class="line">    channel.read(bb, <span class="number">0</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">int</span> pos = (<span class="keyword">int</span>) (size - SHOW_LOG_LENGTH);</div><div class="line">    bb = ByteBuffer.allocate(SHOW_LOG_LENGTH);</div><div class="line">    channel.read(bb, pos);</div><div class="line">&#125;</div><div class="line"></div><div class="line">bb.flip();</div><div class="line">content = <span class="keyword">new</span> String(bb.array());</div></pre></td></tr></table></figure>
<h3 id="IO-重定向"><a href="#IO-重定向" class="headerlink" title="IO 重定向"></a>IO 重定向</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 摘自 Tomcat 9 源代码</span></div><div class="line"><span class="comment">// Catalina.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStreams</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Replace System.out and System.err with a custom PrintStream</span></div><div class="line">    System.setOut(<span class="keyword">new</span> SystemLogHandler(System.out));</div><div class="line">    System.setErr(<span class="keyword">new</span> SystemLogHandler(System.err));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/" target="_blank" rel="external">《Advanced Programming in the UNIX》</a></li>
<li><a href="https://www.amazon.com/Unix-Network-Programming-Sockets-Networking/dp/0131411551" target="_blank" rel="external">《Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)》</a></li>
<li><a href="https://item.jd.com/11681556.html" target="_blank" rel="external">《Netty 权威指南》</a></li>
<li><a href="https://item.jd.com/11449803.html" target="_blank" rel="external">《大型网站系统与 Java 中间件实践》</a></li>
<li><a href="https://unix.stackexchange.com/questions/36841/why-is-number-of-open-files-limited-in-linux" target="_blank" rel="external">Why is number of open files limited in Linux?</a></li>
<li><a href="https://item.jd.com/11520670.html" target="_blank" rel="external">《深入分析 Java Web 内幕》</a></li>
<li><a href="https://item.jd.com/11896988.html" target="_blank" rel="external">《Java Performance: The Definitive Guide》</a></li>
<li><a href="https://www.amazon.cn/gp/product/B01N03IQK4" target="_blank" rel="external">《深入理解计算机系统》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/05/06/IO/" data-id="cjcdlsfvh000zdiem3cauwa0i" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
 <script src="/blog/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>Recommended Posts</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/blog/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/blog/2017/05/09/java-concurrency/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java Concurrency
        
      </div>
    </a>
  
  
    <a href="/blog/2017/05/06/TCP/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">TCP</div>
    </a>
  
</nav>

  
</article>
 
     
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">Content</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-Input-和-Output"><span class="toc-number">1.</span> <span class="toc-text">IO - Input 和 Output</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-种-I-O-模型"><span class="toc-number">1.1.</span> <span class="toc-text">5 种 I/O 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件-I-O"><span class="toc-number">1.2.</span> <span class="toc-text">文件 I/O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准-I-O"><span class="toc-number">1.3.</span> <span class="toc-text">标准 I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-I-O"><span class="toc-number">1.3.1.</span> <span class="toc-text">Binary I/O</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级-I-O"><span class="toc-number">1.4.</span> <span class="toc-text">高级 I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readv-和-writev"><span class="toc-number">1.4.1.</span> <span class="toc-text">readv 和 writev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Mapped-I-O-内存映射-I-O"><span class="toc-number">1.4.2.</span> <span class="toc-text">Memory-Mapped I/O 内存映射 I/O</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-Server-IO"><span class="toc-number">1.5.</span> <span class="toc-text">Client/Server IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO"><span class="toc-number">1.5.1.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#伪异步-IO"><span class="toc-number">1.5.2.</span> <span class="toc-text">伪异步 IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-number">1.5.3.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO-编程"><span class="toc-number">1.5.4.</span> <span class="toc-text">AIO 编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-调优"><span class="toc-number">1.5.5.</span> <span class="toc-text">I/O 调优</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffered-I-O"><span class="toc-number">1.6.</span> <span class="toc-text">Buffered I/O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件-I-O-CSAPP"><span class="toc-number">1.7.</span> <span class="toc-text">文件 I/O - CSAPP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream-available"><span class="toc-number">1.8.</span> <span class="toc-text">InputStream#available()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从文件末尾读取最多-30000-个字节的内容"><span class="toc-number">1.9.</span> <span class="toc-text">从文件末尾读取最多 30000 个字节的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-重定向"><span class="toc-number">1.10.</span> <span class="toc-text">IO 重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-number">1.11.</span> <span class="toc-text">参考</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 赵坤&nbsp;|&nbsp;
      Theme by <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      Contact&nbsp;|&nbsp;igozhaokun@163.com
    </div>
  </div>
</footer>
 <script src="/blog/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">首页</a>
  
    <a href="/blog/archives" class="mobile-nav-link">归档</a>
  
    <a href="/blog/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/blog/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>

      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js"></script>
  


 <script src="/blog/js/is.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>
<script src="/blog/js/elevator.js"></script>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>