<html>
<head>
	
	<title>Annotation</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/>
    

</head>

<body>

<h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><p>注解在许多出名的框架中应用甚广，基于注解配置的方式通常可以在类加载的时候对这些被注解的类自动做一些有意思的事情，根据用户不同的配置，生成不同的信息与代码等，其目的就是让用户书写更少的代码和拥有更灵活的使用框架的方式。以 <a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a> 为例，用户可以这样进行 HTTP 请求:</p>
<p><img src="/2017/05/12/Annotation/17-05-12-17:16:13_718_276.png" alt=""></p>
<p>以这样的方式编程，的确是很具有吸引力啊。上述代码中的 <code>@GET</code> 和 <code>@Path</code> 就是两个注解，对应的源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Target</span>(METHOD)</div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123;</div><div class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="meta">@Target</span>(PARAMETER)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Path &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>@Documented</code> 是为了告诉 <strong>javadoc</strong> 生成文档的时候别忘了也带上这个注解类；<code>@Retention</code> 指明注解类存活多长时间，比如你可以指明在运行期间依然存在，或者仅仅为了编译而存在等等；<code>@Target</code> 则描述了这个注解可以应用在 <code>Java</code> 的哪些代码段上，是构造函数、类、接口，还是参数或者方法等。我们可以看到 <code>@GET</code> 声明了 <code>@Target(METHOD)</code>，因此这个注解只能被用在方法上；而 <code>@Path</code> 声明了 <code>@Target(PARAMETER)</code>，因此它只能被用在参数上。如果需要它能够被用在代码的多个地方可以这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.FIELD&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bogus &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般而言，注解与反射是形影不离的。开发者可以通过 <code>Method.getAnnotations()</code> 方法来获得在某个方法上的所有的注解，以下是 <code>java.lang.reflect.AccessibleObject.java</code> 中的源码:</p>
<p><img src="/2017/05/12/Annotation/17-05-12-17:28:51_472_146.png" alt=""></p>
<p>而 <code>Retrofit</code> 也不例外，它在获得到开发者想要调用的方法之后，如 <code>GithubService</code>，便会尝试获得该方法的所有 <code>Annotations</code>，然后尝试调用注解的方法 <code>value()</code> :</p>
<p><img src="/2017/05/12/Annotation/17-05-12-17:33:27_831_238.png" alt=""></p>
<p>调用成功之后，便会对路径进行解析，进而可以执行相应的 Http 请求了。</p>
<h3 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a>Motan</h3><p>另外一种常用的注解使用方式，是在编译期间自动生成代码，如微博的 RPC 调用框架 <a href="https://github.com/weibocom/motan" target="_blank" rel="external">motan</a> ，当你声明 <code>@MotanAsync</code> 注解的时候，其允许你进行异步 RPC 调用:</p>
<p><img src="/2017/05/12/Annotation/17-05-12-18:07:31_611_153.png" alt=""></p>
<p>motan 的 <code>MotanAsyncProcessor</code> 继承了 <code>AbstractProcessor</code>， 在方法中检测哪些类实现了声明了注解 <code>@MotanAsync</code>，然后在编译的时候就为这个类自动生成另外一个类，让客户来调用:</p>
<p><img src="/2017/05/12/Annotation/17-05-12-19:18:13_1026_307.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Documented.html" target="_blank" rel="external">Annotation Type Documented</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Target.html" target="_blank" rel="external">Annotation Type Target</a></li>
<li><a href="https://github.com/weibocom/motan.git" target="_blank" rel="external">motan</a></li>
</ul>






</body>
</html>
