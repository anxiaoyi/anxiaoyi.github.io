<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>Java并发-锁</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="Java-并发-锁"><a href="#Java-并发-锁" class="headerlink" title="Java 并发-锁"></a>Java 并发-锁</h2><h3 id="内置锁-Synchronized"><a href="#内置锁-Synchronized" class="headerlink" title="内置锁 Synchronized"></a>内置锁 Synchronized</h3><p>Java 提供了一种<strong>内置锁 (Intrinsic Lock)</strong>机制来支持原子性: <strong>同步代码块 (Synchronized Block)</strong>。每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为<strong>内置锁 (Instrinsic Lock)</strong> 或<strong>监视器锁 (Monitor Lock)</strong>。Java 的内置锁相当于一种互斥体(或<strong>互斥锁</strong>)，这意味着最多只有一个线程能持有这种锁。但是，加锁的含义不仅仅局限于<strong>互斥行为</strong>，还包括<strong>内存可见性</strong>，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<p><strong><code>Java synchronized</code> 语句</strong> 是基于 <strong>monitorenter/monitorexit</strong> 机制来实现的。当你写下面这段代码的时候:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// synchronize this operation so that some other thread can't</span></span><br><span class="line">    <span class="comment">// manipulate the array while we are sorting it. This assumes that other</span></span><br><span class="line">    <span class="comment">// threads also synchronize their accesses to the array.</span></span><br><span class="line">    <span class="keyword">synchronized</span>(array) &#123;</span><br><span class="line">        <span class="comment">// now sort elements in array</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上 <strong>JVM</strong> 可能会生成下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">static</span> <span class="title">Sort</span><span class="params">([I)</span>V</span></span><br><span class="line"><span class="function">    aload_0</span></span><br><span class="line"><span class="function">    monitorenter    </span>; lock object in local variable <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">    ; now sort elements in <span class="built_in">array</span></span><br><span class="line"></span><br><span class="line">    aload_0</span><br><span class="line">    monitorexit      ; finished with object in local variable <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p><code>monitorenter</code> 在对象的引用上获取了一个 <strong>exclusive lock (独占锁)</strong></p>
<hr>
<p><strong>内置锁 <code>synchronized</code> 是可重入</strong>的，某个线程试图获取一个已经由它自己持有的锁，那么这个请求就会成功。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在<strong>数据库系统的设计中考虑了监测死锁以及从死锁中恢复</strong>。在执行一个事务 (Transaction) 时可能需要获取多个锁，并一直持有这些锁直到事务提交。当数据库服务器监测到一组事务发生了死锁时 (<strong>通过在表示等待关系的有向图中搜索循环</strong>)，将 选择一个牺牲者并放弃这个事务。作为牺牲者的事务会释放它所持有的资源，从而让其它事务继续进行。应用程序可以重新执行被强行中止的事务，而这个事务现在也可以成功完成。</p>
<p>死锁的四大必要条件 (必须全部满足):</p>
<ol>
<li>互斥</li>
<li>持有并等待资源</li>
<li>不可抢占</li>
<li>循环等待</li>
</ol>
<p>如果所有的线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要这么做</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadlock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                doSomethingElse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候，你并不能清除地知道是否在锁顺序上有足够的控制权来避免死锁的发生:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态的锁顺序</span></span><br><span class="line"><span class="comment">// Warning: deadlock-prone!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Account toAccount,</span></span></span><br><span class="line"><span class="function"><span class="params">                          DollarAmount amount)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAccount.debit(amount);</span><br><span class="line">                toAccount.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里锁的顺序取决于参数顺序，而这些参数顺序又取决于外部输入，考虑下面代码就有可能发生死锁:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: transferMoney(myAccount, yourAccount, <span class="number">10</span>);</span><br><span class="line">B: transferMoney(yourAccount, myAccount, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>System.identityHashCode</code> 来定义锁的顺序:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object tieLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(<span class="keyword">final</span> Account fromAcct,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> Account toAcct,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> DollarAmount amount)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAcct.debit(amount);</span><br><span class="line">                toAcct.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 Account 中包含一个唯一的、不可变的，并且具备可比性的键值，例如</span></span><br><span class="line">    <span class="comment">// 账号，那么制定锁的顺序就更加容易了。</span></span><br><span class="line">    <span class="keyword">int</span> fromHash = System.identityHashCode(fromAcct);</span><br><span class="line">    <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在极少数情况下，两个对象可能拥有相同的散列值，</span></span><br><span class="line">        <span class="comment">// 此时可以通过某种任意的方法来决定锁的顺序，</span></span><br><span class="line">        <span class="comment">// 而这有可能重新引入死锁。为了避免这种情况，可以使用</span></span><br><span class="line">        <span class="comment">// “加时赛”锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (tieLock) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某些获取多个锁的操作并不像 <code>LeftRightDeadLock</code> 或 <code>transferMoney</code> 中那么明显，这两个锁并不一定必须在同一个方法中被获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先获取 Taxi 锁</span></span><br><span class="line">    <span class="comment">// 再获取 Dispatcher 锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        <span class="keyword">if</span> (location.equals(destination))</span><br><span class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">        availableTaxis.add(taxi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先获取 Dispatcher 锁</span></span><br><span class="line">    <span class="comment">// 再获取每一个 Taxi 锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="keyword">for</span> (Taxi t : taxis)</span><br><span class="line">            image.drawMarker(t.getLocation());</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将上述代码修改为<strong>开放调用 (调用某个方法时不需要使用锁)</strong>，从而消除发生死锁的风险:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> location;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> reachedDestination;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.location = location;</span><br><span class="line">            reachedDestination = location.equals(destination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reachedDestination)</span><br><span class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">            availableTaxis.add(taxi);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;Taxi&gt; copy;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            copy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);</span><br><span class="line">        &#125;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="keyword">for</span> (Taxi t : copy)</span><br><span class="line">            image.drawMarker(t.getLocation());</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序中应该尽量使用开放调用。与那些在持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。通过使用<strong>定时锁</strong>能够有效地应对死锁问题，通过 <strong>Thread Dump</strong> 能够帮助你识别死锁的发生。</p>
<h3 id="减少锁的竞争"><a href="#减少锁的竞争" class="headerlink" title="减少锁的竞争"></a>减少锁的竞争</h3><p>有三种方式可以降低锁的竞争程度:</p>
<ul>
<li>减少锁的持有时间</li>
<li>降低锁的请求频率</li>
<li>使用带有协调机制的独占锁，这些机制允许更高的并发性</li>
</ul>
<h3 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁 ReentrantLock"></a>重入锁 ReentrantLock</h3><p><code>ReentrantLock</code> 的 <code>tryLock</code> 方法为你提供了<strong>轮询锁与定时锁</strong>的锁获取模式，与无条件的锁获取模式相比，它具有更完善的错误恢复机制。方法 <code>lockInterruptibly</code> 方法能够在获得锁的同时<strong>保持对中断的响应</strong>。<code>ReentrantLock</code> 的构造函数中提供了两种<strong>公平性</strong>选择: 创建一个非公平的锁 (默认) 或者一个公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允许“插队”。在大多数情况下，非公平锁的性能要高于公平锁的性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁 ReadWriteLock"></a>读写锁 ReadWriteLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记录锁-Record-Locking"><a href="#记录锁-Record-Locking" class="headerlink" title="记录锁 Record Locking"></a>记录锁 Record Locking</h3><p><strong>Record Locking</strong> 更好的叫法应该被称为: <strong>byte-range locking</strong>，目的是为了防止两个进程同时修改一个文件的某块区域。函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// 出错返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *flockptr */</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>flock</code> 结构体定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> l_type; <span class="comment">/* F_RDLCK, F_WRLCK, or F_UNLCK */</span></span><br><span class="line">    <span class="keyword">short</span> l_whence; <span class="comment">/*SEEK_SET, SEEK_CUR, or SEEK_END */</span></span><br><span class="line">    <span class="keyword">off_t</span> l_start; <span class="comment">/*offset in bytes, relative to l_whence */</span></span><br><span class="line">    <span class="keyword">off_t</span> l_len; <span class="comment">/*length, in bytes; 0 means lock to EOF */</span></span><br><span class="line">    <span class="keyword">pid_t</span> l_pid; <span class="comment">/*returned with F_GETLK */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>F_RDLCK</code>: 共享读锁</li>
<li><code>F_WRLCK</code>: 排斥写锁</li>
<li><code>F_UNLCK</code>: 取消某个区域的锁</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁-SpinLock"><a href="#自旋锁-SpinLock" class="headerlink" title="自旋锁 SpinLock"></a>自旋锁 SpinLock</h4><p><strong>互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成</strong>，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，<strong>共享数据的锁定状态只会持续很短的一段时间</strong>，为了这段时间去挂起和恢复线程并不值得。为了能让线程稍微等一会，我们只需让线程执行一个忙循环 (自旋)，这项技术就是所谓的自旋锁。</p>
<p>现在我们假设<strong>硬件</strong>上有一种能够保证原子性的 <code>TestAndSet</code> 指令实现函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> temp = *x;</span><br><span class="line">    *x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TestAndSet</code> 是一种常用的用于支持并发的原子操作指令。另外一种经常使用的指令是原子 <code>Exchange</code> 操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些所有的原子性操作中最重要的是 <code>CompareAndSwap (CAS)</code> 操作，它经常被用于 <a href="http://en.wikipedia.org/wiki/Lock-free_and_wait-free_algorithms" target="_blank" rel="noopener">lock-free and wait-free algorithms</a> 算法中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">CAS</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> old, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    <span class="keyword">if</span> (temp == old) &#123;</span><br><span class="line">        *a = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>CAS</code> 来实现 <code>temp++</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = x;</span><br><span class="line"><span class="keyword">while</span> (!CAS(&amp;x, temp, temp+<span class="number">1</span>)) &#123;</span><br><span class="line">    temp = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>CAS</code> 来实现更链表头插法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Node *q = *head;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    <span class="keyword">if</span> (CAS(head, q, p))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般而言，<code>SpinLock</code> 是一种抽象的数据类型，其通常提供三种操作:</p>
<ul>
<li><code>InitLock</code></li>
<li><code>Lock</code></li>
<li><code>UnLock</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lock(mutex);</span><br><span class="line">Si;</span><br><span class="line">UnLock(mutex);</span><br></pre></td></tr></table></figure>
<p>实现 <code>SpinLock</code> 的伪代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SpinLock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLock</span><span class="params">(SpinLock *L)</span> </span>&#123;</span><br><span class="line">    *L = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lock</span><span class="params">(SpinLock *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(L)) </span><br><span class="line">		;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnLock</span><span class="params">(SpinLock *L)</span> </span>&#123;</span><br><span class="line">    *L = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种使用 <code>Exchange</code> 操作的可能实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SpinLock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLock</span><span class="params">(SpinLock *s)</span> </span>&#123;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lock</span> <span class="params">(SpinLock *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Exchange(&amp;L, s);</span><br><span class="line">    &#125; <span class="keyword">while</span> (L == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnLock</span> <span class="params">(SpinLock *s)</span> </span>&#123;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种使用 <code>CompareAndSwap</code> 指令的实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SpinLock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLock</span><span class="params">(SpinLock *s)</span> </span>&#123;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lock</span> <span class="params">(SpinLock *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    &#125; until (CompareAndSwap(s, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnLock</span> <span class="params">(SpinLock *s)</span> </span>&#123;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自旋锁最大的问题就是可能会占用比较高的 <strong>memory bus</strong> 带宽，另外它也不保证公平性，即无法保证先后进入临界区的两个进程 P 和 Q 按照 FIFO 顺序来服务。</p>
<h4 id="锁消除-Lock-Elimination"><a href="#锁消除-Lock-Elimination" class="headerlink" title="锁消除 Lock Elimination"></a>锁消除 Lock Elimination</h4><p>虚拟机 JIT 在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。主要判定依据来自于<strong>逃逸分析</strong>的数据支持。</p>
<h4 id="锁粗化-Lock-Coarsening"><a href="#锁粗化-Lock-Coarsening" class="headerlink" title="锁粗化 Lock Coarsening"></a>锁粗化 Lock Coarsening</h4><h4 id="轻量级锁-Lightweight-Locking"><a href="#轻量级锁-Lightweight-Locking" class="headerlink" title="轻量级锁 Lightweight Locking"></a>轻量级锁 Lightweight Locking</h4><h4 id="偏向锁-Biased-Locking"><a href="#偏向锁-Biased-Locking" class="headerlink" title="偏向锁 Biased Locking"></a>偏向锁 Biased Locking</h4><p>偏向锁的”偏”，是偏心的”偏”，它的意思就是<strong>这个锁会偏向于第一个获得它的线程</strong>，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p>
<p>JDK 1.6 默认开启 <code>-XX:+UseBiasedLocking</code>，使用 <code>-XX:-UseBiasedLocking</code> 来关闭。</p>
<p><strong>偏向锁转为轻量级锁</strong>的流程图:</p>
<p><img src="217664272.jpg" alt=""></p>
<h4 id="锁升级-Lock-Escalation"><a href="#锁升级-Lock-Escalation" class="headerlink" title="锁升级 Lock Escalation"></a>锁升级 Lock Escalation</h4><p>所谓的锁升级（lock escalation），是数据库的一种作用机制，该机制普遍见于各大数据库产品。 为了节约内存的开销，其会<strong>将为数众多并占用大量资源的细粒度的锁转化为数量较少的且占用相对较少资源的粗粒度的锁</strong>，多数情况下主要指<strong>将为数众多的行锁升级为一个表锁</strong>。当然，DB2 支持很多粒度的锁，如<strong>表空间（table space），表（table），行（row）以及索引（index）</strong>等。MySQL 的 InnoDB 存储引擎支持事务，<strong>默认是行锁</strong>。得益于这些特性，数据库支持高并发。</p>
<p>锁升级与两种事情有关:</p>
<ul>
<li>事务的隔离级别</li>
<li>索引</li>
</ul>
<p>常用的索引有三类：<strong>主键、唯一索引、普通索引</strong>。主键 不由分说，自带最高效的索引属性；唯一索引 指的是该属性值重复率为0，一般可作为业务主键，例如学号；普通索引 与前者不同的是，属性值的重复率大于0，不能作为唯一指定条件，例如学生姓名。<strong>当“值重复率”低时，甚至接近主键或者唯一索引的效果，“普通索引”依然是行锁；当“值重复率”高时，MySQL 不会把这个“普通索引”当做索引，即造成了一个没有索引的 SQL，此时引发表锁</strong>。索引不是越多越好，索引存在一个和这个表相关的文件里，占用硬盘空间，宁缺勿滥，每个表都有主键（id），操作能使用主键尽量使用主键。同 JVM 自动优化 java 代码一样，MySQL 也具有自动优化 SQL 的功能。<strong>低效的索引将被忽略</strong>，这也就倒逼开发者使用正确且高效的索引。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://item.jd.com/10922250.html" target="_blank" rel="noopener">《Java 并发编程实战》</a></li>
<li><a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener">Deadlock</a></li>
<li><a href="https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/" target="_blank" rel="noopener">《Advanced Programming in the UNIX》</a></li>
<li><a href="https://item.jd.com/11252778.html" target="_blank" rel="noopener">《深入理解 Java 虚拟机》</a></li>
<li><a href="https://cis.temple.edu/~giorgio/cis307/readings/spinsem.html" target="_blank" rel="noopener">CIS 4307: Spinlocks and Semaphores</a></li>
<li><a href="https://cs.au.dk/~mis/dOvs/jvmspec/ref--44.html" target="_blank" rel="noopener">enter synchronized region of code</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1312db2lockescalation/" target="_blank" rel="noopener">关于 DB2 锁升级 (lock escalation) 相关问题的探讨</a></li>
<li><a href="http://zhoupq.com/MySQL-%E9%81%BF%E5%85%8D%E8%A1%8C%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%A1%A8%E9%94%81%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E9%AB%98%E6%95%88%E7%9A%84%E7%B4%A2%E5%BC%95/" target="_blank" rel="noopener">MySQL 避免行锁升级为表锁——使用高效的索引</a></li>
<li><a href="http://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></li>
<li><a href="http://www.imooc.com/article/17291?block_id=tuijian_wz" target="_blank" rel="noopener">MySQL数据库事务各隔离级别加锁情况–read uncommitted篇</a></li>
<li><a href="http://www.artima.com/insidejvm/ed2/threadsynchP.html" target="_blank" rel="noopener">Thread Synchronization</a></li>
</ul><!-- hexo-inject:begin --><!-- hexo-inject:end -->






</body>
</html>
