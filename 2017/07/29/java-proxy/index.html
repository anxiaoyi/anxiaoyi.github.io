<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>Java AOP</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="Java-AOP"><a href="#Java-AOP" class="headerlink" title="Java AOP"></a>Java AOP</h2><h3 id="运行期代理"><a href="#运行期代理" class="headerlink" title="运行期代理"></a>运行期代理</h3><h4 id="1-JDK-动态代理"><a href="#1-JDK-动态代理" class="headerlink" title="(1) JDK 动态代理"></a>(1) JDK 动态代理</h4><p><code>Proxy</code> 利用 <code>InvocationHandler</code> <strong>动态创建一个符合某一接口的实例</strong>，生成目标类的代理对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//do something "dynamic"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</div><div class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</div><div class="line">MyInterface proxy = (MyInterface) Proxy.newProxyInstance(</div><div class="line">                            MyInterface.class.getClassLoader(),</div><div class="line">                            <span class="keyword">new</span> Class[] &#123; MyInterface.class &#125;,</div><div class="line">                            handler);</div></pre></td></tr></table></figure>
<h4 id="2-CGLib-动态代理"><a href="#2-CGLib-动态代理" class="headerlink" title="(2) CGLib 动态代理"></a>(2) <a href="https://dzone.com/articles/cglib-missing-manual" target="_blank" rel="external">CGLib 动态代理</a></h4><p><code>CGLib</code> 采用底层的<strong>字节码</strong>技术，<strong>可以为一个类创建子类</strong>，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p>
<p>An enhancer allows the creation of Java proxies for non-interface types. The <code>Enhancer</code> can be compared with the Java standard library’s <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html" target="_blank" rel="external"><code>Proxy</code></a> class which was introduced in Java 1.3. The <code>Enhancer</code> dynamically creates a subclass of a given type but intercepts all method calls. Other than with the <code>Proxy</code> class, this <strong>works for both class and interface types.</strong> </p>
<p>Even though constructors are only methods on the Java byte code level, the Enhancer class <strong>cannot instrument constructors. Neither can it instrument static or final classes</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodInterceptor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">    enhancer.setSuperclass(SampleClass.class);</div><div class="line">    enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span></span></div><div class="line"><span class="function">                <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                <span class="keyword">if</span>(method.getDeclaringClass() != Object.class </div><div class="line">                   &amp;&amp; method.getReturnType() == String.class) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    proxy.invokeSuper(obj, args);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    SampleClass proxy = (SampleClass) enhancer.create();</div><div class="line">    assertEquals(<span class="string">"Hello cglib!"</span>, proxy.test(<span class="keyword">null</span>));</div><div class="line">    assertNotEquals(<span class="string">"Hello cglib!"</span>, proxy.toString());</div><div class="line">    proxy.hashCode(); <span class="comment">// Does not throw an exception or result in an endless loop.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>A Final Word of Warning</strong>:</p>
<p>All cglib classes generate byte code which results in additional classes being stored in a special section of the JVM’s memory: The so called perm space. This permanent space is, as the name suggests, used for permanent objects that do not usually get garbage collected. This is however not completely true: Once a <code>Class</code> is loaded, it cannot be unloaded until the loading <code>ClassLoader</code> becomes available for garbage collection. This is only the case the <code>Class</code> was loaded with a custom <code>ClassLoader</code> which is not a native JVM system <code>ClassLoader</code>. This <code>ClassLoader</code> can be garbage collected if itself, all Classes it ever loaded and all instances of all Classes it ever loaded become available for garbage collection. This means: If you create more and more classes throughout the life of a Java application and if you do not take care of the removal of these classes, you will sooner or later run of of perm space what will result in your application’s death by the hands of an <code>OutOfMemoryError</code>. Therefore, use cglib sparingly (节俭地). However, if you use cglib wisely and carefully, you can really do amazing things with it that go beyond what you can do with non-instrumented Java applications.</p>
<h3 id="类加载期代理"><a href="#类加载期代理" class="headerlink" title="类加载期代理"></a>类加载期代理</h3><p>在类加载期通过<strong>字节码编辑技术</strong>将切面织入目标类中，这种织入方式称之为 <strong>LTW (Load Time Weaving)</strong>。<code>AspectJ LTW</code> 使用 Java 5.0 所提供的代理功能 (agent) 完成加载期切面织入工作。JDK 的代理功能能够让代理器访问到 JVM 的底层部件，<strong>借此向 JVM 注册类文件转换器，在类加载时对类文件的字节码进行转换</strong>。AspectJ LTW 由于基于 JDK 动态代理技术工作，而 JDK 动态代理的作用范围是整个 JVM，所以这种工作方式比较粗放，对于单一 JVM 多个应用的情况尤其不适合。Spring 为 LTW 的过程提供了细粒度的控制，它<strong>支持在单个 <code>ClassLoader</code> 范围内实施类文件转换</strong>，且配置更为简单。</p>
<p><code>Java 5.0</code> 新增了一个 <code>java.lang.instrument</code> 包，该包中有两个能对 JVM 底层组件进行访问的类。具体地说，就是通过 JVM 的 <code>-javaagent</code> 代理参数在启动时获取 <code>JVM</code> 内部组件的引用，以便在后续流程中使用。借助 JDK 动态代理，可以<strong>在 JVM 启动时装配并应用 <code>ClassTransformer</code></strong>，对类字节码进行转换，实现 AOP 的功能。</p>
<p><code>java.lang.instrument</code> 包中定义了两个重要的接口。</p>
<ul>
<li><code>ClassFileTransformer</code>: <strong><code>Class</code> 文件转换器接口</strong>，该接口有一个唯一的方法，如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFileTransformer</span> </span>&#123;</div><div class="line">    <span class="keyword">byte</span>[]</div><div class="line">    transform(  ClassLoader         loader,</div><div class="line">                String              className,</div><div class="line">                Class&lt;?&gt;            classBeingRedefined,</div><div class="line">                ProtectionDomain    protectionDomain,</div><div class="line">                <span class="keyword">byte</span>[]              classfileBuffer)</div><div class="line">        <span class="keyword">throws</span> IllegalClassFormatException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该接口对 <code>Class</code> 文件的字节码进行转换，<code>classfileBuffer</code> 是类文件对应的字节码数组，返回的 <code>byte[]</code> 是转换后的字节码。如果返回 <code>null</code>，则表示不进行字节码处理。</p>
<ul>
<li><code>Instrumentation</code>: 代表 JVM 内部的一个构件，可以通过该接口的方法向 JVM 的内部 “组件” 注册一些 <code>ClassFileTransformer</code>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Instrumentation</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span></div><div class="line">    addTransformer(ClassFileTransformer transformer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>ClassFileTransformer</code> 实例注册到 <code>JVM</code> 后，<code>JVM</code> 在加载 <code>Class</code> 文件时，会 先调用这个 <code>ClassFileTransformer</code> 的 <code>transform()</code> 方法对 <code>Class</code> 文件的字节码进行转换。如果向 <code>JVM</code> 中注册多个 <code>ClassFileTransformer</code>，它们将按照注册的顺序组成链式的调用。这样 <code>ClassFileTransformer</code> 的实现者就可以<strong>从 <code>JVM</code> 层面截获所有类的字节码</strong>，并引入希望添加的逻辑，如让每个类拥有性能监视的能力、织入特殊用途的增强代码等。</p>
<p><img src="17-07-29-11_05_18_810_499.png" alt=""></p>






<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
