<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>HikariCP 性能分析</title>
	<meta name="keywords" content="代码人生,程序员,赵坤" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="HikariCP-性能分析"><a href="#HikariCP-性能分析" class="headerlink" title="HikariCP 性能分析"></a>HikariCP 性能分析</h2><h3 id="用-wait-还是用-yield"><a href="#用-wait-还是用-yield" class="headerlink" title="用 wait() 还是用 yield()"></a>用 <code>wait()</code> 还是用 <code>yield()</code></h3><p>下面代码摘自 <a href="https://github.com/brettwooldridge/HikariCP/blob/61be9b923d8608605eb97264129d4f0467a0a2cc/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L206,L219" target="_blank" rel="noopener">HikariCP</a> 在添加一个 <code>BagEntry</code> 时候的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> T bagEntry)</span> </span>&#123;</span><br><span class="line">    sharedList.add(bagEntry);</span><br><span class="line">    <span class="comment">// spin until a thread takes it or none are waiting</span></span><br><span class="line">    <span class="keyword">while</span> (waiters.get() &gt; <span class="number">0</span> &amp;&amp; !handoffQueue.offer(bagEntry)) &#123;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方，我<strong>不明白为什么使用 <code>yield</code></strong>，于是上网搜索得到三个网友的答案:</p>
<p><code>yield()</code> is a <code>Thread</code> method , <code>wait()</code> is at the origins <code>Object</code> method inheritid in thread as for all classes.</p>
<hr>
<p><code>wait</code> is for waiting on <strong>一个条件</strong>. This might not jump into the eye when looking at the method as it is entirely up to you to define what kind of condition it is. But <strong>the API</strong> tries to <strong>强制</strong> you to use it correctly by requiring that you own the monitor of the object on which you are waiting, which is necessary for a correct condition check in a multi-threaded environment.</p>
<p>So a <strong>正确使用</strong> of wait looks like:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">  <span class="keyword">while</span>( ! <span class="comment">/* your defined condition */</span>)</span><br><span class="line">    object.wait();</span><br><span class="line">  <span class="comment">/* execute other critical actions if needed */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And it must be paired with another thread executing code like:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">  <span class="comment">/* make your defined condition true */</span>)</span><br><span class="line">  object.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In contrast <code>Thread.yield()</code> is just a <strong>hint</strong> that your thread might <strong>释放 CPU</strong> at this point of time. It’s not specified whether it actually does anything and, regardless of whether the CPU has been released or not, it has no impact on the semantics in respect to the memory model. In other words, it does not create any relationship to other threads which would be required for accessing shared variables correctly.</p>
<p>For example the following loop accessing <code>sharedVariable</code> (which is not declared volatile) might run forever without ever noticing updates made by other threads:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(sharedVariable != expectedValue) Thread.yield();</span><br></pre></td></tr></table></figure>
<p>While <code>Thread.yield</code> might help other threads to run (they will run anyway on most systems), it does not enforce re-reading the value of sharedVariable from the shared memory. Thus, without other constructs enforcing memory visibility, e.g. decaring <code>sharedVariable</code> as volatile, this loop is broken.</p>
<hr>
<p>Not even close, because <code>yield()</code> does not wait for anything.</p>
<p>Every thread can be in one of a number of different states: Running means that the thread is actually running on a CPU, Runnable means that nothing is preventing the thread from running except, maybe the availability of a CPU for it to run on. All of the other states can be lumped into a category called blocked. A blocked thread is a thread that is waiting for something to happen before it can become runnable.</p>
<p>The operating system preempts 抢占 running threads on a regular basis: Every so often (between 10 times per second and 100 times per second on most operating systems) the OS tags each running thread and says, “your turn is up, go to the back of the run queue’ (i.e., change state from running to runnable). Then it lets whatever thread is at the head of the run queue use that CPU (i.e., become running again).</p>
<p>When your program calls <code>Thread.yield()</code>, it’s saying to the operating system, <strong>“I still have work to do, but it might not be as important as the work that some other thread is doing. Please send me to the back of the run queue right now.”</strong> If there is an available CPU for the thread to run on though, then it effectively will just keep running (i.e., the <code>yield()</code> call will immediately return).</p>
<p>When your program calls <code>foobar.wait()</code> on the other hand, it’s saying to the operating system, <strong>“Block me until some other thread calls <code>foobar.notify()</code></strong>.</p>
<p>Yielding was first implemented on non-preemptive operating systems and, in non-preemptive threading libraries. On a computer with <strong>只有一个 CPU</strong>, the only way that more than one thread ever got to run was when the threads <strong>明确地</strong> yielded to one another.</p>
<p>Yielding also was useful for <strong>忙等待</strong>. That’s where a thread waits for something to happen by sitting in a tight loop, testing the same condition over and over again. If the condition depended on some other thread to do some work, the waiting thread would <code>yield()</code> each time around the loop in order to let the other thread do its work.</p>
<p>Now that we have preemption and multiprocessor systems and libraries that provide us with higher-level synchronization objects, there is basically no reason why an application programs would need to call <code>yield()</code> anymore.</p>
<h3 id="为什么使用-SynchronousQueue"><a href="#为什么使用-SynchronousQueue" class="headerlink" title="为什么使用 SynchronousQueue"></a>为什么使用 <code>SynchronousQueue</code></h3><p>以下代码摘自 <a href="https://github.com/brettwooldridge/HikariCP/blob/61be9b923d8608605eb97264129d4f0467a0a2cc/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L77" target="_blank" rel="noopener">HikariCP</a> 在实现 <code>ConcurrentBag</code> 借与还的时候都用到的重要同步队列的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SynchronousQueue&lt;T&gt; handoffQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentBag</span><span class="params">(<span class="keyword">final</span> IBagStateListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handoffQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的这个 <code>handoffQueue</code> 在如下几种情况下都使用了:</p>
<ul>
<li><strong>借</strong>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> T bagEntry = handoffQueue.poll(timeout, NANOSECONDS);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>还</strong>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bagEntry.getState() != STATE_NOT_IN_USE || handoffQueue.offer(bagEntry)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>添加</strong>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (waiters.get() &gt; <span class="number">0</span> &amp;&amp; !handoffQueue.offer(bagEntry)) &#123;</span><br><span class="line">    yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>以下内容摘自 <a href="https://item.jd.com/11740734.html" target="_blank" rel="noopener">《Java 并发编程的艺术》</a>:</p>
<p><code>SynchronousQueue</code> 是一个不存储元素的阻塞队列。每一个 <code>put</code> 操作必须等待一个 <code>take</code> 操作，否则不能继续添加元素。它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的 <code>SynchronousQueue</code>，如果设置为 <code>true</code>，则<strong>等待的线程会采用先进先出的顺序访问队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SynchronousQueue</code> 可以看成是<strong>一个传球手，负责把生产者线程处理的数据<font color="red">直接</font>传递给消费者线程</strong>。队列本身并不存储任何元素，非常适合传递性场景。<code>SynchronousQueue</code> 的吞吐量高于 <code>LinkedBlockingQueue</code> 和 <code>ArrayBlockingQueue</code>。</p>
<hr>
<p>在 <a href="https://item.jd.com/11800589.html" target="_blank" rel="noopener">《实战 Java 高并发程序设计》</a> 中也有对其介绍，以下是部分摘抄:</p>
<p>对于 <code>SynchronousQueue</code> 来说，它将 <code>put()</code> 和 <code>take()</code> 两个功能截然不同的操作抽象为一个共通的方法 <code>Transferer.transfer()</code>，从字面意思上看，这就是数据传递的意思:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当 <code>e</code> 参数为<strong>非空</strong>时，表示当前操作传递给一个消费者，如果为空，则表示当前操作需要请求一个数据。如果返回值非空，则表示数据已经接受或者正常提供，如果为空，则表示失败（超时或者中断）。</p>
<hr>
<p>API 介绍与实现:</p>
<ul>
<li><code>offer()</code>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element into this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * up to the specified wait time for another thread to receive it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>poll()</code>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting</span></span><br><span class="line"><span class="comment"> * if necessary up to the specified wait time, for another thread</span></span><br><span class="line"><span class="comment"> * to insert it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h3><p><code>CompletableFuture</code> 是 Java 8 新增的一个<strong>超大型工具类</strong>，它实现了 <code>Future</code> 接口，而更重要的是，它也实现了 <code>CompletionStage</code> 接口，拥有多达 40 种方法！</p>
<p>严重怀疑<a href="https://github.com/brettwooldridge/HikariCP/blob/47b827d11e26e961bcce457cbbfd28c3356c1ee8/src/main/java/com/zaxxer/hikari/pool/HikariPool.java#L311" target="_blank" rel="noopener">这个地方</a>其实用错了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBagItem</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> waiting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldAdd = waiting - addConnectionQueue.size() &gt;= <span class="number">0</span>; <span class="comment">// Yes, &gt;= is intentional.</span></span><br><span class="line">    <span class="keyword">if</span> (shouldAdd) &#123;</span><br><span class="line">        addConnectionExecutor.submit(POOL_ENTRY_CREATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CompletableFuture.completedFuture(Boolean.TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无锁修改状态"><a href="#无锁修改状态" class="headerlink" title="无锁修改状态"></a>无锁修改状态</h3><p>不用这种方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而采用无锁方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolEntry</span> <span class="keyword">implements</span> <span class="title">IConcurrentBagEntry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">        AtomicIntegerFieldUpdater&lt;PoolEntry&gt; stateUpdater;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        stateUpdater = AtomicIntegerFieldUpdater</span><br><span class="line">            .newUpdater(PoolEntry.class, <span class="string">"state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stateUpdater.get(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stateUpdater.compareAndSet(<span class="keyword">this</span>, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        stateUpdater.set(<span class="keyword">this</span>, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><code>Updater</code> 使用<strong>反射</strong>得到这个变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> tclass.getDeclaredField(fieldName);</span><br></pre></td></tr></table></figure>
<ul>
<li>为了确保变量被正确的读取，它<strong>必须是 <code>volatile</code> 类型</strong>的。</li>
</ul>
<hr>
<p><code>AtomicIntegerFieldUpdater</code> 能够<strong>原子更新</strong>整型字段。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/zou90512/p/5559357.html" target="_blank" rel="noopener">面试总结 - 数据库连接池</a></li>
<li><a href="http://freeman1.iteye.com/blog/2268874" target="_blank" rel="noopener">数据库连接池性能比对</a></li>
<li><a href="https://www.oschina.net/p/hikaricp" target="_blank" rel="noopener">HikariCP 详细介绍</a></li>
<li><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">Github - HikariCP</a></li>
<li><a href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole" target="_blank" rel="noopener">Github - WIKI - Down the Rabbit Hole</a></li>
</ul>






<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
