<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HikariCP 性能分析 | 代码人生</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="HikariCP 性能分析用 wait() 还是用 yield()下面代码摘自 HikariCP 在添加一个 BagEntry 时候的实现: 1234567public void add(final T bagEntry) &amp;#123;    sharedList.add(bagEntry);    // spin until a thread takes it or none are waiti">
<meta property="og:type" content="article">
<meta property="og:title" content="HikariCP 性能分析">
<meta property="og:url" content="http://blog.kunzhao.org/2017/07/07/hikaricp/index.html">
<meta property="og:site_name" content="代码人生">
<meta property="og:description" content="HikariCP 性能分析用 wait() 还是用 yield()下面代码摘自 HikariCP 在添加一个 BagEntry 时候的实现: 1234567public void add(final T bagEntry) &amp;#123;    sharedList.add(bagEntry);    // spin until a thread takes it or none are waiti">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2017-09-15T03:20:27.727Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HikariCP 性能分析">
<meta name="twitter:description" content="HikariCP 性能分析用 wait() 还是用 yield()下面代码摘自 HikariCP 在添加一个 BagEntry 时候的实现: 1234567public void add(final T bagEntry) &amp;#123;    sharedList.add(bagEntry);    // spin until a thread takes it or none are waiti">
  
    <link rel="alternate" href="/atom.xml" title="代码人生" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.kunzhao.org"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">首页</a>
        
          <a class="main-nav-link" href="/blog/archives">归档</a>
        
          <a class="main-nav-link" href="/blog/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">代码人生</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-hikaricp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/07/hikaricp/" class="article-date">
  <time datetime="2017-07-07T14:12:56.000Z" itemprop="datePublished">2017-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/开发者手册/">开发者手册</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HikariCP 性能分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="HikariCP-性能分析"><a href="#HikariCP-性能分析" class="headerlink" title="HikariCP 性能分析"></a>HikariCP 性能分析</h2><h3 id="用-wait-还是用-yield"><a href="#用-wait-还是用-yield" class="headerlink" title="用 wait() 还是用 yield()"></a>用 <code>wait()</code> 还是用 <code>yield()</code></h3><p>下面代码摘自 <a href="https://github.com/brettwooldridge/HikariCP/blob/61be9b923d8608605eb97264129d4f0467a0a2cc/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L206,L219" target="_blank" rel="external">HikariCP</a> 在添加一个 <code>BagEntry</code> 时候的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> T bagEntry)</span> </span>&#123;</div><div class="line">    sharedList.add(bagEntry);</div><div class="line">    <span class="comment">// spin until a thread takes it or none are waiting</span></div><div class="line">    <span class="keyword">while</span> (waiters.get() &gt; <span class="number">0</span> &amp;&amp; !handoffQueue.offer(bagEntry)) &#123;</div><div class="line">        yield();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个地方，我<strong>不明白为什么使用 <code>yield</code></strong>，于是上网搜索得到三个网友的答案:</p>
<p><code>yield()</code> is a <code>Thread</code> method , <code>wait()</code> is at the origins <code>Object</code> method inheritid in thread as for all classes.</p>
<hr>
<p><code>wait</code> is for waiting on <strong>一个条件</strong>. This might not jump into the eye when looking at the method as it is entirely up to you to define what kind of condition it is. But <strong>the API</strong> tries to <strong>强制</strong> you to use it correctly by requiring that you own the monitor of the object on which you are waiting, which is necessary for a correct condition check in a multi-threaded environment.</p>
<p>So a <strong>正确使用</strong> of wait looks like:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(object) &#123;</div><div class="line">  <span class="keyword">while</span>( ! <span class="comment">/* your defined condition */</span>)</div><div class="line">    object.wait();</div><div class="line">  <span class="comment">/* execute other critical actions if needed */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>And it must be paired with another thread executing code like:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(object) &#123;</div><div class="line">  <span class="comment">/* make your defined condition true */</span>)</div><div class="line">  object.notify();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In contrast <code>Thread.yield()</code> is just a <strong>hint</strong> that your thread might <strong>释放 CPU</strong> at this point of time. It’s not specified whether it actually does anything and, regardless of whether the CPU has been released or not, it has no impact on the semantics in respect to the memory model. In other words, it does not create any relationship to other threads which would be required for accessing shared variables correctly.</p>
<p>For example the following loop accessing <code>sharedVariable</code> (which is not declared volatile) might run forever without ever noticing updates made by other threads:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(sharedVariable != expectedValue) Thread.yield();</div></pre></td></tr></table></figure>
<p>While <code>Thread.yield</code> might help other threads to run (they will run anyway on most systems), it does not enforce re-reading the value of sharedVariable from the shared memory. Thus, without other constructs enforcing memory visibility, e.g. decaring <code>sharedVariable</code> as volatile, this loop is broken.</p>
<hr>
<p>Not even close, because <code>yield()</code> does not wait for anything.</p>
<p>Every thread can be in one of a number of different states: Running means that the thread is actually running on a CPU, Runnable means that nothing is preventing the thread from running except, maybe the availability of a CPU for it to run on. All of the other states can be lumped into a category called blocked. A blocked thread is a thread that is waiting for something to happen before it can become runnable.</p>
<p>The operating system preempts 抢占 running threads on a regular basis: Every so often (between 10 times per second and 100 times per second on most operating systems) the OS tags each running thread and says, “your turn is up, go to the back of the run queue’ (i.e., change state from running to runnable). Then it lets whatever thread is at the head of the run queue use that CPU (i.e., become running again).</p>
<p>When your program calls <code>Thread.yield()</code>, it’s saying to the operating system, <strong>“I still have work to do, but it might not be as important as the work that some other thread is doing. Please send me to the back of the run queue right now.”</strong> If there is an available CPU for the thread to run on though, then it effectively will just keep running (i.e., the <code>yield()</code> call will immediately return).</p>
<p>When your program calls <code>foobar.wait()</code> on the other hand, it’s saying to the operating system, <strong>“Block me until some other thread calls <code>foobar.notify()</code></strong>.</p>
<p>Yielding was first implemented on non-preemptive operating systems and, in non-preemptive threading libraries. On a computer with <strong>只有一个 CPU</strong>, the only way that more than one thread ever got to run was when the threads <strong>明确地</strong> yielded to one another.</p>
<p>Yielding also was useful for <strong>忙等待</strong>. That’s where a thread waits for something to happen by sitting in a tight loop, testing the same condition over and over again. If the condition depended on some other thread to do some work, the waiting thread would <code>yield()</code> each time around the loop in order to let the other thread do its work.</p>
<p>Now that we have preemption and multiprocessor systems and libraries that provide us with higher-level synchronization objects, there is basically no reason why an application programs would need to call <code>yield()</code> anymore.</p>
<h3 id="为什么使用-SynchronousQueue"><a href="#为什么使用-SynchronousQueue" class="headerlink" title="为什么使用 SynchronousQueue"></a>为什么使用 <code>SynchronousQueue</code></h3><p>以下代码摘自 <a href="https://github.com/brettwooldridge/HikariCP/blob/61be9b923d8608605eb97264129d4f0467a0a2cc/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L77" target="_blank" rel="external">HikariCP</a> 在实现 <code>ConcurrentBag</code> 借与还的时候都用到的重要同步队列的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SynchronousQueue&lt;T&gt; handoffQueue;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentBag</span><span class="params">(<span class="keyword">final</span> IBagStateListener listener)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.handoffQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相应的这个 <code>handoffQueue</code> 在如下几种情况下都使用了:</p>
<ul>
<li><strong>借</strong>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> T bagEntry = handoffQueue.poll(timeout, NANOSECONDS);</div></pre></td></tr></table></figure>
<ul>
<li><strong>还</strong>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (bagEntry.getState() != STATE_NOT_IN_USE || handoffQueue.offer(bagEntry)) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>添加</strong>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (waiters.get() &gt; <span class="number">0</span> &amp;&amp; !handoffQueue.offer(bagEntry)) &#123;</div><div class="line">    yield();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>以下内容摘自 <a href="https://item.jd.com/11740734.html" target="_blank" rel="external">《Java 并发编程的艺术》</a>:</p>
<p><code>SynchronousQueue</code> 是一个不存储元素的阻塞队列。每一个 <code>put</code> 操作必须等待一个 <code>take</code> 操作，否则不能继续添加元素。它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的 <code>SynchronousQueue</code>，如果设置为 <code>true</code>，则<strong>等待的线程会采用先进先出的顺序访问队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SynchronousQueue</code> 可以看成是<strong>一个传球手，负责把生产者线程处理的数据<font color="red">直接</font>传递给消费者线程</strong>。队列本身并不存储任何元素，非常适合传递性场景。<code>SynchronousQueue</code> 的吞吐量高于 <code>LinkedBlockingQueue</code> 和 <code>ArrayBlockingQueue</code>。</p>
<hr>
<p>在 <a href="https://item.jd.com/11800589.html" target="_blank" rel="external">《实战 Java 高并发程序设计》</a> 中也有对其介绍，以下是部分摘抄:</p>
<p>对于 <code>SynchronousQueue</code> 来说，它将 <code>put()</code> 和 <code>take()</code> 两个功能截然不同的操作抽象为一个共通的方法 <code>Transferer.transfer()</code>，从字面意思上看，这就是数据传递的意思:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</div></pre></td></tr></table></figure>
<p>当 <code>e</code> 参数为<strong>非空</strong>时，表示当前操作传递给一个消费者，如果为空，则表示当前操作需要请求一个数据。如果返回值非空，则表示数据已经接受或者正常提供，如果为空，则表示失败（超时或者中断）。</p>
<hr>
<p>API 介绍与实现:</p>
<ul>
<li><code>offer()</code>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Inserts the specified element into this queue, waiting if necessary</span></div><div class="line"><span class="comment"> * up to the specified wait time for another thread to receive it.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (!Thread.interrupted())</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>poll()</code>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting</span></div><div class="line"><span class="comment"> * if necessary up to the specified wait time, for another thread</span></div><div class="line"><span class="comment"> * to insert it.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h3><p><code>CompletableFuture</code> 是 Java 8 新增的一个<strong>超大型工具类</strong>，它实现了 <code>Future</code> 接口，而更重要的是，它也实现了 <code>CompletionStage</code> 接口，拥有多达 40 种方法！</p>
<p>严重怀疑<a href="https://github.com/brettwooldridge/HikariCP/blob/47b827d11e26e961bcce457cbbfd28c3356c1ee8/src/main/java/com/zaxxer/hikari/pool/HikariPool.java#L311" target="_blank" rel="external">这个地方</a>其实用错了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBagItem</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> waiting)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldAdd = waiting - addConnectionQueue.size() &gt;= <span class="number">0</span>; <span class="comment">// Yes, &gt;= is intentional.</span></div><div class="line">    <span class="keyword">if</span> (shouldAdd) &#123;</div><div class="line">        addConnectionExecutor.submit(POOL_ENTRY_CREATOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CompletableFuture.completedFuture(Boolean.TRUE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="无锁修改状态"><a href="#无锁修改状态" class="headerlink" title="无锁修改状态"></a>无锁修改状态</h3><p>不用这种方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    state = newState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而采用无锁方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolEntry</span> <span class="keyword">implements</span> <span class="title">IConcurrentBagEntry</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></div><div class="line">        AtomicIntegerFieldUpdater&lt;PoolEntry&gt; stateUpdater;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        stateUpdater = AtomicIntegerFieldUpdater</div><div class="line">            .newUpdater(PoolEntry.class, <span class="string">"state"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stateUpdater.get(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stateUpdater.compareAndSet(<span class="keyword">this</span>, expect, update);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">        stateUpdater.set(<span class="keyword">this</span>, update);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><code>Updater</code> 使用<strong>反射</strong>得到这个变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> tclass.getDeclaredField(fieldName);</div></pre></td></tr></table></figure>
<ul>
<li>为了确保变量被正确的读取，它<strong>必须是 <code>volatile</code> 类型</strong>的。</li>
</ul>
<hr>
<p><code>AtomicIntegerFieldUpdater</code> 能够<strong>原子更新</strong>整型字段。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/zou90512/p/5559357.html" target="_blank" rel="external">面试总结 - 数据库连接池</a></li>
<li><a href="http://freeman1.iteye.com/blog/2268874" target="_blank" rel="external">数据库连接池性能比对</a></li>
<li><a href="https://www.oschina.net/p/hikaricp" target="_blank" rel="external">HikariCP 详细介绍</a></li>
<li><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="external">Github - HikariCP</a></li>
<li><a href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole" target="_blank" rel="external">Github - WIKI - Down the Rabbit Hole</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.kunzhao.org/2017/07/07/hikaricp/" data-id="cjc5qrt1q003k5cem9bdr0cyc" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
 <script src="/blog/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>Recommended Posts</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/blog/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/blog/2017/07/07/javaweb/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          javaweb
        
      </div>
    </a>
  
  
    <a href="/blog/2017/07/07/MySQL-High-Availability/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MySQL_High_Availability</div>
    </a>
  
</nav>

  
</article>
 
     
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">Content</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HikariCP-性能分析"><span class="toc-number">1.</span> <span class="toc-text">HikariCP 性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用-wait-还是用-yield"><span class="toc-number">1.1.</span> <span class="toc-text">用 wait() 还是用 yield()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用-SynchronousQueue"><span class="toc-number">1.2.</span> <span class="toc-text">为什么使用 SynchronousQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CompletableFuture"><span class="toc-number">1.3.</span> <span class="toc-text">CompletableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无锁修改状态"><span class="toc-number">1.4.</span> <span class="toc-text">无锁修改状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-number">1.5.</span> <span class="toc-text">参考</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 赵坤&nbsp;|&nbsp;
      Theme by <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      Contact&nbsp;|&nbsp;igozhaokun@163.com
    </div>
  </div>
</footer>
 <script src="/blog/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">首页</a>
  
    <a href="/blog/archives" class="mobile-nav-link">归档</a>
  
    <a href="/blog/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/blog/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>

      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js"></script>
  


 <script src="/blog/js/is.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>
<script src="/blog/js/elevator.js"></script>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>