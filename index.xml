<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>首页 on 赵坤的个人网站</title>
    <link>https://kunzhao.org/</link>
    <description>Recent content in 首页 on 赵坤的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 12 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://kunzhao.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>War 文件格式</title>
      <link>https://kunzhao.org/posts/war/</link>
      <pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/war/</guid>
      <description>WAR file (Web Application Resource or Web application ARchive)。WAR 组织文件的标准方式：
WEB-INF 存储在这个文件夹内的文件，默认情况下浏览器访问不到。
web.xml Tomcat 需要
classes 所有编译的 class 文件
lib 包含项目依赖的所有的 JAR 库
tags 包含 Tag 文件
参考  Web Modules  </description>
    </item>
    
    <item>
      <title>JSP</title>
      <link>https://kunzhao.org/posts/jsp/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/jsp/</guid>
      <description>JSP 脚本 脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。
&amp;lt;% 代码片段 %&amp;gt;JSP 声明 &amp;lt;%! int i = 0; %&amp;gt; &amp;lt;%! int a, b, c; %&amp;gt; &amp;lt;%! Circle a = new Circle(2.0); %&amp;gt; JSP 表达式 &amp;lt;p&amp;gt; 今天的日期是: &amp;lt;%= (new java.util.Date()).toLocaleString()%&amp;gt; &amp;lt;/p&amp;gt; JSP 注释 &amp;lt;%-- 该部分注释在网页中不会被显示--%&amp;gt; JSP 指令 &amp;lt;%@ directive attribute=&amp;quot;value&amp;quot; %&amp;gt;三种 directive：
   指令 描述     &amp;lt;%@ page &amp;hellip; %&amp;gt; 定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等   &amp;lt;%@ include &amp;hellip; %&amp;gt; 包含其他文件   &amp;lt;%@ taglib &amp;hellip; %&amp;gt; 引入标签库的定义，可以是自定义标签    &amp;lt;%@ page import=&amp;quot;java.</description>
    </item>
    
    <item>
      <title>IBM MQ</title>
      <link>https://kunzhao.org/posts/ibmmq/</link>
      <pubDate>Mon, 10 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/ibmmq/</guid>
      <description>IBM MQ 架构 IBM WebSphere MQ 架构：
IBM WheSphere MQ 特性：
 支持事务 具有特殊的技术防止消息重复传送，确保消息一次且仅一次传递  概念 消息 队列  本地队列：位于本地物理磁盘 远程队列：本地应用程序只能往里面放消息，不能直接读消息。只能从本地队列读取消息 传输队列：临时存储将要发送到远程队列的消息 启动队列：触发中使用的队列，触发器触发事件时，将触发器消息发送到启动队列 死信队列：存储无法正确发送到目的地的消息的队列  通道 通道：提供从一个队列管理器到另外一个队列管理器的通信路径
通道如何使用：
MQSC MQSC 是用来管理队列管理器等对象的脚本命令，可以使用 runmqsc 向队列管理器发出 MQSC 命令。
MQSC 的官方命令文档：The MQSC Commands
MQSC 的一些规则：
 关键字不区分大小写：ALTER、alter、AlteR 都是一样的 很多命令都有同义词：例如 DEFINE CHANNEL 可以写为 def chl 用单引号引用的字符串，IBM MQ 不做转换处理 每条命令必须以新行开始  Control Commands Control Commands 的官方文档：The control commands
发送消息步骤 发送消息前，需要启动队列管理器、启动监听器（监听在某个端口）。
为了把消息从一个队列管理器发送到另一个队列管理器，您需要定义两个通道；一个是在源队列管理器（指明传输队列名、目标系统的IP:PORT），另一个是在目标队列管理器。
为把消息从一个队列管理器发送到另一个队列管理器，您需要定义六个队列；在源队列管理器需要定义四个（远程队列、启动队列、传输队列、死信队列-推荐），目标队列管理器要定义两个（本地队列、死信队列-推荐）。
编程接口 Queue Manager // declare an object of type queue manager MQQueueManager queueManager = new MQQueueManager(); MQQueueManager queueManager = new MQQueueManager(&amp;#34;qMgrName&amp;#34;); .</description>
    </item>
    
    <item>
      <title>Spring Boot</title>
      <link>https://kunzhao.org/posts/springboot/</link>
      <pubDate>Mon, 10 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/springboot/</guid>
      <description>Spring Boot 提供了两个接口 CommandLineRunner 和 ApplicationRunner，用以当 Spring Boot 应用程序完全启动之前运行指定的代码。
CommandLineRunner @Component public class CommandLineAppStartupRunner implements CommandLineRunner { private static final Logger logger = LoggerFactory.getLogger(CommandLineAppStartupRunner.class); @Override public void run(String...args) throws Exception { logger.info(&amp;#34;Application started with command-line arguments: {} . \n To kill this application, press Ctrl + C.&amp;#34;, Arrays.toString(args)); } } ApplicationRunner 将参数封装为一个对象，可以调用 getOptionNames()、getOptionValues() 和 getSourceArgs() 等便捷的方法。
@Component public class AppStartupRunner implements ApplicationRunner { private static final Logger logger = LoggerFactory.getLogger(AppStartupRunner.class); @Override public void run(ApplicationArguments args) throws Exception { logger.</description>
    </item>
    
    <item>
      <title>JAX-WS</title>
      <link>https://kunzhao.org/posts/jax-ws/</link>
      <pubDate>Fri, 07 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/jax-ws/</guid>
      <description>JAX-WS JAX-WS 代表 Java API for XML Web Service。
WebService  @WebService 用来将**某个类(一个 Interface)**声明为一个 Web Service EndPoint，这个类的实现类也得需要声明 @WebService 接口类的方法必须 public，并且不能使用 static 或 final 来修饰 接口类的方法必须声明 @WebMethod 实现类必须有一个默认的 public 构造器 实现类不要定义 finalize 方法  Apache CXF 定义 Endpoint，此处的 endpointInterface 非常重要，指向的是 Interface 类全称。
@WebService(endpointInterface = &amp;#34;com.baeldung.cxf.introduction.Baeldung&amp;#34;) public class BaeldungImpl implements Baeldung {} 查看 WSDL 信息 URL 后面往往跟一个 ?wsdl 字符串。
底层数据传输 GET WSDL 发送 POST 请求 接受 POST 响应 阅读更多 java 实现WebService 以及不同的调用方式、JAX-WS Web 服务开发调用和数据传输分析</description>
    </item>
    
    <item>
      <title>Oracle</title>
      <link>https://kunzhao.org/posts/oracle/</link>
      <pubDate>Fri, 07 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/oracle/</guid>
      <description>内置数据类型    分类 数据类型 介绍     字符 CHAR [(size [BYTE | CHAR])] 定长字符串，占据 n 字节    NCHAR[(size)] 定长字符串，占据 2n 字节    VARCHAR2(size) 可变长度的字符串    NVARCHAR2(size) 可变长度的 UNICODE 字符串   数值 NUMBER(p,s) p 代表精度(1 - 38)，s 代表 scale (-84 - 127)    FLOAT [(p)] 小数，精度不高    LONG 仅仅为了兼容   日期 DATE 大小固定占用 7 bytes    TIMESTAMP    字节 RAW(size) 定长    LONG RAW 变长，图像、声音、文档、数组，建议使用 LOB    LOB     ROWID 伪列 SELECT ROWID from your_table;  ROWID 不能被用作主键。</description>
    </item>
    
    <item>
      <title>Ant</title>
      <link>https://kunzhao.org/posts/ant/</link>
      <pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/ant/</guid>
      <description>Ant 官方教程 官方教程链接
Ant Properties 提供一些键值对，使用 ${key} 来获取其 value。官网 列举了很多内置的 properties。
Ant Classpath 定义 classpath：
&amp;lt;project name=&amp;#34;HelloWorld&amp;#34; basedir=&amp;#34;.&amp;#34; default=&amp;#34;main&amp;#34;&amp;gt; &amp;lt;path id=&amp;#34;classpath&amp;#34;&amp;gt; &amp;lt;fileset dir=&amp;#34;${lib.dir}&amp;#34; includes=&amp;#34;**/*.jar&amp;#34;/&amp;gt; &amp;lt;/path&amp;gt; &amp;lt;target name=&amp;#34;compile&amp;#34;&amp;gt; &amp;lt;mkdir dir=&amp;#34;${classes.dir}&amp;#34;/&amp;gt; &amp;lt;javac srcdir=&amp;#34;${src.dir}&amp;#34; destdir=&amp;#34;${classes.dir}&amp;#34; classpathref=&amp;#34;classpath&amp;#34;/&amp;gt; &amp;lt;/target&amp;gt; &amp;lt;target name=&amp;#34;run&amp;#34; depends=&amp;#34;jar&amp;#34;&amp;gt; &amp;lt;java fork=&amp;#34;true&amp;#34; classname=&amp;#34;${main-class}&amp;#34;&amp;gt; &amp;lt;classpath&amp;gt; &amp;lt;path refid=&amp;#34;classpath&amp;#34;/&amp;gt; &amp;lt;path location=&amp;#34;${jar.dir}/${ant.project.name}.jar&amp;#34;/&amp;gt; &amp;lt;/classpath&amp;gt; &amp;lt;/java&amp;gt; &amp;lt;/target&amp;gt; &amp;lt;/project&amp;gt; Ant Targets Target 是多个 tasks 的容器，这个 Target 用来完成在整个 build 过程中的某个任务，使之达到某个状态。
&amp;lt;target name=&amp;#34;A&amp;#34;/&amp;gt; &amp;lt;target name=&amp;#34;B&amp;#34; depends=&amp;#34;A&amp;#34;/&amp;gt; &amp;lt;target name=&amp;#34;C&amp;#34; depends=&amp;#34;B&amp;#34;/&amp;gt; &amp;lt;target name=&amp;#34;D&amp;#34; depends=&amp;#34;C,B,A&amp;#34;/&amp;gt; 调用链：</description>
    </item>
    
    <item>
      <title>Struts 2</title>
      <link>https://kunzhao.org/posts/struts2/</link>
      <pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/struts2/</guid>
      <description>Action 访问 Servlet API 使用 ActionContext 来访问 Servlet API。
    Servlet API JSP 对象     HttpServletRequest request   HttpSession session   ServletContext application     操作 Session：
ActionContext.getContext().getSession().put(&amp;#34;user&amp;#34;, userName); 在 JSP 页面中可以通过
${sessionScope.user}来输出userName。
数据校验 ActionSupport 是一个工具类，已经实现了 Action 接口，实现了 Validatable 接口，提供数据校验功能。
@Override public void validate() { if (getUserName() == null || getUserName().trim().equals(&amp;#34;&amp;#34;)) { addFieldError(&amp;#34;username&amp;#34;, getText(&amp;#34;user.required&amp;#34;)); } } struts.xml 配置文件 分为多个配置文件：</description>
    </item>
    
    <item>
      <title>如何维持缓存的一致性？</title>
      <link>https://kunzhao.org/posts/maintaining-cache-consistency/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/maintaining-cache-consistency/</guid>
      <description>&lt;p&gt;Phil Karlton 曾经说过，“计算机科学中只有两件困难的事情：缓存失效和命名问题。” 这句话还有其他很好的举例。我个人最喜欢 Jeff Atwood 的一句话：“计算机科学中有两件困难的事情：缓存失效、命名和一个错误就关闭。”显然，缓存是困难的。就像分布式系统中的几乎所有东西一样，它甚至可能一眼就看不清。我将介绍分布式系统中几种常见的缓存方法，这些方法应该涵盖您将使用的绝大多数缓存系统。具体来说，我将关注如何维护缓存一致性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何改进 NGINX 配置文件节省带宽？</title>
      <link>https://kunzhao.org/posts/help-the-world-by-healing-your-nginx-configuration/</link>
      <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/help-the-world-by-healing-your-nginx-configuration/</guid>
      <description>&lt;p&gt;2014年，Admiral William H. McRaven 在得克萨斯大学发表了著名的演讲，他说，如果你想改变世界，就从整理床铺开始。有时候小事情会有很大的影响——不管是在早上整理床铺，还是对网站的HTTP服务器配置做一些更改。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock/</guid>
      <description>Best Time to Buy and Sell Stock 题目 LeetCode 地址：Best Time to Buy and Sell Stock
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行一次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 这道题有两个简单做法：状态机和动态规划。
使用状态机的做法的好处是，这种思路可以延续到其它几个买卖股票的问题上。关键是要想清楚，某一天有几种状态，在这道题是三种：
 状态 s0: 不买也不卖，无操作。s0 的值只能有一个来源，就是和昨天保持一致，不买也不卖 状态 s1: 买入了股票。s1 的值有两个来源：1. 与昨天一致，即已经买入了，且只能买一次，所以不能再买了，s1 = s1；2. 买入今天的股票，花了 price[i] 钱，s1 = s0 - price[i] 状态 s2: 卖出了股票。s2 的值有两个来源：1. 之前已经卖出了，所以维持卖出状态，不能再次卖了，s2 = s1；2. 卖出之前买入的股票，挣 price[i] 钱，s2 = s1 + price[i]  所以，我们可以得到如下状态转移关系：
 s0 = s0 s1 = s1 s1 = s0 - price[i] s2 = s2 s2 = s1 + price[i]  在这整个过程中，我们都要保证每一天的 s0、s1、s2 都是 max 状态，s2 是最终卖完后的收益，所以返回这个结果就行。</description>
    </item>
    
    <item>
      <title>Brave 收集数据</title>
      <link>https://kunzhao.org/docs/tutorial/zipkin/brave/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/zipkin/brave/</guid>
      <description>Brave 收集数据 在 Java 生态世界中，Zipkin 团队官方提供了 Brave 用来收集数据到 Zipkin Server 中。其它的用来收集数据的框架还有 cassandra-zipkin-tracing、Dropwizard Zipkin、htrace、Spring Cloud Sleuth 以及 Wingtips 等。
示例代码 配置 Tracer 配置 Tracer 以向 Zipkin Server 上传数据。
// Configure a reporter, which controls how often spans are sent // (this dependency is io.zipkin.reporter2:zipkin-sender-okhttp3) sender = OkHttpSender.create(&amp;#34;http://127.0.0.1:9411/api/v2/spans&amp;#34;); // (this dependency is io.zipkin.reporter2:zipkin-reporter-brave) zipkinSpanHandler = AsyncZipkinSpanHandler.create(sender); // Create a tracing component with the service name you want to see in Zipkin. tracing = Tracing.</description>
    </item>
    
    <item>
      <title>B站高可用架构实践</title>
      <link>https://kunzhao.org/docs/cloud-plus-bbs/bilibili-high-availability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/cloud-plus-bbs/bilibili-high-availability/</guid>
      <description>B站高可用架构实践 流量洪峰下要做好高服务质量的架构是一件具备挑战的事情，从Google SRE的系统方法论以及实际业务的应对过程中出发，分享一些体系化的可用性设计。对我们了解系统的全貌上下游的联防有更进一步的了解。
负载均衡 BFE 就是指边缘节点，BFE 选择下游 IDC 的逻辑权衡：
 离 BFE 节点比较近的 基于带宽的调度策略 某个 IDC 的流量已经过载，选择另外一个 IDC  当流量走到某个 IDC 时，这个流量应该如何进行负载均衡？
问题：RPC 定时发送的 ping-pong，也即 healthcheck，占用资源也非常多。服务 A 需要与账号服务维持长连接发送 ping-pong，服务 B 也需要维持长连接发送 ping-pong。这个服务越底层，一般依赖和引用这个服务的资源就越多，一旦有任何抖动，那么产生的这个故障面是很大的。那么应该如何解决？
解决：以前是一个 client 跟所有的 backend 建立连接，做负载均衡。现在引入一个新的算法，子集选择算法，一个 client 跟一小部分的 backend 建立连接。图片中示例的算法，是从《Site Reliability Engineering》这本书里看的。
如何规避单集群抖动带来的问题？多集群。
如上述图片所示，如果采用的是 JSQ 负载均衡算法，那么对于 LBA 它一定是选择 Server Y 这个节点。但如果站在全局的视角来看，就肯定不会选择 Server Y 了，因此这个算法缺乏一个全局的视角。
如果微服务采用的是 Java 语言开发，当它处于 GC 或者 FullGC 的时候，这个时候发一个请求过去，那么它的 latency 肯定会变得非常高，可能会产生过载。
新启动的节点，JVM 会做 JIT，每次新启动都会抖动一波，那么就需要考虑如何对这个节点做预热？
如上图所示，采用 &amp;ldquo;the choice-of-2&amp;rdquo; 算法后，各个机器的 CPU 负载趋向于收敛，即各个机器的 CPU 负载都差不多。Client 如何拿到后台的 Backend 的各项负载？是采用 Middleware 从 Rpc 的 Response 里面获取的，有很多 RPC 也支持获取元数据信息等。</description>
    </item>
    
    <item>
      <title>C &amp; C&#43;&#43;</title>
      <link>https://kunzhao.org/docs/tutorial/distributed-storage/c_cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed-storage/c_cpp/</guid>
      <description>C &amp;amp; C++  补充 C &amp;amp; C++ 知识点
 xx.a 文件 这是静态链接库文件。
undefined reference to pthread_create g++ -pthread ... 链接静态文件 文件组织形式：
|- include | - leveldb | - db.h | - cache.h | - xxx.h |- build | - libleveldb.a |test.c g++ test.c -I include/ -L build/ -l leveldb -pthread -o test.out ./test.out  include/ 文件夹中包含了头文件 build/ 文件夹包含了 libleveldb.a  参考</description>
    </item>
    
    <item>
      <title>createApp</title>
      <link>https://kunzhao.org/docs/tutorial/vue3/createapp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/vue3/createapp/</guid>
      <description>createApp 一个简单的计数器例子 创建渲染器 挂载 App 上下文 // apiCreateApp.ts export function createAppContext(): AppContext { return { app: null as any, config: { isNativeTag: NO, performance: false, globalProperties: {}, optionMergeStrategies: {}, isCustomElement: NO, errorHandler: undefined, warnHandler: undefined }, mixins: [], components: {}, directives: {}, provides: Object.create(null) } } </description>
    </item>
    
    <item>
      <title>DevOps 简介</title>
      <link>https://kunzhao.org/docs/tutorial/devops/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/devops/intro/</guid>
      <description>DevOps 简介 DevOps (Development 与 Operations) 是一种文化，这种文化旨在建立一个使得软件构建、测试、发布等得以快速、稳定，实施交付的环境。
那么如何做到快速？如何做到稳定？答案是自动化工具。开发到测试到上线之间的所有需要手动处理的环节，都是可以尝试优化的点。
DevOps 能力成熟度模型 全球首个 DevOps 标准，即《研发运营一体化（DevOps）能力成熟度模型》，由中国信息通信研究院牵头，云计算开源产业联盟、高效运维社区、 DevOps 时代社区联合 Google、BATJ、清华大学、南京大学、通信及金融等行业顶尖企事业单位专家共同制定。
目前很多公司都在参考这套模型进行实践。
DevOps 工具集锦 信通院整理的的 DevOps 工具集锦（看不清的话，图片上右击，在新标签页中打开图像）：
持续集成  每次提交代码，就会触发完整的流水线。这需要打通版本控制系统和持续集成系统，例如 GitLab 和 Jenkins 集成。 每次流水线，触发自动化测试。 出了问题，第一时间修复。  推荐书籍  《持续交付 2.0》 《DevOps 实践指南》  </description>
    </item>
    
    <item>
      <title>DHCP</title>
      <link>https://kunzhao.org/docs/tutorial/network/dhcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/dhcp/</guid>
      <description>DHCP DHCP 是 Dynamic Host Configuration Protocol (动态主机配置协议) 的缩写。
作用 手机、电脑或其它网络设备想要与其它计算机进行通讯，就需要配置 IP 地址，DHCP 协议就是为网络设备动态分配 IP 地址的一种协议。DHCP 底层基于 UDP 传输层协议，端口 67 是 DHCP Server 端使用的端口，端口 68 是 DHCP Client 端使用的接口。
工作方式 DHCP 协议分配 IP 地址可以分为 4 个步骤：
Discovery 网络中新加入的某个设备（DHCP 客户端），会使用 IP 地址 0.0.0.0 向该网络发送一个广播包，这个包的目的 IP 地址是 255.255.255.255。这个 UDP 包封装的内容如下所示：
   头 内容     MAC 头 源 MAC：设备自身的 MAC 地址，目的 MAC 地址：FF:FF:FF:FF:FF:FF   IP 头 源 IP: 0.</description>
    </item>
    
    <item>
      <title>fastjson 又现高危漏洞！</title>
      <link>https://kunzhao.org/docs/it-zone/2020-06/fastjson-high-risk-vulnerability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/it-zone/2020-06/fastjson-high-risk-vulnerability/</guid>
      <description>fastjson 又现高危漏洞！ 日期：2020-06-01
 5 月 28 日，据 360 网络安全响应中心发布《Fastjson远程代码执行漏洞通告》显示，由阿里巴巴开源的 fastjson 库 又现高危漏洞，该漏洞可导致不法分子远程执行服务器命令等严重后果。
fastjson 是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到 JavaBean。
fastjson 存在远程代码执行漏洞，autotype 开关的限制可以被绕过，链式的反序列化攻击者精心构造反序列化利用链，最终达成远程命令执行的后果。此漏洞本身无法绕过 fastjson 的黑名单限制，需要配合不在黑名单中的反序列化利用链才能完成完整的漏洞利用。
该漏洞影响的版本：&amp;lt;= 1.2.68
该漏洞修复建议：
 升级到 fastjson 1.2.69/1.2.70 版本，下载地址为 Releases · alibaba/fastjson 或者通过配置以下参数开启 SafeMode 来防护攻击：ParserConfig.getGlobalInstance().setSafeMode(true);（safeMode 会完全禁用 autotype，无视白名单，请注意评估对业务影响）  </description>
    </item>
    
    <item>
      <title>Git 配置用户名和邮箱</title>
      <link>https://kunzhao.org/docs/tutorial/git/config-user-and-email/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/config-user-and-email/</guid>
      <description>Git 配置用户名和邮箱 假设你的用户名是 zk，邮箱账号是 xxx@163.com，那么需要提前配置 Git 的用户名和邮箱帐号：
git config --global user.name &amp;#34;zk&amp;#34; git config --global user.email &amp;#34;xxx@163.com&amp;#34; Git 需要知道谁对代码做出了变更，对代码做出变更的这个人的邮件联系方式是什么，以方便追踪。
Git Config 有三个作用域：
 git config --local：只对某个仓库有效 git config --global：对当前用户所有仓库有效 git config --system：对系统所有登录的用户有效  如何查看当前设置的 Git 配置？
git config --list --local git config --list --global git config --list --system  --local 针对的是某个仓库，配置 --local 作用域的时候，需要进入到项目所在的目录才能配置或显示。
 </description>
    </item>
    
    <item>
      <title>grep</title>
      <link>https://kunzhao.org/docs/tutorial/unix-command/grep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-command/grep/</guid>
      <description>grep grep 命令如何使用？grep 命令的常见用法？
简介 grep 命令用于搜索文本。它在给定文件中搜索包含与给定字符串或单词匹配的行。它是 Linux 和类 Unix 系统中最有用的命令之一。让我们看看如何在 Linux 或类 Unix 系统上使用 grep。
grep 命令是一个包含 grep、egrep 和 fgrep 命令的大家族，都用于搜索文本。
常见用法 下面是一些标准的 grep 命令，通过示例说明了如何在Linux、macOS和Unix上使用 grep：
（1）在文件 foo.txt 中搜索单词 word
grep &amp;#39;word&amp;#39; foo.txt （2）在文件 foo.txt 中搜索单词 word，并且忽略大小写
grep -i &amp;#39;word&amp;#39; foo.txt 上述命令会把位于 foo.txt 文件中的 WORD、Word、word 等忽略大小写的 word 全部搜索出来。
（3）在当前目录以及所有子目录中查找单词 word
grep -R &amp;#39;word&amp;#39; .  注意：最后面有一个点，代表当前目录。-r 命令也是递归搜索，只是 -r 不会搜索符号链接文件。
 （4）搜索并显示单词 word 出现的次数
grep -c &amp;#39;word&amp;#39; foo.txt （5）只匹配单词 word</description>
    </item>
    
    <item>
      <title>Map</title>
      <link>https://kunzhao.org/docs/programmer-interview/data-structure/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/data-structure/map/</guid>
      <description>Map </description>
    </item>
    
    <item>
      <title>Netflix Eureka 简介</title>
      <link>https://kunzhao.org/docs/tutorial/eureka/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/eureka/intro/</guid>
      <description>Netflix Eureka 简介 Eureka 干什么 Eureka 是一套服务治理框架，其包含 Server 端和 Client 端。
架构 为什么需要服务治理 A 服务需要调用 B 服务，B 服务的 URL （可能不止一个）可以通过静态配置来维护，但是随着微服务越来越复杂，静态配置就会越来越难以维护，且维护需要耗费好多人力。
服务治理包括什么    组件 描述     注册中心 每个服务需要向注册中心注册自己提供的服务   服务发现 调用方向注册中心咨询自己调用的服务的地址是什么    </description>
    </item>
    
    <item>
      <title>RocketMQ 消息发送流程</title>
      <link>https://kunzhao.org/docs/rocketmq/rocketmq-send-message-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/rocketmq/rocketmq-send-message-flow/</guid>
      <description>RocketMQ 消息发送流程 本文讲述 RocketMQ 发送一条普通消息的流程。
一、服务器启动 我们可以参考官方文档来启动服务:
 启动 Name 服务器:  sh bin/mqnamesrv  启动 Broker 服务器:  sh bin/mqbroker -n localhost:9876 二、构建消息体 一条消息体最少需要指定两个值:
 所属话题 消息内容  如下就是创建了一条话题为 “Test”，消息体为 “Hello World” 的消息:
Message msg = new Message( &amp;#34;Test&amp;#34;, &amp;#34;Hello World&amp;#34;.getBytes() ); 三、启动 Producer 准备发送消息 如果我们想要发送消息呢，我们还需要再启动一个 DefaultProducer (生产者) 类来发消息:
DefaultMQProducer producer = new DefaultMQProducer(); producer.start(); 现在我们所启动的服务如下所示:
四、Name 服务器的均等性 注意我们上述开启的是单个服务，也即一个 Broker 和一个 Name 服务器，但是实际上使用消息队列的时候，我们可能需要搭建的是一个集群，如下所示:
在 RocketMQ 的设计中，客户端需要首先询问 Name 服务器才能确定一个合适的 Broker 以进行消息的发送:</description>
    </item>
    
    <item>
      <title>图片优化</title>
      <link>https://kunzhao.org/docs/tutorial/front-end-optimization-guide/image-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/front-end-optimization-guide/image-optimization/</guid>
      <description>图片优化 图片在网页数据的传输中占据了非常大的流量，如何优化图片，对于前端页面加载的性能极其重要。本文讲述了比较常见的几种优化图片的技巧。
图片格式介绍 （1）JPEG
JPEG 是 Joint Photographic Experts Group 的缩写，不支持透明度，常用于网站的 Banner 图。JPEG 使用的是一种有损图像质量的压缩算法，压缩的越狠，图片的质量损失也就越大，图片的尺寸也就越小。根据你网站所能忍受的图片质量，来相应的选择压缩比：
（2）PNG
支持透明度，支持无损压缩，一般图片的尺寸都比较大。
（3）GIF
适合放动画图片。
（4）WebP
🔥Google 2010 年提出的新的图像压缩格式算法，在 2013 年又推出 Animated WebP，即支持动画的 Webp。优点：更优的图像数据压缩算法、拥有肉眼识别无差异的图像质量、具备了无损和有损的压缩模式、Alpha 透明以及动画的特性。
PNG、JPG、WebP 压缩对比：
GIF 和 WebP 对比：
不同网络环境，加载不同尺寸图片 如下是京东网站首页占据 C 位的宣传图：
它的 URL 地址如下，你任意改变这张图片的 URL 里面的宽、高，放到浏览器里面重新进行请求，就可以得到相应大小的图片：
响应式图片 不同平台设备加载不同大小、甚至不同内容的图片！
CSS 媒体查询 @media all and (max-width: 600px) { img { width: 300px; } } @media all and (min-width: 600px) and (max-width: 1200px) { img { width: 900px; } } srcset、sizes、picture 和 source （1）srcset 属性</description>
    </item>
    
    <item>
      <title>数学之美</title>
      <link>https://kunzhao.org/docs/books/beauty_of_mathematics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/beauty_of_mathematics/</guid>
      <description>数学之美 2000多年前，古埃及人在罗塞塔石碑上，用三种文字记录了托勒密五世登基的诏书，这帮助后人破解了古埃及的象形文字，让我们了解了5000年前古埃及的历史。可见信息冗余是信息安全的保障，这对于信息编码具有重要指导意义。
犹太人为了避免抄错《圣经》，发明了一种校验码的方法，他们把每一个希伯来字母对应于一个数字，这样每行文字加起来便得到一个特殊的数字，这样的数字变成为了这一行的校验码。
隐含马尔可夫链成功应用在机器翻译、拼写纠错、手写体识别、图像处理、基因序列分析、股票预测和投资等方面。
如何准确的识别出一个快递地址，写一个分析器去分析这些描述恐怕是不行的，因为地址是比较复杂的上下文有关的文法。答案是使用有限状态机。当用户输入的地址不太标准或有错别字的时候，有限状态机会束手无措，因为有限状态机是严格匹配的，所以科学家提出了基于概率的有限状态机。
2002 年，Google 想要做一个全新的中、日、韩搜索算法，吴军写的算法比较简单，但是占用内存比较多，Google 服务器数量还没有那么多。辛格提出，用一个拟合函数替换很耗内存的语言模型，无需增加任何服务器，但是搜索质量会降到 80%。辛格指出，这样可以提早两个月将这个新算法提供给中国的用户，用户体验会有质的提高。辛格做事情的哲学，先帮助用户解决 80% 的问题，再慢慢解决剩下的 20% 的问题，是在工业界成功的秘诀之一。
新闻分类的关键在于计算出两篇新闻的相似度，每篇新闻变成一个向量，最后余弦定理可以计算出来相似度。但两两计算的迭代次数太多，如何一次性就把所有新闻的相关性计算出来呢？答案是矩阵运算中的奇异值分解。
如何判断两个集合是否相同？一种答案是双层 for 循环一一比较，复杂度 O(N^2)；稍好一点的办法是对集合进行排序，然后顺序比较，时间复杂度 O(NlogN)；还可以将一个集合的元素放到散列表里面，另外一个与之一一对比，时间复杂度 O(N)，但是额外使用了 O(N) 的空间，不完美；最完美的是计算这两个集合的指纹，对一个集合中的元素分别计算指纹，然后一一相加。
如何判断两个集合基本相同？答案是 Simhash。判断两个网页是否重复，也没有必要完全从头比到尾，只需要每个网页挑选出几个词 (IDF 最大的几个词)，构成特征词，然后计算信息指纹即可。判断一篇文章是否抄袭另外一篇文章，每篇文章切成小的片段，挑选特征词，并计算指纹。YouTuBe 如何从上百万视频中找出一个视频是否另外一个视频的盗版？其核心在于关键帧的提取和特征的提取。关键帧对于视频的重要性，就如同主题词对于新闻的重要性一样。
最大熵原理指出，对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设，这种情况下，概率分布最均匀，预测的风险最小。例如拼音输入法，Wang-Xiao-Bo 转换为王晓波和王小波，唯一确定用户需要的是哪一个，非常难。</description>
    </item>
    
    <item>
      <title>架构</title>
      <link>https://kunzhao.org/docs/tutorial/sentinel/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/sentinel/architecture/</guid>
      <description>架构 随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。
有关 Sentinel 更为详细的使用文档和介绍请移至 Sentinel Github Wiki。
主要特性 流量控制 流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：
熔断降级 除了流量控制以外，及时对调用链路中的不稳定因素进行熔断也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，可能会导致请求发生堆积，进而导致级联错误。
网关限流 Sentinel 支持对 Spring Cloud Gateway、Zuul 等主流的 API Gateway 进行限流。
架构 另外一幅更为漂亮的图：
可扩展性 开源生态 参考  Sentinel Wiki  </description>
    </item>
    
    <item>
      <title>理解 This 关键字</title>
      <link>https://kunzhao.org/docs/javascript/understand-this-keyword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/javascript/understand-this-keyword/</guid>
      <description>理解 This 关键字 JavaScript 中的 this 所指向的对象，取决于上下文以及函数被调用的方式，本文列举了几种常见的情况，帮助大家理解。
一、全局上下文 当直接在一个全局的上下文中，使用 this 指针的时候，this 指针会指向到全局对象上。例如在浏览器的调试工具栏中直接打印 this 指针，其指向的是 Window 对象：
在 node 中打印 this 指针，其指向的是 node 提供的全局对象，其中包含了进程信息等：
二、Function 上下文 在 Function 上下文中，this 的值取决于 function 是如何被调用的。
(1) Function 调用 当 this 指针定义在一个 function 中，那么此 this 仍然会指向全局对象：
function foo() { console.log(this) } foo(); // Window {parent: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …} (2) 严格模式下的 Function 调用 如果在严格模式下定义的 function 的话，this 指针的值将会是 undefined：
function foo() { &amp;#39;use strict&amp;#39;; console.</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://kunzhao.org/docs/tutorial/awk/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/awk/intro/</guid>
      <description>简介 AWK 是一门编程语言。
开始 假设您有一个名称为 emp.data 文件，里面存储的内容包含姓名、每小时的薪资、工作的小时，如下所示：
Beth 4.00 0 Dan 3.75 0 Kathy 4.00 10 Mark 5.00 20 Mary 5.50 22 Susie 4.25 18 现在你想要打印工作超过 0 小时的员工的姓名和薪资，对于 AWK 而言，这相当简单：
awk `$3 &amp;gt; 0 { print $1, $2 * $3 }` emp.data 你会得到如下输出：
Kathy 40 Mark 100 Mary 121 Susie 76.5 位于引号中的内容就是 AWK 的完整代码。$3 &amp;gt; 0，会匹配文件的每一行，看这每一行的第 3 列是否大于 0。{ print $1, $2 * $3 } 打印第一列，以及第二列和第三列的乘积。
如果你想要打印出工作小时数是 0 的员工姓名：
awk `$3 == 0 { print $1 }` emp.</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://kunzhao.org/docs/programmer-interview/design-pattern/observer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/design-pattern/observer/</guid>
      <description>观察者模式 JavaScript class EventObserver { constructor() { this.observers = []; } subscribe(fn) { this.observers.push(fn); } unsubscribe(fn) { this.observers = this.observers.filter((subscriber) =&amp;gt; subscriber !== fn); } broadcast(data) { this.observers.forEach((subscriber) =&amp;gt; subscriber(data)); } } 发布订阅者模式 其实遵循的就是观察者模式
// publisher // Subscriber // unsubscribe // Some place to store callbacks that are registered from subscribers.  function pubSub() { // object which will track of all events and subscription  const subscribers = {} // Publisher:  function publish(eventName, data) { // return if event is not subscribed  if (!</description>
    </item>
    
    <item>
      <title>信息的半衰期</title>
      <link>https://kunzhao.org/posts/half-life-of-information/</link>
      <pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/half-life-of-information/</guid>
      <description>&lt;p&gt;今天，我想与您讨论一下信息能存活多久的问题，这个问题又会如何影响我们工作的方式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅱ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-2/</guid>
      <description>Best Time to Buy and Sell Stock Ⅱ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅱ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你可以进行无限次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 这道题就一个想法，只要今天 price[i] 比昨天 price[i - 1] 的价格涨了，就可以算作是有效的利润，累加到最后的结果中。
答案 // 假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。 // 设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。 // 然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。 // // https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-ii/description public class BestTimetoBuyandSellStockII { public int maxProfit(int[] prices) { int max = 0; for (int i = 1; i &amp;lt; prices.length; i++) { int diff = prices[i] - prices[i - 1]; if (diff &amp;gt; 0) { max += diff; } } return max; } } 扫描下面二维码，在手机上阅读这篇文章：</description>
    </item>
    
    <item>
      <title>find</title>
      <link>https://kunzhao.org/docs/tutorial/unix-command/find/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-command/find/</guid>
      <description>find find 命令的常见用法有哪些？find 命令的例子。
简介 Linux Find命令是类Unix操作系统中最重要、最常用的命令行实用程序之一。find 命令可以，根据不同的查找条件，来查询匹配不同的文件或目录列表。
find 可用于根据各种条件查找，例如您可以按权限、用户、组、文件类型、日期、大小和其他可能的条件查找文件。
通过本文，我们将以示例的形式分享我们的日常Linux find命令体验及其使用。
格式 find [path...] [test...] [action...]  path：find 命令的第一件事，查看每个路径 test：对于遇到的每个文件，find 应用测试条件 action：一旦搜索完成，find 对每个文件执行相应的操作  路径示例：
 find /usr/bin find / find . find ~  测试示例：
 -name pattern：包含 pattern 的文件名 -iname pattern：包含 pattern 的文件名（忽略大小写） -type [df]：文件类型，d 代表目录，f 代表文件 -perm mode：设置为 mode 的文件权限 -user userid：用户为 userid -group groupid：组为 groupid -size [-+]n[cbkMG]：大小为 n[字符(字节)、块、千字节、兆字节、吉字节] -empty：空文件 -amin [-+]n：n 分钟之前访问 -anewer file：file 文件之后访问 -atime [-+]n：n 天之前访问 -cmin [-+]n：n 分钟之前状态改变 -cnewer file：file 文件之后状态改变 -ctime [-+]n：n 天状态之前改变 -mmin [-+]n：n 分钟之前修改 -mtime [-+]n：n 天之前修改 -newer file：file 文件之后修改   - 代表：小于，+ 代表：大于</description>
    </item>
    
    <item>
      <title>HTML 优化</title>
      <link>https://kunzhao.org/docs/tutorial/front-end-optimization-guide/html-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/front-end-optimization-guide/html-optimization/</guid>
      <description>HTML 优化 本文通过一些案例讲述了常见的优化 HTML 的几种小技巧：减少 DOM 树、精简 HTML 文件大小等。
优化 DOM 节点树 去除页面除首屏外的对于用户不可见的信息区块，可以让页面的 DOM 节点数更少，DOM 树结构更简单，然后再使用懒加载异步化请求，去动态加载这些不可见的信息区块。
在《大型网站性能优化实战》这本书中，作者为了优化搜索页面的渲染瓶颈问题，将首屏以下的 33 各搜索结果对应的 HTML 代码放到 &amp;lt;textarea&amp;gt; 节点中，当该区域处于可见状态时，再从 TextArea 中取出 HTML 代码，恢复到 DOM 树中进行渲染。这样一来，页面首次渲染的 DOM 树所包含的节点数大幅度减少，从而有效提高了首次渲染速度。
多个空格合并为一个空格 通过将多个空格合并为一个空格，可以减少 HTML 的大小，从而缩短传输 HTML 文件所需的时间。通常在编写 HTML 文件的时候，总是倾向于格式化它，以方便我们人类阅读，所以这个文件中填充了许多空格，但这些空格对于浏览器来说是用不到的。在替换空格的时候，需要保留 &amp;lt;pre&amp;gt;、&amp;lt;textarea&amp;gt;、&amp;lt;script&amp;gt;、&amp;lt;style&amp;gt; 中的空格。
不过，如果你的网页中使用了 white-space: pre 这个 CSS 属性就要小心了，这个属性可以避免让多个空格压缩为一个，在实际开发网站的时候，其实也很少用到这个属性。如果确实需要，那么就放弃把 HTML 的多个空格合并为一个空格吧。
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello, world! &amp;lt;/title&amp;gt; &amp;lt;script&amp;gt; var x = &amp;#39;Hello, world!&amp;#39;;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; Hello, World! &amp;lt;pre&amp;gt; Hello, World! &amp;lt;/pre&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 转为：</description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://kunzhao.org/docs/tutorial/network/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/http/</guid>
      <description>HTTP 常见状态码    状态码 含义     1xx Information response   100 continue   101 Switching Protocols   2xx success   200 OK: 成功响应   201 Created   202 Accepted   204 No Content: 服务器已经成功处理请求，没有返回任何 Body (比如服务器收到一个发邮件的请求，服务器返回 204，表示已经收到请求，邮件后续会发送)   206 Partial Content: 服务器返回了某个文件的一部分   3xx redirection   301 Moved Permanently: 永久重定向   302 Found: 临时重定向   304 Not Modified: 浏览器通过 If-None-Match 头或 If-Modified-Since 头询问，服务器告知文件未改动   4xx client errors   400 Bad Request: 客户端发送的 HTTP 有语法错误、太大、帧错误等   401 Unauthorized   403 Forbidden   404 Not Found   405 Method Not Allowed   429 Too Many Requests   5xx server errors   500 Internal Server Error   502 Bad Gateway   503 Service Unavailable   504 Gateway Timeout    HTTP 方法    方法 含义     GET 获取数据   HEAD 与 GET 类似，但只返回响应头   POST 提交表单   PUT 用一个新的资源完全替换掉服务器的资源   DELETE 删除资源   CONNECT 建立一个 tunnel   OPTIONS 询问服务器支持哪些方法   TRACE 发起环回诊断，主要用于诊断   PATCH 对服务器资源进行部分更新    HTTP 报文 在浏览器中输入 &amp;ldquo;kunzhao.</description>
    </item>
    
    <item>
      <title>JavaScript 数组</title>
      <link>https://kunzhao.org/docs/javascript/javascript-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/javascript/javascript-array/</guid>
      <description>JavaScript 数组 使用 JavaScript 在编程的时候，我们有很大一部分时间都是在与数组打交道，因此对数组常见的方法做到灵活的运用至关重要。本文整理了和 JavaScript 数组相关的，日常经常需要的功能和使用技巧，供大家参阅。
从数组中移除指定元素 查阅 JavaScript 的数组 API，发现其并没有提供一个像 remove(obj) 或 removeAll(obj) 此类的方法，供我们方便的删除对象，因此我们需要通过使用其它的 API 来达到我们移出元素的目的。
(1) 使用 splice 方法 splice 方法可以从指定索引处，向数组中添加元素或者删除元素，其会直接在原数组上改变，因此通过此方法可以达到我们的目的。但是在移除元素之前，我们必须首先通过 indexOf 方法找到我们的元素在数组中处于的索引位置。
const array = [2, 5, 9]; const index = array.indexOf(5); if (index &amp;gt; -1) { array.splice(index, 1); // 1 代表删除 1 个元素 } console.log(array) 当然，如果你不想使用 indexOf 的话，也可以直接从后向前遍历整个数组，对每个符合要求的元素都使用 splice 方法：
const array = [2, 5, 9]; for (var i = array.length; i--; ) { if (array[i] === 5) { array.</description>
    </item>
    
    <item>
      <title>LeapArray</title>
      <link>https://kunzhao.org/docs/tutorial/sentinel/leaparray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/sentinel/leaparray/</guid>
      <description>LeapArray Sentinel 底层采用高性能的滑动窗口数据结构 LeapArray 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。
主要数据结构 protected int windowLengthInMs; protected int sampleCount; protected int intervalInMs; protected final AtomicReferenceArray&amp;lt;WindowWrap&amp;lt;T&amp;gt;&amp;gt; array;  intervalInMs 代表滑动窗口的总时间长度 sampleCount 表示要将 intervalInMs 切割成多少份，也就是滑动窗口中有多少个 bucket windowLengthInMs 表示每一份代表多长时间 array 表示的是底层的数组，即这么多份 bucket 构成的数组  根据时间戳定位某个 Bucket （1）获取对应的索引
long timeId = timeMillis / windowLengthInMs; // Calculate current index so we can map the timestamp to the leap array. return (int)(timeId % array.length()); （2）计算当前 Bucket 开始的时间
long windowStart = timeMillis - timeMillis % windowLengthInMs; （3）如果此 Bucket 不存在，创建并 CAS 更新</description>
    </item>
    
    <item>
      <title>leveldb 源码分析与实现</title>
      <link>https://kunzhao.org/docs/tutorial/distributed-storage/leveldb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed-storage/leveldb/</guid>
      <description>leveldb 源码分析与实现  源代码基于 1.22 之后的版本
 特性 leveldb 是一个键值对 library，它的键是有序排列的，用户也可以提供自定义的键比较器，多个操作也可以合并为一起，进行原子操作更新。其架构如下:
编译 mkdir -p build &amp;amp;&amp;amp; cd build cmake -DCMAKE_BUILD_TYPE=Release .. &amp;amp;&amp;amp; cmake --build . 如果 Ubuntu 提示 No CMAKE_CXX_COMPILER could be found :
sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install build-essential 打开数据库 Options // Options to control the behavior of a database (passed to DB::Open) struct LEVELDB_EXPORT Options { // Create an Options object with default values for all fields.</description>
    </item>
    
    <item>
      <title>Patterns</title>
      <link>https://kunzhao.org/docs/tutorial/awk/patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/awk/patterns/</guid>
      <description>Patterns Patterns 控制是否执行 actions，只有当 pattern 匹配的时候，才会执行 action。
本文介绍六种常用的 pattern：
 BEGIN { statements }：所有行处理之前执行一次 BEGIN END { statements }：所有行处理完了执行一次 END expression { statements }：普通的表达式 /正则表达式/ { statements }：匹配正则 组合表达式 { statements }：使用 &amp;amp;&amp;amp; 或 || 或 ! 进行组合 pattern1, pattern2 { statements }：范围匹配  BEGIN 和 END BEGIN 和 END 只会执行一次，BEGIN 是在开始执行前执行，END 是在结束前执行。
一种常见的使用 BEGIN 的用法是改变默认的列分割符，列分割符默认被一个内置变量 FS 所控制，这个变量的默认值是空格或者tabs。如下示例在 BEGIN 中设置了 FS 为 \t，同时打印了表头。在 END 块中打印了面积和人口的总和。
BEGIN { FS = &amp;#34;\t&amp;#34; printf(&amp;#34;%10s %6s %5s %s\n\n&amp;#34;, &amp;#34;COUNTRY&amp;#34;, &amp;#34;AREA&amp;#34;, &amp;#34;POP&amp;#34;, &amp;#34;CONTINENT&amp;#34;) } { printf(&amp;#34;%10s %6d %5d %s\n&amp;#34;, $1, $2, $3, $4) area = area + $2 pop = pop + $3 } END { printf(&amp;#34;\n%10s %6d %5d\n&amp;#34;, &amp;#34;TOTAL&amp;#34;, area, pop) } expression 表达式示例：</description>
    </item>
    
    <item>
      <title>RocketMQ 消息存储流程</title>
      <link>https://kunzhao.org/docs/rocketmq/rocketmq-message-store-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/rocketmq/rocketmq-message-store-flow/</guid>
      <description>RocketMQ 消息存储流程 本文讲述 RocketMQ 存储一条消息的流程。
一、存储位置 当有一条消息过来之后，Broker 首先需要做的是确定这条消息应该存储在哪个文件里面。在 RocketMQ 中，这个用来存储消息的文件被称之为 MappedFile。这个文件默认创建的大小为 1GB。
一个文件为 1GB 大小，也即 1024 * 1024 * 1024 = 1073741824 字节，这每个文件的命名是按照总的字节偏移量来命名的。例如第一个文件偏移量为 0，那么它的名字为 00000000000000000000；当当前这 1G 文件被存储满了之后，就会创建下一个文件，下一个文件的偏移量则为 1GB，那么它的名字为 00000000001073741824，以此类推。
默认情况下这些消息文件位于 $HOME/store/commitlog 目录下，如下图所示:
二、文件创建 当 Broker 启动的时候，其会将位于存储目录下的所有消息文件加载到一个列表中:
当有新的消息到来的时候，其会默认选择列表中的最后一个文件来进行消息的保存:
public class MappedFileQueue { public MappedFile getLastMappedFile() { MappedFile mappedFileLast = null; while (!this.mappedFiles.isEmpty()) { try { mappedFileLast = this.mappedFiles.get(this.mappedFiles.size() - 1); break; } catch (IndexOutOfBoundsException e) { //continue;  } catch (Exception e) { log.</description>
    </item>
    
    <item>
      <title>Rust 语言首次进入 Tiobe 前 20 名</title>
      <link>https://kunzhao.org/docs/it-zone/2020-06/rust-enter-top-20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/it-zone/2020-06/rust-enter-top-20/</guid>
      <description>Rust 语言首次进入 Tiobe 前 20 名 日期：2020-06-02
 Rust 在 Tiobe 上的排名已大大提高，从去年的38位上升到今天的20位。Tiobe 的索引基于主要搜索引擎上对某种语言的搜索，因此这并不意味着更多的人正在使用 Rust，但是它表明更多的开发人员正在搜索有关该语言的信息。
在 Stack Overflow 的2020年调查中， Rust 被开发人员连续第五年票选为最受欢迎的编程语言。今年，有86％的开发人员表示他们热衷于使用Rust，但只有5％的开发人员实际将其用于编程。
另一方面，由于Microsoft已公开预览其针对Windows运行时（WinRT）的 Rust 库，因此它可能会得到更广泛的使用 ，这使开发人员可以更轻松地在Rust中编写Windows，跨平台应用程序和驱动程序。
Tiobe软件首席执行官Paul Jansen说，Rust的崛起是因为它是一种“正确的”系统编程语言。
然而，Rust 项目的2020年开发人员调查发现，由于其陡峭的学习曲线以及很少有公司使用它，用户难以采用该语言。 Google 在新的Fuchsia OS 排除了 Rust 语言，因为很少有开发人员对此感到熟悉。</description>
    </item>
    
    <item>
      <title>Spring Cloud Eureka 示例</title>
      <link>https://kunzhao.org/docs/tutorial/eureka/demo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/eureka/demo/</guid>
      <description>Spring Cloud Eureka 示例 搭建服务注册中心 假设你使用的是 Maven，pom.xml 文件内容如下所示：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.3.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;service-registration-and-discovery-service&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;service-registration-and-discovery-service&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;spring-cloud.version&amp;gt;Hoxton.SR1&amp;lt;/spring-cloud.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;/project&amp;gt; 启动一个服务注册中心 @EnableEurekaServer @SpringBootApplication public class ServiceRegistrationAndDiscoveryServiceApplication { public static void main(String[] args) { SpringApplication.</description>
    </item>
    
    <item>
      <title>上帝掷骰子吗</title>
      <link>https://kunzhao.org/docs/books/history_of_quantum_physics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/history_of_quantum_physics/</guid>
      <description>上帝掷骰子吗-量子物理史话 1887年德国，赫兹在实验室证实了电磁波的存在，也证实了光其实是电磁波的一种，两者具有共同的波的特性，古老的光学终于可以被完全包容于新兴的电磁学里面。1901年，赫兹死后的第 7 年，无线电报已经可以穿越大西洋，实现两地的实时通讯了。
赫兹铜环接收器的缺口之间不停地爆发着电火花，明白无误地昭示着电磁波的存在。但偶然间，赫兹又发现了一个奇怪的现象：当有光照射到这个缺口上的时候，似乎火花就出现得更容易一些。
 量子就是能量的最小单位，就是能量里的一美分。一切能量的传输，都只能以这个量为单位来进行，它可以传输一个量子，两个量子，任意整数个量子，但却不能传输1 又1/2 个量子，那个状态是不允许的，就像你不能用现钱支付1 又1/2 美分一样。这个值，现在已经成为了自然科学中最为 重要的常数之一，以它的发现者命名，称为“普朗克常数”，用 h 来表示。
在后来十几年的时间里，普朗克一直认为量子的假设并不是一个物理真实，而纯粹是一个为了方便而引入的假设而已。他不断地告诫人们，在引用普朗克常数 h 的时候，要尽量小心谨慎，不到万不得已千万不要胡思乱想。</description>
    </item>
    
    <item>
      <title>创建 Git 仓库</title>
      <link>https://kunzhao.org/docs/tutorial/git/create-repository/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/create-repository/</guid>
      <description>创建 Git 仓库 （1）已有项目使用 Git 管理
假设你的项目所在文件夹叫做：abc_project
cd abc_project git init （2）新建项目直接使用 Git 管理
假设新建的项目名为 xxx_project
git init xxx_project </description>
    </item>
    
    <item>
      <title>穗康小程序口罩预约前后端架构及产品设计</title>
      <link>https://kunzhao.org/docs/cloud-plus-bbs/suikang-mini-program-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/cloud-plus-bbs/suikang-mini-program-design/</guid>
      <description>穗康小程序口罩预约前后端架构及产品设计 在战“疫”期间，腾讯与广州市政府合作，在小程序“穗康”上，2天内上线了全国首款口罩预约功能，上线首日访问量1.7亿，累计参与口罩预约人次1400万+。那么，它是如何在2天内开发上线，扛住了超大并发量呢？其背后的前后端架构是怎样的？
无损服务设计 整个流程下来需要 3 个实时接口：
 药店当前口罩的库存情况 哪个时间段有名额 提交预约实时返回结果  有损服务设计 结果，口罩预约关注度远超预期：
下面展示的 UI 的设计：
为什么有 “损” 平衡的理论就是 CAP 理论、BASE 最终一致性：
牺牲强一致换取高可用 两个机房需要同步，并发性差。以下是优化后的代码，引入计时器：
降低了专线依赖。
怎么 &amp;ldquo;损&amp;rdquo;  放弃绝对一致，追求高可用和快速响应 万有一失，用户重试 伸缩调度，降级服务  （1）穗康小程序 引入消息队列，最终一致：
（2）QQ 相册负载高 选择扩容？带宽和存储成本高。
（3）转账 用户重试极少量消息。再想一下微信的红色感叹号，点一下重新发送。
（4）穗康的预约重试 （5）QQ 相册降级 </description>
    </item>
    
    <item>
      <title>分布式系统一致性问题</title>
      <link>https://kunzhao.org/posts/consistency-problem-of-the-distrubuted-system/</link>
      <pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/consistency-problem-of-the-distrubuted-system/</guid>
      <description>&lt;p&gt;描述解决分布式系统一致性问题的典型思路!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅲ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-3/</guid>
      <description>Best Time to Buy and Sell Stock Ⅲ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅲ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行两次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 参考 Best Time to Buy and Sell Stock 思路上状态机，状态机应用两次即可。
答案 // 最多两次交易 // 且不能同时持有，必须卖掉这个，然后持有另外一个 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ // public class BestTimetoBuyandSellStockIII { // Buy Sell Buy Sell  // s0 ----&amp;gt; s1 -----&amp;gt; s2 -----&amp;gt; s3 ------&amp;gt; s4 (end)  // ↑___| ↑__| ↑____| ↑___|  //  public int maxProfit(int[] prices) { if (prices == null || prices.</description>
    </item>
    
    <item>
      <title>CSS 优化</title>
      <link>https://kunzhao.org/docs/tutorial/front-end-optimization-guide/css-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/front-end-optimization-guide/css-optimization/</guid>
      <description>CSS 优化 本文讲述在实际工作中如何优化 CSS，提升页面加载的性能！
避免使用 @import @import url(&amp;#34;base.css&amp;#34;); @import url(&amp;#34;layout.css&amp;#34;); @import url(&amp;#34;carousel.css&amp;#34;); 由于 @import 属性允许相互之间嵌套引入，因此浏览器必须串行的去下载每一个 @import 引入的文件，因此会增加下载 CSS 文件的时间，而使用 &amp;lt;link&amp;gt; 就可以并行下载 CSS 文件，可有效提升 CSS 加载的性能：
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;base.css&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;layout.css&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;carousel.css&amp;#34;&amp;gt; 简化 CSS 选择器 浏览器是从右向左逐步解析选择器表达式的，例如 #id .class &amp;gt; ul a 。首先找到页面上所有匹配 a 的节点，然后找到所有 ul 元素，并且将 a 元素恰好是 ul 元素子节点的元素过滤出来，直至解析到最左侧的选择器 #id 。
如下是在网站上针对 50000 个元素使用不同 CSS 选择器选择元素的时间对比：
   选择器 查询时间(ms)     div 4.8740   .</description>
    </item>
    
    <item>
      <title>Git 查看文件差异</title>
      <link>https://kunzhao.org/docs/tutorial/git/check-file-diff/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/check-file-diff/</guid>
      <description>Git 查看文件差异 Git 三个区 Git 有三个区：工作区、Stage 区（暂存区）、版本库。这意味着，一个文件可能在这三个区都有所不同。如下图所示，一个文件使用 git add 命令之后，这个文件就转移到了暂存区，继续使用 git commit 之后就转移到了版本库。git diff 使用不同的命令参数可以查看文件在这三个区域中的两两对比的差异。
本地代码（工作区）与暂存区中的差异 git diff 示例结果如下所示：
diff 输出的格式介绍 下面解释上述 git diff 输出的格式：
 第一行，展示了使用什么命令做的比较 第二行，100644 代表这是一个普通文件 --- 表示原始文件，即这个文件没有修改前的内容 +++ 表示新文件，即这个文件修改后的内容 -1,5 中的 - 表示原始文件，1,5 表示从第 1 行到第 4 行做了改动 +1,5 中的 + 表示新文件，1,5 表示从第 1 行到第 4 行做了改动 @@ -1,5 +1,5 @@ 表示这个文件的第 1 行到第 4 行，变更为了新文件的第 1 行到第 4 行  本地代码（工作区）和版本库的差异 git diff HEAD  HEAD 指：当前工作分支的版本库</description>
    </item>
    
    <item>
      <title>HTTP2</title>
      <link>https://kunzhao.org/docs/tutorial/network/http2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/http2/</guid>
      <description>HTTP2 二进制分帧层 HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。
HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。
数据流、消息和帧 新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 HTTP/2 的三个概念：
 数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。 消息：与逻辑请求或响应消息对应的完整的一系列帧。 帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。  这些概念的关系总结如下：
 所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。  简言之，HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。 这是 HTTP/2 协议所有其他功能和性能优化的基础。
请求与响应复用 在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接。 这是 HTTP/1.x 交付模型的直接结果，该模型可以保证每个连接每次只交付一个响应（响应排队）。 更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。
HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。
快照捕捉了同一个连接内并行的多个数据流。 客户端正在向服务器传输一个 DATA 帧（数据流 5），与此同时，服务器正向客户端交错发送数据流 1 和数据流 3 的一系列帧。因此，一个连接上同时有三个并行数据流。
将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，让我们可以：</description>
    </item>
    
    <item>
      <title>leveldb 源码分析与实现 - 读取</title>
      <link>https://kunzhao.org/docs/tutorial/distributed-storage/leveldb-read/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/distributed-storage/leveldb-read/</guid>
      <description>leveldb 源码分析与实现: 读取 读文件的过程 首先查看 memtable，其次查看 immutable memtable，最后尝试从 versions_-&amp;gt;current() 中获取。
// First look in the memtable, then in the immutable memtable (if any). LookupKey lkey(key, snapshot); if (mem-&amp;gt;Get(lkey, value, &amp;amp;s)) { // Done } else if (imm != nullptr &amp;amp;&amp;amp; imm-&amp;gt;Get(lkey, value, &amp;amp;s)) { // Done } else { s = current-&amp;gt;Get(options, lkey, value, &amp;amp;stats); have_stat_update = true; } MemTable // memtable.cc bool MemTable::Get(const LookupKey&amp;amp; key, std::string* value, Status* s) { // 取出和这个 key 关联的 tag  const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8); switch (static_cast&amp;lt;ValueType&amp;gt;(tag &amp;amp; 0xff)) { // 有值  case kTypeValue: { Slice v = GetLengthPrefixedSlice(key_ptr + key_length); value-&amp;gt;assign(v.</description>
    </item>
    
    <item>
      <title>ls</title>
      <link>https://kunzhao.org/docs/tutorial/unix-command/ls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-command/ls/</guid>
      <description>ls ls 命令教程，ls 命令的常见使用方法介绍。
简介 ls 命令是一个命令行实用程序，用于列出通过标准输入提供给它的一个或多个目录的内容。它将结果写入标准输出。ls 命令支持显示关于文件的各种信息、对一系列选项进行排序和递归列表。
示例 （1）显示目录中的文件
ls /home/zk （2）显示隐藏的文件和文件夹
ls -a /home/zk 结果：
ls -a /home/george . .goobook .tmux.conf .. .goobook_auth.json .urlview .asoundrc .inputrc .vim .asoundrc.asoundconf .install.sh .viminfo .asoundrc.asoundconf.bak .irbrc .viminfo.tmp ... （3）列出来的文件，标识上文件的类型
ls -F 显示结果如下所示：
bin@ dotfiles/ file.txt irc/ src/ code/ Downloads/ go/ logs/ 不同文件类型显示的后缀不同：
 /：目录 @：symbolic link |：FIFO =：socket &amp;gt;：door 什么也不显示，代表正常文件  （4）显示更多信息
ls -l 显示结果：
-rwxrw-r-- 10 root root 2048 Jan 13 07:11 afile.</description>
    </item>
    
    <item>
      <title>RocketMQ 消息接受流程</title>
      <link>https://kunzhao.org/docs/rocketmq/rocketmq-message-receive-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/rocketmq/rocketmq-message-receive-flow/</guid>
      <description>RocketMQ 消息接受流程 本篇讲述 RocketMQ 消息接受流程
一、消费者注册 生产者负责往服务器 Broker 发送消息，消费者则从 Broker 获取消息。消费者获取消息采用的是订阅者模式，即消费者客户端可以任意订阅一个或者多个话题来消费消息:
public class Consumer { public static void main(String[] args) throws InterruptedException, MQClientException { /* * 订阅一个或者多个话题 */ consumer.subscribe(&amp;#34;TopicTest&amp;#34;, &amp;#34;*&amp;#34;); } } 当消费者客户端启动以后，其会每隔 30 秒从命名服务器查询一次用户订阅的所有话题路由信息:
public class MQClientInstance { private void startScheduledTask() { this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { // 从命名服务器拉取话题信息  MQClientInstance.this.updateTopicRouteInfoFromNameServer(); } }, 10, this.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS); } } 我们由 RocketMQ 消息发送流程 这篇文章知道 RocketMQ 在发送消息的时候，每条消息会以轮循的方式均衡地分发的不同 Broker 的不同队列中去。由此，消费者客户端从服务器命名服务器获取下来的便是话题的所有消息队列:</description>
    </item>
    
    <item>
      <title>代码整洁之道</title>
      <link>https://kunzhao.org/docs/books/clean_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/clean_code/</guid>
      <description>代码整洁之道 勒布朗法则：Later equals never.
随着混乱的增加，团队生产力也持续下降，趋近于零。生产力下降的时候，管理层只能增加更多的人手，期望提高生产力。
什么是整洁代码  我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。&amp;mdash; Bjarne Stroustrup，C++ 语言发明者
  整洁的代码应可由作者之外的开发者阅读和增补。它应有单元测试和验收测试。它使用有意义的命名。它只提供一种而非多种做一件事的途径。它只有尽量少的依赖关系，且要明确地定义和提供清晰、尽量少的 API。代码应通过其表面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。&amp;mdash; Dave Thomas, OTI 公司创始人
  整洁的代码总是看起来像是某位特别在意它的人写的。几乎没有改进的余地，代码作者什么都想到了。&amp;mdash; 《修改代码的艺术》作者
 有意义的命名 对于变量，如果其需要注释来补充，那就不算是名副其实。比如你需要定义一个变量，这个变量存储的是消逝的时间，其单位是天，那么下面是一些比较好的命名：
int elapsedTimeInDays; int daysSinceCreation; int daysSinceModification; int fileAgeInDays; 别用 accountList 来指一组账号，除非它真的是 List 类型，List 一词对于程序员有特殊意义，所以用 accountGroup 或 bunchOfAcounts，甚至用 accounts 都会好一些。
别说废话，废话都是冗余。假如你有一个 Product 类，如果还有一个 ProductInfo 或 ProductData 类，它们虽然名称不同，意思却无区别。Info 和 Data 就像 a、an 和 the 一样，是意义含混的废话。下面三个函数的命名，我们怎么知道应该调用哪个呢？
getActiveAccount(); getActiveAccounts(); getActiveAccountInfo(); 使用常量，WORK_DAYS_PER_WEEK 比数字 5 要好找的多。
 对于类名，其应该是名词或名词短语，如 Customer、WikiPage、Account 和 AddressParser，避免使用 Manager、Processor、Data 或 Info 这样的类名。类名不应当是动词。</description>
    </item>
    
    <item>
      <title>可扩展性</title>
      <link>https://kunzhao.org/docs/tutorial/sentinel/spi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/sentinel/spi/</guid>
      <description>可扩展性 SpiLoader public final class SpiLoader { public static &amp;lt;T&amp;gt; T loadFirstInstanceOrDefault(Class&amp;lt;T&amp;gt; clazz, Class&amp;lt;? extends T&amp;gt; defaultClass) { AssertUtil.notNull(clazz, &amp;#34;SPI class cannot be null&amp;#34;); AssertUtil.notNull(defaultClass, &amp;#34;default SPI class cannot be null&amp;#34;); try { String key = clazz.getName(); // Not thread-safe, as it&amp;#39;s expected to be resolved in a thread-safe context.  ServiceLoader&amp;lt;T&amp;gt; serviceLoader = SERVICE_LOADER_MAP.get(key); if (serviceLoader == null) { serviceLoader = ServiceLoaderUtil.getServiceLoader(clazz); SERVICE_LOADER_MAP.put(key, serviceLoader); } for (T instance : serviceLoader) { if (instance.</description>
    </item>
    
    <item>
      <title>谷歌修改 Chromium 源码中的“黑白名单”术语</title>
      <link>https://kunzhao.org/docs/it-zone/2020-06/chrome-change-blacklist-to-blocklist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/it-zone/2020-06/chrome-change-blacklist-to-blocklist/</guid>
      <description>谷歌修改 Chromium 源码中的“黑白名单”术语 日期：2020-06-09
 【为了种族中立，谷歌修改 Chromium 源码中的“黑白名单”术语】
国外正在进行的 Black Lives Matter 运动，谷歌已表态支持。
据外媒报道，Google 在修改 Chromium 源码中的有种族歧视色彩的术语，来消除微妙的种族主义形式。
 blacklist 改成 blocklist， whitelist 改成 allowlist；
 2019 年 10 月，Chromium 开源项目的官方代码风格指南中，新增了如何编写种族中立代码的内容。其中明确指出，Chrome 和 Chromium 开发人员应避免使用“黑名单”和“白名单”一词，而应使用中性术语“阻止名单”和“允许名单”。
其实早在 2018 年 5 月，Google 已开始着手删除普通用户在 Chrome 浏览器中能看到的“黑名单”和“白名单”。
但普通用户看不到的 Chrome / Chromium 源码中，还有很多很多，据统计约 2000 多处。</description>
    </item>
    
    <item>
      <title>Java 并发 - 锁</title>
      <link>https://kunzhao.org/posts/java-lock/</link>
      <pubDate>Sat, 13 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/java-lock/</guid>
      <description>&lt;p&gt;Java 世界中都有哪些锁？锁的分类？如何减少锁的竞争等问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JVM 性能调优</title>
      <link>https://kunzhao.org/posts/jvm-optimization/</link>
      <pubDate>Tue, 02 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/posts/jvm-optimization/</guid>
      <description>&lt;p&gt;JVM 如何进行性能调优？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ⅳ</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-4/</guid>
      <description>Best Time to Buy and Sell Stock Ⅳ 题目 LeetCode 地址：Best Time to Buy and Sell Stock Ⅳ
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行K次交易（某天买入一支股票，然后过几天卖掉），请问你能收获的最大利润是多少？
分析 参考 Best Time to Buy and Sell Stock 思路上状态机，状态机应用K次即可。
答案 // 最多交易 k 次 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ // public class BestTimetoBuyandSellStockIV { public int maxProfit(int k, int[] prices) { if (prices == null || prices.length &amp;lt;= 1 || k &amp;lt;= 0) { return 0; } if (k &amp;gt;= prices.</description>
    </item>
    
    <item>
      <title>Git 重置</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-reset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-reset/</guid>
      <description>Git 重置 git reset 命令是 Git 最危险最容易误用的命令之一！一定要慎用，要清除地知道你自己在做什么！
Git reset 命令格式 git reset [--soft | --mixed | --hard] [&amp;lt;commit&amp;gt;] Git 提交历史记录 cat .git/refs/heads/master 显示的就是当前版本库的最新的 commitid
Git 重置与版本变化关系图 上述图，
 1 代表更新引用指向，即引用指向新的 commit 2 代表暂存区的内容与版本库保持一致 3 代表工作区的内容与暂存区保持一致  使用不同的参数，执行的操作不一样：
 --hard 参数，上图 1、2、3 这三步全部执行 --soft 参数，上图 1 执行 --mixed 参数，上图 1、2 执行 不使用参数，等同于使用了 --mixed 参数  根据上述解释，我们来看几个例子：
彻底回退到上一次提交 git reset --hard HEAD^  HEAD^ 指：HEAD 的父提交，即上一次提交。注意 --hard 选项会将本地工作区的内容也恢复为上一次提交，且不可恢复，所以此命令慎用！！！
 彻底回退到某一次 commit 根据 commit id 回退到某一次的提交：</description>
    </item>
    
    <item>
      <title>HTTP3</title>
      <link>https://kunzhao.org/docs/tutorial/network/http3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/http3/</guid>
      <description>HTTP3 HTTP/1.1 和 HTTP/2 使用 TCP 传输协议，HTTP/3 使用 QUIC (Quick UDP Internet Connections) 传输层协议，其是由 Google 开发的一种基于 UDP 的传输协议。之所以用 QUIC 协议的最主要原因，是为了彻底解决队头阻塞问题。
QUIC TCP 队头阻塞 HTTP/2 解决了 HTTP 的队头拥塞（head of line blocking）问题，客户端无须等待一个请求完成才能发送下一个请求，但它解决的只是 HTTP 的队头阻塞问题。
如果 HTTP/2 连接双方的网络中有一个数据包丢失，或者任何一方的网络出现中断，整个TCP连接就会暂停，丢失的数据包需要被重新传输。因为TCP是一个按序传输的链条，因此如果其中一个点丢失了，链路上之后的内容就都需要等待。
这种单个数据包造成的阻塞，就是 TCP 上的队头阻塞（head of line blocking）。
安全性 QUIC 始终保证安全性。QUIC 协议没有明文的版本，所以想要建立一个 QUIC 连接，就必须通过 TLS 1.3 来安全地建立一个加密连接。QUIC 只在加密协议协商时会发送几个明文传送的初始握手报文。
减少延迟 TCP 需要 3 次握手，QUIC 提供了 0-RTT 和 1-RTT 握手，减少了协商和建立连接所需要的时间。
HTTP3 协议特点 协议栈 可靠性 虽然 UDP 不提供可靠的传输，但 QUIC 在基于 UDP 之时增加了一层带来可靠性的层。它提供了数据包重传、拥塞控制、调整传输节奏（pacing）以及其他一些TCP中存在的特性。</description>
    </item>
    
    <item>
      <title>JS 优化</title>
      <link>https://kunzhao.org/docs/tutorial/front-end-optimization-guide/js-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/front-end-optimization-guide/js-optimization/</guid>
      <description>JS 优化 本文介绍常见的优化 JS、提升 JS 加载性能的优化方法！
提升加载性能 script 放入到 body 中 &amp;lt;script&amp;gt; 标签经常以下面的这种方式引入：
&amp;lt;script src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 当 HTML 解析器看到这一行代码时，就会请求获取脚本，并执行脚本。一旦这个过程完成，解析就可以继续，剩下的 HTML 也可以被分析。所以你可以想象，这个操作会对页面的加载时间产生多么大的影响。如果脚本加载的时间比预期的稍长，例如，如果网络有点慢，或者如果您在移动设备上，并且网速特别慢，则在加载和执行脚本之前，访问者可能会看到一个空白页。
所以推荐将 script 标签从 &amp;lt;head&amp;gt; 位置挪到 &amp;lt;/body&amp;gt; 标签前。如果你这样做了，脚本在所有页面都被解析和加载之后才会加载和执行，这是对 &amp;lt;head&amp;gt; 替代方案的巨大改进。
&amp;lt;script defer src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; Async 和 Defer 如果不考虑兼容旧浏览器，那么 async 和 defer 这两个布尔属性值，会是提升页面加载速度的更好选择：
&amp;lt;script async src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script defer src=&amp;#34;script.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 这两个属性都可以达到异步加载和执行 script 标签的目的，如果同时指定了两个，那么 async 优先级高一点，老一点的浏览器不支持 async 会降级到 defer。这些属性只有在页面的 &amp;lt;head&amp;gt; 部分使用 &amp;lt;script&amp;gt; 时才有意义，如果像我们上面看到的那样将脚本放在 &amp;lt;body&amp;gt; 中，则这些属性是无用的。
使用 async 会阻塞 HTML 的解析：
使用 defer 并不会阻塞 HTML 的解析：</description>
    </item>
    
    <item>
      <title>RocketMQ 消息过滤流程</title>
      <link>https://kunzhao.org/docs/rocketmq/rocketmq-message-filter-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/rocketmq/rocketmq-message-filter-flow/</guid>
      <description>RocketMQ 消息过滤流程 讲述 RocketMQ 消息过滤流程
一、消息过滤类型 Producer 在发送消息的时候可以指定消息的标签类型，还可以为每一个消息添加一个或者多个额外的属性:
// 指定标签 Message msg = new Message(&amp;#34;TopicTest&amp;#34;, &amp;#34;TagA&amp;#34;, (&amp;#34;Hello RocketMQ&amp;#34;).getBytes(RemotingHelper.DEFAULT_CHARSET)); // 添加属性 a msg.putUserProperty(&amp;#34;a&amp;#34;, 5); 根据标签和属性的不同，RocketMQ 客户端在消费消息的时候有三种消息过滤类型:
(1) 标签匹配 consumer.subscribe(&amp;#34;TopicTest&amp;#34;, &amp;#34;TagA | TagB | TagC&amp;#34;); (2) SQL 匹配 consumer.subscribe(&amp;#34;TopicTest&amp;#34;, MessageSelector.bySql( &amp;#34;(TAGS is not null and TAGS in (&amp;#39;TagA&amp;#39;, &amp;#39;TagB&amp;#39;))&amp;#34; + &amp;#34;and (a is not null and a between 0 3)&amp;#34;)); (3) 自定义匹配 客户端实现 MessageFilter 类，自定义过滤逻辑:
ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); File classFile = new File(classLoader.</description>
    </item>
    
    <item>
      <title>ssh</title>
      <link>https://kunzhao.org/docs/tutorial/unix-command/ssh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-command/ssh/</guid>
      <description>ssh 本文展示了一些常见的 ssh 命令，了解一些 ssh 技巧将有利于任何系统管理员、网络工程师或安全专业人员。
连接远程主机 localhost:~$ ssh -v -p 22 -C neo@remoteserver  -v：打印 debug 日志信息，用于打印连接时候的一些日志。 -p 22：指定连接远程主机的哪个端口，默认情况下，不用指定，因为 ssh 默认端口就是 22。编辑 sshd_config 文件，可以修改默认的 ssh 的监听端口。 -C：传输数据的时候，是否对数据启用压缩。 neo@remoteserver：neo 代表远程主机的用户名，remoteserver 代表远程主机的 IP 或者域名。添加 -4 选项，可以只连接 IPv4 连接；添加 -6 选项，只连接 IPv6 连接。  拷贝文件到远程服务器 远程拷贝文件的命令 scp 建立在 ssh 命令之上：
localhost:~$ scp mypic.png neo@remoteserver:/media/data/mypic_2.png  mypic.png：代表本地电脑上的图片 /media/data/mypic_2.png：代表你想把图片拷贝到远程主机的哪个路径  流量代理 SSH 代理特性被放在第1位是有充分理由的。它的功能比许多用户意识到的要强大得多，它允许您使用几乎任何应用程序访问远程服务器可以访问的任何系统。ssh客户机可以仅用一行代码，就可以使用SOCKS代理服务器在连接隧道上通信。
localhost:~$ ssh -D 8888 user@remoteserver localhost:~$ netstat -pan | grep 8888 tcp 0 0 127.</description>
    </item>
    
    <item>
      <title>企业 IT 架构转型之道</title>
      <link>https://kunzhao.org/docs/books/the_transformation_of_enterprise_it_architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/the_transformation_of_enterprise_it_architecture/</guid>
      <description>企业 IT 架构转型之道 共享服务体系搭建 SOA 的主要特性：
 面向服务的分布式计算。 服务间松散耦合。 支持服务的组装。 服务注册和自动发现。 以服务契约方式定义服务交互方式。  基于 “中心化” 的 ESB 服务调用方式  “去中心化” 服务架构调用方式   数据拆分实现数据库能力线性扩展 数据库的读写分离 读写分离基本原理是让主数据库处理事务性增、改、删（INSERT、UPDATE、DELETE）操作，而从数据库专门负责处理查询（SELECT）操作，在数据库的后台会把事务性操作导致的主数据库中的数据变更同步到集群中的从数据库。
数据库分库分表 采用分库分表的方式将业务数据拆分后，如果每一条SQL语句中都能带有分库分表键，SQL语句的执行效率最高：
但不是所有的业务场景在进行数据库访问时每次都能带分库分表键的。比如在买家中心的界面中，要显示买家test1过去三个月的订单列表信息。此时就出现了我们所说的全表扫描，一条SQL语句同时被推送到后端所有数据库中运行。如果是高并发情况下同时请求的话，为了数据库整体的扩展能力，则要考虑下面描述的异构索引手段来避免这样的情况发生。对于在内存中要进行大数据量聚合操作和计算的SQL请求，如果这类SQL的不是大量并发或频繁调用的话，平台本身的性能影响也不会太大，如果这类SQL请求有并发或频繁访问的要求，则要考虑采用其他的平台来满足这一类场景的要求，比如Hadoop这类做大数据量离线分析的产品，如果应用对请求的实时性要求比较高，则可采用如内存数据库或HBase这类平台。
所谓“异构索引表”，就是采用异步机制将原表内的每一次创建或更新，都换另一个维度保存一份完整的数据表或索引表。本质上这是互联网公司很多时候都采用的一个解决思路：“拿空间换时间”。也就是应用在创建或更新一条按照订单ID为分库分表键的订单数据时，也会再保存一份按照买家ID为分库分表键的订单索引数据。
基于订单索引表实现买家订单列表查看流程示意：
实现对数据的异步索引创建有多种实现方式，其中一种就是从数据库层采用 binlog 数据复制的方式实现。
采用数据异构索引的方式在实战中基本能解决和避免90%以上的跨join或全表扫描的情况，是在分布式数据场景下，提升数据库服务性能和处理吞吐能力的最有效技术手段。但在某些场景下，比如淘宝商品的搜索和高级搜索，因为商品搜索几乎是访问淘宝用户都会进行的操作，所以调用非常频繁，如果采用SQL语句的方式在商品数据库进行全表扫描的操作，则必然对数据库的整体性能和数据库连接资源带来巨大的压力。面对此类场景，我们不建议采用数据库的方式提供这样的搜索服务，而是采用专业的搜索引擎平台来行使这样的职能，如Lucene、Solr、ElasticSearch 等。
异步化与缓存原则 业务流程异步化 以淘宝的交易订单为例，目前淘宝的订单创建流程需要调用超过200个服务，就算所有服务的调用时间都控制在20ms内返回结果，整个订单创建的时间也会超过4s：
以异步化方式将上述交易创建过程中，对于有严格先后调用关系的服务保持顺序执行，对于能够同步执行的所有服务均采用异步化方式处理。阿里巴巴内部使用消息中间件的方式实现了业务异步化，提高了服务的并发处理，从而大大减少整个业务请求处理所花的时间。
数据库事务异步化 扣款是一个要求事务一致性的典型场景，稍微数据不一致带来的后果都可能是成百上千（可能在某些借款项目中达到上百万的金额）的金额差异。所以在传统的实现方式中，整个扣款的逻辑代码都是在一个大的事务中，通过数据库的事务特性来实现这样一个稍显复杂的业务一致性。
数据库事务的异步化：通俗来说，就是将大事务拆分成小事务，降低数据库的资源被长时间事务锁占用而造成的数据库瓶颈，就能大大提升平台的处理吞吐量和事务操作的响应时间。
在实际的改造方案中，同样基于消息服务提供的异步机制，将整个还款流程进行异步化的处理：
事务与柔性事务 不管是业务流程异步化，还是数据库事务异步化，其实都面临一个如何保证业务事务一致性的问题。面对这个问题目前并没有完美的解决方案，本节会介绍淘宝是如何对订单创建场景实现业务一致的实践，以及近一两年来我们在分布式事务上所作出的创新尝试，供各技术同行在解决此类问题时借鉴和参考。
关于数据库事务，核心是体现数据库ACID（原子性、一致性、隔离性和持久性）属性，即作为一个事务中包含的所有逻辑处理操作在作用到数据库上时，只有这个事务中所有的操作都成功，对数据库的修改才会永久更新到数据库中，任何一个操作失败，对于数据库之前的修改都会失效。在分布式领域，基于CAP理论和在其基础上延伸出的BASE理论，有人提出了“柔性事务”的概念。
（1）CAP理论
一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。“一致性”指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。“可用性”指用户在访问数据时可以得到及时的响应。“分区容错性”指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。
CAP定理并不意味着所有系统的设计都必须抛弃三个要素之中的一个。CAP三者可以在一定程度上衡量，并不是非黑即白的，例如可用性从0%到100%有不同等级。
（2）BASE理论
BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency, CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（EventualConsitency）。BASE是指基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。
  “基本可用”是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。
  “柔性状态”是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是柔性状态的体现。MySQLReplication的异步复制也是一种柔性状态体现。
  “最终一致性”是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。
  对于如何实现高可用，我们认为：</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock With Cooldown</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Best Time to Buy and Sell Stock With Cooldown 题目 LeetCode 地址：Best Time to Buy and Sell Stock With Cooldown
有一个数组，第 i 个元素的值代表第 i 天的股票价格，如果你最多只能进行任意次交易（某天买入一支股票，然后过几天卖掉），你卖出一只股票后，接下来的一天不能买，必须要到后天才能买。也就是说有冷静期1天。请问你能收获的最大利润是多少？
答案 // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ // 交易任意多次，只不过 buy sell 之后的第二天必须 cooldown 隔天才能再次 buy // // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/240277/Java-solution-in-Chinese public class BestTimetoBuyandSellStockwithCooldown { public int maxProfit(int[] prices) { if (prices == null || prices.length &amp;lt;= 1) { return 0; } // 买入只能是从前天买入 buy[i] = sell[i - 2] - prices[i];  // 卖出可以昨天卖出 sell[i] = buy[i - 1] + prices[i];  int[] sell = new int[prices.</description>
    </item>
    
    <item>
      <title>Git checkout</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-checkout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-checkout/</guid>
      <description>Git checkout git checkout 检出命令，可以用来切换分支、查看某个 commit 的代码等。
detached HEAD 当你执行 git checkout [commitId] 时，你会看到下面的文件警告：
Note: switching to &#39;467dd6520&#39;. You are in &#39;detached HEAD&#39; state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -c with the switch command.</description>
    </item>
    
    <item>
      <title>HTTPS</title>
      <link>https://kunzhao.org/docs/tutorial/network/https/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/https/</guid>
      <description>HTTPS 为什么出现 HTTPS 防止 敏感数据 (银行卡号、账号密码等) 被劫持。HTTPS 会对 HTTP 的请求和响应进行加密，因此即使劫持，攻击者看到的也都是一些随机的字符串。
RSA 应用场景 （1）加密
Bob 想要给 Alice 发送 &amp;ldquo;Hello Alice!&amp;rdquo; 这个信息：
 公钥加密 私钥解密  （2）数字签名
 私钥签名 公钥验证  HTTPS 握手 CA 证书验证过程 抓包可以抓到吗 可以。
参考  Public-key cryptography  </description>
    </item>
    
    <item>
      <title>Redis 5 设计与源码分析</title>
      <link>https://kunzhao.org/docs/books/redis_5_source_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/redis_5_source_code/</guid>
      <description>Redis 5 设计与源码分析 Redis 5.0 新特性  新增Streams数据类型，这是 Redis 5.0 最重要的改进之一。可以把Streams当作消息队列。 新的模块API、定时器、集群及字典。 RDB中持久化存储LFU和LRU的信息。 将集群管理功能完全用C语言集成到redis-cli中，Redis 3.x 和 Redis4.x 的集群管理是通过Ruby脚本实现的。 有序集合新增命令ZPOPMIN/ZPOPMAX。 改进HyperLogLog的实现。 新增Client Unblock和Client ID。 新增LOLWUT命令。 Redis主从复制中的从不再称为Slave，改称Replicas。 Redis 5.0引入动态哈希，以平衡CPU的使用率和相应性能，可以通过配置文件进行配置。Redis 5.0默认使用动态哈希。 Redis核心代码进行了部分重构和优化。  简单动态字符串 （1） 长度小于 32 的短字符串
struct __attribute__ ((__packed__))sdshdr5 { unsigned char flags; // 低 3 位存储类型，高 5 位存储长度  char buf[]; // 柔性数组 } 结构如下：
（2） 长度大于 31 的字符串
此处仅展示一个示例：
struct __attribute__ ((__packed__))sdshdr8 { uint8_t len; // 已使用长度  uint8_t alloc; // 已分配的字节总长度  unsigned char flags; // 低 3 位存储类型  char buf[]; // 柔性数组 } SDS 读操作的复杂度多为O(1)，直接读取成员变量；涉及修改的写操作，则可能会触发扩容。</description>
    </item>
    
    <item>
      <title>RocketMQ 消息索引流程</title>
      <link>https://kunzhao.org/docs/rocketmq/rocketmq-message-indexing-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/rocketmq/rocketmq-message-indexing-flow/</guid>
      <description>RocketMQ 消息索引流程 讲述 RocketMQ 消息索引服务
一、消息查询方式 对于 Producer 发送到 Broker 服务器的消息，RocketMQ 支持多种方式来方便地查询消息:
(1) 根据键查询消息 如下所示，在构建消息的时候，指定了这条消息的键为 “OrderID001”:
Message msg = new Message(&amp;#34;TopicTest&amp;#34;, &amp;#34;TagA&amp;#34;, &amp;#34;OrderID001&amp;#34;, // Keys  &amp;#34;Hello world&amp;#34;.getBytes(RemotingHelper.DEFAULT_CHARSET)); 那么，当这条消息发送成功后，我们可以使用 queryMsgByKey 命令查询到这条消息的详细信息:
MQAdminStartup.main(new String[] { &amp;#34;queryMsgByKey&amp;#34;, &amp;#34;-n&amp;#34;, &amp;#34;localhost:9876&amp;#34;, &amp;#34;-t&amp;#34;, &amp;#34;TopicTest&amp;#34;, &amp;#34;-k&amp;#34;, &amp;#34;OrderID001&amp;#34; }); (2) 根据ID(偏移量)查询消息 消息在发送成功之后，其返回的 SendResult 类中包含了这条消息的唯一偏移量 ID (注意此处指的是 offsetMsgId):
用户可以使用 queryMsgById 命令查询这条消息的详细信息:
MQAdminStartup.main(new String[] { &amp;#34;queryMsgById&amp;#34;, &amp;#34;-n&amp;#34;, &amp;#34;localhost:9876&amp;#34;, &amp;#34;-i&amp;#34;, &amp;#34;0A6C73D900002A9F0000000000004010&amp;#34; }); (3) 根据唯一键查询消息 消息在发送成功之后，其返回的 SendResult 类中包含了这条消息的唯一 ID:
用户可以使用 queryMsgByUniqueKey 命令查询这条消息的详细信息:</description>
    </item>
    
    <item>
      <title>top</title>
      <link>https://kunzhao.org/docs/tutorial/unix-command/top/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-command/top/</guid>
      <description>top 本文介绍 top 命令的常见例子！top 可以显示系统运行的进程和资源等情况的有用信息。
基础展示 top 上述命令将会显示：
 红色区域：系统的统计信息 蓝色区域：系统所有的进程列表信息  默认情况下，top 命令每隔 3 秒刷新一次。
 红色区域
 第一行展示的是：时间、电脑运行多久了、多少人登录着电脑、过去 1、5、15 分钟电脑的平均负载。 第二行展示的是，任务的总数量，以及各个状态的任务数量。 第三行展示的是 CPU 的一些信息。  CPU 信息的每一列的含义：
 us：用户态 CPU 占用处理器的总时间 sy：内核态 CPU 占用处理器的总时间 ni：使用手动设置的 nice 值执行进程所花费的时间。 id：CPU空闲时间的数量。 wa：CPU等待I/O完成所花费的时间。 hi：维护硬件中断所花费的时间。 si：维护软件中断所花费的时间。 st：由于运行虚拟机而损失的时间（“窃取时间”）。  第四行显示物理内存的总量（以kibibytes为单位），以及空闲、使用、缓冲或缓存的内存量。 第五行显示交换内存的总量（也以kibibytes为单位），以及空闲、使用和可用的内存量。后者包括预期可以从缓存中恢复的内存。
 蓝色区域的，进程列表中的各个列的信息如下：
 PID：进程ID。 USER：进程的所有者。 PR：流程优先级。 NI：这个过程很有价值。 VIRT：进程使用的虚拟内存量。 RES：进程使用的常驻内存量。 SHR：进程使用的共享内存量。 S： 进程的状态。（有关此字段可以采用的值，请参见下面的列表）。 %CPU：自上次更新以来进程使用的CPU时间的份额。 %MEM：使用的物理内存份额。 TIME+：任务使用的总CPU时间（以百分之一秒为单位）。 COMMAND：命令名或命令行（名称+选项）。  内存值以kibibytes为单位显示。进程的状态可以是以下之一：
 D： 不间断睡眠 R： 跑步 S： 睡觉 T： 跟踪（停止） Z： 僵尸  按 Q 退出 top 命令。</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Best Time to Buy and Sell Stock with Transaction Fee  每次交易都需要交易费用
 // 可以交易任意多次 // 只不过每一次都有小费 // // https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/160964/java-Using-State-Machine-like-stock-III public class BestTimetoBuyandSellStockwithTransactionFee { public int maxProfit(int[] prices, int fee) { if (prices == null || prices.length &amp;lt;= 1) { return 0; } int s0 = 0; int s1 = s0 - prices[0]; // 买入  for (int i = 1; i &amp;lt; prices.length; i++) { // 这两种状态都能转移到 s0 状态:  //  // s0 -&amp;gt; s0  // s1 卖出 -&amp;gt; s0  s0 = Math.</description>
    </item>
    
    <item>
      <title>cat</title>
      <link>https://kunzhao.org/docs/tutorial/unix-command/cat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-command/cat/</guid>
      <description>cat cat 命令的常见用法！
查看文件内容 要使用 cat 显示文件的内容，只需传递要查看的一个或多个文件的名称。文件内容将打印到标准输出并在终端中可见。下面的示例假设文件foo.txt 文件只有一行“Hello World”。
cat foo.txt Hello world 如果文件的内容很长，则全部内容将写入终端。在这种情况下，很难找到文件的某些部分。在寻找特定内容时，grep 可能是一个更好的选择。
将一个文件的内容写入到另外一个文件 使用cat工具结合重定向，可以将文件内容写入新的文件。下面的示例假设文件foo.txt文件只有一行“Hello World”并将其写入bar.txt文件.
cat foo.txt &amp;gt; bar.txt cat bar.txt Hello world 如果 bar.txt 文件不存在，那么 cat 工具会自动创建 bar.txt 文件。
将一个文件的内容追加到另外一个文件 cat wine.txt &amp;gt;&amp;gt; beer.txt 多个文件合并为一个 cat *.txt &amp;gt; combined.txt 上述命令行，将当前目录以 .txt 结尾的文件，合并到 combined.txt 文件中。
cat 输出显示行号 -n 参数可以显示文件的行号：
cat -n /usr/share/dict/words 1 A 2 a 3 aa 4 aal 5 aalii 输出的每行行尾显示 $ 符号 cat -e test hello everyone, how do you do?</description>
    </item>
    
    <item>
      <title>CDN</title>
      <link>https://kunzhao.org/docs/tutorial/network/cdn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/cdn/</guid>
      <description>CDN  核心理念：就近访问数据
 CDN 分发系统架构 回溯 由于边缘节点数目比较多，但是每个集群规模比较小，不可能缓存下来所有东西，因而可能无法命中，这样就会在边缘节点之上。有区域节点，规模就要更大，缓存的数据会更多，命中的概率也就更大。在区域节点之上是中心节点，规模更大，缓存数据更多。如果还不命中，就只好回源网站访问了。
CDN 可缓存的内容  静态资源：图片、CSS、JS、HTML 文件、流媒体等 动态数据：缓存动态数据  如何找到合适的边缘节点  基于 DNS 的全局负载均衡。
 根据用户 IP、所处的运营商、请求 URL 中携带的参数、服务器的负载情况等综合分析后，全局负载均衡服务器返回一台缓存服务器的 IP 地址。
动态资源如何缓存  边缘计算：动态数据生成的计算、逻辑、存储等，也放到边缘节点，然后定时地从数据源同步存储的数据等内容 路径优化：源站到边缘节点的路径经过优化 (调整 TCP 参数、多路复用、数据压缩)，采用更为可靠的路径来传输  CDN 挂掉怎么办 为了防止 CDN 挂掉，引入的时候要加入一个判断：
&amp;lt;script src=&amp;#34;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;window.jQuery || document.write(&amp;#39;&amp;lt;script src=&amp;#34;js/vendor/jquery-1.10.2.min.js&amp;#34;&amp;gt;&amp;lt;\/script&amp;gt;&amp;#39;)&amp;lt;/script&amp;gt; 这段代码第一行很简单就是你正常引入 cdn 的地址。下面一行的话就是首先判断 Windows.jQuery 是否存在；也就是说判断一下这个CDN是不是挂掉了，如果没有挂掉，那么就直接使用，如果挂掉了，那么就要在后面引入自己的本地资源库。这样就可以保证在可以使用 cdn 的时候使用 cdn 不可以使用的时候就加载本地的。</description>
    </item>
    
    <item>
      <title>Git 保存当前进度</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-stash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-stash/</guid>
      <description>Git 保存当前进度 git stash 命令可以帮助我们保存和恢复日常的工作进度。
应用场景 你正在 dev 分支上开发项目的某个新功能，开发到一半的时候，master 分支的代码（线上正在运行的代码）出现了一个 bug，需要紧急修复。你现在需要从 dev 分支切换到 master 分支修 BUG，而你现在在 dev 分支正在开发的代码也不可能开发到一半就要 push 上去，此时就可以先在 dev 分支把代码给 stash 起来，也就是暂存起来，然后再切换到 master 分支。等 master 分支修复好了后，再切回 dev 分支，执行 stash pop 把这部分代码给恢复出来即可。
下面示例几个基础用法：
保存当前工作进度 git stash 显示进度列表 git stash list stash 就是一个栈数据结构管理的，你可以保存多次工作进度，并且恢复的时候也可以选择恢复哪个。
恢复进度 # 恢复最新保存的工作进度，并将工作进度从 stash 列表中清除 git stash pop # 恢复某个指定的 stash (git stash list 可以看到) git stash pop [&amp;lt;stash&amp;gt;] 命令 git stash apply [&amp;lt;stash&amp;gt;] 同 git stash pop，只是不会从 stash 列表中删除恢复的进度。</description>
    </item>
    
    <item>
      <title>RocketMQ 定时消息和重试消息</title>
      <link>https://kunzhao.org/docs/rocketmq/rocketmq-timing-message-and-retry-message/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/rocketmq/rocketmq-timing-message-and-retry-message/</guid>
      <description>RocketMQ 定时消息和重试消息 讲述 RocketMQ 定时消息和重试消息
一、定时消息概述 RocketMQ 支持 Producer 端发送定时消息，即该消息被发送之后，到一段时间之后才能被 Consumer 消费者端消费。但是当前开源版本的 RocketMQ 所支持的定时时间是有限的、不同级别的精度的时间，并不是任意无限制的定时时间。因此在每条消息上设置定时时间的 API 叫做 setDelayTimeLevel，而非 setDelayTime 这样的命名:
Message msg = new Message(&amp;#34;TopicTest&amp;#34; /* Topic */, &amp;#34;TagA&amp;#34; /* Tag */, (&amp;#34;Hello RocketMQ &amp;#34; + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */); msg.setDelayTimeLevel(i + 1); 默认 Broker 服务器端有 18 个定时级别:
public class MessageStoreConfig { private String messageDelayLevel = &amp;#34;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&amp;#34;; } 这 18 个定时级别在服务器端启动的时候，会被解析并放置到表 delayLevelTable 中。解析的过程就是上述字符串按照空格拆分开，然后根据时间单位的不同再进一步进行计算，得到最终的毫秒时间。级别就是根据这些毫秒时间的顺序而确定的，例如上述 1s 延迟就是级别 1， 5s 延迟就是级别 2，以此类推:</description>
    </item>
    
    <item>
      <title>深度剖析 Apache Dubbo 核心技术</title>
      <link>https://kunzhao.org/docs/books/in-depth_analysis_of_the_core_technology_of_apache_dubbo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/in-depth_analysis_of_the_core_technology_of_apache_dubbo/</guid>
      <description>深度剖析 Apache Dubbo 核心技术 SPI 扩展 Dubbo 支持扩展的核心接口上，都会通过类似 @SPI(&amp;quot;dubbo&amp;quot;) 这样的注解，来标识当前接口的默认实现。如果你想替换掉这个默认实现，那么需要两个步骤。第一，实现 Protocol 接口，然后在 META-INF/dubbo 目录下创建一个名字为 org.apache.dubbo.rpc.Protocol 的文本文件。这个 META-INF 目录如果使用的是 IDEA 开发，那么其应该放到 resources 目录下的顶层，这样打 jar 包的时候，其也会被复制到 jar 包的第一级目录。内容如下：
myProtocol = com.zk.MyProtocol 第二，需要在 XML 配置文件中，声明使用这个扩展实现：
&amp;lt;dubbo:protocol name=&amp;#34;myProtocol&amp;#34;&amp;gt; 其实 JDK 本身也提供了 SPI 扩展，Dubbo 之所以没有使用默认提供的实现，是因为：
 JDK 标准的 SPI 一次性实例化扩展点的所有实现，如果有些没有使用到，那么会浪费资源。 扩展点加载失败的异常提示不是很好。 增强了 Ioc 和 AOP 的支持。  性能 Dubbo 会给每个服务提供者的实现类生产一个 Wrapper 类，这个 Wrapper 类里面最终调用服务提供者的接口实现类，Wrapper 类的存在是为了减少反射的调用。当服务提供方收到消费方发来的请求后，需要根据消费者传递过来的方法名和参数反射调用服务提供者的实现类，而反射本身是有性能开销的，Dubbo 把每个服务提供者的实现类通过 JavaAssist 包装为一个 Wrapper 类以减少反射调用开销。
其实就是由反射改为了比较方法名称，然后调用，伪代码如下：
GreetingServiceImpl impl = (GreetingServiceImpl) object; if (&amp;#34;sayHello&amp;#34;.</description>
    </item>
    
    <item>
      <title>Binary Search 二分搜索</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-search/</guid>
      <description>Binary Search // https://leetcode.com/problems/binary-search/ // public class BinarySearch { public int search(int[] nums, int target) { if (nums == null || nums.length == 0) { return -1; } int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] == target) { return m; } else if (nums[m] &amp;gt; target) { hi = m - 1; } else { lo = m + 1; } } return -1; } } </description>
    </item>
    
    <item>
      <title>DNS</title>
      <link>https://kunzhao.org/docs/tutorial/network/dns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/dns/</guid>
      <description>DNS DNS 使用的传输层协议 主要使用 UDP 协议，端口 53, 也有一些采用 TCP 来实现。
DNS 层次结构  根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址 顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址 权威 DNS 服务器 ：返回相应主机的 IP 地址  DNS 数据库的记录类型    类型 描述     A、AAAA IP 地址   MX SMTP mail exchangers   NS name servers   CNAME domain name aliases    DNS 的解析流程 DNS 做负载均衡 DNS 除了可以通过名称映射为 IP 地址，它还可以做另外一件事，就是负载均衡。</description>
    </item>
    
    <item>
      <title>Git 多次提交合并成一次提交</title>
      <link>https://kunzhao.org/docs/tutorial/git/merge-multiple-commit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/merge-multiple-commit/</guid>
      <description>Git 多次提交合并成一次提交 你在 dev 分支上开发某个功能，在本地执行了三次 commit，注意这三次 commit 都没有 push 到远程分支，都只是在本地存在。现在你想要在 push 之前，将你本地的这多个 commit 合并成一个 commit，请问应该怎么做？
答案是：git rebase -i HEAD~N，N 代表你想把最近的几条 commitId 记录合并。具体操作步骤如下：
查看提交记录 git log 查看提交记录：
871adf OK, feature Z is fully implemented --- newer commit --┐ 0c3317 Whoops, not yet... | 87871a I&#39;m ready! | 643d0e Code cleanup |-- Join these into one afb581 Fix this and that | 4e9baa Cool implementation | d94e78 Prepare the workbench for feature Z -------------------┘ 6394dc Feature Y --- older commit  假设 6394dc 提交已经 push 上去了 你现在想把 d94e78 ~ 871adf 这几个 commit 合并一下  即最终你再次执行 git log 想要看到的效果如下：</description>
    </item>
    
    <item>
      <title>os-release</title>
      <link>https://kunzhao.org/docs/tutorial/unix-command/os-release/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-command/os-release/</guid>
      <description>如何知道是 Ubuntu 还是 Cent OS 系统 ? $ cat /etc/os-release NAME=&amp;#34;Ubuntu&amp;#34; VERSION=&amp;#34;20.04.1 LTS (Focal Fossa)&amp;#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=&amp;#34;Ubuntu 20.04.1 LTS&amp;#34; VERSION_ID=&amp;#34;20.04&amp;#34; HOME_URL=&amp;#34;https://www.ubuntu.com/&amp;#34; SUPPORT_URL=&amp;#34;https://help.ubuntu.com/&amp;#34; BUG_REPORT_URL=&amp;#34;https://bugs.launchpad.net/ubuntu/&amp;#34; PRIVACY_POLICY_URL=&amp;#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&amp;#34; VERSION_CODENAME=focal UBUNTU_CODENAME=focal </description>
    </item>
    
    <item>
      <title>RocketMQ 主备同步</title>
      <link>https://kunzhao.org/docs/rocketmq/rocketmq-master-slave-sync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/rocketmq/rocketmq-master-slave-sync/</guid>
      <description>RocketMQ 主备同步 介绍 RocketMQ 的主备同步机制
一、简介 RocketMQ 通过 Master-Slave 主备机制，来实现整个系统的高可用，具体表现在:
 Master 磁盘坏掉，Slave 依然保存了一份 Master 宕机，不影响消费者继续消费  二、搭建环境 我们在一台机器上搭建一个 Master 一个 Slave 的环境:
为了能够将 Master 和 Slave 搭建在同一台计算机上，我们除了需要将 Broker 的角色设置为 SLAVE ，还需要为其指定单独的 brokerId、 storePathRootDir、 storePathCommitLog。
// SLAVE 角色 messageStoreConfig.setBrokerRole(BrokerRole.SLAVE); // 一个机器如果要启动多个 Broker，那么每个 Broker 的 store 根目录必须不同 messageStoreConfig.setStorePathRootDir(storePathRootDir); // 一个机器如果要启动多个 Broker，那么每个 Broker 的 storePathCommitLog 根目录必须不同 messageStoreConfig.setStorePathCommitLog(storePathCommitLog); // 设置 Slave 的 Master HA 地址 messageStoreConfig.setHaMasterAddress(&amp;#34;localhost:10912&amp;#34;); // SLAVE 角色的 brokerId 必须大于 0 brokerConfig.setBrokerId(1); 注意 Slave 和 Master 的 brokerName 必须一致，即它们必须处于同一个 BrokerData 数据结构里面。实际上在做了如上的修改之后， Slave 和 Master 依旧不能同时运行在同一台机器上，因为 Slave 本身也可以称为 Master，接受来自其他 Slave 的请求，因此当运行 Slave 的时候，需要将 HAService 里面的启动 AcceptSocketService 运行的相关方法注释掉。</description>
    </item>
    
    <item>
      <title>人人都是架构师 (一)</title>
      <link>https://kunzhao.org/docs/books/everyone-is-architect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/everyone-is-architect/</guid>
      <description>人人都是架构师 - 分布式系统架构落地与瓶颈突破 分布式系统应对高并发、大流量的常用手段：
 扩容 动静分离 缓存 服务降级 限流  限流 常见算法：
 令牌桶，Nginx 限流模块用的是这个：限制的是流量的平均流入速率，允许一定程度上的突发流量。 漏桶：限制的是流出速率，并且这个速率还是保持不变的，不允许突发流量。  Nginx 限流 http { # 每个 IP 的 session 空间大小 limit_zone one $binary_remote_addr 20m; # 每个 IP 每秒允许发起的请求数 limit_req_zone $binary_remote_addr zone=req_one:20m rate=10r/s; # 每个 IP 能够发起的并发连接数 limit_conn one 10; # 缓存还没有来得及处理的请求 limit_req zone=req_one burst=100; } 消峰  活动分时段 答题验证  高并发读 &amp;ldquo;马某出轨王某&amp;rdquo;、&amp;ldquo;iPhone SE 2020 发布&amp;rdquo; 等这种热点新闻的 key 会始终落在同一个缓存节点上，分布式缓存一定会出现单点瓶颈，其资源连接容易瞬间耗尽。有如下两种方案解决这个问题：
 基于 Redis 的集群多写多读方案。  多写如何保持一致性：将 Key 配置在 ZooKeeper，客户端监听 ZNode，一旦变化，全量更新本地持有的 Key   LocalCache 结合 Redis 集群的多级 Cache 方案。  LocalCache 拉取下来的商品数量有 5 个，但是实际上只有 4 个了，怎么解决？对于这种读场景，允许接受一定程度上的数据脏读，最终扣减库存的时候再提示商品已经售罄即可。    实时热点自动发现 交易系统产生的相关数据、上游系统中埋点上报的数据这两个，异步写入日志，对日志进行次数统计和热点分析</description>
    </item>
    
    <item>
      <title>Circular Array (循环数组)</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/circular-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/circular-array/</guid>
      <description>Circular Array 循环数组 来自一亩三分地，微软面试官问的问题。过去任意 1 秒内来自同一 IP 的请求是否超过 100 次，可以用循环数组可以做。
 微软
 // // https://www.javaguides.net/2018/09/queue-implementation-using-circular-array-in-java.html // package com.zk.algorithm.array; /** * Queue Implementation using Circular Array * @author Ramesh Fadatare * */ public class CircularArray { // Array used to implement the queue.  private int[] queueRep; // 添加数据，存放在 (rear + 1) % size，size++  // 取出数据，(front + 1) % size，size--  private int size, front, rear; // Length of the array used to implement the queue.</description>
    </item>
    
    <item>
      <title>Git 分支</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-branch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-branch/</guid>
      <description>Git 分支 Git 的分支管理命令：git branch。
示例 列举本地所有分支 git branch  当前分支会用 * 标识出来，也会用特别的颜色标识出来
 列举本地和远程所有分支 git branch -a 创建分支 git branch &amp;lt;branchName&amp;gt; 删除分支 # 删除时，会检查此分支是否已经合并到其它分支，否则拒绝删除 git branch -d &amp;lt;branchName&amp;gt; # 不管有没有合并到其它分支，都强制删除分支 git branch -D &amp;lt;branchName&amp;gt; 重命名分支 # 如果版本库已经存在 newbranch，则拒绝重命名 git branch -m &amp;lt;oldbranch&amp;gt; &amp;lt;newbranch&amp;gt; # 如果版本库已经存在 newbranch，则强制重命名 git branch -M &amp;lt;oldbranch&amp;gt; &amp;lt;newbranch&amp;gt; 创建并切换分支 git checkout -b &amp;lt;new_branch&amp;gt; 扫描下面二维码在手机端阅读：</description>
    </item>
    
    <item>
      <title>TCP</title>
      <link>https://kunzhao.org/docs/tutorial/network/tcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/tcp/</guid>
      <description>TCP TCP 头 三次握手 四次挥手 起始序列号 ISN ISN 为什么不从 1 开始 client 第一次尝试建立连接: client 发送 1,2,3 数据包给 server，我们假设这个时候 3 这个数据包丢失了。紧接着 client 第二次尝试建立连接: client 发送 1,2 给 server，主观上并没有想发送 3 这个数据包，但是第一次的 3 数据包可能又会回来发送给 server，因此造成数据错误)。
起始序列号 ISN 如何计算 起始 ISN 是基于时钟的，每 4 毫秒加一，转一圈要 4.55 个小时。
TCP 初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。 RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。
ISN = M + F (localhost, localport, remotehost, remoteport) M 是一个计时器，这个计时器每隔 4 毫秒加 1。F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</description>
    </item>
    
    <item>
      <title>编写可读代码的艺术</title>
      <link>https://kunzhao.org/docs/books/the-art-of-readable-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/the-art-of-readable-code/</guid>
      <description>编写可读代码的艺术 代码应当易于理解 Q: 可读性基本定理？
 可读性基本原理：使别人理解它所需的时间最小化。
 Q: 代码总是越小越好？
 减少代码行数是一个好目标，但是把理解代码所需的时间最小化是一个更好的目标。
 表面层次的改进 把信息装到名字里 （1）选择专业的词
def getPage(url) 上述例子，get 词没有表达出很多信息。从本地缓存得到一个页面，还是从数据库中，或者从互联网中？如果从互联网中，应该使用更为专业的名字：fetchPage(url) 或 downloadPage(url)。
class BinaryTree { int size(); } 上述例子，size() 返回的是什么？树的高度，节点树，还是树在内存中所占的空间？size() 没有承载更多的信息，更专业的词汇是 height()、numNodes() 或 memoryBytes()。
英语是一门丰富的语言，有很多词汇可以选择。下面是一些例子，这些单词更富有表现力，可能更适合你的语境：
   单词 更多选择     send deliver、dispatch、announce、distribute、route   find search、extract、locate、recover   start launch、create、begin、open   make create、set up、build、generate、compose、add、new    （2）避免像 tmp 和 retval 这样泛泛的名字
除非你有更好的理由！
（3）用具体的名字代替抽象的名字
searchCanStart() 比 canListenOnPort() 更具体一些，这个名字直接描述了方法所做的事情。</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/container-with-most-water/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/container-with-most-water/</guid>
      <description>Container With Most Water // 两个柱子中间包含最多的水 // 可以看一下这道题的这个图 // 这个是两个柱子之间的所能容纳的水的矩形面积 // // https://leetcode.com/problems/container-with-most-water/ // // [1,8,6,2,5,4,8,3,7] // ↑ ↑ // 7 * 7 = 49 // public class ContainerWithMostWater { public int maxArea(int[] height) { int maxArea = Integer.MIN_VALUE; int lo = 0; int hi = height.length - 1; // O(n)  while (lo &amp;lt; hi) { maxArea = Math.max(maxArea, Math.min(height[lo], height[hi]) * (hi - lo)); // =======================================  // 此处这个地方，必须是小的一边移动  // 因为大的移动的话，面积一定变小 (宽度变小，而且高度不会超过小的)  // 而小的移动有可能变大  //  // 另外一种解释：  // 我们选择一个高的，以便容纳更多的水  // https://leetcode.</description>
    </item>
    
    <item>
      <title>Git 分支合并</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-merge-branch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-merge-branch/</guid>
      <description>Git 分支合并 某个功能在开发分支上开发完毕后，需要合并到 master 分支，合并分支有两种方式：
 git merge git rebase  分支现状展示  从 master 分支的 A 提交点，拉取了分支 user2/i18n user2/i18n 的功能开发总共有两个 commit：E 和 F master 在 A 提交点之后，又有 B、C 和 D 这三个提交被合入进来  Git merge 我们使用 git merge 来合并 user2/i18n 分支到 master 分支上：
# 切换到 master 分支 git checkout master # 合并 user2/i18n 分支 git merge user2/i18n 合并后的分支示意图：
Git rebase 我们使用 git rebase 来合并 user2/i18n 到 master 分支上：
git checkout user2/i18n git rebase master # 如果有冲突，则需要解决冲突 # 解决完冲突，使用 git add -u 将完成冲突解决的文件加入到暂存区 # git rebase --continue # 直接推送，用本地的 user2/i18n 分支更新远程的 master 分支即可 git push origin user2/i18n:master rebase 之后的分支示例：</description>
    </item>
    
    <item>
      <title>UDP</title>
      <link>https://kunzhao.org/docs/tutorial/network/udp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/network/udp/</guid>
      <description>UDP UDP 头 与 TCP 区别  无连接 不保证不丢失、不保证按序到达 基于数据报，一个一个发，一个一个收 无拥塞控制，让我发，我就发，管它洪水滔天 无状态服务  应用场景  需要资源少，网络情况较好的内网，或者对于丢包不敏感的应用 不需要一对一沟通建立连接，可以广播的应用: DHCP 处理速度快、低时延、可以容忍少数丢包 Quick UDP Internet Connections: Google 提出的，降低通信时延 流媒体协议，有的帧比较重要，有的不重要 实时游戏。游戏玩家多，服务器却不多，而维护 TCP 需要一些数据结构 IoT 物联网 4G 网络，数据流量上网的数据面对的协议 GTP-U 就是基于 UDP 的  </description>
    </item>
    
    <item>
      <title>炒股的智慧</title>
      <link>https://kunzhao.org/docs/books/the-wisdom-of-trading-stocks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/the-wisdom-of-trading-stocks/</guid>
      <description>炒股的智慧  如果要我用一句话解释何以一般股民败多胜少，那就是：人性使然！说的全面些，就是这些永远不变的人性&amp;ndash;讨厌风险、急着发财、自以为是、赶潮跟风、因循守旧和耿于报复&amp;ndash;使股民难以逃避开股市的陷阱。说得简单些，就是好贪小便宜、吃不得小亏的心态使得一般股民几乎必然地成为了输家。
 炒股的挑战 炒股与人性 炒股最重要的原则就是止损。但人性是好贪小便宜，不肯吃小亏，只有不断地因为贪了小便宜却失去大便宜，不肯吃小亏最终却吃了大亏，你才能最终学会不贪小便宜，不怕吃小亏。
特殊的赌局 问问你自己喜欢做决定吗？喜欢独自为自己地决定负全部责任吗？对 99% 的人来说，答案是否定的。股市这一恒久的赌局却要求你每时每刻都要做理性的决定，并且为决定的结果负全部的责任！这就淘汰了一大部分股民，因为他们没有办法长期承受这样的心理能力。
一般股民何以失败 人性讨厌风险 纽约有位叫做夏皮诺的心理医生，请了一批人来做两个实验：
 实验一  选择：第一，75% 的机会得到 1000 美元，但有 25% 的机会什么都得不到；第二，确定得到 700 美元。结果 80% 的人选择了第二选择，大多数人宁愿少些，也要确定的利润。
 股民好获小利，买进的股票升了一点，便迫不及待地脱手。这只股票或许有 75% 继续上升地机会，但为了避免 25% 什么都得不到的可能性，股民宁可少赚些。任何炒过股的读者都明白，要用较出场价更高地价位重新入场是多么困难。股价一天比一天高，你只能做旁观者。
  实验二  选择：第一，75% 的机会付出 1000 美元，但有 25% 的机会什么都不付；第二，确定付出 700 美元。结果 75% 的人选择了第一选择。他们为了搏 25% 什么都不付的机会，从数学上讲多失去了 50 美元。
 一旦买进的股票跌了，股民便死皮赖脸不肯止损，想象出各种各样的理由说服自己下跌只是暂时的。其真正的原因只不过为了搏那 25% 可能全身而退的机会！结果是小亏慢慢积累成大亏。
 人的发财心太急 心一旦大了，行动上就开始缺少谨慎。首先我每次买股买得太多，其次止损止得太迟。我为此遭受了巨大的损失。
人好自以为是 一天结束的时候，股票以某一价钱收盘。你有没有思考过它代表了什么？它代表了股市的参与者在今天收市的时候对该股票的认同。
不要太固执己见，不要对自己的分析抱太大的信心。认真观察股市，不对时就认错。否则，你在这行生存的机会是不大的。
人好跟风 人好报复 在股市中，买进的股票跌了，你就再多买一点，因为第二次买的价钱较上次为低，所以平均进价摊低了。从心理上看，你的心态和赌场亏钱时一样。一方面你亏不起，另一方面你在报复股市，报复股市让你亏钱。同时内心希望，只要赢一手，就能连本带利全回来。因为平均进价摊低了，股票的小反弹就能提供你全身而退的机会。
这样的心态是极其有害的。股票跌的时候通常有它跌的理由，常常下跌的股票会越跌越低。这样被套牢，你就越陷越深，直到你心理无法承受的地步。一个致命的大亏损，常常就彻底淘汰了一位股民。
人总是迟疑不决，心怀侥幸 每个炒股人都会经过这个过程。20元买好股票，定好18元止损，当股票跌到18元时，你有没有想想再等等？或许股票马上反弹！股票又跌到16元，你会不会拍自己的脑壳说：“真该按定好的规矩办！18元时就走人；现若股票反弹5毛钱我就一定说再见。”
现股票跌到10元了，你准备怎么办？你会发毛吗？你会不会发狠：“老子这次拼了！现在就是不走，我倒要看看你最低会跌到什么地方？”
当然，最后的结局很少例外，通常是股票学校又多了位交了学费毕不了业的炒股
股票分析的基本知识 技术分析 升势：一浪比一浪高     朋友，你认为什么因素使投资者入市买股票？华尔街有过调查，使一般投资者入场买股票的原因最主要的就是因为股票在升！你明白吗？一般投资者入场买股票主要不是因为股票的成本收益比率低或红利高，而是因为股票在升！升！升！而投资人卖股票的最主要原因是因为股票在跌！在跌！</description>
    </item>
    
    <item>
      <title>Count Of Smaller After Self</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/countofsmallerafterself/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/countofsmallerafterself/</guid>
      <description>Count Of Smaller After Self 题目 数组里面的每一个数字，排在这个数字后面的小于这个数字的有多少个数字
解法 import java.util.ArrayList; import java.util.List; // Input: [5,2,6,1] // Output: [2,1,1,0] // // 统计小于自己的有多少个数字 public class CountOfSmallerAfterSelf { public List&amp;lt;Integer&amp;gt; countSmaller(int[] nums) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int curr = nums[i]; int count = 0; for (int j = i + 1; j &amp;lt; nums.length; j++) { if (nums[j] &amp;lt; curr) { count++; } } result.</description>
    </item>
    
    <item>
      <title>Git 解决冲突</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-fix-conflict/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-fix-conflict/</guid>
      <description>Git 解决冲突 某个分支的代码想要合并到其它分支，可能会产生冲突，产生的原因就是这两个分支都对代码的同一个区域做了修改，Git 本身并不知道应该采用哪个修改最为合适，因此需要你来决定。
解决冲突 如下所示是冲突代码的示例：
 A 和 B 之间的代码，是你本地的代码所做的改动 B 和 C 之间的代码，是远程代码所做的改动  你的工作是重新编辑 A 到 C 区域之间的内容，去掉 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; 、=======、&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 符号，重新编辑 A 和 C 之间的代码，以让整个项目运行起来。
编辑完之后，可以通过 git add 命令将冲突的文件假如到暂存区，然后再 git commit，就完成了冲突解决。
打开图形界面工具解决冲突 使用图形化工具来帮助你解决冲突，不过需要事先安装工具。打开图形界面工具的命令如下：
git mergetool 打开之前，也可以使用 git config 进行简单的配置，比如使用 vimdiff 工具作为默认的冲突解决工具：
git config merge.tool vimdiff git config merge.conflictstyle diff3 git config mergetool.prompt false 放弃合并操作 你暂时不想解决冲突：
git reset 参考  How to resolve merge conflicts in Git  扫描下面二维码，在手机端阅读：</description>
    </item>
    
    <item>
      <title>Git tag</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-tag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-tag/</guid>
      <description>Git tag 什么是 Tags Tag 是对某次 commit 的一个有意义的命名，比如某个重大的版本发布，某个重大的 BUG 修复等。如下展示了前端开发框架 React 在开发过程中标记的各个版本的 Tag 列表。
显示版本库的 Tag 列表 git tag 创建 Tag # 在最新的提交是创建一个 Tag git tag myTag # 创建一个带有说明信息的 Tag git tag -m &amp;#34;My fir st annotated tag.&amp;#34; myTag2 删除 Tag git tag -d myTag 重命名 Tag 只能先删除旧的 Tag，然后创建一个新的
将 Tag 推送到远程服务器 # 将 myTag 推送到远程服务器 git push origin myTag # 将本地所有 Tag 推送到远程服务器 git push origin refs/tags/* # 或 git push origin --tags 扫描下面二维码，在手机端阅读：</description>
    </item>
    
    <item>
      <title>设计循环队列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/designcircularqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/designcircularqueue/</guid>
      <description>Design Circular Queue 题目 设计循环队列
解法 public class DesignCircularQueue { static class MyCircularQueue { private int[] queue; private int frontIndex; private int rearIndex; private int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { this.size = k + 1; this.queue = new int[k + 1]; } /** Insert an element into the circular queue. Return true if the operation is successful.</description>
    </item>
    
    <item>
      <title>Git add 和 Git rm</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-add-and-rm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-add-and-rm/</guid>
      <description>Git add 和 Git rm  git add 用来从工作区向暂存区添加文件 git rm 用来从工作区向暂存区删除文件  git add 示例 git add [--all|-A] git add . git add -u Git 1.X 版本  假设 . 当前指向的目录是 .git 文件所在的目录
 Git 2.X 版本  假设 . 当前指向的目录是 .git 文件所在的目录
 git rm 示例 # 只从工作区删除文件 rm xxx.txt # 只从暂存区删除文件 git rm --cached # 从工作区和暂存区都删除这个文件 git rm xxx.txt # 递归强制删除 xxx_folder 中的所有文件 # -r: recursive # -f: override the up-to-date check git rm -rf xxx_folder 参考  Difference between “git add -A” and “git add .</description>
    </item>
    
    <item>
      <title>有序数组查找最小和最大元素的位置</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findfirstandlastpositionofelementinsortedarray/</guid>
      <description>有序数组查找最小和最大元素的位置 public class FindFirstandLastPositionofElementinSortedArray { public int[] searchRange(int[] nums, int target) { int minIndex = searchMinIndex(nums, target); if (minIndex == -1) { return new int[]{ -1, -1 }; } int maxIndex = searchMaxIndex(nums, target); return new int[] { minIndex, maxIndex }; } private int searchMaxIndex(int[] nums, int target) { int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] &amp;gt; target) { hi = m - 1; } else if (nums[m] &amp;lt; target) { lo = m + 1; } else { if (m == nums.</description>
    </item>
    
    <item>
      <title>Git push 和 Git pull</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-push-and-pull/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-push-and-pull/</guid>
      <description>Git push 和 Git pull git push 、git pull 用于向远程分支推送文件，以及从远程分支拉取文件等。
远程版本库地址 .git/config 文件中记录了当前仓库远程版本库的地址：
vi .git/config 直接修改这个地址保存后，当前版本库的远程版本库的地址也就变化了。Git 本身也提供了用来操纵版本库地址的命令：
# 添加远程版本库地址 git remote add origin git@github.com:facebook/react.git # 更新远程版本库地址 git remote set-url origin git@github.com:facebook/react.git push 和 pull push 命令和 pull 命令的语法相似：
git push &amp;lt;remote_name&amp;gt; &amp;lt;branch_name&amp;gt; git pull &amp;lt;remote_name&amp;gt; &amp;lt;branch_name&amp;gt; 不带参数，执行命令 git push 的过程（git pull 同理）：
 如果当前分支有 remote（如何知道是否有 remote？还是看 .git/config 文件，如下图所示，每个 branch 的 remote 都不是空的），那么 git push 相当于执行了 git push &amp;lt;remote&amp;gt; 如果没有设置，则相当于执行 git push origin  一般而言，你这个项目本身应该只有一个版本库地址，如下图所示，版本库的名称就叫做 origin，它的地址就是 url 后面的那一部分：</description>
    </item>
    
    <item>
      <title>数据流寻找中位数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findmedianfromdatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findmedianfromdatastream/</guid>
      <description>数据流寻找中位数 import java.util.Comparator; import java.util.PriorityQueue; // https://leetcode.com/problems/find-median-from-data-stream/ // 剑指 Offer 41 题 // public class FindMedianfromDataStream { // 堆顶是最小的  // 最小堆的堆顶是最大值  //  private PriorityQueue&amp;lt;Integer&amp;gt; minQueue = new PriorityQueue&amp;lt;&amp;gt;(); // 堆顶是最大的  // 最大堆的堆顶是最小的值  private PriorityQueue&amp;lt;Integer&amp;gt; maxQueue = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Integer&amp;gt;() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); private boolean sameSize = true; public FindMedianfromDataStream() { } public void addNum(int num) { if (sameSize) { minQueue.</description>
    </item>
    
    <item>
      <title>Git commit</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-commit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-commit/</guid>
      <description>Git commit git commit 可以将暂存区的文件，commit 提交到本地仓库中。
git commit -m -m 代表 message 信息的意思。git commit 需要一个信息作为它的参数，这个信息是对此次 commit 的简短描述，消息应该放到双引号里面。
git commit -m &amp;#34;my brief description about commit&amp;#34;  如果没有携带 -m 参数，Git 也会弹出编辑器让你输入消息的。
 git commit -a -a 选项代表 all，即所有。该选项可以将本地工作区所有改动的/被删除的文件，直接 commit 到仓库中，而无需调用 git add/rm 命令手动添加或删除。
git commit -am &amp;#34;My message&amp;#34;  -a 并不会将新添加的文件 commit 到版本库中。
 git commit &amp;ndash;amend --amend 选项可以让你修改上一次提交的信息。
# 第一次提交信息 git commit -m &amp;#34;my first message&amp;#34; # 你对 my first message 这个描述不满意 # 所以使用下面命令来修正成你想要的信息 git commit --amend -m &amp;#34;an updated commit message&amp;#34; 参考  Git Commit Command Explained  扫描下面二维码，在手机端阅读：</description>
    </item>
    
    <item>
      <title>旋转有序数组中寻找最小数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findminimuminrotatedsortedarray/</guid>
      <description>旋转有序数组中寻找最小数字 // 没有重复元素 // 1 2 3 4 5 6 7 // // 5 6 7 1 2 3 4 // lo hi // public class FindMinimuminRotatedSortedArray { public int findMin(int[] nums) { int lo = 0; // always point to 前半部分  int hi = nums.length - 1; // always point to 后半部分  if (nums[lo] &amp;gt; nums[hi]) { while (lo &amp;lt; hi) { if (hi - lo == 1) { return nums[hi]; } int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] &amp;lt; nums[0]) { // middle 位于后半部分  hi = m; } else if (nums[m] &amp;gt; nums[nums.</description>
    </item>
    
    <item>
      <title>寻找峰值元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findpeakelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findpeakelement/</guid>
      <description>寻找峰值元素 题目 你给出一个整数数组(size为n)，其具有以下特点：
 相邻位置的数字是不同的 A[0] &amp;lt; A[1] 并且 A[n - 2] &amp;gt; A[n - 1]  假定P是峰值的位置则满足A[P] &amp;gt; A[P-1]且A[P] &amp;gt; A[P+1]，返回数组中任意一个峰值的位置。
 数组保证至少存在一个峰 如果数组存在多个峰，返回其中任意一个就行 数组至少包含 3 个数   微软面试题
 解法 // https://www.lintcode.com/problem/find-peak-element/description // // Microsoft // A[P] &amp;gt; A[P-1] &amp;amp;&amp;amp; A[P] &amp;gt; A[P+1] public class FindPeakElement { // 返回的是索引  //  // 数组太大的话，会超时  public int findPeak(int[] A) { // [x,x,x,x,x]  int lo = 1; int hi = A.</description>
    </item>
    
    <item>
      <title>寻找重复数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/findtheduplicatenumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/findtheduplicatenumber/</guid>
      <description>寻找重复数字 // Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), // prove that at least one duplicate number must exist. // Assume that there is only one duplicate number, find the duplicate one. // // 1 到 n 的数字，某个数字重复，可能重复次数 &amp;gt; 1 // // Input: [3,1,3,4,2] // Output: 3 // // https://leetcode.com/problems/find-the-duplicate-number/ public class FindtheDuplicateNumber { // ==================================  // 数组不允许修改版本  //  // 剑指 Offer  // ==================================  public int findDuplicate(int[] nums) { int lo = 1; int hi = nums.</description>
    </item>
    
    <item>
      <title>第一个缺失的最小正数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/firstmissingpositive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/firstmissingpositive/</guid>
      <description>第一个缺失的最小正数 import java.util.ArrayList; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Set; // https://leetcode.com/problems/first-missing-positive/ // Given an unsorted integer array, find the smallest missing positive integer. // // Input: [3,4,-1,1] // Output: 2 // // Input: [7,8,9,11,12] // Output: 1 // public class FirstMissingPositive { // ===============================  // 不使用辅助空间  //  // 最核心的是，遇见哪些数字可以不用管:  // - 负数  // - 大于 nums.length 的数  // ===============================  public int firstMissingPositive(int[] nums) { int i = 0; while (i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>数据流的第一个唯一数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/firstuniquenumberindatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/firstuniquenumberindatastream/</guid>
      <description>数据流的第一个唯一数字 import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map; // https://www.lintcode.com/problem/first-unique-number-in-data-stream/description // // 给一个连续的数据流,写一个函数返回终止数字到达时的第一个唯一数字（包括终止数字）, // 如果在终止数字前无唯一数字或者找不到这个终止数字, 返回 -1. public class FirstUniqueNumberinDataStream { public int firstUniqueNumber(int[] nums, int number) { boolean hasStopNumber = false; HashMap&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int count= map.getOrDefault(nums[i], 0); map.put(nums[i], count + 1); if (nums[i] == number) { hasStopNumber = true; break; } } if (!hasStopNumber) { return -1; } for (Map.</description>
    </item>
    
    <item>
      <title>插入区间</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/insertinterval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/insertinterval/</guid>
      <description>插入区间 import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; import com.zk.algorithm.beans.Interval; // Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] // Output: [[1,2],[3,10],[12,16]] // Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. public class InsertInterval { // 插入一个新的 interval  // 如果有交集，那么合并  public List&amp;lt;Interval&amp;gt; insert(List&amp;lt;Interval&amp;gt; intervals, Interval newInterval) { intervals.add(newInterval); Collections.sort(intervals, new Comparator&amp;lt;Interval&amp;gt;() { public int compare(Interval a, Interval b) { if (a.start &amp;lt; b.start) { return -1; } else if (a.</description>
    </item>
    
    <item>
      <title>数组交集</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/intersectionoftwoarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/intersectionoftwoarrays/</guid>
      <description>数组交集 方法一 // // Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] // Output: [9,4] // public class IntersectionofTwoArrays { public int[] intersection(int[] nums1, int[] nums2) { Set&amp;lt;Integer&amp;gt; set1 = toSet(nums1); Set&amp;lt;Integer&amp;gt; set2 = toSet(nums2); return findIntersection(set1, set2); } private int[] findIntersection(Set&amp;lt;Integer&amp;gt; set1, Set&amp;lt;Integer&amp;gt; set2) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int num: set2) { if (set1.contains(num)) { list.add(num); } } int[] res = new int[list.size()]; for (int i = 0; i &amp;lt; list.</description>
    </item>
    
    <item>
      <title>最小的K个数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/ksmallestnuminanarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/ksmallestnuminanarray/</guid>
      <description>最小的K个数 import java.util.ArrayList; // 牛客网 // https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf // 最小的 k 个数 // public class KSmallestNumInAnArray { public ArrayList&amp;lt;Integer&amp;gt; GetLeastNumbers_Solution(int[] input, int k) { int lo = 0; int hi = input.length - 1; while (lo &amp;lt;= hi) { int kth = partition(input, lo, hi); if (kth == k - 1) { ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; k; i++) { res.add(input[i]); } return res; } else if (kth &amp;lt; k - 1) { lo = kth + 1; } else { hi = kth - 1; } } return new ArrayList&amp;lt;Integer&amp;gt;(); } private int partition(int[] nums, int lo, int hi) { int left = lo - 1; int pivot = nums[hi]; for (int i = lo; i &amp;lt;= hi - 1; i++) { if (nums[i] &amp;lt;= pivot) { swap(nums, ++left, i); } } swap(nums, left + 1, hi); return left + 1; } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } </description>
    </item>
    
    <item>
      <title>绝对值差为K的数对数量</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kdiffpairsinanarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kdiffpairsinanarray/</guid>
      <description>绝对值差为K的数对数量 描述 给定一个整数数组和一个整数k，您需要找到数组中唯一k-diff对的数量。这里k-diff对被定义为整数对(i, j)，其中i和j都是数组中的数字，它们的绝对差是k。
 对(i,j)和(j,i)计为同一对。 数组的长度不超过10,000。 给定输入中的所有整数都属于以下范围：[ -1e7, 1e7]。  答案 import java.util.Arrays; // https://www.lintcode.com/problem/k-diff-pairs-in-an-array/description // Amazon // // 这个 pair 差的绝对值 == k public class KdiffPairsinanArray { // O(n^2)  public int findPairs(int[] nums, int k) { Arrays.sort(nums); int count = 0; for (int i = 0; i &amp;lt; nums.length - 1; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>第 K 个最大的数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kthlargestelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kthlargestelement/</guid>
      <description>第 K 个最大的数字 数组中的第 K 个最大数字 // 数组无序 public class KthLargestElementinanArray { public int findKthLargest(int[] nums, int k) { k = nums.length - k; // 1 2 3 4 5 6  // ↑(第 2 大)  // ↑(partition = 2 的时候，实际上指向的是这里)  int lo = 0; int hi = nums.length - 1; // ==========================  // while (lo &amp;lt; hi)  // nums = [1]，这种情况进入不了循环  //  // ==========================  while (lo &amp;lt;= hi) { int index = partition(nums, lo, hi); if (index == k) { return nums[index]; } else if (index &amp;lt; k) { lo = index + 1; } else { hi = index - 1; } } return -1; } private int partition(int[] nums, int lo, int high) { int i = lo - 1; int pivot = nums[high]; for (int j = lo; j &amp;lt;= high - 1; j++) { if (nums[j] &amp;lt;= pivot) { i++; swap(nums, i, j); } } swap(nums, i + 1, high); return i + 1; } private void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } } 数据流中的第 K 个最大数字  堆  import java.</description>
    </item>
    
    <item>
      <title>第 K 个最小的数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kthsmallestelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kthsmallestelement/</guid>
      <description>第 K 个最小的数字 9 * 9 乘法表中的第 K 个最小数字 // http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3819&amp;amp;konwledgeId=40 // https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/ // // 百度乘法表 // 9 * 9 乘法表 // public class KthSmallestNumberinMultiplicationTable { public int findKthNumber(int m, int n, int k) { int lo = 1; int hi = m * n; while (lo &amp;lt;= hi) { int middle = lo + ((hi - lo) &amp;gt;&amp;gt; 1); int count = countLessOrEqualK(m, n, middle); if (count &amp;lt; k) { lo = middle + 1; } else { hi = middle - 1; } } return lo; } private int countLessOrEqualK(int m, int n, int k) { int c = 0; for (int i = 1; i &amp;lt;= m; i++) { // 1 2 3 4  // 2 4 6 8  // 3 6 9 12  //  // k = 5  // - k &amp;gt;= 第 1 行的 (1 2 3 4) 最后的 4，所以 c += n 个  // - k &amp;lt; 第 2 行的 (2 4 6 8) 最后的 8，所以 c += k / i 个  //  if (k &amp;gt;= n * i) { c += n; } else { c += k / i; } } return c; } } 行或列均有序的矩阵中的第 K 个最小数字 // matrix = [ // [ 1, 5, 9], // [10, 11, 13], // [12, 13, 15] // ], // k = 8,  // return 13.</description>
    </item>
    
    <item>
      <title>数组元素所能拼成的最大数字</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/largestnumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/largestnumber/</guid>
      <description>数组元素所能拼成的最大数字 import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class LargestNumber { public String largestNumber(int[] nums) { List&amp;lt;String&amp;gt; numList = toList(nums); Collections.sort(numList, new Comparator&amp;lt;String&amp;gt;() { @Override public int compare(String a, String b) { return (b + a).compareTo(a + b); } }); final StringBuilder sb = new StringBuilder(); for (String str: numList) { sb.append(str); } String res = sb.toString(); if (allZero(res)) { return &amp;#34;0&amp;#34;; } return res; } private boolean allZero(String str) { for (char c: str.</description>
    </item>
    
    <item>
      <title>柱状图中最大的矩形</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/largestrectangleinhistogram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/largestrectangleinhistogram/</guid>
      <description>柱状图中最大的矩形 描述 题目来源
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。
题解 // https://leetcode.com/problems/largest-rectangle-in-histogram/ 直方图 // __ // __| | // | | | // | | | __ // __ | | |__| | // | |__| | | | | // |__|__|__|__|__|__| // public class LargestRectangleinHistogram { public int largestRectangleArea(int[] heights) { // =================================  // 左边最多延展到哪个索引  // =================================  // 左边比自己大的或相等的  //  // 单调栈找到第一个比自己大的或者小的数字  int[] left = new int[heights.</description>
    </item>
    
    <item>
      <title>最长序列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/longestsequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/longestsequence/</guid>
      <description>最长序列 最长连续递增相差为 1 的序列 import java.util.Arrays; // [100, 4, 200, 1, 3, 2] // // 必须是连续的 1 2 3 4 差值为 1 public class LongestConsecutiveSequence { public int longestConsecutive(int[] nums) { if (nums.length == 0) { return 0; } Arrays.sort(nums); int longestStreak = 1; int currentStreak = 1; for (int i = 1; i &amp;lt; nums.length; i++) { if (nums[i] != nums[i - 1]) { if (nums[i] == nums[i - 1] + 1) { currentStreak += 1; } else { longestStreak = Math.</description>
    </item>
    
    <item>
      <title>找出过半数的元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/majorityelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/majorityelement/</guid>
      <description>找出过半数的元素 // Given an array of size n, find the majority element. // The majority element is the element that appears more than ⌊ n/2 ⌋ times. // You may assume that the array is non-empty and the majority element always exist in the array. // public class MajorityElement { public int majorityElement(int[] nums) { int candidate = nums[0]; int count = 1; for (int i = 1; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>最大的岛屿</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maxareaofisland/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maxareaofisland/</guid>
      <description>最大的岛屿 // 时间复杂度 O(row * col)，因为每个小方格访问一次 // public class MaxAreaofIsland { public int maxAreaOfIsland(int[][] grid) { int row = grid.length; int col = grid[0].length; boolean[][] visited = new boolean[row][col]; int max = 0; for (int r = 0; r &amp;lt; row; r++) { for (int c = 0; c &amp;lt; col; c++) { max = Math.max(maxArea(grid, visited, r, c), max); } } return max; } private int maxArea(int[][] grid, boolean[][] visited, int r, int c) { if (r &amp;lt; 0 || r &amp;gt;= grid.</description>
    </item>
    
    <item>
      <title>直线上最多的点数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maxpointsonaline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maxpointsonaline/</guid>
      <description>直线上最多的点数 描述 题目 给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。
输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^|| o| o o| o| o o+-------------------&amp;gt;0 1 2 3 4 5 6题解 public class MaxPointsonaLine { public int maxPoints(Point[] points) { if (points.length &amp;lt;= 1) { return points.length; } int max = 0; for (int i = 0; i &amp;lt; points.length - 1; i++) { for (int j = i + 1; j &amp;lt; points.</description>
    </item>
    
    <item>
      <title>最大的矩形</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximalrectangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximalrectangle/</guid>
      <description>最大的矩形 描述 题目 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
输入:[[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;]]输出: 6答案 // Given a matrix: // [ // [1, 1, 0, 0, 1], // [0, 1, 0, 0, 1], // [0, 0, 1, 1, 1], // [0, 0, 1, 1, 1], // [0, 0, 0, 0, 1] // ] // return 6. public class MaximalRectangle { public int maximalRectangle(boolean[][] matrix) { if (matrix == null || matrix.</description>
    </item>
    
    <item>
      <title>子数组的最大平均值</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumaveragesubarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumaveragesubarray/</guid>
      <description>子数组的最大平均值 描述 原题 给定一个由 n 个整数组成的数组，找到给定长度 k 的连续子数组，该子数组具有最大平均值。你需要输出最大平均值。
答案  前缀和  // https://www.lintcode.com/problem/maximum-average-subarray/description // 给定一个由 n 个整数组成的数组，找到给定长度 k 的连续子数组，该子数组具有最大平均值。你需要输出最大平均值。 // 注意这个长度 k 是固定的 // public class MaximumAverageSubarray { public double findMaxAverage(int[] nums, int k) { int[] prefixSum = prefixSum(nums); int maxSum = 0; for (int i = k; i &amp;lt; prefixSum.length; i++) { maxSum = Math.max(maxSum, prefixSum[i] - prefixSum[i - k]); } return maxSum * 1.0 / k; } private int[] prefixSum(int[] nums) { int[] prefixSum = new int[nums.</description>
    </item>
    
    <item>
      <title>连续子数组最大乘积</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumproductsubarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumproductsubarray/</guid>
      <description>连续子数组最大乘积 // 连续子数组最大乘积 public class MaximumProductSubarray { public int maxProduct(int[] nums) { int min = nums[0]; int max = nums[0]; int ans = nums[0]; for (int i = 1; i &amp;lt; nums.length; i++) { // ==============================  // max 值基于更新后的 min 值进行了计算  // ==============================  int A = nums[i] * min; int B = nums[i] * max; min = min(A, B, nums[i]); max = max(A, B, nums[i]); if (max &amp;gt; ans) { ans = max; } } return ans; } private int min(int.</description>
    </item>
    
    <item>
      <title>最大子数组之和为 K</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumsizesubarraysumequalsk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumsizesubarraysumequalsk/</guid>
      <description>最大子数组之和为 K  微软
 描述 给一个数组nums和目标值k，找到数组中最长的子数组，使其中的元素和为k。如果没有，则返回0。
 数组之和保证在32位有符号整型数的范围内
 题解  前缀和 + Map  import java.util.HashMap; import java.util.Map; // https://www.lintcode.com/problem/maximum-size-subarray-sum-equals-k/description // Facebook // // 微软面试题 // longest consecutive sequence of numbers that sum to K // https://www.1point3acres.com/bbs/thread-541121-1-1.html // // 给一个数组nums和目标值k，找到数组中最长的子数组，使其中的元素和为k。如果没有，则返回0。 // // ↓ ↓ (k = 17) // 2 [ 3 5 6 3 ] 8 public class MaximumSizeSubarraySumEqualsk { public int maxSubArrayLen(int[] nums, int k) { int[] prefixSum = prefixSum(nums); // 感觉就是跟 two sum 似的  // 借助 map 直接让复杂度降低了  Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); // 左边的边界  map.</description>
    </item>
    
    <item>
      <title>最大子矩阵</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumsubmatrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumsubmatrix/</guid>
      <description>最大子矩阵 描述 原题 给出一个大小为 n x n 的矩阵，里面元素为 正整数 和 负整数 ，找到具有最大和的子矩阵。
输入:matrix = [[1,3,-1],[2,3,-2],[-1,-2,-3]]输出: 9解释:具有最大和的子矩阵是:[[1,3],[2,3]]题解  二维数组的前缀和  // https://www.lintcode.com/problem/maximum-submatrix/description // // Given an n x n matrix of positive and negative integers, // find the submatrix with the largest possible sum. // public class MaximumSubmatrix { public int maxSubmatrix(int[][] matrix) { if (matrix == null || matrix.</description>
    </item>
    
    <item>
      <title>最大的交换</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/maximumswap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/maximumswap/</guid>
      <description>最大的交换 描述 原题 给定一个非负整数, 你可以选择交换它的两个数位. 返回你能获得的最大的合法的数.
 给定的数字在 [0, 10^8] 范围内
 输入: 2736输出: 7236解释: 交换数字2和数字7.题解 // https://www.lintcode.com/problem/maximum-swap/description // // 给定一个非负整数, 你可以选择交换它的两个数位. 返回你能获得的最大的合法的数. // // 输入: 2736 // 输出: 7236 // 解释: 交换数字2和数字7. // // 给定的数字在 [0, 10^8] 范围内 public class MaximumSwap { public static void main(String...args) { MaximumSwap maximumSwap = new MaximumSwap(); System.out.println(maximumSwap.maximumSwap0(98368)); System.out.println(maximumSwap.maximumSwap0(1993)); } public int maximumSwap0(int num) { char[] arr = String.valueOf(num).toCharArray(); int[] max = new int[arr.</description>
    </item>
    
    <item>
      <title>两个有序数组合并后的中位数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/medianoftwosortedarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/medianoftwosortedarrays/</guid>
      <description>两个有序数组合并后的中位数  微软
 题解 public class MedianofTwoSortedArrays { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int n = nums1.length + nums2.length; if (n % 2 == 1) { return findKth(nums1, nums2, 0, nums1.length - 1, 0, nums2.length - 1, n / 2 + 1); } else { double a = findKth(nums1, nums2, 0, nums1.length - 1, 0, nums2.length - 1, n / 2); double b = findKth(nums1, nums2, 0, nums1.</description>
    </item>
    
    <item>
      <title>合并区间</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/mergeintervals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/mergeintervals/</guid>
      <description>合并区间 描述 原题 给出一个区间的集合，请合并所有重叠的区间。
输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].题解 // Input: [[1,3],[2,6],[8,10],[15,18]] // Output: [[1,6],[8,10],[15,18]] // Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. // // 56: https://leetcode.com/problems/merge-intervals/ public class MergeIntervals { public List&amp;lt;Interval&amp;gt; merge(List&amp;lt;Interval&amp;gt; intervals) { if (intervals == null || intervals.isEmpty()) { return Collections.emptyList(); } Collections.sort(intervals, new Comparator&amp;lt;Interval&amp;gt;() { @Override public int compare(Interval a, Interval b) { if (a.</description>
    </item>
    
    <item>
      <title>合并 K 个有序数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/mergeksortedarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/mergeksortedarrays/</guid>
      <description>合并 K 个有序数组 题解  优先级队列  import java.util.PriorityQueue; // https://www.lintcode.com/problem/merge-k-sorted-arrays/description // public class MergeKSortedArrays { public int[] mergekSortedArrays(int[][] arrays) { PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(); int n = 0; for (int i = 0; i &amp;lt; arrays.length; i++) { for (int j = 0; j &amp;lt; arrays[i].length; j++) { n++; queue.offer(arrays[i][j]); } } int[] sortedArr = new int[n]; int index = 0; while (!queue.isEmpty()) { sortedArr[index++] = queue.poll(); } return sortedArr; } } </description>
    </item>
    
    <item>
      <title>长度最小的子数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/minimumsizesubarraysum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/minimumsizesubarraysum/</guid>
      <description>长度最小的子数组 描述 题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
输入：s = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。题解 // Given an array of n positive integers and a positive integer s, // find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn&amp;#39;t one, return 0 instead. // // Input: s = 7, nums = [2,3,1,2,4,3] // Output: 2 // Explanation: the subarray [4,3] has the minimal length under the problem constraint.</description>
    </item>
    
    <item>
      <title>数据流滑动窗口平均值</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/movingaveragefromdatastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/movingaveragefromdatastream/</guid>
      <description>数据流滑动窗口平均值 描述 原题 给出一串整数流和窗口大小，计算滑动窗口中所有整数的平均值。
题解 import java.util.LinkedList; import java.util.Queue; // https://www.lintcode.com/problem/moving-average-from-data-stream/description // 给出一串整数流和窗口大小，计算滑动窗口中所有整数的平均值。 // // MovingAverage m = new MovingAverage(3); // m.next(1) = 1 // 返回 1.00000 // m.next(10) = (1 + 10) / 2 // 返回 5.50000 // m.next(3) = (1 + 10 + 3) / 3 // 返回 4.66667 // m.next(5) = (10 + 3 + 5) / 3 // 返回 6.00000 // public class MovingAveragefromDataStream { private final int size; private final Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); private double sum; /* * @param size: An integer */ public MovingAveragefromDataStream(int size) { this.</description>
    </item>
    
    <item>
      <title>下一个更大元素 II</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/nextgreaterelementii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/nextgreaterelementii/</guid>
      <description>下一个更大元素 II 描述 原题 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。
输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。题解 // 循环数组 // Input: [1,2,1] // Output: [2,-1,2] public class NextGreaterElementII { // O(n^2)  public int[] nextGreaterElements(int[] nums) { int[] greater = new int[nums.length]; for (int i = 0; i &amp;lt; nums.length; i++) { greater[i] = findNextGreat(nums, i); } return greater; } private int findNextGreat(int[] nums, int i) { int great = nums[i]; int j = i + 1; while (j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>下一个排列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/nextpermutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/nextpermutation/</guid>
      <description>下一个排列  微软
 描述 原题 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1题解 public class NextPermutation { // 1 5 8 4 7 6 5 3 1  // ↑  // ↑(5 &amp;gt; 4 最后一个大于它的)  // 1 5 8 5 7 6 4 3 1 (交换)  // ↑(reverse)↑  // 1 5 8 5 1 3 4 6 7  //  // 找到第一个不符合从右到左升序对的数字 i = 4  // 找到第一个刚刚大于 nums[i] 的数字 j = 5  // swap(i, j)  // reverse(i + 1)  //  // ↓ (第一个不符合的数字 3，如果相等，比如多个 3 还要再往前找)  // 7 3 6 4 2  // ↑ (第一个刚刚大于 3 的数字 4)  //  // 7 4 6 3 2 (交换)  //  // 7 4 2 3 6 (4 后面的数字也交换)  public void nextPermutation(int[] nums) { int i = nums.</description>
    </item>
    
    <item>
      <title>数飞机</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/numberofairplanesinthesky/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/numberofairplanesinthesky/</guid>
      <description>数飞机 描述 原题 给出飞机的起飞和降落时间的列表，用序列 interval 表示. 请计算出天上同时最多有多少架飞机？
 如果多架飞机降落和起飞在同一时刻，我们认为降落有优先权。
 输入: [(1, 10), (2, 3), (5, 8), (4, 7)]输出: 3解释: 第一架飞机在1时刻起飞, 10时刻降落.第二架飞机在2时刻起飞, 3时刻降落.第三架飞机在5时刻起飞, 8时刻降落.第四架飞机在4时刻起飞, 7时刻降落.在5时刻到6时刻之间, 天空中有三架飞机.题解 import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; import com.zk.algorithm.beans.Interval; // https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/description // Amazon // // Input: [(1, 10), (2, 3), (5, 8), (4, 7)] // Output: 3 // Explanation: // The first airplane takes off at 1 and lands at 10.</description>
    </item>
    
    <item>
      <title>分割等和子集</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/partitionequalsubsetsum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/partitionequalsubsetsum/</guid>
      <description>分割等和子集 描述 原题 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
 每个数组中的元素不会超过 100 数组的大小不会超过 200  输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11].题解 import java.util.Arrays; // https://leetcode.com/problems/partition-equal-subset-sum/ // // 0 1 背包问题 // 从 nums.length 个数中找出若干个数，使其和 == sum /2 // // 416. Two subset public class PartitionEqualSubsetSum { public boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) { sum += num; } if ((sum &amp;amp; 1) == 1) { return false; } // ======================  // sum 变为一半  // ======================  sum /= 2; int n = nums.</description>
    </item>
    
    <item>
      <title>数组除了自身的乘积</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/productofarrayexceptself/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/productofarrayexceptself/</guid>
      <description>描述 原题 给定 n 个整数的数组 nums，其中 n &amp;gt; 1，返回一个数组输出，使得 output[i] 等于 nums 的所有除了nums[i] 的元素的乘积。
输入: [1,2,3,4]输出: [24,12,8,6]解释:2*3*4=241*3*4=121*2*4=81*2*3=6题解 // 给定n个整数的数组nums，其中n&amp;gt; 1，返回一个数组输出，使得output [i]等于nums的所有除了nums [i]的元素的乘积。 // 在没有除和O(n)时间内解决 // https://www.lintcode.com/problem/product-of-array-except-self/description // 输入: [1,2,3,4] // 输出: [24,12,8,6] // 解释: // 2*3*4=24 // 1*3*4=12 // 1*2*4=8 // 1*2*3=6 // // 输入: [2,3,8] // 输出: [24,16,6] // 解释: // 3*8=24 // 2*8=16 // 2*3=6 public class ProductofArrayExceptSelf { public int[] productExceptSelf(int[] nums) { //  // 2, 3, 8  //  // 2, 6, 1  // 1, 24, 8  //  // 24, 16, 6  int[] leftProduct = new int[nums.</description>
    </item>
    
    <item>
      <title>根据身高重建队列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/queuereconstructionbyheight/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/queuereconstructionbyheight/</guid>
      <description>根据身高重建队列 原题 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。
注意：
 总人数少于1100人。  示例
输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]题解 import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List; // https://leetcode.com/problems/queue-reconstruction-by-height/ public class QueueReconstructionbyHeight { // [[7,0], [7,1], [6,1], [5,2], [5,0], [4,4]]  //  // [[7,0]]  // [[7,0], [7,1]]  // [[7,0], [6,1], [7,1]]  // [[7,0], [6,1], [5,2], [7,1]]  // [[5,0], [7,0], [6,1], [5,2], [7,1]]  // [[5,0], [7,0], [6,1], [5,2], [4,4], [7,1]]  public int[][] reconstructQueue(int[][] people) { // 个高的排在最前面，个矮的排在后面  Arrays.</description>
    </item>
    
    <item>
      <title>限流器</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/ratelimiter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/ratelimiter/</guid>
      <description>限流器  基于 Token Bucket 的限流算法 基于 Redis 的限流算法  public class RateLimiter { public static long now() { return System.currentTimeMillis(); } // ==================  // - Token Bucket  // - Redis  // ==================  // =========================  // Token Bucket 算法  // 每过 RATE / PER 时间，就加  // =========================  public static class TokenBucketRateLimiter { private long lastCheck = now(); private static final int RATE = 5; // 5 requests  private static final int PER = 8; // 8 seconds  private int allowance = RATE; public boolean overhead(String key) { long current = now(); long timePassed = current - lastCheck; lastCheck = timePassed; // ======================  // 过去的这段时间内可以增加多少个 allowance  // ======================  allowance += timePassed * (RATE / PER); if (allowance &amp;gt; RATE) { allowance = RATE; } // ======================  // 是否能够减去 1.</description>
    </item>
    
    <item>
      <title>删除排序数组中的重复项</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/removeduplicatesfromsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/removeduplicatesfromsortedarray/</guid>
      <description>删除排序数组中的重复项 描述 原题 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
 示例 1:
给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。题解 // 排序数组 // 移除重复数字 public class RemoveDuplicatesfromSortedArray { public int removeDuplicates(int[] nums) { // [1,1,1,1,2,2,3,4,5,5]  //  int noDuplicated = 0; for (int i = 1; i &amp;lt; nums.length; i++) { if (nums[i] == nums[i - 1]) { continue; } else { nums[++noDuplicated] = nums[i]; } } return nums.</description>
    </item>
    
    <item>
      <title>两个有序数组第 K 大的数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/kth-of-two-sorted-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/kth-of-two-sorted-array/</guid>
      <description>两个有序数组第 K 大的数 O(n) 解法 class Main { static int kth(int arr1[], int arr2[], int m, int n, int k) { int[] sorted1 = new int[m + n]; int i = 0, j = 0, d = 0; while (i &amp;lt; m &amp;amp;&amp;amp; j &amp;lt; n) { if (arr1[i] &amp;lt; arr2[j]) sorted1[d++] = arr1[i++]; else sorted1[d++] = arr2[j++]; } while (i &amp;lt; m) sorted1[d++] = arr1[i++]; while (j &amp;lt; n) sorted1[d++] = arr2[j++]; return sorted1[k - 1]; } // main function  public static void main (String[] args) { int arr1[] = {2, 3, 6, 7, 9}; int arr2[] = {1, 4, 8, 10}; int k = 5; System.</description>
    </item>
    
    <item>
      <title>移除元素</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/removeelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/removeelement/</guid>
      <description>移除元素 描述 原题 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:
给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。题解 public class RemoveElement { // [1,1,1,2,2]  public int removeElement(int[] nums, int val) { int valid = -1; for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] != val) { nums[++valid] = nums[i]; } } return nums.</description>
    </item>
    
    <item>
      <title>逆序对</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/reversepairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/reversepairs/</guid>
      <description>逆序对 描述 数组的逆序对个数
题解 // https://www.lintcode.com/problem/reverse-pairs/description // // Input: A = [2, 4, 1, 3, 5] // Output: 3 // Explanation: // (2, 1), (4, 1), (4, 3) are reverse pairs // // 逆序对个数 public class ReversePairs { public long reversePairs(int[] A) { return mergeSort(A, 0, A.length - 1); } private long mergeSort(int[] A, int lo, int hi) { int sum = 0; if (lo &amp;lt; hi) { int mid = lo + ((hi - lo) &amp;gt;&amp;gt; 1); // =====================  // 注意：这个地方是都加了一遍  // =====================  sum += mergeSort(A, lo, mid); sum += mergeSort(A, mid + 1, hi); sum += merge(A, lo, mid, hi); } return sum; } private int merge(int[] A, int lo, int mid, int hi) { int[] temp = new int[hi - lo + 1]; int tempIndex = 0; int loIndex = lo; int hiIndex = mid + 1; int count = 0; while (loIndex &amp;lt;= mid &amp;amp;&amp;amp; hiIndex &amp;lt;= hi) { // left | right  // 3 5 6 | 2  //  // 3 比 2 大的话，那么 3 5 6 都比 2 大  if (A[loIndex] &amp;gt; A[hiIndex]) { count += mid - loIndex + 1; temp[tempIndex++] = A[hiIndex++]; } else { temp[tempIndex++] = A[loIndex++]; } } while (loIndex &amp;lt;= mid) { temp[tempIndex++] = A[loIndex++]; } while (hiIndex &amp;lt;= hi) { temp[tempIndex++] = A[hiIndex++]; } tempIndex = 0; while (tempIndex &amp;lt; temp.</description>
    </item>
    
    <item>
      <title>旋转图像</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/rotateimage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/rotateimage/</guid>
      <description>旋转图像 描述 原题 给定一个 n × n 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。
说明：
你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
题解 // Given input matrix = // [ // [1,2,3], // [4,5,6], // [7,8,9] // ],  // rotate the input matrix in-place such that it becomes: // [ // [7,4,1], // [8,5,2], // [9,6,3] // ] public class RotateImage { public void rotate(int[][] matrix) { int n = matrix.length; for (int i = 0; i &amp;lt; n / 2; i++) { // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓  // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓  //  // 【j 走到哪里停】?</description>
    </item>
    
    <item>
      <title>二维数组中的查找</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/searcha2dmatrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/searcha2dmatrix/</guid>
      <description>二维数组中的查找 描述  剑指offer  在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
题解 // 这个算法适用于行有序、列有序的情况 public class Searcha2DMatrix { public boolean searchMatrix(int[][] matrix, int target) { if (matrix.length == 0) { return false; } int m = matrix.length; int n = matrix[0].length; // 第一行最后一个数字  //  int r = 0; int c = n - 1; while (r &amp;lt; m &amp;amp;&amp;amp; c &amp;gt;= 0) { int val = matrix[r][c]; if (target &amp;gt; val) { r++; } else if (target &amp;lt; val) { c--; } else { return true; } } return false; } } </description>
    </item>
    
    <item>
      <title>搜索区间</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/searchforarange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/searchforarange/</guid>
      <description>搜索区间 描述 原题 给定一个包含 n 个整数的排序数组，找出给定目标值 target 的起始和结束位置。
如果目标值不在数组中，则返回 [-1, -1]
题解 // LintCode // https://www.lintcode.com/problem/search-for-a-range/leaderboard // public class SearchforaRange { public int[] searchRange(int[] A, int target) { if (A == null || A.length == 0) { return new int[]{ -1, -1 }; } int start = searchStartIndex(A, target); int end = searchEndIndex(A, target); return new int[]{ start, end }; } // target 开始的地方  private int searchStartIndex(int[] A, int target) { int lo = 0; int hi = A.</description>
    </item>
    
    <item>
      <title>搜索旋转排序数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/searchinrotatedsortedarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/searchinrotatedsortedarray/</guid>
      <description>搜索旋转排序数组 Search in Rotated Sorted Array 和 Search in Rotated Sorted Array II
数组无重复数字 // 么有重复数字 public class SearchinRotatedSortedArray { // https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14472/Java-AC-Solution-using-once-binary-search  // 使用一次二分搜索  //  // 核心思想: 确定 m 位于哪一边，然后确定 target 是不是位于有序的一边  //  public int search(int[] nums, int target) { int lo = 0; int hi = nums.length - 1; while (lo &amp;lt;= hi) { int m = lo + ((hi - lo) &amp;gt;&amp;gt; 1); if (nums[m] == target) { return m; } // 6 7 1 2 3 4 5  // ↑ ↑ ↑ ↑ ↑  //  // 1 2 3 4 5 6 7  // ↑ ↑ ↑ ↑ ↑ ↑ ↑  //  // 右侧有序  // target 是不是位于有序右侧空间  if (nums[m] &amp;lt;= nums[hi]) { if (target &amp;gt; nums[m] &amp;amp;&amp;amp; target &amp;lt;= nums[hi]) { lo = m + 1; } else { hi = m - 1; } } else { // 6 7 1 2 3 4 5  // ↑ ↑  //  // target 是否位于左侧有序空间内  if (target &amp;gt;= nums[lo] &amp;amp;&amp;amp; target &amp;lt; nums[m]) { hi = m - 1; } else { lo = m + 1; } } } return -1; } // ================================  // 下面这个方案先查找 min 值  // ================================  public int search0(int[] nums, int target) { // ================================  // 忘记这一步骤了  // ================================  if (nums.</description>
    </item>
    
    <item>
      <title>滑动窗口最大值</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/slidingwindowmaximum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/slidingwindowmaximum/</guid>
      <description>滑动窗口最大值 描述 原题 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 31 [3 -1 -3] 5 3 6 7 31 3 [-1 -3 5] 3 6 7 51 3 -1 [-3 5 3] 6 7 51 3 -1 -3 [5 3 6] 7 61 3 -1 -3 5 [3 6 7] 7题解 import java.</description>
    </item>
    
    <item>
      <title>滑动窗口中位数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/slidingwindowmedian/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/slidingwindowmedian/</guid>
      <description>滑动窗口中位数 描述 原题 中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。
例如：
 [2,3,4]，中位数是 3 [2,3]，中位数是 (2 + 3) / 2 = 2.5  给你一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。
示例：
给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。
窗口位置 中位数--------------- -----[1 3 -1] -3 5 3 6 7 11 [3 -1 -3] 5 3 6 7 -11 3 [-1 -3 5] 3 6 7 -11 3 -1 [-3 5 3] 6 7 31 3 -1 -3 [5 3 6] 7 51 3 -1 -3 5 [3 6 7] 6因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。</description>
    </item>
    
    <item>
      <title>颜色分类</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sortcolors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sortcolors/</guid>
      <description>颜色分类 描述 原题 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
题解 public class SortColors { // 0,0,1,1,2,2  //  // 2 0 1 0 1 1 2  public void sortColors(int[] nums) { // 000001111122222  // ↑ ↑  // l r  //  int left = 0; int right = nums.length - 1; int i = 0; while (i &amp;lt;= right) { if (nums[i] == 0) { // =========================  // 遇到 0 就换到左边  //  // 0 0 0 0 1 1 1 1 0 2  // ↑ ↑  // left i  //  // =========================  swap(nums, left++, i++); } else if (nums[i] == 1) { i++; } else { // =========================  // right 指向的是第一个非 2 的位置  //  // 遇到 2 就换到右边，但是换过来的不一定是 1 还是 0，所以 i 不能动  //  // 1 1 1 1 1 2 2 0  // ↑ ↑  // i right  //  // =========================  swap(nums, i, right--); } } } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } </description>
    </item>
    
    <item>
      <title>螺旋矩阵</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/spiralmatrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/spiralmatrix/</guid>
      <description>螺旋矩阵 Spiral Matrix 和 Spiral Matrix II
返回螺旋顺序 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
import java.util.ArrayList; import java.util.Collections; import java.util.List; public class SpiralMatrix { public List&amp;lt;Integer&amp;gt; spiralOrder(int[][] matrix) { if (matrix == null || matrix.length == 0) { return Collections.emptyList(); } List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int left = 0; int right = matrix[0].length - 1; int top = 0; int bottom = matrix.length - 1; while (true) { for (int c = left; c &amp;lt;= right; c++) { res.</description>
    </item>
    
    <item>
      <title>分割数组的最大值</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/splitarraylargestsum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/splitarraylargestsum/</guid>
      <description>分割数组的最大值 描述 原题 给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。
注意: 数组长度 n 满足以下条件:
 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)  输入:nums = [7,2,5,10,8]m = 2输出:18解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。题解 // 数组包含非负整数，以及一个 整数 m // 将数组分成 m 个连续的 subarray // 写一个算法，来使得所有的这些 subarrays 的最大和最小 // // [7,2,5,10,8] // // https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java public class SplitArrayLargestSum { // [.......]  //  // max: 所有数相加  // min: Math.</description>
    </item>
    
    <item>
      <title>X 的平方根</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sqrt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sqrt/</guid>
      <description>X 的平方根 描述 原题 实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
题解 public class Sqrt { public int mySqrt(int x) { // 注意边界条件  if (x == 0) { return 0; } int lo = 1; int hi = x / 2; int ans = lo; while (lo &amp;lt;= hi) { int mid = lo + ((hi - lo) &amp;gt;&amp;gt; 1); // 注意这里  // 防止溢出  if (mid &amp;gt; x / mid) { hi = mid - 1; } else if (mid &amp;lt;= x / mid) { ans = mid; lo = mid + 1; } } return ans; } } </description>
    </item>
    
    <item>
      <title>乘积小于K的子数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/subarrayproductlessthank/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/subarrayproductlessthank/</guid>
      <description>乘积小于K的子数组 描述 原题 给定一个正整数数组 nums。
找出该数组内乘积小于 k 的连续的子数组的个数。
示例 1:
输入: nums = [10,5,2,6], k = 100输出: 8解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。需要注意的是 [10,5,2] 并不是乘积小于100的子数组。题解 // Input: nums = [10, 5, 2, 6], k = 100 // Output: 8 // Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</description>
    </item>
    
    <item>
      <title>和为K的子数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/subarraysumequalsk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/subarraysumequalsk/</guid>
      <description>和为K的子数组 描述 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。题解 // Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. // // 和为 k 的连续子数组，有多少组 public class SubarraySumEqualsK { public int subarraySum(int[] nums, int k) { int[] preSum = calcPreSum(nums); int count = 0; for (int i = 0; i &amp;lt; preSum.</description>
    </item>
    
    <item>
      <title>K 个不同整数的子数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/subarrayswithkdifferentintegers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/subarrayswithkdifferentintegers/</guid>
      <description>K 个不同整数的子数组 描述 给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。
（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）
返回 A 中好子数组的数目。
示例 1：
输入：A = [1,2,1,2,3], K = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].题解 import java.util.HashMap; import java.util.Map; // Input: A = [1,2,1,2,3], K = 2 // Output: 7 // Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. // // 子数组里面有 k 个不同的数字 // // 解法参考了 // https://leetcode.</description>
    </item>
    
    <item>
      <title>2、3、4个数之和</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sum/</guid>
      <description>2、3、4个数之和 从 nums 数组中找到数字相加的结果符合要求的几个数字。
两数之和 import java.util.HashMap; import java.util.Map; // 返回索引 // // O(N) public class TwoSum { public int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { if (map.containsKey(target - nums[i])) { return new int[]{ map.get(target - nums[i]), i }; } map.put(nums[i], i); } return new int[]{}; } } 三个数之和 import java.util.List; import java.util.LinkedList; import java.util.ArrayList; import java.</description>
    </item>
    
    <item>
      <title>子数组的最小值之和</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sumofsubarrayminimums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sumofsubarrayminimums/</guid>
      <description>子数组的最小值之和 描述 原题 给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。
由于答案可能很大，因此返回答案模 10^9 + 7。
示例：
输入：[3,1,2,4]输出：17解释：子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。题解 import java.util.Stack; // // 连续子数组里面的最小值 min 相加的和 // [3,1,2,4]: // // [3][1][2][4][3,1][1,2][2,4][3,1,2][1,2,4][3,1,2,4] // public class SumofSubarrayMinimums { public int sumSubarrayMins(int[] A) { Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;(); // ==========================================  // 最左侧，第一个比 A[i] 小的值  // ==========================================  int[] leftMin = new int[A.length]; for (int i = 0; i &amp;lt; A.</description>
    </item>
    
    <item>
      <title>第三大的数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/thirdmaximumnumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/thirdmaximumnumber/</guid>
      <description>第三大的数 描述 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是 O(n)。
示例 1:
输入: [3, 2, 1]输出: 1解释: 第三大的数是 1.题解 // 返回第三大，如果不存在，返回最大的 // // Input: [3, 2, 1] // Output: 1 // Explanation: The third maximum is 1. // // Input: [2, 2, 3, 1] // Output: 1 // Explanation: Note that the third maximum here means the third maximum distinct number. // Both numbers with value 2 are both considered as second maximum. // // https://leetcode.</description>
    </item>
    
    <item>
      <title>前K大数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/topklargestnumbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/topklargestnumbers/</guid>
      <description>前K大数 描述 原题 在一个数组中找到前K大的数
题解 // https://www.lintcode.com/problem/top-k-largest-numbers/description // // Input: [3, 10, 1000, -99, 4, 100] and k = 3 // Output: [1000, 100, 10] import java.util.*; public class TopkLargestNumbers { public int[] topk(int[] nums, int k) { PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Integer&amp;gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); } }); for (int num: nums) { queue.offer(num); if (queue.size() &amp;gt; k) { queue.poll(); } } // addFirst();  // addLast();  // removeFirst();  // removeLast();  int[] res = new int[queue.</description>
    </item>
    
    <item>
      <title>有效的山脉数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/validmountainarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/validmountainarray/</guid>
      <description>有效的山脉数组 原题 给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。
让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：
 A.length &amp;gt;= 3 在 0 &amp;lt; i &amp;lt; A.length - 1 条件下，存在 i 使得：  A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]    题解 // https://leetcode.com/problems/valid-mountain-array/ // // (1) A.length &amp;gt;= 3 // (2) There exists some i with 0 &amp;lt; i &amp;lt; A.length - 1 such that: // A[0] &amp;lt; A[1] &amp;lt; .</description>
    </item>
    
    <item>
      <title>有效的数独</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/validsudoku/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/validsudoku/</guid>
      <description>有效的数独 描述 原题 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。  题解 import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; // https://leetcode.com/problems/valid-sudoku/ // // public class ValidSudoku { public boolean isValidSudoku(char[][] board) { int m = board.length; int n = board[0].length; Map&amp;lt;Integer, Set&amp;lt;Integer&amp;gt;&amp;gt; rowMap = new HashMap&amp;lt;&amp;gt;(); Map&amp;lt;Integer, Set&amp;lt;Integer&amp;gt;&amp;gt; colMap = new HashMap&amp;lt;&amp;gt;(); // 1 2 3  // 4 5 6  // 7 8 9  Map&amp;lt;Integer, Set&amp;lt;Integer&amp;gt;&amp;gt; smallBoxMap = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { char c = board[i][j]; if (c == &amp;#39;.</description>
    </item>
    
    <item>
      <title>有效三角形的个数</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/validtrianglenumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/validtrianglenumber/</guid>
      <description>有效三角形的个数 描述 原题 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。
示例 1:
输入: [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3题解 import java.util.Arrays; // 给定一个包含非负整数的数组，你的任务是计算从数组中选出的可以制作三角形的三元组数目，如果我们把它们作为三角形的边长。 // 非负 // // https://www.lintcode.com/problem/valid-triangle-number/description // public class ValidTriangleNumber { // ERROR: O(n ^ 2)，错误解法  public int triangleNumber(int[] nums) { // a + b &amp;gt; c  // c &amp;lt; a + b  //  // 1 2 3 4  Arrays.sort(nums); int count = 0; // 2 2 3 4  // ↑  // 2, 2, 4  // 2, 3, 4  // 2, 3, 4  // 2, 2, 3  for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/combinationsum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/combinationsum/</guid>
      <description>组合总和 下属题目，所有数字均是正整数
Combination Sum 原题 一个数组，从这个数组中找出所有相加等于 target 的元素的组合，数组中的每一个数字可以被多次重复选取。
 数组无重复数字。
 import java.util.ArrayList; import java.util.List; // Input: candidates = [2,3,5], target = 8, // A solution set is: // [ // [2,2,2,2], // [2,3,3], // [3,5] // ] // // candidates 里面没有重复数字 // 每一个 candidate 可以重复使用多次 // // 时间复杂度可以转为，见这个帖子分析 // https://leetcode.com/problems/combination-sum/discuss/16634/if-asked-to-discuss-the-time-complexity-of-your-solution-what-would-you-say // // 每个元素有 ceil(target / element) 个 // 展开后的数组个数为 n&amp;#39; = ceil(target / element) * n // 最后时间复杂度为 O(k * 2 ^ n&amp;#39;) // public class CombinationSum { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); helper(candidates, res, new ArrayList&amp;lt;Integer&amp;gt;(), 0, 0, target); return res; } private void helper(int[] candidates, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res, List&amp;lt;Integer&amp;gt; cur, int curSum, int index, int target) { if (curSum &amp;gt; target) { return; } if (curSum == target) { res.</description>
    </item>
    
    <item>
      <title>组合</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/combinations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/combinations/</guid>
      <description>组合 描述 原题 给定两个整数 n 和 k，返回 1 &amp;hellip; n 中所有可能的 k 个数的组合。
示例:
输入: n = 4, k = 2输出:[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]题解 import java.util.ArrayList; import java.util.List; // Input: n = 4, k = 2 // Output: // [ // [2,4], // [3,4], // [2,3], // [1,2], // [1,3], // [1,4], // ] // // 时间复杂度看起来像是 C(n, k)，从 n 个数里面选择 k 个 // 所以总的时间复杂度为 C(n, k) * O(k) public class Combinations { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int[] array = buildArray(n); helper(res, new ArrayList&amp;lt;Integer&amp;gt;(), array, k, 0); return res; } private void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res, List&amp;lt;Integer&amp;gt; cur, int[] array, int k, int begin) { // Base Case  // 得到之后，需要花费 O(K) 来拷贝结果到 res 里面  //  if (cur.</description>
    </item>
    
    <item>
      <title>为运算表达式设计优先级</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/differentwaystoaddparentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/differentwaystoaddparentheses/</guid>
      <description>为运算表达式设计优先级 描述 原题 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。
输入: &amp;quot;2-1-1&amp;quot;输出: [0, 2]解释: ((2-1)-1) = 0 (2-(1-1)) = 2 头条面试题
 题解 import java.util.LinkedList; import java.util.List; // 头条面试题 // // https://leetcode.com/problems/different-ways-to-add-parentheses/ // Input: &amp;#34;2*3-4*5&amp;#34; // Output: [-34, -14, -10, -10, 10] // Explanation: // (2*(3-(4*5))) = -34 // ((2*3)-(4*5)) = -14 // ((2*(3-4))*5) = -10 // (2*((3-4)*5)) = -10 // (((2*3)-4)*5) = 10 // // 只有 +、- 和 * // // 有几种不同的结果 public class DifferentWaysToAddParentheses { public List&amp;lt;Integer&amp;gt; diffWaysToCompute(String input) { List&amp;lt;Integer&amp;gt; ret = new LinkedList&amp;lt;Integer&amp;gt;(); for (int i = 0; i &amp;lt; input.</description>
    </item>
    
    <item>
      <title>快算 24</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/game24/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/game24/</guid>
      <description>快算 24 描述 原题 你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。
题解 import java.util.ArrayList; // Input: [4, 1, 8, 7] // Output: True // Explanation: (8-4) * (7-1) = 24 // // https://leetcode.com/articles/24-game/ public class Game24 { public boolean judgePoint24(int[] nums) { ArrayList A = new ArrayList&amp;lt;Double&amp;gt;(); for (int v: nums) { A.add((double) v); } return solve(A); } private boolean solve(ArrayList&amp;lt;Double&amp;gt; nums) { if (nums.size() == 0) return false; if (nums.</description>
    </item>
    
    <item>
      <title>生成括号对</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/generateparentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/generateparentheses/</guid>
      <description>生成括号对 描述 原题 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
输入：n = 3输出：[&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;]题解 import java.util.LinkedList; import java.util.List; // 时间复杂度，总的括号对个数是 Catalan number 个 // O(C(2n, n) / (n + 1)) // public class GenerateParentheses { public List&amp;lt;String&amp;gt; generateParenthesis(int n) { List&amp;lt;String&amp;gt; res = new LinkedList&amp;lt;&amp;gt;(); helper(res, &amp;#34;&amp;#34;, 0, 0, n); return res; } private void helper(List&amp;lt;String&amp;gt; res, String cur, int open, int close, int n) { if (open == n &amp;amp;&amp;amp; close == n) { res.</description>
    </item>
    
    <item>
      <title>字母大小写全排列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/lettercasepermutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/lettercasepermutation/</guid>
      <description>字母大小写全排列 描述 给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。
题解 import java.util.ArrayList; import java.util.List; // Examples: // Input: S = &amp;#34;a1b2&amp;#34; // Output: [&amp;#34;a1b2&amp;#34;, &amp;#34;a1B2&amp;#34;, &amp;#34;A1b2&amp;#34;, &amp;#34;A1B2&amp;#34;]  // Input: S = &amp;#34;3z4&amp;#34; // Output: [&amp;#34;3z4&amp;#34;, &amp;#34;3Z4&amp;#34;]  // Input: S = &amp;#34;12345&amp;#34; // Output: [&amp;#34;12345&amp;#34;] // // 假设字符串中包含 k 个需要转的字符 // 那么总共有 2 ^ k 个状态，base case 需要拷贝，那么就是 O(n) // 所以复杂度为 O(n * 2^k) public class LetterCasePermutation { public List&amp;lt;String&amp;gt; letterCasePermutation(String S) { List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); helper(res, S.</description>
    </item>
    
    <item>
      <title>电话号码的字母组合</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/lettercombinationsofaphonenumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/lettercombinationsofaphonenumber/</guid>
      <description>电话号码的字母组合 描述 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
题解 import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; // 时间复杂度为 O(3 ^ N * 4 ^ M) 次方个 // // 每一个数有 3 种选法的有 N 个 // 每一个数有 4 种选法的有 M 个 // public class LetterCombinationsofaPhoneNumber { static Map&amp;lt;Character, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); static { map.put(&amp;#39;2&amp;#39;, &amp;#34;abc&amp;#34;); map.put(&amp;#39;3&amp;#39;, &amp;#34;def&amp;#34;); map.put(&amp;#39;4&amp;#39;, &amp;#34;ghi&amp;#34;); map.put(&amp;#39;5&amp;#39;, &amp;#34;jkl&amp;#34;); map.put(&amp;#39;6&amp;#39;, &amp;#34;mno&amp;#34;); map.put(&amp;#39;7&amp;#39;, &amp;#34;pqrs&amp;#34;); map.put(&amp;#39;8&amp;#39;, &amp;#34;tuv&amp;#34;); map.put(&amp;#39;9&amp;#39;, &amp;#34;wxyz&amp;#34;); } public List&amp;lt;String&amp;gt; letterCombinations(String digits) { List&amp;lt;String&amp;gt; res = new LinkedList&amp;lt;&amp;gt;(); if (digits == null || digits.</description>
    </item>
    
    <item>
      <title>N 皇后</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/nqueues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/nqueues/</guid>
      <description>N 皇后 描述 原题 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
题解 import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.List; public class NQueues { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueens(int n) { char[][] grid = new char[n][n]; for (int i = 0; i &amp;lt; n; i++) { Arrays.fill(grid[i], &amp;#39;.&amp;#39;); } List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(); helper(res, grid, 0, n); return res; } // 方法是对于固定的列 colIndex，依次试探第 0 1 2 ... n 行，然后看是否 OK，如果 OK，试探 colIndex + 1 列  // colIndex == n 的时候，就可以返回了  private void helper(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res, char[][] grid, int colIndex /** 对于固定的列 */, int n) { if (colIndex == n) { res.</description>
    </item>
    
    <item>
      <title>CSS 垂直居中</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-center/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-center/</guid>
      <description>CSS 垂直居中 有固定的高度和宽度 主要是依靠 absolute 属性置于距离左上角 50% 的位置，然后再利用 margin 调整位置。
.parent { position: relative; } .child { width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px; } 效果如下  假如不添加 margin   无固定的高度和宽度 使用 transform 属性：
.parent { position: relative; } .child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 使用 flexbox 布局 .container { display: flex; justify-content: center; align-items: center; } 单行文本水平垂直居中 transform .</description>
    </item>
    
    <item>
      <title>Git .gitignore 文件</title>
      <link>https://kunzhao.org/docs/tutorial/git/git-ignore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/git/git-ignore/</guid>
      <description>Git .gitignore 文件 Git 可以使用 .gitignore 文件来对工作区的某个目录、某个文件等设置忽略，忽略后这些文件的状态变化，将不会被记录在 git 中，也不会被 push 到远程服务器上。
如果想要忽略项目里面的某些文件夹，比如 build/、target/、node_modules/ 等文件夹，不 push 到服务器上，就需要在相应的目录中添加一个 .gitignore 文件，并在里面将这些文件夹的名字给加上。
.gitignore 的作用范围 作用范围：.gitignore 文件所处的目录及其子目录。
如何查看哪些文件被忽略了 git status --ignored # 或 git check-ignore -v example.jpg .gitignore 文件语法  # 开始的行代表注释 *：代表任意多个字符，?：代表一个字符，[abc] 代表可选字符范围等 **：匹配任意数量的目录 名称以 / 开头：只忽略此目录下的文件，对于子目录中的文件不忽略 名称以 / 结尾：忽略整个目录，同名文件不忽略；否则同名文件和目录都被忽略 名称以 ! 开头：代表不忽略这个文件  示例 # 任何目录下面的 .DS_Store 文件都会被忽略 .DS_Store # 忽略整个目录 node_modules/ logs/ # 忽略所有以 log 结尾的文件，但是 example.log 不被忽略 *.log !example.log # 忽略 abc 文件夹下面的以 log 结尾的文件，注意：子目录不会被忽略 abc/*.</description>
    </item>
    
    <item>
      <title>Java 垃圾回收器</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/java-gc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/java-gc/</guid>
      <description>Java 垃圾回收器 判断对象是否可回收 如何判断一个对象属于垃圾对象呢？
引用计数法 对于一个对象 A，只要有任意一个对象引用了 A，则 A 的计数器加 1，当引用失效的时候，引用计数器就减 1。如果 A 的应用计数器为 0，则对象 A 就不可能再被使用。
 缺点：无法处理循环引用的问题。
 可达性分析算法 通过一系列的称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的循环称为引用链。当一个对象到 GC Roots 没有任何引用链的时候，则证明此对象是不可达的，因此它们会被判定为可回收对象。
可以作为 GC Roots 的对象：
 类静态属性中引用的对象 常量引用的对象 虚拟机栈中引用的对象 本地方法栈中引用的对象  垃圾回收算法 标记-清除算法 从每个 GC Roots 对象出发，依次标记有引用关系的对象，最后将没有被标记的对象清除。
 缺点：带来大量空间碎片，导致需要分配一个较大连续空间时，容易触发 GC。
 标记-整理(标记-压缩)算法 从每个 GC Roots 对象出发，标记存活的对象，然后将存活的对象整理到内存空间的一端，形成连续的已使用空间，最后将已使用空间外的部分全部清理掉，消除空间碎片问题。
标记-复制算法 为了能够并行的标记和整理，将整个空间分为两块，每次只激活一块，垃圾回收只需把存活的对象复制到另一块未激活的空间上，将未激活空间标记为已激活，将已激活空间标记为未激活，然后清除原空间中的原对象。
分代收集算法 垃圾收集器一般根据对象存活周期的不同，将内存划分为几块，根据每块内存空间的特点，使用不同的回收算法，提供回收效率。
分区算法 将整个堆空间划分为连续的不同小空间，每一个小空间独立使用，独立回收。
 优点：可以控制一次回收多少个小区间。
 HotSpot 虚拟机垃圾收集器 Serial 新生代 Serial 收集器采用复制算法，使用单线程进行垃圾回收，回收时 Java 应用程序中的线程都需要暂停 (Stop-The-World)，以等待回收完成。使用 -XX:+UseSerialGC 可以指定新生代采用 Serial 收集器，老年代采用 Serial Old 收集器。</description>
    </item>
    
    <item>
      <title>平均负载</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/avg-load/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/avg-load/</guid>
      <description>平均负载  作者：赵坤
 uptime 命令 了解负载情况：
$ uptime 22:39:37 up 2:47, 1 user, load average: 1.44, 1.12, 0.79 含义：
# 当前时间 22:39:37 # 系统运行多久了 up 2:47 # 当前有几个用户登录 1 user # 过去 1 分钟、5 分钟、15 分钟的平均负载 load average: 1.44, 1.12, 0.79 平均负载的含义  平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。
  可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。  $ ps -efl F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD 4 S root 1 0 0 80 0 - 42420 - 19:51 ?</description>
    </item>
    
    <item>
      <title>并发 - 多线程的实现方式</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/multi-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/multi-thread/</guid>
      <description>多线程的实现方式 Java多线程实现方式主要有四种：
 继承 Thread 类 实现 Runnable 接口 实现 Callable 接口 使用线程池  继承 Thread 类 class MyThread extends Thread { @Override public void run() { System.out.println(&amp;#34;MyThread.run()&amp;#34;); } } MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.start(); myThread2.start(); 实现 Runnable 接口 class MyTask implements Runnable { @Override public void run() { System.out.println(&amp;#34;MyTask running....&amp;#34;); } } new Thread(new MyTask()).start(); 实现 Callable 接口 Callable 接口可以在任务执行完之后获取结果：
public class MyCallable implements Callable&amp;lt;String&amp;gt; { @Override public String call() throws Exception { return String.</description>
    </item>
    
    <item>
      <title>设计数据密集型应用程序 - 可靠 &amp; 可扩展 &amp; 可维护</title>
      <link>https://kunzhao.org/docs/books/ddia-chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/ddia-chapter1/</guid>
      <description>设计数据密集型应用程序 - 可靠 &amp;amp; 可扩展 &amp;amp; 可维护  笔记来自于 《Designing Data-Intensive Applications》 的第一章
 何为数据密集型应用程序 很多应用程序都需要用到如下和数据打交道的系统:
 数据库 缓存 搜索数据 &amp;amp; 索引 流处理 批量处理  设计这样的应用程序需要考虑很多因素，在此重点关注:
 可靠性: 系统持续工作 可扩展: 能维持系统负载 (Load) 的增长 可维护: 多人维护  Twitter 的负载  2012 年 Tweet 平均产生的速率: 4.6k/s，峰值速率可以达到 12k/s. 用户浏览首页的这个 API 请求平均: 300k/s.  Twitter 主要的挑战在于，每个用户可以关注很多人，每个人可以被很多人关注。实现这种系统通常有两种方式:
(1) 用户发布 Tweet 直接写入到大的 Tweet 表中即可。而用户浏览首页，需要首先查找用户关注的所有人，找到这些人发布的所有 Tweet，然后(按照时间)合并这些 Tweet:
SELECT tweets.*, users.* FROM tweets JOIN users ON tweets.sender_id = users.</description>
    </item>
    
    <item>
      <title>CPU 上下文切换</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/context-switch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/context-switch/</guid>
      <description>CPU 上下文切换  作者：赵坤
 CPU 上下文  CPU 上下文是 CPU 在运行任何任务前，必须的依赖环境。在每个任务运行前，CPU 需要知道任务从哪里加载、又从哪里开始运行，所以这些环境通常包括 CPU 寄存器和程序计数器等。
 查看系统上下文切换情况 可以使用 vmstat 查询：
# 每隔 5 秒查询一次 $ vmstat 5 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 256 170532 136656 3361432 0 0 38 53 189 557 6 2 92 0 0 0 0 256 170060 136668 3362284 0 0 0 62 441 785 2 1 97 0 0 0 0 256 170320 136676 3362360 0 0 0 13 706 1002 3 1 97 0 0  cs：每秒上下文切换的次数</description>
    </item>
    
    <item>
      <title>并发 - synchronized</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/synchronized/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/synchronized/</guid>
      <description>synchronized 锁的对象是谁 当你使用 synchronized 关键字的时候，JVM 底层使用 Monitor 锁来实现同步。而锁的对象可以分为：
 如果 synchronized 的是普通方法，那么锁是当前实例 如果 synchronized 的是静态方法，那么锁是当前类的 Class 如果 synchronized 的是同步块，那么锁是括号里面的对象  synchronized 同步块 底层基于 monitorenter 和 monitorexit 这一对指令实现的。
public void foo(Object lock) { synchronized (lock) { lock.hashCode(); } } 上面的Java代码将编译为下面的字节码：
public void foo(java.lang.Object); Code: 0: aload_1 1: dup 2: astore_2 3: monitorenter 4: aload_1 5: invokevirtual java/lang/Object.hashCode:()I 8: pop 9: aload_2 10: monitorexit 11: goto 19 14: astore_3 15: aload_2 16: monitorexit 17: aload_3 18: athrow 19: return Exception table: from to target type 4 11 14 any 14 17 14 any synchronized 方法 方法标记为 ACC_SYNCHRONIZED，同样需要进行 monitorenter 操作。</description>
    </item>
    
    <item>
      <title>移动端响应式布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/mobile-responsive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/mobile-responsive/</guid>
      <description>移动端响应式布局 1px 的坑  1px 的坑：CSS 中的 1px 并不是固定的大小，它是一个跟设备大小有关系的单位。PC 端的 5px 单位看到的视觉效果并不等同于移动端看到的 5px 的效果。
 1 CSS 像素与屏幕物理像素的换算公式：
1 CSS 像素 = 物理像素 / 分辨率 rem rem 是一种相对于根字体大小的相对单位。根字体就是 &amp;lt;html&amp;gt; 元素的字体，改变了 &amp;lt;html&amp;gt; 字体的大小，那么整个页面上基于 rem 的大小都会改变。一般初始值是 16px。
这种方案需要监听屏幕窗口大小的变化，然后动态地改变 &amp;lt;html&amp;gt; 的 font-size，这个 font-size 一变化，整个页面的其他元素的大小也会跟着变化，从而达到适配的效果。
function refreshRem() { var docEl = doc.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + &amp;#39;px&amp;#39;; flexible.rem = win.rem = rem; } win.addEventListener(&amp;#39;resize&amp;#39;, refreshRem); 有了这个函数，再使用 CSS 预编译插件 px2rem 将 CSS 中定义的 px 转为 rem 单位即可。</description>
    </item>
    
    <item>
      <title>设计数据密集型应用程序 - 数据模型 &amp; 查询语言</title>
      <link>https://kunzhao.org/docs/books/ddia-chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/ddia-chapter2/</guid>
      <description>设计数据密集型应用程序 - 数据模型 &amp;amp; 查询语言  笔记来自于 《Designing Data-Intensive Applications》 的第二章
 LinkedIn 的简历 简历是一种 self-contained 文档，采用 JSON 的表达方式应该会更为合适。
JSON 示例如下:
{ &amp;#34;user_id&amp;#34;: 251, &amp;#34;first_name&amp;#34;: &amp;#34;Bill&amp;#34;, &amp;#34;last_name&amp;#34;: &amp;#34;Gates&amp;#34;, &amp;#34;summary&amp;#34;: &amp;#34;Co-chair of the Bill &amp;amp; Melinda Gates... Active blogger.&amp;#34;, &amp;#34;region_id&amp;#34;: &amp;#34;us:91&amp;#34;, &amp;#34;industry_id&amp;#34;: 131, &amp;#34;photo_url&amp;#34;: &amp;#34;/p/7/000/253/05b/308dd6e.jpg&amp;#34;, &amp;#34;positions&amp;#34;: [ {&amp;#34;job_title&amp;#34;: &amp;#34;Co-chair&amp;#34;, &amp;#34;organization&amp;#34;: &amp;#34;Bill &amp;amp; Melinda Gates Foundation&amp;#34;}, {&amp;#34;job_title&amp;#34;: &amp;#34;Co-founder, Chairman&amp;#34;, &amp;#34;organization&amp;#34;: &amp;#34;Microsoft&amp;#34;} ], &amp;#34;education&amp;#34;: [ {&amp;#34;school_name&amp;#34;: &amp;#34;Harvard University&amp;#34;, &amp;#34;start&amp;#34;: 1973, &amp;#34;end&amp;#34;: 1975}, {&amp;#34;school_name&amp;#34;: &amp;#34;Lakeside School, Seattle&amp;#34;, &amp;#34;start&amp;#34;: null, &amp;#34;end&amp;#34;: null} ], &amp;#34;contact_info&amp;#34;: { &amp;#34;blog&amp;#34;: &amp;#34;http://thegatesnotes.</description>
    </item>
    
    <item>
      <title>position 属性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/position/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/position/</guid>
      <description>position 属性 作用：决定一个元素放在页面的哪个位置。
static 这是默认值。含义：不要以任何特殊的方式摆放这个元素的位置。
relative 这个属性同 static 的表现一致。如果你加了其它的属性比如 top、right、bottom、left 属性，那么就会导致它相应的偏离自己原来的默认位置。
fixed 让元素相对于浏览器的窗口摆放位置。这个元素不会随着页面的滚动而滚动。
absolute 让元素相对于离自己最近的 position 属性的值是非 static 的祖先元素摆放位置。如果实在找不到 position 属性是非 static 的祖先，那么就会相对于 body 元素摆放位置，随着页面的滚动而滚动。
sticky sticky 是粘性定位 (动态定位)。它依据滚动的位置动态地在 fixed 定位和 relative 定位之间切换。
参考  CSS position explained  </description>
    </item>
    
    <item>
      <title>并发 - ThreadLocal</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/threadlocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/threadlocal/</guid>
      <description>ThreadLocal 作用 有一个比喻：
学生需要在签字墙签字，锁 相当于只有一个签字笔，学生们需要争抢这个签字笔；而 ThreadLocal 相当于给每个学生发了一个签字笔，每人一个，效率大大提升。
底层原理 假如你自己需要实现 ThreadLocal&amp;lt;T&amp;gt; 相关的 API，请问你会怎么做？
 你可能会使用 ConcurrentHashMap&amp;lt;Thread, T&amp;gt;，以 Thread.currentThread() 作为 key，这完全可以。但是缺点明显：1. 处理并发问题；2. 必须有指针指向 Thraed 和 这个对象，即使 Thraed 已经结束了，可以被 GC 了。 那我们改为  Collections.synchronizedMap(new WeakHashMap&amp;lt;Thread, T&amp;gt;()) 怎样？ 可以解决 GC 问题，但是多线程问题仍然没有解决。  Java 实现的想法，没有用 &amp;lt;Thread, T&amp;gt; ，而是大概如下：
new WeakHashMap&amp;lt;ThreadLocal,T&amp;gt;() 而事实上，在每个 Thread 内部也的确有这么一个 Map 指针：
public class Thread implements Runnable { ThreadLocal.ThreadLocalMap threadLocals = null; } 虽然 ThreadLocalMap 并不是一个 WeakHashMap，但是它的设计类似 WeakHashMap，它的 Key 是由 Weak Reference 引用的。</description>
    </item>
    
    <item>
      <title>设计数据密集型应用程序 - 存储和读取</title>
      <link>https://kunzhao.org/docs/books/ddia-chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/ddia-chapter3/</guid>
      <description>设计数据密集型应用程序 - 存储和读取  笔记来自于 《Designing Data-Intensive Applications》 的第三章
 精心选取的索引可以提升查询的速度，但是也会影响写入的速度。很多数据库系统内部会采用一种 append-only log file 文件，来记录更新了什么数据。
Hash 索引 使用 in-memory hash map 对只进行追加写入的文件进行索引:
如上述讨论，我们只对文件追加，但是如何防止文件大到超出磁盘空间呢？一种可行的办法是，将 log 文件切分为 segments (当一个 segment 文件达到某个大小的时候，就关闭它，然后开始往新的 segment 文件中写入)，我们可以在这些 compaction 中进行 compaction (去除对 key 的重复的历史更新，只保留最近一次的更新即可)。
事实上，在执行 compaction (可以让 segment 文件不至于太大) 的时候，我们还可以同时 merge segments 到新的 segment 文件中，可以使用一个后台线程来执行这些操作。在执行操作的同时，我们依然可以使用旧的 segment 文件继续对外提供 read 和 write 服务。当 merge 完毕后，我们再切换到新的 segment 文件上，然后将旧的 segment 文件删除即可。
现在每一个 segment 文件都拥有了自己的 in-memory hash table，存储了 key 到文件偏移量的映射关系。根据 key 查找值的过程，我们首先检查最近的 segment 的 hash map，如果 key 不在里面，我们就查找第二个 segment，以此类推。merge 操作本身会保证 segment 文件不至于太多，所以我们也无须查看太多的 hash map。当然在实际实现中，还是有很多问题需要考虑:</description>
    </item>
    
    <item>
      <title>CSS 盒模型</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/box-sizing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/box-sizing/</guid>
      <description>CSS 盒模型 作用 决定一个元素占据多大的矩形面积。
W3C 盒模型 （标准模型） .myClass { box-sizing: content-box; }  box-sizing 属性的默认值是：content-box
 IE 盒模型 .myClass { box-sizing: border-box; } W3C VS IE 对比 </description>
    </item>
    
    <item>
      <title>并发 - 线程池</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/threadpool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/threadpool/</guid>
      <description>线程池 好处 说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。
设计哲学 将任务的提交与执行解耦开，从而无须太大的困难就能为某种类型的任务指定和修改执行策略。
用法 任务无须返回值，调用这个方法：
public void execute(Runnable command) {} 需要返回值的任务，调用 submit：
Future&amp;lt;Object&amp;gt; future = executor.submit(hasReturnValuetask); try { Object s = future.get(); } catch (InterruptedException e) { // ... } catch (ExecutionException e) { // ... } 构造器参数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { // ... } execute() 方法运行原理 （1） 如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务。部分代码片段如下：
if (workerCountOf(c) &amp;lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.</description>
    </item>
    
    <item>
      <title>设计数据密集型应用程序 - 编码与演化</title>
      <link>https://kunzhao.org/docs/books/ddia-chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/ddia-chapter4/</guid>
      <description>设计数据密集型应用程序 - 编码与演化  笔记来自于 《Designing Data-Intensive Applications》 的第四章
 JSON 的二进制编码 { &amp;#34;userName&amp;#34;: &amp;#34;Martin&amp;#34;, &amp;#34;favoriteNumber&amp;#34;: 1337, &amp;#34;interests&amp;#34;: [&amp;#34;daydreaming&amp;#34;, &amp;#34;hacking&amp;#34;] } MessagePack, a binary encoding for JSON.
第一个字节 0x83 表示接下来将会是一个对象，第二个字节 0xa8，表示接下来是一个字符串。
Thrift 和 Protocol Buffers Protocol Buffers 是由 Google 开发的，Thrift 是有 Facebook 开发的，二者均需要使用一个 schema 来帮助编码。在 Thrift 世界中，对上述 JSON 的编码，需要首先使用 Thrift IDL 来描述 schema:
struct Person { 1: required string userName, 2: optional i64 favoriteNumber, 3: optional list&amp;lt;string&amp;gt; interests } Protocol Buffers 中定义的 schema 如下所示:</description>
    </item>
    
    <item>
      <title>BFC 和 IFC</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/bfc_ifc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/bfc_ifc/</guid>
      <description>BFC 和 IFC BFC - Block formatting context 简介 BFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context 提供了一个环境，HTML 元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。
何时触发 BFC  &amp;lt;html&amp;gt; float 属性不为 none position 属性是 absolute 或 fixed overflow 属性不为 visible display 属性为 inline-block display 属性为 table-cell、table-caption、table、table-row 等表格元素 display 属性为 flow-root display 属性为 flex、inline-flex display 属性为 grid、inline-grid column-count 或 column-width 属性不为 auto 的 column-span 属性为 all  BFC 作用 消除外边距重叠 发生外边距重叠 &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;margin-bottom: 100px&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;margin-top: 100px&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;   分别放在不同的 BFC 容器中 &amp;lt;div style=&amp;#34;overflow: hidden;&amp;#34;&amp;gt; &amp;lt;p style=&amp;#34;margin-bottom: 100px;&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;overflow: hidden;&amp;#34;&amp;gt; &amp;lt;p style=&amp;#34;margin-top: 100px;&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;    包含浮动的元素 包含 float 孩子，容器高度变窄 &amp;lt;div style=&amp;#34;border: 1px solid #000;&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;width: 100px; height: 100px; float: left;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;   触发容器的 BFC，正常计算高度 &amp;lt;div style=&amp;#34;border: 1px solid #000; overflow: hidden&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;width: 100px; height: 100px; float: left;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;    阻止元素被浮动元素覆盖 div B 被 float div A 覆盖 &amp;lt;div class=&amp;#34;A&amp;#34; style=&amp;#34;float: left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;B&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;   触发容器的 BFC &amp;lt;div class=&amp;#34;A&amp;#34; style=&amp;#34;float: left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;B&amp;#34; style=&amp;#34;overflow: hidden&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;    IFC - Inline formatting context 什么时候触发 IFC 当一个 block 容器只包含 inline 元素的时候就会触发 IFC</description>
    </item>
    
    <item>
      <title>并发 - volatile</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/volatile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/volatile/</guid>
      <description>volatile 作用  在多处理器中，保证共享变量的 “可见性”（一个线程修改后，另外一个线程能立即读取到这个最新修改的值） 禁止对指令进行重排序  三大特性  原子性 有序性 可见性  对比 synchronized  volatile 无法保证原子性 volatile 不会使线程陷入阻塞，不会引起线程上下文的切换和调度  典型用法 数绵羊程序：
volatile boolean sleep; while (!sleep) { countSleep(); } 底层原理 有 volatile 变量修饰的共享变量进行写操作的时候会多出一行以 lock;  指令开头的汇编代码。而 lock;  指令相当于一个内存屏障，其作用如下所示：
 将当前处理器缓存行的数据写回到系统内存。 这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。  </description>
    </item>
    
    <item>
      <title>设计数据密集型应用程序 - Replication</title>
      <link>https://kunzhao.org/docs/books/ddia-chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/books/ddia-chapter5/</guid>
      <description>设计数据密集型应用程序 - Replication Replication 就是将相同数据的拷贝防止在多个通过网络连接在一起的机器上。
为什么需要 Replication  让数据在地理位置上更靠近用户 部分数据坏掉的时候，系统依然能持续工作 可伸缩，增加机器即可增加吞吐量  如果你需要 replication 的数据不发生变化，那么 replication 的过程是及其简单的，你只需拷贝到其它各个机器上，然后你的任务就完成了。然而 replication 最难的地方也就在这个地方，如何处理变化的数据？接下来就介绍三种常见的处理 replication 中数据变化的算法: single-leader、multi-leader、leaderless。
Leaders 和 Followers 每一个存储一份数据库拷贝的节点称之为: replica。每一个 replica 都需要处理写数据的操作，久而久之，每一个节点之间存储的数据也就不再一致了。解决这种问题最常见的办法就是: leader-based replication (active/passive 或 master-slave replication)，它的工作原理如下:
 其中某个 replica 被指定为 leader (master 或 primary)，客户端想要写数据，那么必须将它们的写数据的请求发送给 leader，然后 leader 随后写入到自己的本地磁盘中。 其余的 replica 称之为 follower (read replicas, slaves, secondaries, hot standbys)，当 leader 写入数据到本地磁盘的时候，同时将数据改变的部分作为 replication log 或者 change stream 发送给它的 followers。每一个 follower 根据收到的 log 按照和 leader 处理不同写操作之间的相同的顺序，来更新它自己本地的数据。 当一个客户端想要读取数据的时候，它可以发送读请求给 leader 或者任意一个 follower。但是写请求的话只能发送给 leader。  这种模式的 replication 内置在许多数据库中，例如: PostgreSQL、MySQL、Oracle Data Guard、SQL Server 的 AlwaysOn Availability Groups，甚至在许多非关系型数据库中也有它的身影，例如: MongoDB、RethinkDB、Espresso，这种模式也局限于数据库，像消息中间件 Kafka 和 RabbitMQ 高可用的队列都依赖它，一些网络文件系统和 replicated block devices 例如 DRBD 也是同样的道理。</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap 1.8</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/concurrenthashmap-18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/concurrenthashmap-18/</guid>
      <description>ConcurrentHashMap 1.8 计算 size() final long sumCount() { CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) { for (int i = 0; i &amp;lt; as.length; ++i) { if ((a = as[i]) != null) sum += a.value; } } return sum; } public int size() { long n = sumCount(); return ((n &amp;lt; 0L) ? 0 : (n &amp;gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n); } </description>
    </item>
    
    <item>
      <title>CyclicBarrier</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/cyclicbarrier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/cyclicbarrier/</guid>
      <description>CyclicBarrier 作用 让一组线程等待某个事件(barrier)的发生。
实现原理 在 dowait 方法中有如下计数器：
int index = --count; if (index == 0) { // tripped  boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } 其中 runGeneration 或 breakBarrier 中有如下代码片段：
trip.signalAll(); trip 是信号量：
/** Condition to wait on until tripped */ private final Condition trip = lock.</description>
    </item>
    
    <item>
      <title>左固定右自适应</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/layout-left-fix-right-responsive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/layout-left-fix-right-responsive/</guid>
      <description>两列布局：左固定，右自适应 &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p&amp;gt;这是左边的盒子&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt; &amp;lt;p&amp;gt;这是右边的盒子&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 双 float .container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } .left, .right { box-sizing: border-box; float: left; } .right { width: calc(100% - 120px); } float + margin-left .container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } .left { box-sizing: border-box; float: left; } .right { margin-left: 120px; } absolute + margin-left .left { box-sizing: border-box; position: absolute; } .</description>
    </item>
    
    <item>
      <title>ArrayList</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/arraylist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/arraylist/</guid>
      <description>ArrayList  基于 JDK 1.8 实现分析的
 初始容量 /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * Constructs an empty list with an initial capacity of ten.</description>
    </item>
    
    <item>
      <title>flex 布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/flex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/flex/</guid>
      <description>flex 布局 flex 容器 开启 flex 容器 .myClass { /** inline-flex 也可以开启 */ display: flex; } flex-direction flex-direction 定义了 main axis，其决定容器内的元素是横向布局还是纵向布局，其可选值如下：
 row (默认) row-reverse column column-reverse  flex-wrap flex-wrap 指定容器内的元素如何换行，默认情况下是挤在一行。其可选值如下：
 nowrap (默认) wrap：from top to bottom wrap-reverse：from bottom to top  flex-flow flex-flow 是 flex-direction 和 flex-wrap 这两个属性的缩写，能够同时定义这两个属性。
.myClass { flex-flow: flex-direction flex-wrap; }  flex-flow 的默认值：row nowrap
 justify-content 在 main axis 轴上如何利用剩余空间：
align-items 在 cross axis 轴上如何利用空间：</description>
    </item>
    
    <item>
      <title>CSS 九宫格</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-jiugongge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-jiugongge/</guid>
      <description>CSS 九宫格 公共 CSS 属性 .square{ position: relative; width: 100%; height: 0; padding-bottom: 100%; /* padding百分比是相对父元素宽度计算的 */ margin-bottom: 30px; } .square-inner{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; /* 铺满父元素容器，这时候宽高就始终相等了 */ } .square-inner&amp;gt;li{ width: calc(98% / 3); /* calc里面的运算符两边要空格 */ height: calc(98% / 3); margin-right: 1%; margin-bottom: 1%; overflow: hidden; } FlexBox HTML：
&amp;lt;div class=&amp;#34;square&amp;#34;&amp;gt; &amp;lt;ul class=&amp;#34;square-inner flex&amp;#34;&amp;gt; &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;6&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;7&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;8&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;9&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt;   CSS：</description>
    </item>
    
    <item>
      <title>HashMap</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/hashmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/hashmap/</guid>
      <description>HashMap get 方法如何实现的 public V get(Object key) { Node&amp;lt;K,V&amp;gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&amp;lt;K,V&amp;gt; getNode(int hash, Object key) { Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; int n; K k; if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp; (first = tab[(n - 1) &amp;amp; hash]) != null) { if (first.hash == hash &amp;amp;&amp;amp; // always check first node  ((k = first.</description>
    </item>
    
    <item>
      <title>TreeMap</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/treemap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/treemap/</guid>
      <description>TreeMap 如何保证有序 只需要看 put 方法的部分细节即可：
Comparator&amp;lt;? super K&amp;gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp &amp;lt; 0) t = t.left; else if (cmp &amp;gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } </description>
    </item>
    
    <item>
      <title>清除浮动</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/clear-float/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/clear-float/</guid>
      <description>清除浮动 clear:both 给浮动元素后面的元素添加 clear: both 属性。
.element { clear: both; } 空 DIV &amp;lt;div style=&amp;#34;clear: both;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; overflow：触发 BFC 给浮动元素的容器添加 overflow:hidden; 或 overflow:auto; 可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。
:after 添加一个 :after 伪元素来清除浮动。
.clearfix:after { content: &amp;#34;.&amp;#34;; visibility: hidden; display: block; height: 0; clear: both; } 参考  All About Floats CSS - 清除浮动  </description>
    </item>
    
    <item>
      <title>CSS 画三角形</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-triangle/</guid>
      <description>CSS 画三角形 上三角形 #triangle-up { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; } 下三角形 #triangle-down { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } 左三角形 #triangle-left { width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; } 右三角形 #triangle-right { width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; } 左上朝向的直角三角形 #triangle-topleft { width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; } 右上朝向的直角三角形 #triangle-topright { width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; } 左下朝向的直角三角形 #triangle-bottomleft { width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; } 右下朝向的直角三角形 #triangle-bottomright { width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; } 参考  The Shape of CSS  </description>
    </item>
    
    <item>
      <title>CSS 选择器</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-selector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-selector/</guid>
      <description>CSS 选择器 选择器类型    选择器 示例     ID #id   class .class   标签 p   通用 *   属性 [type=&amp;quot;text&amp;quot;]   伪类 :hover   伪元素 ::first-line   子选择器、相邻选择器     权重优先级 important &amp;gt; 内嵌样式 &amp;gt; ID &amp;gt; 类 &amp;gt; 标签 | 伪类 | 属性选择 &amp;gt; 伪元素 &amp;gt; 继承 &amp;gt; 通配符
权重赋值  内联样式如 style=XXX：1000 ID 选择器：100 类、伪类、属性选择器：10 标签、伪元素选择器：1 通配符、子选择器、相邻选择器等：0  比较规则：逐级比较。权重一样的 CSS 表达式，在样式表中后声明的优先。</description>
    </item>
    
    <item>
      <title>CSS 两边固定中间自适应布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/fixed-side-responsive-middle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/fixed-side-responsive-middle/</guid>
      <description>CSS 两边固定中间自适应布局 中间 float BFC 布局 &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;center&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;浮动布局&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; .container &amp;gt; div{ height: 200px; } .left { float: left; width: 300px; background: red; } .right { float: right; width: 300px; background: blue; } .center { overflow: hidden; background: yellow; }  缺点：中间浮动布局的内容最后才加载
 圣杯布局  父元素：需要内边距 三个孩子全部是：float: left 左右分别是相对布局  &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;center&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;圣杯布局&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; .container { padding: 0 300px; } .</description>
    </item>
    
    <item>
      <title>CSS3 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css3-new-feature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css3-new-feature/</guid>
      <description>CSS3 新特性 新特性概览    新特性 说明     新的选择器    阴影 Box 阴影、文本阴影   圆角    渐变    透明度    Transitions    Transformations 旋转、缩放、扭曲、平移等   动画    多列布局    Flexbox 构建 Flex 布局   Grids 构建二维布局   @font face 嵌入更多字体   @media 响应式设计    阴影：box-shadow 圆角：border-radius .</description>
    </item>
    
    <item>
      <title>ES6 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/es6-new-feature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/es6-new-feature/</guid>
      <description>ES6 新特性 var =&amp;gt; let/const var 是 function-scoped 的 var x = 3; function func(randomize) { if (randomize) { var x = Math.random(); // (A) scope: whole function  return x; } return x; // accesses the x from line A } func(false); // undefined   let/const 是 block-scoped 的 let x = 3; function func(randomize) { if (randomize) { let x = Math.random(); return x; } return x; } func(false); // 3    IIFE =&amp;gt; block ES5 使用 IIFE 限制 tmp 作用域 (function () { // open IIFE  var tmp = ···; ··· }()); // close IIFE  console.</description>
    </item>
    
    <item>
      <title>display</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/display/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/display/</guid>
      <description>display 常设置的值 div { display: inline; display: inline-block; display: block; display: run-in; display: none; } Flexbox .header { display: flex; } Flow-Root  flow-root 创建了一个新的 BFC 。
 .group { display: flow-root; } Grid body { display: grid; } Table div { display: table; display: table-cell; display: table-column; display: table-colgroup; display: table-header-group; display: table-row-group; display: table-footer-group; display: table-row; display: table-caption; } </description>
    </item>
    
    <item>
      <title>ES2020 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/es2020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/es2020/</guid>
      <description>ES2020 新特性 BigInt JavaScript 最大数值 Number.MAX_SAFE_INTEGER，那么如何表达比这个数值更大的数字呢？
// 注意后缀有 n：表示 large number const bigNum = 10000000000000n; console.log(bigNum * 2n); 动态 import const doMath = async (num1, num2) =&amp;gt; { if (num1 &amp;amp;&amp;amp; num2) { const math = await import(&amp;#39;./math.js&amp;#39;) console.log(math.add(5, 10)) } } doMath(4, 2) Nullish Coalescing let person = { profile: { name: &amp;#34;&amp;#34;, age: 0 } }; // 默认值 console.log(person.profile.name || &amp;#34;Anonymous&amp;#34;) console.log(person.profile.age || 18) 现在可以不使用 ||，而用 ?? 来指定默认值了：</description>
    </item>
    
    <item>
      <title>创建对象</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/create-object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/create-object/</guid>
      <description>创建对象 new Object() var d = new Object(); Object.create() var a = Object.create(null); 内部原理 Object.create = function (proto, propertiesObject) { if (typeof proto !== &amp;#39;object&amp;#39; &amp;amp;&amp;amp; typeof proto !== &amp;#39;function&amp;#39;) { throw new TypeError(&amp;#39;Object prototype may only be an Object: &amp;#39; + proto); } else if (proto === null) { throw new Error(&amp;#34;This browser&amp;#39;s implementation of Object.create is a shim and doesn&amp;#39;t support &amp;#39;null&amp;#39; as the first argument.&amp;#34;); } if (typeof propertiesObject !</description>
    </item>
    
    <item>
      <title>Object.freeze()</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/object-freeze/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/object-freeze/</guid>
      <description>Object.freeze() 作用  可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。
 行为 Object.freeze() 是浅冻结，浅不可变。
var ob1 = { foo : 1, bar : { value : 2 } }; Object.freeze( ob1 ); const ob2 = { foo : 1, bar : { value : 2 } } ob1.foo = 4; // (frozen) ob1.foo not modified ob2.foo = 4; // (const) ob2.foo modified  ob1.bar.value = 4; // (frozen) modified, because ob1.bar is nested ob2.bar.value = 4; // (const) modified  ob1.</description>
    </item>
    
    <item>
      <title>Cookie 和 Session</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/cookie-session/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/cookie-session/</guid>
      <description>Cookie 和 Session Cookie 作用  登录、购物车、游戏分数 用户个性化信息、主题、其他设置 记录和分析用户行为  创建 Cookie 服务器在返回网页内容的时候，使用 Set-Cookie 头来创建 Cookie：
HTTP/2.0 200 OK Content-Type: text/html Set-Cookie: yummy_cookie=choco Set-Cookie: tasty_cookie=strawberry [page content] Cookie 的有效期  Session：浏览器关闭当前 Tab 页就过期 Expires 和 Max-Age  Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Expires=&amp;lt;date&amp;gt; Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Max-Age=&amp;lt;non-zero-digit&amp;gt; Cookie 访问权限 Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2021 07:28:00 GMT; Secure; HttpOnly  Secure：只有 HTTPS 协议的时候，浏览器端的 Cookie 才会上传到 Server HttpOnly：声明这个的 Cookie，使用 Document.cokie 无法读和写  JavaScript 读写 Cookie document.</description>
    </item>
    
    <item>
      <title>call、apply、bind</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/call-apply-bind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/call-apply-bind/</guid>
      <description>call、apply、bind call func.call([thisArg[, arg1, arg2, ...argN]]) 底层原理 /** * 每个函数都可以调用call方法，来改变当前这个函数执行的this关键字，并且支持传入参数 */ Function.prototype.myCall = function(context) { //第一个参数为调用call方法的函数中的this指向  var context = context || global; //将this赋给context的fn属性  context.fn = this;//此处this是指调用myCall的function  var arr = []; for (var i=0,len=arguments.length;i&amp;lt;len;i++) { arr.push(&amp;#34;arguments[&amp;#34; + i + &amp;#34;]&amp;#34;); } //执行这个函数，并返回结果  var result = eval(&amp;#34;context.fn(&amp;#34; + arr.toString() + &amp;#34;)&amp;#34;); //将this指向销毁  delete context.fn; return result; } apply func.apply(thisArg, [ argsArray]) 底层原理 /** * apply函数传入的是this指向和参数数组 */ Function.prototype.myApply = function(context, arr) { var context = context || global; context.</description>
    </item>
    
    <item>
      <title>画正方形</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-square/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-square/</guid>
      <description>画正方形 实现一个正方形，拖拽窗口，正方形等比例缩放
vw &amp;lt;div class=&amp;#34;square&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;This is a Square&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; .square { background: #000; width: 50vw; height: 50vw; } .square h1 { color: #fff; } padding-bottom &amp;lt;div style=&amp;#34;height:0;width:20%;padding-bottom:20%;background-color:red&amp;#34;&amp;gt; &amp;lt;div&amp;gt; Content goes here &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 参考  [How to style a div to be a responsive square?(https://stackoverflow.com/questions/19068070/how-to-style-a-div-to-be-a-responsive-square)  </description>
    </item>
    
    <item>
      <title>CSS 画圆</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-draw-circle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-draw-circle/</guid>
      <description>CSS 画圆 border-radius #circle { width: 200px; height: 200px; background: #f00; border-radius: 50%; } </description>
    </item>
    
    <item>
      <title>CSS 画扇形</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-sector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-sector/</guid>
      <description>CSS 画扇形 #cone { width: 0; height: 0; border-left: 70px solid transparent; border-right: 70px solid transparent; border-top: 100px solid red; border-radius: 50%; } </description>
    </item>
    
    <item>
      <title>三栏等宽布局</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/three-equal-layout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/three-equal-layout/</guid>
      <description>三栏等宽布局 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;111&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;222&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;333&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; float ul { width: 500px; background: #ccc; overflow: hidden; } li { list-style: none; width: 33.33%; float: left; background: red; } flex ul { width: 500px; background: #ccc; display: flex; } li { list-style: none; flex: 1; background: red; } </description>
    </item>
    
    <item>
      <title>CSS 画半圆</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-draw-half-circle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-draw-half-circle/</guid>
      <description>CSS 画半圆 $size: 45px; div { background: #9e978e; display: inline-block; margin: 0 1em 1em 0; } .top, .bottom { height: $size; width: $size * 2; } .right, .left { height: $size * 2; width: $size; } .top { border-top-left-radius: $size * 2; border-top-right-radius: $size * 2; } .right { border-bottom-right-radius: $size * 2; border-top-right-radius: $size * 2; } .bottom { border-bottom-left-radius: $size * 2; border-bottom-right-radius: $size * 2; } .left { border-bottom-left-radius: $size * 2; border-top-left-radius: $size * 2; } 效果：</description>
    </item>
    
    <item>
      <title>动画</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/animation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/animation/</guid>
      <description>动画 CSS animation .element { animation: pulse 5s infinite; } @keyframes pulse { 0% { background-color: #001F3F; } 100% { background-color: #FF4136; } } 在 @keyframes 中，0% 代表动画的开始，100% 代表动画的结束。animation 可用的子属性：
.element { animation-name: stretch; animation-duration: 1.5s; animation-timing-function: ease-out; animation-delay: 0s; animation-direction: alternate; animation-iteration-count: infinite; animation-fill-mode: none; animation-play-state: running; } CSS transition transition 控制的是从一种状态/阶段/样式，转变为另外一种状态/阶段/样式，animation 控制的是整个动画的每一帧。
.example { transition: [transition-property] [transition-duration] [transition-timing-function] [transition-delay]; } 鼠标悬浮在 div 的时候，转变 background 和 padding 的状态：
div { transition: all 0.</description>
    </item>
    
    <item>
      <title>CSS 单位</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/css-units/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/css-units/</guid>
      <description>CSS 单位 绝对单位    单位 描述     cm 厘米   mm 毫米   in 英寸   px 像素   pt points   pc picas (1pc = 12pt)    相对单位    单位 描述     em 相对于当前元素的 font-size，2em 意味着两倍 font-size 的大小   ex 相对于当前字体的 x-height   ch 相对于 &amp;lsquo;0&amp;rsquo; 的宽度   rem 相对于根元素的字体大小   vw 相当于 viewport 宽度的 1%   vh 相当于 viewport 高度的 1%   vmin 相当于 viewport 较短边的 1%   vmax 相当于 viewport 较长边的 1%   % 相对于父元素    参考  CSS Units  </description>
    </item>
    
    <item>
      <title>prototype、__proto__、[[prototype]]</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/prototype/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/prototype/</guid>
      <description>prototype、proto、[[prototype]] prototype 谁创建的 当你创建一个 Function object 的时候，一个名字为 prototype 的属性也会自动创建，并附着在 function object 上。
function Foo() { this.name = &amp;#34;Zhao Kun&amp;#34;; } Foo.hasOwnProperty(&amp;#39;prototype&amp;#39;); // true [[prototype]] 谁创建的 使用 new 关键字创建一个新的对象，那么这个对象本身会有一个内部的/私有的或指针指向 Foo 的 prototype：
function Foo() { this.name = &amp;#34;Zhao Kun&amp;#34;; } let b = new Foo(); b.[[Prototype]] === Foo.prototype // true proto 谁创建的 __proto__ 是 [[prototype]] 的 public 形式的指针：
let b = new Foo(); b.__proto___ === Foo.prototype // true 自 ECMAScript5 起，你有另外一种选择，可以拿到这个对象内部的私有的 [[prototype]] 的这个指针：</description>
    </item>
    
    <item>
      <title>HTML 语义化</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/html-semantic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/html-semantic/</guid>
      <description>HTML 语义化 作用 Web语义化是指使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。 简单来说就是利于 SEO，便于阅读维护理解。
常见语义化标签  i：专业术语 em：强调文本 strong：这个文本非常重要 section：文档中的一个区域、一节 article：文档、页面、网站中的独立结构 aside：附属信息 nav：页面的导航链接区域 footer：页脚 hgroup：文章的标题 header：页眉  dl、dt、dd &amp;lt;dl&amp;gt; 代表 description list，这个 list 封装了若干个 terms (&amp;lt;dt&amp;gt;) 以及 descriptions (&amp;lt;dd&amp;gt;) 信息。
&amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt;火狐浏览器&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 由 Mozilla 组织以及数百个志愿者一起开发的一款免费、开源、跨平台的 Web 浏览器。 &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt;Chrome 浏览器&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 谷歌浏览器，是一个由Google（谷歌）公司开发的开放源代码网页浏览器。 &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; </description>
    </item>
    
    <item>
      <title>二叉搜索树中删除一个节点</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/delete-node-in-bst/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/delete-node-in-bst/</guid>
      <description>二叉搜索树中删除一个节点  微软
 // https://leetcode.com/problems/delete-node-in-a-bst/ // // 微软面试题 // // 这道题的删除节点，就是把这个节点所有的孩子都给删除了 public class DeleteNodeinaBST { public TreeNode deleteNode(TreeNode root, int key) { // ================  // search the node  // ================  TreeNode curr = root; TreeNode predecessor = null; // 我们是从 root 的 left 树进去的吗?  boolean left = false; while (curr != null) { if (curr.val == key) { break; } else if (curr.val &amp;gt; key) { predecessor = curr; curr = curr.</description>
    </item>
    
    <item>
      <title>内存</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/memory/</guid>
      <description>内存  作者：赵坤
 内存分配 首先给出 32 位系统虚拟内存空间分布图：
在 C 语言中，内存分配采用 malloc() 函数进行分配。底层实现：
 申请的内存小于 128K，使用 brk() 函数完成，也就是从上图中的堆中分配的内存 申请的内存大于 128K，使用 mmap() 内存映射函数完成，也就是从上图中的文件映射中分配的内存  内存回收 应用程序应通过 free() 或 unmap() 来释放内存。
当然，系统也会监管进程的内存，当发现系统内存不足时，会采取措施：
 使用 LRU 算法回收缓存 回收不常访问的内存，写到 Swap 区（位于硬盘上） 杀死进程  查看整个系统的内存 $ free total used free shared buff/cache available Mem: 6030036 2312004 266488 624252 3451544 2911700 Swap: 2097148 256 2096892 查看某个进程的内存 使用 top 或 ps：
$ top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 8883 zk 20 0 16.</description>
    </item>
    
    <item>
      <title>基础 - finally</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/finally/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/finally/</guid>
      <description>finally 常见疑惑代码片段 （1）下面代码中的 finally 块会执行吗？
try { // do something  System.exit(1); } finally{ System.out.println(“Print from finally”); } 答案：不会。
（2）finally 会执行吗？
public static int test() { try { return 0; } finally { System.out.println(&amp;#34;finally trumps return.&amp;#34;); } } 答案：
finally trumps return. 0 （3）这个方法返回的值是 10 还是 12？
public static int getMonthsInYear() { try { return 10; } finally { return 12; } } 答案：12
（4）执行顺序
try{ int divideByZeroException = 5 / 0; } catch (Exception e){ System.</description>
    </item>
    
    <item>
      <title>char</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/char/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/char/</guid>
      <description>char char 能存储中文字符吗 在 Java 中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母都是用 Unicode 编码来表示的。所以，在Java中，char 类型变量可以存储一个中文汉字。</description>
    </item>
    
    <item>
      <title>HTML5 新特性</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/html5-new-feature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/html5-new-feature/</guid>
      <description>HTML5 新特性 新的 HTML5 语义 章节、轮廓等语义标签 &amp;lt;section&amp;gt;、&amp;lt;article&amp;gt;、&amp;lt;nav&amp;gt;、&amp;lt;header&amp;gt;、&amp;lt;footer&amp;gt;、&amp;lt;aside&amp;gt;
音频、视频 &amp;lt;audio&amp;gt;、&amp;lt;video&amp;gt;
input 校验 &amp;lt;input&amp;gt; 标签引入了新的属性：
 required：表单的这个字段不为空 minlength 和 maxlength：文本的长度要求 min 和 max：数值类型的大小值约束 type：是否是数值？邮件地址？或其它类型 pattern：输入的内容必须符合整个正则表达式  新的语义元素 &amp;lt;mark&amp;gt;、&amp;lt;figure&amp;gt;、&amp;lt;figcaption&amp;gt;、&amp;lt;data&amp;gt;、&amp;lt;time&amp;gt;、&amp;lt;output&amp;gt;、&amp;lt;progress&amp;gt;、&amp;lt;meter&amp;gt;、&amp;lt;main&amp;gt;
iframe 安全  sandbox 属性：附加更多限制 srcdoc 属性：内嵌的 HTML 内容  MathML 数学公式 使用 MathML 直接插入数学公式
数据传输 Web Sockets 浏览器和服务器建立一个长久连接，双方都可以发送信息给对方。
Server-sent events Server 推送 event 给客户端：
const evtSource = new EventSource(&amp;#39;ssedemo.php&amp;#39;) WebRTC RTC：Real-Time Communication
存储 IndexedDB 选择多个文件 &amp;lt;input type = &#39;file&#39;&amp;gt; 新增 multiple 属性，可选择多个文件。
多媒体 Camera API &amp;lt;input type=&amp;#34;file&amp;#34; id=&amp;#34;take-picture&amp;#34; accept=&amp;#34;image/*&amp;#34;&amp;gt; Graphics canvas 画布</description>
    </item>
    
    <item>
      <title>Java 异常</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/java-exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/java-exception/</guid>
      <description>Java 异常 异常架构图 </description>
    </item>
    
    <item>
      <title>二叉搜索树中新增一个节点</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/insert-into-bst/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/insert-into-bst/</guid>
      <description>二叉搜索树中新增一个节点  微软
 // https://leetcode.com/problems/insert-into-a-binary-search-tree/ // 保证二叉树原来没有值为 val 的节点 // // 微软面试题 public class InsertintoaBinarySearchTree { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode backupRoot = root; TreeNode predecessor = null; while (root != null) { predecessor = root; if (root.val &amp;gt; val) { root = root.left; } else if (root.val &amp;lt; val) { root = root.right; } } if (predecessor.</description>
    </item>
    
    <item>
      <title>类加载</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/classload/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/classload/</guid>
      <description>类加载 </description>
    </item>
    
    <item>
      <title>meta</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/meta/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/meta/</guid>
      <description>meta 作用 提供 Document 的元信息。
charset 属性 &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; content 属性 &amp;lt;head&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;Free Web tutorials&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;keywords&amp;#34; content=&amp;#34;HTML,CSS,XML,JavaScript&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; http-equiv &amp;lt;!-- Redirect page after 3 seconds --&amp;gt; &amp;lt;meta http-equiv=&amp;#34;refresh&amp;#34; content=&amp;#34;3;url=https://www.mozilla.org&amp;#34;&amp;gt; name &amp;lt;head&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;Free Web tutorials&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;keywords&amp;#34; content=&amp;#34;HTML,CSS,JavaScript&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;author&amp;#34; content=&amp;#34;John Doe&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; </description>
    </item>
    
    <item>
      <title>二叉树的直径</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/diameter-of-binary-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/diameter-of-binary-tree/</guid>
      <description>二叉树的直径  微软
 // https://leetcode.com/problems/diameter-of-binary-tree/ // // 二叉树的直径 // // Given a binary tree // 1 // / \ // 2 3 // / \ // 4 5 // Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. public class DiameterofBinaryTree { public int diameterOfBinaryTree(TreeNode root) { if (root == null) { return 0; } int rootDiameter = depth(root.left) + depth(root.right); int leftDiameter = diameterOfBinaryTree(root.left); int rightDiameter = diameterOfBinaryTree(root.</description>
    </item>
    
    <item>
      <title>中序遍历的下一个节点</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/next-node-of-inorder-traverse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/next-node-of-inorder-traverse/</guid>
      <description>中序遍历的下一个节点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
// https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e // // 牛客网 // 二叉树中包含指向父节点的指针 next public class NextNodeOfBinaryTree { public TreeLinkNode GetNext(TreeLinkNode pNode) { if (pNode == null) { return null; } // 1  // 2 3  // 4 5 6 7  // 8 9  if (pNode.right != null) { // 2 的下一个节点:  //  // 如果 8 存在，那么最终是 8  // 如果 8 不存在，那么最终是 5  TreeLinkNode p = pNode.</description>
    </item>
    
    <item>
      <title>二叉树最大路径和</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-maximum-path-sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-maximum-path-sum/</guid>
      <description>二叉树最大路径和 解法一 // // 从树的任何一个节点开始，到任何一个节点结束，路径和最长 // 至少包含一个节点 // // Hard 级别 // public class BinaryTreeMaximumPathSum { int result = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { helper(root); return result; } private int helper(TreeNode root) { if (root == null) { return 0; } int left = helper(root.left); int right = helper(root.right); // - 只选择 root  // - 选择 root + left  // - 选择 root + right  // - 为什么没有 left ?</description>
    </item>
    
    <item>
      <title>二叉树非递归中序遍历</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-inorder-traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-inorder-traversal/</guid>
      <description>二叉树非递归中序遍历 public class BinaryTreeInorderTraversal { public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) { if (root == null) { return Collections.emptyList(); } List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); TreeNode curr = root; // 1  // / \  // 2 3  // / \  // 4 5  // / \  // 6 7  //  // 4 2 6 5 7 1 3  while (true) { // =========================  // 这个地方容易出错：  //  // stack.</description>
    </item>
    
    <item>
      <title>二叉树的公共祖先</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>二叉树的公共祖先 二叉树的公共祖先 // 所有 NODE 节点的值都是唯一的 // p 和 q 一定存在于二叉树里面 public class LowestCommonAncestorofaBinaryTree { // =========================  // 这个方法最优  // =========================  public TreeNode lowestCommonAncestor0(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;amp;&amp;amp; right != null) { return root; } return left !</description>
    </item>
    
    <item>
      <title>一颗二叉树是否是另外一颗的子树</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/is-subtree-another-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/is-subtree-another-tree/</guid>
      <description>一颗二叉树是否是另外一颗的子树 // O(N^2) public class SubtreeOfAnotherTree { public boolean isSubtree(TreeNode s /** root tree */, TreeNode t /** sub tree */) { return isSameTree(s, t) || (s != null ? (isSubtree(s.left, t) || isSubtree(s.right, t)) : false); } private boolean isSameTree(TreeNode a, TreeNode b) { if (a == null &amp;amp;&amp;amp; b == null) { return true; } if (a == null || b == null) { return false; } if (a.</description>
    </item>
    
    <item>
      <title>二叉树右视图</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-right-side-view/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/binary-tree-right-side-view/</guid>
      <description>二叉树右视图  微软问的其实是左视图。 原题
 递归 public class Solution { public List&amp;lt;Integer&amp;gt; rightSideView(TreeNode root) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;(); rightView(root, result, 0); return result; } public void rightView(TreeNode curr, List&amp;lt;Integer&amp;gt; result, int currDepth){ if (curr == null){ return; } if (currDepth == result.size()){ result.add(curr.val); } rightView(curr.right, result, currDepth + 1); rightView(curr.left, result, currDepth + 1); } } 层次遍历 public class Solution { public List&amp;lt;Integer&amp;gt; rightSideView(TreeNode root) { Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; rst = new ArrayList&amp;lt;&amp;gt;(); if (root == null) return rst; queue.</description>
    </item>
    
    <item>
      <title>Java 集合类框架图</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/collections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/collections/</guid>
      <description>Java 集合类框架图 Collections 框架图 List 框架图 Set 框架图 Map 框架图 Queue 框架图 参考  Overview of Java Collections Framework API (UML diagram)  </description>
    </item>
    
    <item>
      <title>JavaScript 检测数组</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/js-detect-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/js-detect-array/</guid>
      <description>JavaScript 检测数组 Array.isArray Array.isArray(obj) 兼容旧版本：
if (typeof Array.isArray === &amp;#39;undefined&amp;#39;) { Array.isArray = function(obj) { return Object.prototype.toString.call(obj) === &amp;#39;[object Array]&amp;#39;; } } constructor function isArray(obj) { return !!obj &amp;amp;&amp;amp; obj.constructor === Array; } </description>
    </item>
    
    <item>
      <title>Kafka 高吞吐量怎么实现的</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/kafka-high-throughput/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/kafka-high-throughput/</guid>
      <description>Kafka 高吞吐量怎么实现的 顺序读写 Producer 发送的消息顺序追加到文件中，Consumer 从 Broker 自带偏移量读取消息。这两者可以充分利用磁盘的顺序写和顺序读性能，速度远快于随机读写。
   零拷贝 mmap 持久化文件 Broker 写入数据，并非真正的 flush 到磁盘上了，而是写入到 mmap 中。
sendfile 读取 Customer 从 Broker 读取数据，采用 sendfile，将磁盘文件读到 OS 内核缓冲区后，直接转到 socket buffer 进行网络发送。
分区 Kafka 将消息分成多个 partition，增加了并行处理的能力。
批量发送 Producer 发送多个消息到同一分区，通过批量发送可以减少系统性能开销。
 batch.size：默认积压到 16K 就会批量发送 linger.ms：设置一定延迟来收集更多消息。默认 0ms ，即有消息就立马发送。  上述两个条件有任一条件满足，就会触发批量发送。
数据压缩 Kafka 支持三种压缩算法：
 gzip snappy lz4  /*compressType有四种取值:none lz4 gzip snappy*/ props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, compressType); 参考  Kafka为什么吞吐量大、速度快？  </description>
    </item>
    
    <item>
      <title>WordLadder</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/word-ladder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/word-ladder/</guid>
      <description>WordLadder  微软、阿里巴巴
 // 常见面试题 // 阿里巴巴、微软都问过 // https://leetcode.com/problems/word-ladder/ // public class WordLadder { // Runtime: 135 ms, faster than 39.64% of Java online submissions for Word Ladder.  public int ladderLength(String beginWord, String endWord, List&amp;lt;String&amp;gt; wordList) { Set&amp;lt;String&amp;gt; wordSet = new HashSet&amp;lt;&amp;gt;(wordList); if (!wordSet.contains(endWord)) { return 0; } Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.offer(beginWord); int level = 0; while (!queue.isEmpty()) { level++; int size = queue.size(); for (int i = 0; i &amp;lt; size; i++) { String curr = queue.</description>
    </item>
    
    <item>
      <title>磁盘 I/O</title>
      <link>https://kunzhao.org/docs/tutorial/unix-optimize/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/tutorial/unix-optimize/io/</guid>
      <description>磁盘 I/O  作者：赵坤
 虚拟文件系统 I/O 调度 为了减小不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理各种不同的块设备。通用块层，其实是处在文件系统和磁盘驱动中间的一个块设备抽象层。它会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。
Linux 内核支持四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine。
 NONE，不使用 I/O 调度算法 NOOP，先入先出 CFQ（Completely Fair Scheduler），为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求 DeadLine，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理  每块磁盘 I/O 性能 $ iostat -d -x 1 Linux 5.4.0-42-generic (zk) 2020年09月02日 _x86_64_	(4 CPU) Device r/s rkB/s rrqm/s %rrqm r_await rareq-sz w/s wkB/s wrqm/s %wrqm w_await wareq-sz d/s dkB/s drqm/s %drqm d_await dareq-sz aqu-sz %util loop0 0.</description>
    </item>
    
    <item>
      <title>秒杀系统设计</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/design-seckilling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/design-seckilling/</guid>
      <description>秒杀系统设计 秒杀其实主要解决两个问题，一个是并发读，一个是并发写。并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。另外，我们还要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。
秒杀系统架构原则  数据尽量少: 可以简化秒杀页面的大小，去掉不必要的页面装修效果，等等。 请求数尽量少: 减少请求数最常用的一个实践就是合并 CSS 和 JavaScript 文件，把多个 JavaScript 文件合并成一个文件，在 URL 中用逗号隔开。 路径要尽量短: 缩短访问路径有一种办法，就是多个相互强依赖的应用合并部署在一起，把远程过程调用（RPC）变成 JVM 内部之间的方法调用。 依赖要尽量少: 0 级系统要尽量减少对 1 级系统的强依赖，防止重要的系统被不重要的系统拖垮。例如支付系统是 0 级系统，而优惠券是 1 级系统的话，在极端情况下可以把优惠券给降级，防止支付系统被优惠券这个 1 级系统给拖垮。 不要有单点: 应用无状态化。  动静分离 热点数据 流量削峰 排队 答题 系统优化 配置线程数 很多多线程的场景都有一个默认配置，即 “线程数 = 2 * CPU 核数 + 1” 。除去这个配置，还有一个根据最佳实践得出来的公式：线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量。
 最好的办法是通过性能测试来发现最佳的线程数。
 发现 CPU 瓶颈 JProfiler 和 Yourkit 这两个工具。</description>
    </item>
    
    <item>
      <title>JavaScript 继承</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/js-extend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/js-extend/</guid>
      <description>JavaScript 继承 原型链 function Parent() {} function Child() {} Child.prototype = new Parent(); Child.prototype.constructor = Child; 构造器 function Parent() {} function Child() { Parent.call(this); } 原型链 + 构造器 function Parent() {} function Child() { Parent.call(this); } Child.prototype = new Parent(); 原型式 function extendObject(obj) { function F() {} F.prototype = obj; return new F(); } 其实上述代码就是 Object.create() 的兼容方法。
寄生组合 function inheritPrototype(child, parent) { var prototype = extendObject(parent.prototype); prototype.constructor = child; child.prototype = prototype; } function Child() { Parent.</description>
    </item>
    
    <item>
      <title>为什么阿里要自研 RocketMQ ?</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/why-develop-rocketmq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/why-develop-rocketmq/</guid>
      <description>为什么阿里要自研 RocketMQ ? 为什么要重写一个类似于 Kafka 的消息队列，而非基于 Kafka 作二次开发？
初衷 Kafka is a distributed streaming platform, which was born from logging aggregation cases. 它并不需要太高的并发. In some large scale cases in alibaba, we found that the original model 无法满足我们的实际需求.
无法支持更多分区  Each partition stores the whole message data. 尽管单个分区是顺序写的, 随着越来越多的针对不同分区的写入, 在操作系统层面已经变为随机写了. Due to the scattered data files, it is difficult to use the Linux IO Group Commit mechanism.  RocketMQ 支持更多分区  所有消息数据都存储在 Commit Log 文件中。所有写入都是完全顺序的，而读取是随机的。对磁盘的访问是完全顺序的，这避免了磁盘锁争用，并且在创建大量队列时不会导致高磁盘 IO 等待。 ConsumeQueue 存储实际的用户消费位置信息，这些信息也以顺序方式刷新到磁盘。  参考  How to Support More Queues in RocketMQ?</description>
    </item>
    
    <item>
      <title>二维数组寻找最长的单调递增序列</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/longest-increasing-path-in-a-matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/longest-increasing-path-in-a-matrix/</guid>
      <description>二维数组寻找最长的单调递增序列  微软
 // Input: nums = // [ // [9,9,4], // [6,6,8], // [2,1,1] // ] // Output: 4 // Explanation: The longest increasing path is [1, 2, 6, 9]. // // 微软面试题: 二维数组寻找最长的单调递增序列 // // =========================== // 时间复杂度分析: // 每个单元格，尝试它的四个相邻单元格 // 每个单元格都当做起始单元格，使用一个 Cache 来存储结果 // O(M * N) // =========================== public class LongestIncreasingPathinaMatrix { public int longestIncreasingPath(int[][] matrix) { if (matrix.length == 0) { return 0; } int[][] cached = new int[matrix.</description>
    </item>
    
    <item>
      <title>数组乱序</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/array-shuffle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/array-shuffle/</guid>
      <description>数组乱序 Fisher-Yates 乱序算法 /** * Shuffles array in place. * @param {Array} a items An array containing the items. */ function shuffle(a) { var j, x, i; for (i = a.length - 1; i &amp;gt; 0; i--) { j = Math.floor(Math.random() * (i + 1)); x = a[i]; a[i] = a[j]; a[j] = x; } return a; } ES6 /** * Shuffles array in place. ES6 version * @param {Array} a items An array containing the items.</description>
    </item>
    
    <item>
      <title>typeof</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/typeof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/typeof/</guid>
      <description>typeof 用法 typeof operand typeof(operand) typeof null &amp;gt; typeof null &amp;#34;object&amp;#34; 为什么 typeof null 是 object 根据 Why is typeof null “object”?，这是 JavaScript 实现上的一个 Bug，如果修正这个 Bug，会导致现有代码出现更多的 Bug。
JavaScript 底层的 object 的 type 是使用 0 来表示的，而 null 在多数平台上也是使用 0 来表示，所以 null 的 type 也是 0，因此返回 object。
null 是 object 吗 null 不是 object，它是 primitive value 。
typeof typeof null &amp;gt; typeof typeof null &amp;#34;string&amp;#34; typeof Array &amp;gt; typeof Array &amp;#34;function&amp;#34; typeof [1,2,3] &amp;gt; typeof [1,2,3] &amp;#34;object&amp;#34; typeof 5 &amp;gt; typeof 5 &amp;#34;number&amp;#34; typeof false &amp;#34;boolean&amp;#34; typeof undefined typeof undefined &amp;#34;undefined&amp;#34; typeof String(&amp;ldquo;asdfasdf&amp;rdquo;) typeof String(&amp;#34;asdfasdf&amp;#34;) &amp;#34;string&amp;#34; 更多 </description>
    </item>
    
    <item>
      <title>数组去重</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/array-unique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/array-unique/</guid>
      <description>数组去重 indexOf function onlyUnique(value, index, self) { return self.indexOf(value) === index; } filter var myArray = [&amp;#39;a&amp;#39;, 1, &amp;#39;a&amp;#39;, 2, &amp;#39;1&amp;#39;]; var unique = myArray.filter((v, i, a) =&amp;gt; a.indexOf(v) === i); Set function uniqueArray(a) { return [...new Set(a)]; } 参考  Get all unique values in a JavaScript array (remove duplicates)  </description>
    </item>
    
    <item>
      <title>数组扁平化</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/flattern-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/flattern-array/</guid>
      <description>数组扁平化 递归实现 const flatten = function(arr, result = []) { for (let i = 0, length = arr.length; i &amp;lt; length; i++) { const value = arr[i]; if (Array.isArray(value)) { flatten(value, result); } else { result.push(value); } } return result; }; ES2015 reduce function flatten(arr) { return arr.reduce(function (flat, toFlatten) { return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten); }, []); } 示例：
flatten([[1, 2, 3], [4, 5]]); // [1, 2, 3, 4, 5] flatten([[[1, [1.</description>
    </item>
    
    <item>
      <title>new 关键字</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/new/</guid>
      <description>new 关键字 new 做了什么  创建一个对象 设置 __proto__ 属性 设置 this 指向这个对象 执行构造函数 返回对象  function New(func) { var res = {}; if (func.prototype !== null) { res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === &amp;#34;object&amp;#34; || typeof ret === &amp;#34;function&amp;#34;) &amp;amp;&amp;amp; ret !== null) { return ret; } return res; } 参考  What is the &amp;lsquo;new&amp;rsquo; keyword in JavaScript?  </description>
    </item>
    
    <item>
      <title>数据类型</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/data-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/data-types/</guid>
      <description>数据类型 8 种数据类型  Primitive values 原始类型: Boolean、Null、Undefined、Number、BigInt、String、Symbol Object：Object  null vs undefined undefined 指已经声明，但是未赋值：
let testVar; alert(testVar); // undefined null 是已经赋值的变量：
let tetVar = null; alert(testVar); // null </description>
    </item>
    
    <item>
      <title>instanceof</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/instanceof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/instanceof/</guid>
      <description>instanceof 作用 检测构造器函数的 prototype 是否位于某个对象的 __proto__ 原型链上。
原理 function instance_of(V, F) { var O = F.prototype; V = V.__proto__; while (true) { if (V === null) return false; if (O === V) return true; V = V.__proto__; } } 为什么下列 instanceof 返回 false console.log(true instanceof Boolean); // false console.log(0 instanceof Number); // false console.log(&amp;#34;&amp;#34; instanceof String); // false console.log(new Boolean(true) instanceof Boolean); // true console.log(new Number(0) instanceof Number); // true console.</description>
    </item>
    
    <item>
      <title>let、var、const</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/let-vs-const-vs-var/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/let-vs-const-vs-var/</guid>
      <description>let、var、const var  var 作用域：在整个 function 内有效 在声明之前就可以引用  function run() { console.log(foo) // 声明之前就可以引用，值：undefined 	var foo = &amp;#34;Foo&amp;#34;; }  function 外定义会创建全局对象  var foo = &amp;#34;Foo&amp;#34;; console.log(window.foo) // Foo，附着在 window 对象  可以再次定义相同变量  &amp;#39;use strict&amp;#39; var foo = &amp;#34;foo1&amp;#34; var foo = &amp;#34;foo2&amp;#34; // foo 值替换为 foo2  闭包引用问题  // 打印 3 次 3 for (var i = 0; i &amp;lt; 3; i++) { setTimeout(() =&amp;gt; console.</description>
    </item>
    
    <item>
      <title>柯里化 - Currying</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/currying/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/currying/</guid>
      <description>柯里化 - Currying 作用 将 f(a, b, c) 调用形式转为 f(a)(b)(c) 调用形式，它对函数只做转换，不做执行。
实现 function curry(func) { return function curried(...args) { if (args.length &amp;gt;= func.length) { return func.apply(this, args); } else { return function(...args2) { return curried.apply(this, args.concat(args2)); } } }; } 优点  多参数复用性 函数式编程  参考  Currying  </description>
    </item>
    
    <item>
      <title>setTimeout</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/settimeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/settimeout/</guid>
      <description>setTimeout 用 setTimeout 实现 setInterval { const intervals = new Map(); function setInterval(fn, time, context, ...args) { // 随机生成一个 ID  const id = Math.floor(Math.random() * 10000); intervals.set(id, setTimeout(function next() { intervals.set(id, setTimeout(next, time)); fn.apply(context, args); }, time)); return id; } function clearInterval(id) { clearTimeout(intervals.get(id)); } } 如何使用：
const interval = setInterval(console.log, 100, console, &amp;#34;hi&amp;#34;); clearInterval(interval); requestAnimationFrame  作用：告诉浏览器在下一次 repaint 的时候，更新你的动画，也就是说这个是转为动画设计的 API requestAnimationFrame 的调用时机：浏览器的 repaint 阶段 使用 requestAnimationFrame，只有你的网站页面的 Tab 页处于 visible 的时候，浏览器才会去运行你的动画。更省 CPU、更省 GPU、更省内存、更节约电量。 动画至少 60帧/秒，看起来才更流畅：  setInterval(function() { // animiate something }, 1000/60); </description>
    </item>
    
    <item>
      <title>Strict Mode</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/strict-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/strict-mode/</guid>
      <description>Strict Mode 作用  Strict Mode is a new feature in ECMAScript 5 that allows you to place a program, or a function, in a &amp;ldquo;strict&amp;rdquo; operating context. 这种严格的上下文能够禁掉一些行为以及抛出更多地错误.
 为什么需要它  Strict mode makes it easier to write &amp;ldquo;secure&amp;rdquo; JavaScript.
 如何开启  文件顶部：  // File: myscript.js  &amp;#39;use strict&amp;#39;; var a = 2; ...  function 顶部：  function doSomething() { &amp;#39;use strict&amp;#39;; ... } 约束  禁止全局变量  &amp;#39;use strict&amp;#39;; // Assignment to a non-writable global var undefined = 5; // throws a TypeError var Infinity = 5; // throws a TypeError  delete 不可删除的属性，会抛出异常。例如尝试 delete Object.</description>
    </item>
    
    <item>
      <title>实现 sleep 函数</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/implement-sleep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/implement-sleep/</guid>
      <description>实现 sleep 函数 const sleep = (milliseconds) =&amp;gt; { return new Promise(resolve =&amp;gt; setTimeout(resolve, milliseconds)) } 如何使用：
sleep(500).then(() =&amp;gt; { //do stuff }) 在 async 函数中使用：
const doSomething = async () =&amp;gt; { await sleep(2000) //do stuff } doSomething() </description>
    </item>
    
    <item>
      <title>JS 深浅拷贝</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/js-copy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/js-copy/</guid>
      <description>JS 深浅拷贝 浅拷贝 ES6 Object assign var A1 = { a: &amp;#34;2&amp;#34; }; var A2 = Object.assign({}, A1); Object assign 的兼容写法 if (!Object.assign) { Object.defineProperty(Object, &amp;#39;assign&amp;#39;, { enumerable: false, configurable: true, writable: true, value: function(target) { &amp;#39;use strict&amp;#39;; if (target === undefined || target === null) { throw new TypeError(&amp;#39;Cannot convert first argument to object&amp;#39;); } var to = Object(target); for (var i = 1; i &amp;lt; arguments.length; i++) { var nextSource = arguments[i]; if (nextSource === undefined || nextSource === null) { continue; } nextSource = Object(nextSource); var keysArray = Object.</description>
    </item>
    
    <item>
      <title>实现 Promise.all</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/implement-promise-all/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/implement-promise-all/</guid>
      <description>实现 Promise.all 借助 async/await Promise.all = async (promises) =&amp;gt; { const results = []; for (p of promises) { results.push(await p); } return results; } 不借助 async/await Promise.all = (promises) =&amp;gt; { let resolved = 0; let results = []; return new Promise((resolve, reject) =&amp;gt; { for (let promise of promises) { promise .then((result) =&amp;gt; { results.push(result); if (++resolved === promises.length) resolve(results); }) .catch((e) =&amp;gt; { reject(e); }); } }) } 参考  How to Implement Promise.</description>
    </item>
    
    <item>
      <title>实现 retry</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/implement-retry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/implement-retry/</guid>
      <description>实现 retry 只要没有 resolve，就一直 retry
方法 const wait = ms =&amp;gt; new Promise(r =&amp;gt; setTimeout(r, ms)); const retryOperation = (operation, delay, times) =&amp;gt; new Promise((resolve, reject) =&amp;gt; { return operation() .then(resolve) .catch((reason) =&amp;gt; { if (times - 1 &amp;gt; 0) { return wait(delay) .then(retryOperation.bind(null, operation, delay, times - 1)) .then(resolve) .catch(reject); } return reject(reason); }); }); 如何使用：
如果没有 resolve 或 reject，那么就每隔 1 秒重试一次，最多重试 5 秒：
retryOperation(func, 1000, 5) .then(console.log) .catch(console.log); 参考  Promise Retry Design Patterns  </description>
    </item>
    
    <item>
      <title>PancakeSorting</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/pancake-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/pancake-sorting/</guid>
      <description>PancakeSorting 煎饼排序  微软
 // 微软面试题 // https://leetcode.com/problems/pancake-sorting/ // // https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;amp;tid=518795&amp;amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D327%26sortid%3D327 // 给出算法题，完成一个只能flip subarray的sort功能。 // 然后面试官提示看代码XX行，可以优化。 然后在她的提示下进行了两次优化。 // 然后要写flip的功能，时间来不及了，就匆匆用python的 reverse()完成了个简单的flip。 // 然后面试官说能不能不用reverse，我说可以，用forloop和stack就行了。她说可以用swap。 // 然后说时间到了，问我有没有想问的，我就问了能不能有更快的算法完成这个sort，她说没有了。 // // 看起来 flip 的意思是指只能从 0 ~ index 的位置整体翻转 // // Any valid answer that sorts the array within 10 * A.length flips will be judged as correct. // A[i] is a permutation of [1, 2, ..., A.length] public class PancakeSorting { public List&amp;lt;Integer&amp;gt; pancakeSort(int[] A) { List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int end = A.</description>
    </item>
    
    <item>
      <title>Sentinel 与 Hystrix 的对比</title>
      <link>https://kunzhao.org/docs/programmer-interview/java/sentinel-vs-hystrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/java/sentinel-vs-hystrix/</guid>
      <description>Sentinel 与 Hystrix 的对比 对比     Sentinel Hystrix     隔离策略 信号量隔离 线程池隔离/信号量隔离   熔断降级策略 基于响应时间或失败比率 基于失败比率   实时指标实现 滑动窗口 滑动窗口（基于 RxJava）   规则配置 支持多种数据源 支持多种数据源   扩展性 多个扩展点 插件的形式   基于注解的支持 支持 支持   限流 基于 QPS，支持基于调用关系的限流 有限的支持   流量整形 支持慢启动、匀速器模式 不支持   系统负载保护 支持 不支持   控制台 开箱即用，可配置规则、查看秒级监控、机器发现等 不完善   常见框架的适配 Servlet、Spring Cloud、Dubbo、gRPC 等 Servlet、Spring Cloud Netflix    参考  Sentinel 与 Hystrix 的对比  </description>
    </item>
    
    <item>
      <title>跨域</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/cors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/cors/</guid>
      <description>跨域 定义 跨域：指一个 domain 下的 HTML 或脚本试图去请求另一个 domain 下的资源。
同源策略 同源策略 （Same origin policy）：两个 URL 的协议、域名、端口相同。
同源限制访问资源  Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js 对象无法获得 AJAX 请求不能发送  JSONP &amp;lt;script&amp;gt; var script = document.createElement(&amp;#39;script&amp;#39;); script.type = &amp;#39;text/javascript&amp;#39;; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数  script.src = &amp;#39;http://www.domain2.com:8080/login?user=admin&amp;amp;callback=handleCallback&amp;#39;; document.head.appendChild(script); // 回调执行函数  function handleCallback(res) { alert(JSON.stringify(res)); } &amp;lt;/script&amp;gt; 后端返回的内容如下所示，即返回后立即执行 handleCallback：
handleCallback({&amp;#34;status&amp;#34;: true, &amp;#34;user&amp;#34;: &amp;#34;admin&amp;#34;})  JSONP 只能进行 GET 调用
 跨域资源共享 (CORS) 服务端设置 Access-Control-Allow-Origin:* 头即可，前端无须设置。如果想要进行 cookie 的读写，那么前端需要设置这个属性为 true：</description>
    </item>
    
    <item>
      <title>堆排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/heap-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/heap-sort/</guid>
      <description>堆排序 // - 建堆，不同节点运行 heapify 的时间与节点所处的高度相关 // https://www.cnblogs.com/LzyRapx/p/9565305.html // // 树高 h = lgn // // 第 0 层，只有根节点，它需要最多向下调整 h * 2^0 次 // 第 1 层，有 2 个节点，它需要向下调整 (h - 1) * 2^1 次 // 第 2 层，有 4 个节点，它需要向下调整 (h - 2) * 2^2 次 // // 第 h 层，有 2^h 个节点，它需要向下调整 (h - h) * 2^h 次 // // O(n) = h * 2^0 + (h - 1) * 2^1 + (h - 2) * 2^2 + .</description>
    </item>
    
    <item>
      <title>节流和防抖</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/throttle-and-debounce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/throttle-and-debounce/</guid>
      <description>节流和防抖 作用 解决页面卡顿等性能问题
节流函数 一定时间内，某个函数只执行一次。By using throttle function, we don&amp;rsquo;t allow to our function to execute more than once every X milliseconds.
function throttle (callback, limit) { var waiting = false; // 一开始，处于非等待状态  return function () { // 返回一个节流函数  if (!waiting) { // 如果没有等待  callback.apply(this, arguments); // 执行函数  waiting = true; // 等待置位 true  setTimeout(function () { // limit 时间之后  waiting = false; // 重新置位 false  }, limit); } } }  callback 函数：哪个函数需要节流？ limit：多长时间之后可以重新调用  也可以基于时间判断来实现：</description>
    </item>
    
    <item>
      <title>链表归并排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/linkedlist-mergesort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/linkedlist-mergesort/</guid>
      <description>链表归并排序 // ============================= // MergeSort // // 切分为三部分: // - small // - equal // - large // ============================= public class SortList { public ListNode sortList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode lessOrEqualThanPivot = new ListNode(-1); ListNode pivot = head; ListNode greatThanPivot = new ListNode(-1); ListNode equalPivot = new ListNode(-1); ListNode p = head; ListNode pLess = lessOrEqualThanPivot; ListNode pGreat = greatThanPivot; ListNode pEqual = equalPivot; while (p !</description>
    </item>
    
    <item>
      <title>快排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/quicksort/</guid>
      <description>快排序 // T(n) = T(n - 1) + T(0)，每次都分为 n - 1 个和 0 个元素 // T(n - 1) = T(n - 2) + T(0) // ... // 迭代想加 // T(n) = O(n^2) // // - 最坏情况: // T(n) = 2T(n / 2) + O(n) // T(n / 2) = 2T(n / 4) + O(n) // // 画出树，整颗树高 log2^n 然后每次都是 O(n) 所以 nlogn // // n.................O(n) // n/2 n/2.............O(n) // n/4 n/4 n/4 n/4.</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/mergesort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/mergesort/</guid>
      <description>归并排序 public class MergeSort { public void sort(int[] array) { sort(array, 0, array.length - 1); } private void sort(int[] array, int begin, int end) { if (end &amp;gt; begin) { int middle = begin + ((end - begin) &amp;gt;&amp;gt; 1); // ===========================  // begin ~ middle  // ===========================  sort(array, begin, middle); // ===========================  // middle + 1 ~ end  // ===========================  sort(array, middle + 1, end); merge(array, begin, middle, end); } } private void merge(int[] array, int begin, int middle, int end) { int[] temp = new int[end - begin + 1]; int i = begin; int j = middle + 1; int k = 0; while (i &amp;lt;= middle &amp;amp;&amp;amp; j &amp;lt;= end) { if (array[i] &amp;lt; array[j]) { temp[k++] = array[i++]; } else { temp[k++] = array[j++]; } } while (i &amp;lt;= middle) { temp[k++] = array[i++]; } while (j &amp;lt;= end) { temp[k++] = array[j++]; } k = 0; while (k &amp;lt; temp.</description>
    </item>
    
    <item>
      <title>栈排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/sort-stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/sort-stack/</guid>
      <description>栈排序 // 美团面试题: https://www.nowcoder.com/discuss/268612?type=2&amp;amp;order=0&amp;amp;pos=49&amp;amp;page=1 public class SortStack { public static void stackSorting(Stack&amp;lt;Integer&amp;gt; stack) { Stack&amp;lt;Integer&amp;gt; t = new Stack&amp;lt;&amp;gt;(); while(!stack.isEmpty()) { int item = stack.pop(); while(!t.isEmpty() &amp;amp;&amp;amp; t.peek() &amp;gt; item) stack.push(t.pop()); t.push(item); } while(!t.isEmpty()) stack.push(t.pop()); } } </description>
    </item>
    
    <item>
      <title>磁盘多路归并排序</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/disk-merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/disk-merge-sort/</guid>
      <description>磁盘多路归并排序 // 磁盘多路归并排序 // https://mp.weixin.qq.com/s?__biz=MzI0MzQyMTYzOQ==&amp;amp;mid=2247484900&amp;amp;idx=1&amp;amp;sn=a120748f4c1229dbb851732e4cd5f47c&amp;amp;pass_ticket=TEG93hpjf7gdkxzIPcHay9NH%2FprQkpCtcZYYI4NcTDeNiCpFQAsK%2Bh4x9M1mviQ8 // // 1 2 3 4 5 (文件 1 2 3 4 5) // ---------- // 2 5 5 7 12 // 3 6 5 8 13 // 4 6 6 9 13 // // 内存中维护的数组变化，方括号内代表这个数字属于哪个文件 // 2[1] 5[2] 5[3] 7[4] 12[5] // 3[1] 5[2] 5[3] 7[4] 12[5] // 4[1] 5[2] 5[3] 7[4] 12[5] // 5[2] 5[3] 6[2] 7[4] 12[5] // 5[3] 6[2] 6[2] 7[4] 12[5] // .</description>
    </item>
    
    <item>
      <title>求解逆波兰表达式</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/evaluate-reverse-polish-notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/evaluate-reverse-polish-notation/</guid>
      <description>求解逆波兰表达式 - 写一个计算器  微软
 // https://leetcode.com/problems/evaluate-reverse-polish-notation/submissions/ // // Input: [&amp;#34;2&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;+&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;*&amp;#34;] // Output: 9 // Explanation: ((2 + 1) * 3) = 9 // // Input: [&amp;#34;4&amp;#34;, &amp;#34;13&amp;#34;, &amp;#34;5&amp;#34;, &amp;#34;/&amp;#34;, &amp;#34;+&amp;#34;] // Output: 6 // Explanation: (4 + (13 / 5)) = 6 // // 微软面试题: 写一个计算器 // 这个原题，给你的已经是一个逆波兰表达式了 public class EvaluateReversePolishNotation { public int evalRPN(String[] tokens) { Stack&amp;lt;Integer&amp;gt; numStack = new Stack&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; tokens.</description>
    </item>
    
    <item>
      <title>浏览器缓存</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/cache/</guid>
      <description>浏览器缓存 强缓存 HTTP 1.0 Expires Expires: Wed, 11 May 2018 07:20:00 GMT  缺点：时间是绝对时间，很难保证用户计算机时间和服务器时间一致
 HTTP 1.1 Cache-Control Cache-Control: max-age=315360000  优先级高于 Expires
 Cache-Control 取值如下：
 no-store：不缓存到本地 public：多用户共享 private：只能被终端浏览器缓存 no-cache：缓存到本地，但是使用这个缓存之前，必须与服务器进行新鲜度验证  （1）禁用缓存
Cache-Control: no-store （2）缓存静态资源
Cache-Control: public, max-age=604800, immutable （3）重新校验资源
Cache-Control: no-cache Cache-Control: no-cache, max-age=0 协商缓存 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP 状态为 304 并且会显示一个 Not Modified 的字符串。
那么浏览器如何询问服务器？
If-Modified-Since 浏览器请求服务器的时候带上这个头 If-Modified-Since，它的值是这个文件上一次服务器返回来的时候携带的 Last-Modified 的 HTTP 头的值。如果服务器有新的资源，那么会返回新的资源，否则响应 304。
If-None-Match If-Modified-Since 是根据文件的修改时间定的，而 If-None-Match 携带的值是这个文件的指纹，即上一次服务器返回这个文件携带的 ETag HTTP 头的值。浏览器将这个信息发送给服务器，可以更为精确地知道这个文件有没有变化。如果服务器有新的资源，返回新的，否则响应 304 状态码。</description>
    </item>
    
    <item>
      <title>MinStack</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/minstack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/minstack/</guid>
      <description>MinStack 使用两个栈 // 使用了两个栈 // 占用内存大 // // 使用一个栈的解法见 MinStack_Solution_1.java public class MinStack { private Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;(); private Stack&amp;lt;Integer&amp;gt; minStack = new Stack&amp;lt;Integer&amp;gt;(); /** initialize your data structure here. */ public MinStack() { } public void push(int x) { stack.push(x); if (minStack.isEmpty()) { minStack.push(x); } else { minStack.push(x &amp;lt; minStack.peek() ? x : minStack.peek()); } } public void pop() { stack.pop(); minStack.pop(); } public int top() { return stack.</description>
    </item>
    
    <item>
      <title>事件循环</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/eventloop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/eventloop/</guid>
      <description>事件循环 Event Loop JS 是单线程的。在 JavaScript 引擎里，取 task 和执行 task 的代码封装在一个死循环里面，JavaScript 引擎等待 tasks 的出现，有则执行，无则 sleep。异步任务分为宏任务和微任务。
Macro Task 宏任务 宏任务示例：&amp;lt;script&amp;gt;、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI 渲染
Micro Task 微任务 微任务示例：process.nextTick、Promises、queueMicrotask、MutationObserver
 Micro is like macro but with higher priority.
 Event Loop 算法 while (true) { // 执行宏任务  let task = macroTaskQueue.getOldestTask(); execute(task); // 执行微任务  while (microTaskQueue.length &amp;gt; 0) { execute(microTaskQueue.getOldestTask()) } // 渲染  if (isRenderTime()) { render(); } } Node EventLoop vs 浏览器 EventLoop  microtask 的执行时机不同。</description>
    </item>
    
    <item>
      <title>浏览器存储</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/storage/</guid>
      <description>浏览器存储 Web Storage  Web Storage 也叫 DOM Storage.
 浏览器提供了两种支持 Web Storage 的对象：
 window.localStorage：数据没有过期时间 window.sessionStorage：仅仅会话期间有效，关闭当前浏览器 Tab 页面的时候，数据消失  注意，这两个 Storage 对象存储的 value 只支持 String 类型，你存储其他类型，浏览器也会自动转为 String 类型存储进去。
sessionStorage.setItem(&amp;#39;key&amp;#39;, &amp;#39;value&amp;#39;) localStorage.setItem(&amp;#39;key&amp;#39;, &amp;#39;value&amp;#39;) 存储大小  Cookie 允许 4KB Opera 10.50+ 允许 5MB Safari 8 允许 5MB Firefox 34 允许 10MB Chrome 允许 10MB IE 允许 10MB  数据可见性 （1）LocalStorage
只有相同协议、相同 Host、相同端口，这三个都相同，才能算作是同一个 Origin。 只要两个页面处于同一 Origin ，那么存储在这一 Origin 的 LocalStorage 数据便可以自由访问。
（2）SessionStorage</description>
    </item>
    
    <item>
      <title>DOM 操作 API</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/dom-operate-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/dom-operate-api/</guid>
      <description>JavaScript 常见原生 DOM 操作 API 总结 节点查找 API    方法 示例 描述     querySelector var el = document.querySelector(&amp;quot;.myclass&amp;quot;); 返回第一个匹配 selector 的元素   querySelectorAll var matches = document.querySelectorAll(&amp;quot;p&amp;quot;); 返回一个匹配的 NodeList 数组   getElementById var elem = document.getElementById(&#39;para&#39;); 返回匹配 ID 的 Element   getElementsByClassName document.getElementsByClassName(&#39;red test&#39;) 返回匹配 class 的一个 array-like 的元素数组   getElementsByTagName var allParas = document.getElementsByTagName(&#39;p&#39;); 返回指定 Tag 的 HTMLCollection   getElementsByName var up_names = document.</description>
    </item>
    
    <item>
      <title>Event</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/event/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/event/</guid>
      <description>Event target 和 currentTarget  target：哪个元素触发了事件？ currentTarget：哪个元素监听了这个事件  事件代理/委托 原因 添加的事件监听器数量，影响页面的整体运行性能，因为访问 DOM 的次数越多，引起浏览器的重绘和重排的次数也就越多。通过事件委托，可以减少添加的事件监听器数量，提高页面性能。
原理 利用事件冒泡。
示例 &amp;lt;ul id=&amp;#34;list&amp;#34;&amp;gt; &amp;lt;li id=&amp;#34;item1&amp;#34;&amp;gt;item1&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;#34;item2&amp;#34;&amp;gt;item2&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;#34;item3&amp;#34;&amp;gt;item3&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;#34;item4&amp;#34;&amp;gt;item4&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 目的：点击 li 然后弹出这个 li 的内容：
window.onload=function(){ var ulNode=document.getElementById(&amp;#34;list&amp;#34;); ulNode.addEventListener(&amp;#39;click&amp;#39;,function(e){ if(e.target &amp;amp;&amp;amp; e.target.nodeName.toUpperCase() == &amp;#34;LI&amp;#34;){/*判断目标事件是否为li*/ alert(e.target.innerHTML); } },false); }; </description>
    </item>
    
    <item>
      <title>冒泡捕获</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/event-bubble-capture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/event-bubble-capture/</guid>
      <description>冒泡捕获 冒泡 &amp;lt;style&amp;gt; body * { margin: 10px; border: 1px solid blue; } &amp;lt;/style&amp;gt; &amp;lt;form onclick=&amp;#34;alert(&amp;#39;form&amp;#39;)&amp;#34;&amp;gt;FORM &amp;lt;div onclick=&amp;#34;alert(&amp;#39;div&amp;#39;)&amp;#34;&amp;gt;DIV &amp;lt;p onclick=&amp;#34;alert(&amp;#39;p&amp;#39;)&amp;#34;&amp;gt;P&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/form&amp;gt;  冒泡：点击 p 元素，首先 alert p，其次 alert div，最后 alert form。从最内层的元素冒泡到最外层的元素。
 阻止冒泡 stopPropagation 阻止向父元素冒泡：
event.stopPropagation() 示例：
&amp;lt;body onclick=&amp;#34;alert(`the bubbling doesn&amp;#39;t reach here`)&amp;#34;&amp;gt; &amp;lt;button onclick=&amp;#34;event.stopPropagation()&amp;#34;&amp;gt;Click me&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; 阻止冒泡 stopImmediatePropagation 阻止向父元素冒泡，并且当前元素绑定的其它事件也不会执行：
event.stopImmediatePropagation() 举例：
$(&amp;#39;p&amp;#39;).click(event =&amp;gt; event.stopImmediatePropagation()) $(&amp;#39;p&amp;#39;).click(event =&amp;gt; console.log(&amp;#39;这个事件不会执行&amp;#39;)) 但是如果你调整一下顺序，这个事件就会执行了：
$(&amp;#39;p&amp;#39;).click(event =&amp;gt; console.log(&amp;#39;这个事件会执行&amp;#39;)) $(&amp;#39;p&amp;#39;).click(event =&amp;gt; event.stopImmediatePropagation()) 捕获 事件传播的三个阶段 DOM Events 描述了事件传播的三个阶段：</description>
    </item>
    
    <item>
      <title>重绘和重排</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/repaint-reflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/repaint-reflow/</guid>
      <description>重绘和重排 网页渲染  &amp;ldquo;生成布局&amp;rdquo;（flow）和&amp;quot;绘制&amp;rdquo;（paint）这两步，合称为&amp;quot;渲染&amp;rdquo;（render）。
 重绘 repint 重绘：某种操作改变了某个元素的外观，但并未改变这个元素的布局，从而需要重新绘制。例如对 outline、visibility、background、color 的改变。重绘不一定会引起重排。
重排/回流 reflow 重排/回流：某种操作改变了某个元素、网页的一部分或整个网页的布局，其对于性能的影响更为严重。重排必会导致重绘。
重排触发机制 重排发生的根本原理就是元素的几何属性发生了改变，那么我们就从能够改变元素几何属性的角度入手
 添加或删除可见的 DOM 元素 元素位置改变 元素本身的尺寸发生改变 内容改变 页面渲染器初始化 浏览器窗口大小发生改变  如何优化 浏览器自身优化 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。
主要包括以下属性或方法：
offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight width、height getComputedStyle() getBoundingClientRect() 所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。
合并读操作/写操作 不要这样：
// bad div.style.left = div.offsetLeft + 10 + &amp;#34;px&amp;#34;; div.style.top = div.offsetTop + 10 + &amp;#34;px&amp;#34;; 读写分离合并：
// good var left = div.offsetLeft; var top = div.offsetTop; div.style.left = left + 10 + &amp;#34;px&amp;#34;; div.</description>
    </item>
    
    <item>
      <title>浏览器如何渲染页面 ?</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/how-browser-render-html/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/how-browser-render-html/</guid>
      <description>浏览器如何渲染页面 ? 渲染主流程 Webkit 渲染流程  Mozilla 的 Gecko 渲染流程   构建 DOM 树 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1&amp;#34;&amp;gt; &amp;lt;link href=&amp;#34;style.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Critical Path&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;Hello &amp;lt;span&amp;gt;web performance&amp;lt;/span&amp;gt; students!&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;img src=&amp;#34;awesome-photo.jpg&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 对于上述 HTML 片段，浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符，然后分析出各个 HTML 标签、各个标签对应的属性等。最后，根据标签之间的关系，构建 DOM 树。
构建 CSSOM 树 在浏览器构建我们这个简单页面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：
body { font-size: 16px } p { font-weight: bold } span { color: red } p span { display: none } img { float: right } 与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML：</description>
    </item>
    
    <item>
      <title>Web 安全</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/web_security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/web_security/</guid>
      <description>Web 安全 点击劫持 点击劫持 (Clickjacking) 技术又称为界面伪装攻击 (UI redress attack )，是一种视觉上的欺骗手段。攻击者使用一个或多个透明的 iframe 覆盖在一个正常的网页上，然后诱使用户在该网页上进行操作，当用户在不知情的情况下点击透明的 iframe 页面时，用户的操作已经被劫持到攻击者事先设计好的恶意按钮或链接上。攻击者既可以通过点击劫持设计一个独立的恶意网站，执行钓鱼攻击等；也可以与 XSS 和 CSRF 攻击相结合，突破传统的防御措施，提升漏洞的危害程度。
Cross-site request forgery (CSRF) CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
一个典型的CSRF攻击有着如下的流程：
 受害者登录 a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了 b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。 a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com 以受害者的名义执行了 act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。  CSRF 的特点  攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。  CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。
防护策略 （1）同源检测（Origin 和 Referer 验证）
既然 CSRF 大多来自第三方网站，那么我们就**直接禁止外域（或者不受信任的域名）**对我们发起请求。在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：origin 和 referer。
（2）CSRF Token
CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击。具体步骤：</description>
    </item>
    
    <item>
      <title>VUE 生命周期</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/vue-lifecycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/vue-lifecycle/</guid>
      <description>VUE 生命周期 </description>
    </item>
    
    <item>
      <title>找出最多 K 个不同字符的最长子串</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/longest-substring-with-at-most-k-distinct-characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/longest-substring-with-at-most-k-distinct-characters/</guid>
      <description>找出最多 K 个不同字符的最长子串  微软、网易
 // https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/description // 网易 // 微软面试题 // // 给定字符串S，找到最多有k个不同字符的最长子串 T // // 输入: S = &amp;#34;eceba&amp;#34; 并且 k = 3 // 输出: 4 // 解释: T = &amp;#34;eceb&amp;#34; public class LongestSubstringwithAtMostKDistinctCharacters { public int lengthOfLongestSubstringKDistinct(String s, int k) { if (k == 0 || s.length() == 0) { return 0; } Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int longest = 0; int right = 0; int left = 0; while (right &amp;lt; s.</description>
    </item>
    
    <item>
      <title>Vue.nextTick</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/nexttick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/nexttick/</guid>
      <description>Vue.nextTick 作用 在 DOM 更新后，执行一个回调。
// DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) Vue 何时更新 DOM Vue 在修改数据后，DOM 不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行 DOM 更新。
应用场景 created/mounted 操作 DOM mounted: function () { this.$nextTick(function () { // Code that will run only after the  // entire view has been rendered  }) } 显示输入框并获取焦点 showInput() { this.show = true this.$nextTick(function () { // DOM 更新了  document.getElementById(&amp;#34;keywords&amp;#34;).focus() }) } </description>
    </item>
    
    <item>
      <title>两个字符串整数相加</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/add-strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/add-strings/</guid>
      <description>两个字符串整数相加  微软
 // https://leetcode.com/problems/add-strings/ // 没有 leading zeros // 微软面试题 public class AddStrings { // 1 2 3 4  // 7 8 9  public String addStrings(String num1, String num2) { if (num1 == null) { return num2; } if (num2 == null) { return num1; } final StringBuilder sb = new StringBuilder(Math.max(num1.length(), num2.length()) + 1); int index1 = num1.length() - 1; int index2 = num2.length() - 1; int remainder = 0; while (index1 &amp;gt;= 0 &amp;amp;&amp;amp; index2 &amp;gt;= 0) { char a = num1.</description>
    </item>
    
    <item>
      <title>二维矩阵数值和最小的路径</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/minimum-path-sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/minimum-path-sum/</guid>
      <description>二维矩阵数值和最小的路径  微软
 // 微软面试题: 二维矩阵，没有负值，找出从左上角到右下角，使得路径上的数值和最小的路径 // https://leetcode.com/problems/minimum-path-sum/ // public class MinimumPathSum { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] minSum = new int[m][n]; minSum[0][0] = grid[0][0]; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (i == 0 &amp;amp;&amp;amp; j == 0) { continue; } if (i - 1 &amp;lt; 0) { minSum[i][j] = minSum[i][j - 1] + grid[i][j]; } else if (j - 1 &amp;lt; 0) { minSum[i][j] = minSum[i - 1][j] + grid[i][j]; } else { // =======================  // 这一个公式就可以了  // =======================  minSum[i][j] = Math.</description>
    </item>
    
    <item>
      <title>最小火车票费用</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/minimum-cost-for-tickets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/minimum-cost-for-tickets/</guid>
      <description>最小火车票费用 // 亚马逊电面 // 最小火车票费用 // // 一年有 365 天，第一天编号为 1 // days = [1,4,6,7,8,20] 你的旅游时间必须覆盖到1、4、6、... // costs = [2,7,15] 旅游有 1 日游、7 日游、30 日游 // 问覆盖到所有天数的最小 cost // // https://leetcode.com/problems/minimum-cost-for-tickets/ public class MinimumCostForTickets { public int mincostTickets(int[] days, int[] costs) { Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; days.length; i++) { set.add(days[i]); } int[] dp = new int[366]; for (int i = 1; i &amp;lt; 366; i++) { if (!</description>
    </item>
    
    <item>
      <title>最长递增子序列 (LIS)</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/lis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/lis/</guid>
      <description>最长递增子序列 (LIS) 方法一 // 未排序 // [10,9,2,5,3,7,101,18] =&amp;gt; [2,3,7,101], length = 4 public class LongestIncreasingSubsequence { public int lengthOfLIS(int[] array) { if (array.length == 0) { return 0; } // [10,9,2,5,3,7,101,18]  // 1(10)  // 1(9)  // 1(2)  // 2(5)  // 2(3)  // 3(7)  // 4(101)  // 4(18)  //  // 每个长度 i + 1 的最小值  // 这是一个有序序列  int[] lisLength = new int[array.</description>
    </item>
    
    <item>
      <title>链表是否有环</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/linkedlist-has-cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/linkedlist-has-cycle/</guid>
      <description>链表是否有环  微软
 // https://leetcode.com/problems/linked-list-cycle/discuss/44669/Fully-Explained!-why-fast-and-slow-can-meet-in-the-cycle // https://www.cnblogs.com/wuyuegb2312/p/3183214.html // // 解释: 为什么快指针、慢指针能够相遇 // // 在任意时刻，p1 和 p2都在环上。由于 p1 每次向前 1 步，p2 每次向前两步， // 用相对运动的观点来看，把 p1 看作静止，那么 p2 每次相对 p1 向前 1 步， // 二者在顺时针方向上的距离每经过一个时刻就减少 1，直到变为 0，也即二者恰好相遇。 // 这样就证明了在离散情况下，对于有环链表，二者也是必然在某一时刻相遇在某个节点上的。 public class LinkedListCycle { public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode slower = head; ListNode faster = head.next; while (slower != null &amp;amp;&amp;amp; faster != null) { if (slower == faster) { return true; } slower = slower.</description>
    </item>
    
    <item>
      <title>找出链表环的入口节点</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/find-linkedlist-cycle-start-node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/find-linkedlist-cycle-start-node/</guid>
      <description>找出链表环的入口节点  微软
 // 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 // ↑_________| // // 假设链表长度为 L = 4 // 假设环长度为 C = 3 // 假设相遇时的点，距离环的入口 [逆时针顺序] 长度为 K // // 最终相遇: // - 快指针走了 L + m * C + K 步骤 // - 慢指针走了 L + n * C + K 步骤 // // L + m * C + K = 2 * (L + n * C + K) // // 化简得到 m * C = L + 2n * C + K // 化简得到 (m - 2n) * C = L + K // 化简得到 K = (m - 2n) * C - L = n&amp;#39; * C - L // // 即 K 是常数 // // 此时，相遇点 K 的位置是 n&amp;#39; * C - L，它再走 L 步就能到链表入口处 // 而此时慢指针从头开始走，也需要 L 步才能到链表入口处，所以这个是可以找到入口的 // // 还有就是如下这个代码，faster 从头开始移动 C 个，因为总长度是 L + C 个，所以全程还剩余 L 个 // 慢指针也需要走 L 步，所以还是会相遇 public class LinkedListCycle2 { public ListNode detectCycle(ListNode head) { // 是否有环  ListNode meetNode = hasCycle(head); if (meetNode == null) { return null; } // 求出环的个数  int cycleLen = lengthOfCycle(meetNode); // 先移动 cycleLen 个  ListNode faster = head; while (cycleLen &amp;gt; 0) { faster = faster.</description>
    </item>
    
    <item>
      <title>5 个线程读 1 个线程写</title>
      <link>https://kunzhao.org/docs/programmer-interview/algorithm/5-read-1-write/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/algorithm/5-read-1-write/</guid>
      <description>5 个线程读 1 个线程写  微软
 /** * 微软三面面试题: * * - 一个线程写，如果 5 个读线程没有读完，那么等待 * - 5 个线程【同时】读，如果已经读过，那么等待 * * @author zk */ public class ReaderWriter { public static void main(String[] args) { final int READ_COUNT = 5; final ReaderWriter rw = new ReaderWriter(READ_COUNT); Thread writer = new Thread(new Runnable() { @Override public void run() { AtomicInteger atomicInteger = new AtomicInteger(); while (true) { rw.write(atomicInteger.getAndIncrement()); } } }); writer.</description>
    </item>
    
    <item>
      <title>VUE 面试题</title>
      <link>https://kunzhao.org/docs/programmer-interview/front-end/vue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kunzhao.org/docs/programmer-interview/front-end/vue/</guid>
      <description>VUE 面试题 整理 VUE 相关的常见面试题
介绍一下 VUE 介绍一下 VUEX VUE 2.X 和 3.0 的区别 （1）数据监听方式变化
VUE 2.X 使用 ES5 的 Object.defineProperty() 的 get() 和 set(newValue) 实现，VUE 3.0 基于 Proxy 监听实现，同时更为强大：
 可以检测属性的新增和删除 可以检测数组索引的变化和 length 的变化 支持 Map、Set、WeakMap 和 WeakSet   优点：速度加倍，内存占用减半。
 （2）体积更小
支持 Tree Shaking，内置组件、内置指令按需引入。
（3）速度更快
参考：vue3.0和vue2.x的区别、Vue 3.0 和 Vue 2.0的对比以及Vue 2.0精讲以及Vue全家桶精讲
VUE 的生命周期 VUE 数据双向绑定原理 VUE 采用发布者-订阅者模式的方式来实现双向绑定。
（1）视图更新数据：
input 标签监听 input 事件即可。
（2）数据更新视图：
Object.defineProperty() 监听数据变化，通过消息订阅器发布消息，订阅者收到消息执行相应的操纵 DOM 的函数，从而更新视图。</description>
    </item>
    
  </channel>
</rss>